
Chameleon-Mini.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .flashdata    00010000  00010000  00010000  0000df52  2**1
                  CONTENTS, READONLY
  1 .spmhelper    00000014  00021fe0  00021fe0  0001df52  2**0
                  CONTENTS, READONLY
  2 .text         0000d9c6  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .data         00000474  00802000  0000d9c6  0000da7a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  4 .bss          000012ec  00802474  00802474  0000deee  2**0
                  ALLOC
  5 .eeprom       00000064  00810000  00810000  0000deee  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .comment      00000011  00000000  00000000  0001df66  2**0
                  CONTENTS, READONLY
  7 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  0001df78  2**2
                  CONTENTS, READONLY
  8 .debug_aranges 00000e98  00000000  00000000  0001dfb8  2**3
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_info   000314bd  00000000  00000000  0001ee50  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_abbrev 0000733e  00000000  00000000  0005030d  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_line   0000ff51  00000000  00000000  0005764b  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_frame  00002a2c  00000000  00000000  0006759c  2**2
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    0000992f  00000000  00000000  00069fc8  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_loc    00014cfc  00000000  00000000  000738f7  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_ranges 00001310  00000000  00000000  000885f8  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 01 0c 	jmp	0x1802	; 0x1802 <__ctors_end>
       4:	0c 94 26 0c 	jmp	0x184c	; 0x184c <__bad_interrupt>
       8:	0c 94 26 0c 	jmp	0x184c	; 0x184c <__bad_interrupt>
       c:	0c 94 26 0c 	jmp	0x184c	; 0x184c <__bad_interrupt>
      10:	0c 94 26 0c 	jmp	0x184c	; 0x184c <__bad_interrupt>
      14:	0c 94 26 0c 	jmp	0x184c	; 0x184c <__bad_interrupt>
      18:	0c 94 26 0c 	jmp	0x184c	; 0x184c <__bad_interrupt>
      1c:	0c 94 26 0c 	jmp	0x184c	; 0x184c <__bad_interrupt>
      20:	0c 94 26 0c 	jmp	0x184c	; 0x184c <__bad_interrupt>
      24:	0c 94 26 0c 	jmp	0x184c	; 0x184c <__bad_interrupt>
      28:	0c 94 9f 0d 	jmp	0x1b3e	; 0x1b3e <__vector_10>
      2c:	0c 94 26 0c 	jmp	0x184c	; 0x184c <__bad_interrupt>
      30:	0c 94 26 0c 	jmp	0x184c	; 0x184c <__bad_interrupt>
      34:	0c 94 26 0c 	jmp	0x184c	; 0x184c <__bad_interrupt>
      38:	0c 94 26 0c 	jmp	0x184c	; 0x184c <__bad_interrupt>
      3c:	0c 94 26 0c 	jmp	0x184c	; 0x184c <__bad_interrupt>
      40:	0c 94 26 0c 	jmp	0x184c	; 0x184c <__bad_interrupt>
      44:	0c 94 26 0c 	jmp	0x184c	; 0x184c <__bad_interrupt>
      48:	0c 94 26 0c 	jmp	0x184c	; 0x184c <__bad_interrupt>
      4c:	0c 94 26 0c 	jmp	0x184c	; 0x184c <__bad_interrupt>
      50:	0c 94 26 0c 	jmp	0x184c	; 0x184c <__bad_interrupt>
      54:	0c 94 26 0c 	jmp	0x184c	; 0x184c <__bad_interrupt>
      58:	0c 94 26 0c 	jmp	0x184c	; 0x184c <__bad_interrupt>
      5c:	0c 94 26 0c 	jmp	0x184c	; 0x184c <__bad_interrupt>
      60:	0c 94 26 0c 	jmp	0x184c	; 0x184c <__bad_interrupt>
      64:	0c 94 26 0c 	jmp	0x184c	; 0x184c <__bad_interrupt>
      68:	0c 94 26 0c 	jmp	0x184c	; 0x184c <__bad_interrupt>
      6c:	0c 94 26 0c 	jmp	0x184c	; 0x184c <__bad_interrupt>
      70:	0c 94 26 0c 	jmp	0x184c	; 0x184c <__bad_interrupt>
      74:	0c 94 26 0c 	jmp	0x184c	; 0x184c <__bad_interrupt>
      78:	0c 94 26 0c 	jmp	0x184c	; 0x184c <__bad_interrupt>
      7c:	0c 94 26 0c 	jmp	0x184c	; 0x184c <__bad_interrupt>
      80:	0c 94 26 0c 	jmp	0x184c	; 0x184c <__bad_interrupt>
      84:	0c 94 26 0c 	jmp	0x184c	; 0x184c <__bad_interrupt>
      88:	0c 94 ab 24 	jmp	0x4956	; 0x4956 <__vector_34>
      8c:	0c 94 f7 2d 	jmp	0x5bee	; 0x5bee <__vector_35>
      90:	0c 94 26 0c 	jmp	0x184c	; 0x184c <__bad_interrupt>
      94:	0c 94 26 0c 	jmp	0x184c	; 0x184c <__bad_interrupt>
      98:	0c 94 26 0c 	jmp	0x184c	; 0x184c <__bad_interrupt>
      9c:	0c 94 26 0c 	jmp	0x184c	; 0x184c <__bad_interrupt>
      a0:	0c 94 26 0c 	jmp	0x184c	; 0x184c <__bad_interrupt>
      a4:	0c 94 26 0c 	jmp	0x184c	; 0x184c <__bad_interrupt>
      a8:	0c 94 26 0c 	jmp	0x184c	; 0x184c <__bad_interrupt>
      ac:	0c 94 26 0c 	jmp	0x184c	; 0x184c <__bad_interrupt>
      b0:	0c 94 26 0c 	jmp	0x184c	; 0x184c <__bad_interrupt>
      b4:	0c 94 26 0c 	jmp	0x184c	; 0x184c <__bad_interrupt>
      b8:	0c 94 26 0c 	jmp	0x184c	; 0x184c <__bad_interrupt>
      bc:	0c 94 79 25 	jmp	0x4af2	; 0x4af2 <__vector_47>
      c0:	0c 94 26 0c 	jmp	0x184c	; 0x184c <__bad_interrupt>
      c4:	0c 94 26 29 	jmp	0x524c	; 0x524c <__vector_49>
      c8:	0c 94 69 2f 	jmp	0x5ed2	; 0x5ed2 <__vector_50>
      cc:	0c 94 26 0c 	jmp	0x184c	; 0x184c <__bad_interrupt>
      d0:	0c 94 26 0c 	jmp	0x184c	; 0x184c <__bad_interrupt>
      d4:	0c 94 26 0c 	jmp	0x184c	; 0x184c <__bad_interrupt>
      d8:	0c 94 26 0c 	jmp	0x184c	; 0x184c <__bad_interrupt>
      dc:	0c 94 26 0c 	jmp	0x184c	; 0x184c <__bad_interrupt>
      e0:	0c 94 26 0c 	jmp	0x184c	; 0x184c <__bad_interrupt>
      e4:	0c 94 26 0c 	jmp	0x184c	; 0x184c <__bad_interrupt>
      e8:	0c 94 26 0c 	jmp	0x184c	; 0x184c <__bad_interrupt>
      ec:	0c 94 26 0c 	jmp	0x184c	; 0x184c <__bad_interrupt>
      f0:	0c 94 26 0c 	jmp	0x184c	; 0x184c <__bad_interrupt>
      f4:	0c 94 26 0c 	jmp	0x184c	; 0x184c <__bad_interrupt>
      f8:	0c 94 26 0c 	jmp	0x184c	; 0x184c <__bad_interrupt>
      fc:	0c 94 26 0c 	jmp	0x184c	; 0x184c <__bad_interrupt>
     100:	0c 94 26 0c 	jmp	0x184c	; 0x184c <__bad_interrupt>
     104:	0c 94 26 0c 	jmp	0x184c	; 0x184c <__bad_interrupt>
     108:	0c 94 26 0c 	jmp	0x184c	; 0x184c <__bad_interrupt>
     10c:	0c 94 26 0c 	jmp	0x184c	; 0x184c <__bad_interrupt>
     110:	0c 94 42 2f 	jmp	0x5e84	; 0x5e84 <__vector_68>
     114:	0c 94 01 29 	jmp	0x5202	; 0x5202 <__vector_69>
     118:	0c 94 26 0c 	jmp	0x184c	; 0x184c <__bad_interrupt>
     11c:	0c 94 26 0c 	jmp	0x184c	; 0x184c <__bad_interrupt>
     120:	0c 94 26 0c 	jmp	0x184c	; 0x184c <__bad_interrupt>
     124:	0c 94 26 0c 	jmp	0x184c	; 0x184c <__bad_interrupt>
     128:	0c 94 26 0c 	jmp	0x184c	; 0x184c <__bad_interrupt>
     12c:	0c 94 26 0c 	jmp	0x184c	; 0x184c <__bad_interrupt>
     130:	0c 94 26 0c 	jmp	0x184c	; 0x184c <__bad_interrupt>
     134:	0c 94 26 0c 	jmp	0x184c	; 0x184c <__bad_interrupt>
     138:	0c 94 26 0c 	jmp	0x184c	; 0x184c <__bad_interrupt>
     13c:	0c 94 e1 24 	jmp	0x49c2	; 0x49c2 <__vector_79>
     140:	0c 94 5f 0c 	jmp	0x18be	; 0x18be <__vector_80>
     144:	0c 94 30 28 	jmp	0x5060	; 0x5060 <__vector_81>
     148:	0c 94 25 2e 	jmp	0x5c4a	; 0x5c4a <__vector_82>
     14c:	0c 94 26 0c 	jmp	0x184c	; 0x184c <__bad_interrupt>
     150:	0c 94 26 0c 	jmp	0x184c	; 0x184c <__bad_interrupt>
     154:	0c 94 78 28 	jmp	0x50f0	; 0x50f0 <__vector_85>
     158:	0c 94 9f 2f 	jmp	0x5f3e	; 0x5f3e <__vector_86>
     15c:	0c 94 26 0c 	jmp	0x184c	; 0x184c <__bad_interrupt>
     160:	0c 94 26 0c 	jmp	0x184c	; 0x184c <__bad_interrupt>
     164:	0c 94 26 0c 	jmp	0x184c	; 0x184c <__bad_interrupt>
     168:	0c 94 26 0c 	jmp	0x184c	; 0x184c <__bad_interrupt>
     16c:	0c 94 26 0c 	jmp	0x184c	; 0x184c <__bad_interrupt>
     170:	0c 94 26 0c 	jmp	0x184c	; 0x184c <__bad_interrupt>
     174:	0c 94 26 0c 	jmp	0x184c	; 0x184c <__bad_interrupt>
     178:	0c 94 26 0c 	jmp	0x184c	; 0x184c <__bad_interrupt>
     17c:	0c 94 26 0c 	jmp	0x184c	; 0x184c <__bad_interrupt>
     180:	0c 94 26 0c 	jmp	0x184c	; 0x184c <__bad_interrupt>
     184:	0c 94 26 0c 	jmp	0x184c	; 0x184c <__bad_interrupt>
     188:	0c 94 26 0c 	jmp	0x184c	; 0x184c <__bad_interrupt>
     18c:	0c 94 26 0c 	jmp	0x184c	; 0x184c <__bad_interrupt>
     190:	0c 94 26 0c 	jmp	0x184c	; 0x184c <__bad_interrupt>
     194:	0c 94 26 0c 	jmp	0x184c	; 0x184c <__bad_interrupt>
     198:	0c 94 26 0c 	jmp	0x184c	; 0x184c <__bad_interrupt>
     19c:	0c 94 26 0c 	jmp	0x184c	; 0x184c <__bad_interrupt>
     1a0:	0c 94 26 0c 	jmp	0x184c	; 0x184c <__bad_interrupt>
     1a4:	0c 94 26 0c 	jmp	0x184c	; 0x184c <__bad_interrupt>
     1a8:	0c 94 26 0c 	jmp	0x184c	; 0x184c <__bad_interrupt>
     1ac:	0c 94 26 0c 	jmp	0x184c	; 0x184c <__bad_interrupt>
     1b0:	0c 94 26 0c 	jmp	0x184c	; 0x184c <__bad_interrupt>
     1b4:	0c 94 26 0c 	jmp	0x184c	; 0x184c <__bad_interrupt>
     1b8:	0c 94 26 0c 	jmp	0x184c	; 0x184c <__bad_interrupt>
     1bc:	0c 94 26 0c 	jmp	0x184c	; 0x184c <__bad_interrupt>
     1c0:	0c 94 26 0c 	jmp	0x184c	; 0x184c <__bad_interrupt>
     1c4:	0c 94 26 0c 	jmp	0x184c	; 0x184c <__bad_interrupt>
     1c8:	0c 94 26 0c 	jmp	0x184c	; 0x184c <__bad_interrupt>
     1cc:	0c 94 26 0c 	jmp	0x184c	; 0x184c <__bad_interrupt>
     1d0:	0c 94 26 0c 	jmp	0x184c	; 0x184c <__bad_interrupt>
     1d4:	0c 94 26 0c 	jmp	0x184c	; 0x184c <__bad_interrupt>
     1d8:	0c 94 26 0c 	jmp	0x184c	; 0x184c <__bad_interrupt>
     1dc:	0c 94 26 0c 	jmp	0x184c	; 0x184c <__bad_interrupt>
     1e0:	0c 94 26 0c 	jmp	0x184c	; 0x184c <__bad_interrupt>
     1e4:	0c 94 26 0c 	jmp	0x184c	; 0x184c <__bad_interrupt>
     1e8:	0c 94 26 0c 	jmp	0x184c	; 0x184c <__bad_interrupt>
     1ec:	0c 94 26 0c 	jmp	0x184c	; 0x184c <__bad_interrupt>
     1f0:	0c 94 26 0c 	jmp	0x184c	; 0x184c <__bad_interrupt>
     1f4:	0c 94 d4 62 	jmp	0xc5a8	; 0xc5a8 <__vector_125>
     1f8:	0c 94 26 0c 	jmp	0x184c	; 0x184c <__bad_interrupt>

000001fc <ProductString>:
     1fc:	1e 03 43 00 68 00 61 00 6d 00 65 00 6c 00 65 00     ..C.h.a.m.e.l.e.
     20c:	6f 00 6e 00 2d 00 4d 00 69 00 6e 00 69 00 00 00     o.n.-.M.i.n.i...

0000021c <ManufacturerString>:
     21c:	2a 03 4b 00 61 00 73 00 70 00 65 00 72 00 20 00     *.K.a.s.p.e.r. .
     22c:	26 00 20 00 4f 00 73 00 77 00 61 00 6c 00 64 00     &. .O.s.w.a.l.d.
     23c:	20 00 47 00 6d 00 62 00 48 00 00 00                  .G.m.b.H...

00000248 <LanguageString>:
     248:	04 03 09 04                                         ....

0000024c <ConfigurationDescriptor>:
     24c:	09 02 3e 00 02 01 00 c0 32 09 04 00 00 01 02 02     ..>.....2.......
     25c:	01 00 05 24 00 10 01 04 24 02 06 05 24 06 00 01     ...$....$...$...
     26c:	07 05 82 03 08 00 ff 09 04 01 00 02 0a 00 00 00     ................
     27c:	07 05 04 02 10 00 05 07 05 83 02 10 00 05           ..............

0000028a <DeviceDescriptor>:
     28a:	12 01 10 01 02 00 00 08 d0 16 b2 04 01 00 01 02     ................
     29a:	dc 01                                               ..

0000029c <ConfigurationTable>:
     29c:	49 0e 4a 0e 4b 0e 4c 0e 4d 0e 4e 0e 4f 0e 50 0e     I.J.K.L.M.N.O.P.
     2ac:	53 0e 54 0e 00 00 00 01 3a 26 bb 26 da 26 51 32     S.T.....:&.&.&Q2
     2bc:	6d 32 71 32 4f 0e 72 32 93 35 a6 35 40 00 07 00     m2q2O.r2.5.5@...
     2cc:	3a 26 bb 26 da 26 65 32 6d 32 71 32 4f 0e 72 32     :&.&.&e2m2q2O.r2
     2dc:	93 35 a6 35 50 00 07 00 3a 26 bb 26 da 26 69 32     .5.5P...:&.&.&i2
     2ec:	6d 32 71 32 4f 0e 72 32 93 35 a6 35 a4 00 07 00     m2q2O.r2.5.5....
     2fc:	3a 26 bb 26 da 26 e6 35 22 36 26 36 4f 0e 27 36     :&.&.&.5"6&6O.'6
     30c:	1e 3d 3a 3d 00 04 04 00 3a 26 bb 26 da 26 f5 35     .=:=....:&.&.&.5
     31c:	22 36 26 36 4f 0e 27 36 1e 3d 3a 3d 00 04 07 00     "6&6O.'6.=:=....
     32c:	3a 26 bb 26 da 26 04 36 22 36 26 36 4f 0e 27 36     :&.&.&.6"6&6O.'6
     33c:	1e 3d 3a 3d 00 10 04 00 3a 26 bb 26 da 26 13 36     .=:=....:&.&.&.6
     34c:	22 36 26 36 4f 0e 27 36 1e 3d 3a 3d 00 10 07 00     "6&6O.'6.=:=....
     35c:	59 30 18 31 39 31 38 54 46 54 4b 54 4c 54 4e 54     Y0.1918TFTKTLTNT
     36c:	53 0e 54 0e 00 00 00 01 96 27 1e 28 c2 29 68 4c     S.T......'.(.)hL
     37c:	6b 4c 78 4c 79 4c 2a 4f 53 0e 54 0e 00 00 00 00     kLxLyL*OS.T.....
     38c:	1a 58 9d 58 cf 58 47 59 4a 59 4d 59 4e 59 4f 59     .X.X.XGYJYMYNYOY
     39c:	26 5a 2f 5a 2c 00 08 00 1a 58 9d 58 cf 58 4c 0e     &Z/Z,....X.X.XL.
     3ac:	4d 0e 4e 0e 4f 0e 50 0e 53 0e 54 0e 00 00 00 01     M.N.O.P.S.T.....
     3bc:	1a 58 9d 58 cf 58 38 5a 3b 5a 3e 5a 3f 5a 40 5a     .X.X.X8Z;Z>Z?Z@Z
     3cc:	31 5c 38 5c 2c 00 08 00 1a 58 9d 58 cf 58 3f 5c     1\8\,....X.X.X?\
     3dc:	42 5c 45 5c 46 5c 47 5c 7f 5d 86 5d 2c 00 08 00     B\E\F\G\.].],...

000003ec <ConfigurationMap>:
     3ec:	00 4e 4f 4e 45 00 00 00 00 00 00 00 00 00 00 00     .NONE...........
     3fc:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
     40c:	00 01 4d 46 5f 55 4c 54 52 41 4c 49 47 48 54 00     ..MF_ULTRALIGHT.
     41c:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
     42c:	00 00 02 4d 46 5f 55 4c 54 52 41 4c 49 47 48 54     ...MF_ULTRALIGHT
     43c:	5f 45 56 31 5f 38 30 42 00 00 00 00 00 00 00 00     _EV1_80B........
     44c:	00 00 00 03 4d 46 5f 55 4c 54 52 41 4c 49 47 48     ....MF_ULTRALIGH
     45c:	54 5f 45 56 31 5f 31 36 34 42 00 00 00 00 00 00     T_EV1_164B......
     46c:	00 00 00 00 04 4d 46 5f 43 4c 41 53 53 49 43 5f     .....MF_CLASSIC_
     47c:	31 4b 00 00 00 00 00 00 00 00 00 00 00 00 00 00     1K..............
     48c:	00 00 00 00 00 05 4d 46 5f 43 4c 41 53 53 49 43     ......MF_CLASSIC
     49c:	5f 31 4b 5f 37 42 00 00 00 00 00 00 00 00 00 00     _1K_7B..........
     4ac:	00 00 00 00 00 00 06 4d 46 5f 43 4c 41 53 53 49     .......MF_CLASSI
     4bc:	43 5f 34 4b 00 00 00 00 00 00 00 00 00 00 00 00     C_4K............
     4cc:	00 00 00 00 00 00 00 07 4d 46 5f 43 4c 41 53 53     ........MF_CLASS
     4dc:	49 43 5f 34 4b 5f 37 42 00 00 00 00 00 00 00 00     IC_4K_7B........
     4ec:	00 00 00 00 00 00 00 00 08 49 53 4f 31 34 34 34     .........ISO1444
     4fc:	33 41 5f 53 4e 49 46 46 00 00 00 00 00 00 00 00     3A_SNIFF........
     50c:	00 00 00 00 00 00 00 00 00 09 49 53 4f 31 34 34     ..........ISO144
     51c:	34 33 41 5f 52 45 41 44 45 52 00 00 00 00 00 00     43A_READER......
     52c:	00 00 00 00 00 00 00 00 00 00 0a 56 49 43 49 4e     ...........VICIN
     53c:	49 54 59 00 00 00 00 00 00 00 00 00 00 00 00 00     ITY.............
     54c:	00 00 00 00 00 00 00 00 00 00 00 0b 49 53 4f 31     ............ISO1
     55c:	35 36 39 33 5f 53 4e 49 46 46 00 00 00 00 00 00     5693_SNIFF......
     56c:	00 00 00 00 00 00 00 00 00 00 00 00 0c 53 4c 32     .............SL2
     57c:	53 32 30 30 32 00 00 00 00 00 00 00 00 00 00 00     S2002...........
     58c:	00 00 00 00 00 00 00 00 00 00 00 00 00 0d 54 49     ..............TI
     59c:	54 41 47 49 54 53 54 41 4e 44 41 52 44 00 00 00     TAGITSTANDARD...
     5ac:	00 00 00 00 00 00 00 00 00 00 00 00 00 00           ..............

000005ba <OddParityByteTable>:
     5ba:	01 00 00 01 00 01 01 00 00 01 01 00 01 00 00 01     ................
     5ca:	00 01 01 00 01 00 00 01 01 00 00 01 00 01 01 00     ................
     5da:	00 01 01 00 01 00 00 01 01 00 00 01 00 01 01 00     ................
     5ea:	01 00 00 01 00 01 01 00 00 01 01 00 01 00 00 01     ................
     5fa:	00 01 01 00 01 00 00 01 01 00 00 01 00 01 01 00     ................
     60a:	01 00 00 01 00 01 01 00 00 01 01 00 01 00 00 01     ................
     61a:	01 00 00 01 00 01 01 00 00 01 01 00 01 00 00 01     ................
     62a:	00 01 01 00 01 00 00 01 01 00 00 01 00 01 01 00     ................
     63a:	00 01 01 00 01 00 00 01 01 00 00 01 00 01 01 00     ................
     64a:	01 00 00 01 00 01 01 00 00 01 01 00 01 00 00 01     ................
     65a:	01 00 00 01 00 01 01 00 00 01 01 00 01 00 00 01     ................
     66a:	00 01 01 00 01 00 00 01 01 00 00 01 00 01 01 00     ................
     67a:	01 00 00 01 00 01 01 00 00 01 01 00 01 00 00 01     ................
     68a:	00 01 01 00 01 00 00 01 01 00 00 01 00 01 01 00     ................
     69a:	00 01 01 00 01 00 00 01 01 00 00 01 00 01 01 00     ................
     6aa:	01 00 00 01 00 01 01 00 00 01 01 00 01 00 00 01     ................

000006ba <BitReverseByteTable>:
     6ba:	00 80 40 c0 20 a0 60 e0 10 90 50 d0 30 b0 70 f0     ..@. .`...P.0.p.
     6ca:	08 88 48 c8 28 a8 68 e8 18 98 58 d8 38 b8 78 f8     ..H.(.h...X.8.x.
     6da:	04 84 44 c4 24 a4 64 e4 14 94 54 d4 34 b4 74 f4     ..D.$.d...T.4.t.
     6ea:	0c 8c 4c cc 2c ac 6c ec 1c 9c 5c dc 3c bc 7c fc     ..L.,.l...\.<.|.
     6fa:	02 82 42 c2 22 a2 62 e2 12 92 52 d2 32 b2 72 f2     ..B.".b...R.2.r.
     70a:	0a 8a 4a ca 2a aa 6a ea 1a 9a 5a da 3a ba 7a fa     ..J.*.j...Z.:.z.
     71a:	06 86 46 c6 26 a6 66 e6 16 96 56 d6 36 b6 76 f6     ..F.&.f...V.6.v.
     72a:	0e 8e 4e ce 2e ae 6e ee 1e 9e 5e de 3e be 7e fe     ..N...n...^.>.~.
     73a:	01 81 41 c1 21 a1 61 e1 11 91 51 d1 31 b1 71 f1     ..A.!.a...Q.1.q.
     74a:	09 89 49 c9 29 a9 69 e9 19 99 59 d9 39 b9 79 f9     ..I.).i...Y.9.y.
     75a:	05 85 45 c5 25 a5 65 e5 15 95 55 d5 35 b5 75 f5     ..E.%.e...U.5.u.
     76a:	0d 8d 4d cd 2d ad 6d ed 1d 9d 5d dd 3d bd 7d fd     ..M.-.m...].=.}.
     77a:	03 83 43 c3 23 a3 63 e3 13 93 53 d3 33 b3 73 f3     ..C.#.c...S.3.s.
     78a:	0b 8b 4b cb 2b ab 6b eb 1b 9b 5b db 3b bb 7b fb     ..K.+.k...[.;.{.
     79a:	07 87 47 c7 27 a7 67 e7 17 97 57 d7 37 b7 77 f7     ..G.'.g...W.7.w.
     7aa:	0f 8f 4f cf 2f af 6f ef 1f 9f 5f df 3f bf 7f ff     ..O./.o..._.?...

000007ba <ButtonActionMap>:
     7ba:	00 4e 4f 4e 45 00 00 00 00 00 00 00 00 00 00 00     .NONE...........
     7ca:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
     7da:	00 01 55 49 44 5f 52 41 4e 44 4f 4d 00 00 00 00     ..UID_RANDOM....
     7ea:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
     7fa:	00 00 02 55 49 44 5f 4c 45 46 54 5f 49 4e 43 52     ...UID_LEFT_INCR
     80a:	45 4d 45 4e 54 00 00 00 00 00 00 00 00 00 00 00     EMENT...........
     81a:	00 00 00 03 55 49 44 5f 52 49 47 48 54 5f 49 4e     ....UID_RIGHT_IN
     82a:	43 52 45 4d 45 4e 54 00 00 00 00 00 00 00 00 00     CREMENT.........
     83a:	00 00 00 00 04 55 49 44 5f 4c 45 46 54 5f 44 45     .....UID_LEFT_DE
     84a:	43 52 45 4d 45 4e 54 00 00 00 00 00 00 00 00 00     CREMENT.........
     85a:	00 00 00 00 00 05 55 49 44 5f 52 49 47 48 54 5f     ......UID_RIGHT_
     86a:	44 45 43 52 45 4d 45 4e 54 00 00 00 00 00 00 00     DECREMENT.......
     87a:	00 00 00 00 00 00 06 43 59 43 4c 45 5f 53 45 54     .......CYCLE_SET
     88a:	54 49 4e 47 53 00 00 00 00 00 00 00 00 00 00 00     TINGS...........
     89a:	00 00 00 00 00 00 00 07 53 54 4f 52 45 5f 4d 45     ........STORE_ME
     8aa:	4d 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     M...............
     8ba:	00 00 00 00 00 00 00 00 08 52 45 43 41 4c 4c 5f     .........RECALL_
     8ca:	4d 45 4d 00 00 00 00 00 00 00 00 00 00 00 00 00     MEM.............
     8da:	00 00 00 00 00 00 00 00 00 09 54 4f 47 47 4c 45     ..........TOGGLE
     8ea:	5f 46 49 45 4c 44 00 00 00 00 00 00 00 00 00 00     _FIELD..........
     8fa:	00 00 00 00 00 00 00 00 00 00 0a 53 54 4f 52 45     ...........STORE
     90a:	5f 4c 4f 47 00 00 00 00 00 00 00 00 00 00 00 00     _LOG............
     91a:	00 00 00 00 00 00 00 00 00 00 00                    ...........

00000925 <LogModeMap>:
     925:	00 4f 46 46 00 00 00 00 00 00 00 00 00 00 00 00     .OFF............
     935:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
     945:	00 01 4d 45 4d 4f 52 59 00 00 00 00 00 00 00 00     ..MEMORY........
     955:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
     965:	00 00 02 4c 49 56 45 00 00 00 00 00 00 00 00 00     ...LIVE.........
     975:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
     985:	00 00 00                                            ...

00000988 <LEDFunctionMap>:
     988:	00 4e 4f 4e 45 00 00 00 00 00 00 00 00 00 00 00     .NONE...........
     998:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
     9a8:	00 01 50 4f 57 45 52 45 44 00 00 00 00 00 00 00     ..POWERED.......
     9b8:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
     9c8:	00 00 02 54 45 52 4d 49 4e 41 4c 5f 43 4f 4e 4e     ...TERMINAL_CONN
     9d8:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
     9e8:	00 00 00 03 54 45 52 4d 49 4e 41 4c 5f 52 58 54     ....TERMINAL_RXT
     9f8:	58 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     X...............
     a08:	00 00 00 00 04 53 45 54 54 49 4e 47 5f 43 48 41     .....SETTING_CHA
     a18:	4e 47 45 00 00 00 00 00 00 00 00 00 00 00 00 00     NGE.............
     a28:	00 00 00 00 00 05 4d 45 4d 4f 52 59 5f 53 54 4f     ......MEMORY_STO
     a38:	52 45 44 00 00 00 00 00 00 00 00 00 00 00 00 00     RED.............
     a48:	00 00 00 00 00 00 06 4d 45 4d 4f 52 59 5f 43 48     .......MEMORY_CH
     a58:	41 4e 47 45 44 00 00 00 00 00 00 00 00 00 00 00     ANGED...........
     a68:	00 00 00 00 00 00 00 08 43 4f 44 45 43 5f 52 58     ........CODEC_RX
     a78:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
     a88:	00 00 00 00 00 00 00 00 09 43 4f 44 45 43 5f 54     .........CODEC_T
     a98:	58 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     X...............
     aa8:	00 00 00 00 00 00 00 00 00 07 46 49 45 4c 44 5f     ..........FIELD_
     ab8:	44 45 54 45 43 54 45 44 00 00 00 00 00 00 00 00     DETECTED........
     ac8:	00 00 00 00 00 00 00 00 00 00 0a 4c 4f 47 4d 45     ...........LOGME
     ad8:	4d 5f 46 55 4c 4c 00 00 00 00 00 00 00 00 00 00     M_FULL..........
     ae8:	00 00 00 00 00 00 00 00 00 00 00                    ...........

00000af3 <__c.7244>:
     af3:	25 63 2c 25 63 00                                   %c,%c.

00000af9 <__c.7238>:
     af9:	25 35 64 00                                         %5d.

00000afd <__c.7235>:
     afd:	41 6e 79 20 69 6e 74 65 67 65 72 20 66 72 6f 6d     Any integer from
     b0d:	20 30 20 74 6f 20 25 75 2e 20 52 65 66 65 72 65      0 to %u. Refere
     b1d:	6e 63 65 20 76 6f 6c 74 61 67 65 20 77 69 6c 6c     nce voltage will
     b2d:	20 62 65 20 28 56 43 43 20 2a 20 54 48 52 45 53      be (VCC * THRES
     b3d:	48 4f 4c 44 20 2f 20 34 30 39 35 29 20 6d 56 2e     HOLD / 4095) mV.
     b4d:	00                                                  .

00000b4e <__c.7229>:
     b4e:	25 75 00                                            %u.

00000b51 <__c.7224>:
     b51:	25 35 64 00                                         %5d.

00000b55 <__c.7221>:
     b55:	30 20 3d 20 6e 6f 20 74 69 6d 65 6f 75 74 0d 0a     0 = no timeout..
     b65:	31 2d 36 30 30 20 3d 20 31 30 30 20 6d 73 20 2d     1-600 = 100 ms -
     b75:	20 36 30 30 30 30 20 6d 73 20 74 69 6d 65 6f 75      60000 ms timeou
     b85:	74 00                                               t.

00000b87 <__c.7215>:
     b87:	25 75 20 6d 73 00                                   %u ms.

00000b8d <__c.7187>:
     b8d:	25 34 2e 34 58 00                                   %4.4X.

00000b93 <__c.7182>:
     b93:	25 35 75 20 6d 56 00                                %5u mV.

00000b9a <__c.7133>:
     b9a:	25 75 20 28 66 72 6f 6d 20 77 68 69 63 68 20 25     %u (from which %
     baa:	75 20 6e 6f 6e 2d 76 6f 6c 61 74 69 6c 65 29 00     u non-volatile).

00000bba <__c.7078>:
     bba:	25 75 00                                            %u.

00000bbd <__c.7073>:
     bbd:	25 75 00                                            %u.

00000bc0 <__c.7056>:
     bc0:	25 63 2c 25 63 00                                   %c,%c.

00000bc6 <__c.7043>:
     bc6:	52 41 4e 44 4f 4d 00                                RANDOM.

00000bcd <__c.7035>:
     bcd:	4e 4f 20 55 49 44 2e 00                             NO UID..

00000bd5 <__c.7013>:
     bd5:	43 68 61 6d 65 6c 65 6f 6e 4d 69 6e 69 20 52 65     ChameleonMini Re
     be5:	76 47 20 25 53 20 75 73 69 6e 67 20 4c 55 46 41     vG %S using LUFA
     bf5:	20 25 53 20 63 6f 6d 70 69 6c 65 64 20 77 69 74      %S compiled wit
     c05:	68 20 41 56 52 2d 47 43 43 20 25 53 2e 20 42 61     h AVR-GCC %S. Ba
     c15:	73 65 64 20 6f 6e 20 74 68 65 20 6f 70 65 6e 2d     sed on the open-
     c25:	73 6f 75 72 63 65 20 4e 46 43 20 74 6f 6f 6c 20     source NFC tool 
     c35:	43 68 61 6d 65 6c 65 6f 6e 4d 69 6e 69 2e 20 68     ChameleonMini. h
     c45:	74 74 70 73 3a 2f 2f 67 69 74 68 75 62 2e 63 6f     ttps://github.co
     c55:	6d 2f 65 6d 73 65 63 2f 43 68 61 6d 65 6c 65 6f     m/emsec/Chameleo
     c65:	6e 4d 69 6e 69 20 63 6f 6d 6d 69 74 20 25 53 00     nMini commit %S.

00000c75 <__c.7015>:
     c75:	31 38 31 30 32 37 00                                181027.

00000c7c <__c.7017>:
     c7c:	31 35 31 31 31 35 00                                151115.

00000c83 <__c.7019>:
     c83:	34 2e 39 2e 32 00                                   4.9.2.

00000c89 <__c.7021>:
     c89:	65 38 35 30 30 62 35 00                             e8500b5.

00000c91 <__c.6736>:
     c91:	0d 0a 00                                            ...

00000c94 <__c.6724>:
     c94:	0d 0a 00                                            ...

00000c97 <__c.6722>:
     c97:	0d 0a 00                                            ...

00000c9a <__c.6710>:
     c9a:	0d 0a 00                                            ...

00000c9d <__c.6699>:
     c9d:	0d 0a 00                                            ...

00000ca0 <__c.6697>:
     ca0:	0d 0a 00                                            ...

00000ca3 <StatusTable>:
     ca3:	64 31 30 30 3a 4f 4b 00 00 00 00 00 00 00 00 00     d100:OK.........
     cb3:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
     cc3:	00 65 31 30 31 3a 4f 4b 20 57 49 54 48 20 54 45     .e101:OK WITH TE
     cd3:	58 54 00 00 00 00 00 00 00 00 00 00 00 00 00 00     XT..............
     ce3:	00 00 6e 31 31 30 3a 57 41 49 54 49 4e 47 20 46     ..n110:WAITING F
     cf3:	4f 52 20 58 4d 4f 44 45 4d 00 00 00 00 00 00 00     OR XMODEM.......
     d03:	00 00 00 c8 32 30 30 3a 55 4e 4b 4e 4f 57 4e 20     ....200:UNKNOWN 
     d13:	43 4f 4d 4d 41 4e 44 00 00 00 00 00 00 00 00 00     COMMAND.........
     d23:	00 00 00 00 c9 32 30 31 3a 49 4e 56 41 4c 49 44     .....201:INVALID
     d33:	20 43 4f 4d 4d 41 4e 44 20 55 53 41 47 45 00 00      COMMAND USAGE..
     d43:	00 00 00 00 00 ca 32 30 32 3a 49 4e 56 41 4c 49     ......202:INVALI
     d53:	44 20 50 41 52 41 4d 45 54 45 52 00 00 00 00 00     D PARAMETER.....
     d63:	00 00 00 00 00 00 78 31 32 30 3a 46 41 4c 53 45     ......x120:FALSE
     d73:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
     d83:	00 00 00 00 00 00 00 79 31 32 31 3a 54 52 55 45     .......y121:TRUE
     d93:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
     da3:	00 00 00 00 00 00 00 00 cb 32 30 33 3a 54 49 4d     .........203:TIM
     db3:	45 4f 55 54 00 00 00 00 00 00 00 00 00 00 00 00     EOUT............
     dc3:	00 00 00 00 00 00 00 00 00                          .........

00000dcc <CommandTable>:
     dcc:	56 45 52 53 49 4f 4e 00 00 00 00 00 00 00 00 00     VERSION.........
     ddc:	00 00 00 00 00 00 5c 1a 43 4f 4e 46 49 47 00 00     ......\.CONFIG..
     dec:	00 00 00 00 00 00 00 00 00 00 00 00 84 1a 7e 1a     ..............~.
     dfc:	55 49 44 00 00 00 00 00 00 00 00 00 00 00 00 00     UID.............
     e0c:	00 00 00 00 e5 1a a6 1a 52 45 41 44 4f 4e 4c 59     ........READONLY
     e1c:	00 00 00 00 00 00 00 00 00 00 00 00 43 1b 37 1b     ............C.7.
     e2c:	55 50 4c 4f 41 44 00 00 00 00 00 00 00 00 00 00     UPLOAD..........
     e3c:	70 1b 00 00 00 00 00 00 44 4f 57 4e 4c 4f 41 44     p.......DOWNLOAD
     e4c:	00 00 00 00 00 00 00 00 75 1b 00 00 00 00 00 00     ........u.......
     e5c:	52 45 53 45 54 00 00 00 00 00 00 00 00 00 00 00     RESET...........
     e6c:	7a 1b 00 00 00 00 00 00 55 50 47 52 41 44 45 00     z.......UPGRADE.
     e7c:	00 00 00 00 00 00 00 00 85 1b 00 00 00 00 00 00     ................
     e8c:	4d 45 4d 53 49 5a 45 00 00 00 00 00 00 00 00 00     MEMSIZE.........
     e9c:	00 00 00 00 00 00 90 1b 55 49 44 53 49 5a 45 00     ........UIDSIZE.
     eac:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 a8 1b     ................
     ebc:	52 42 55 54 54 4f 4e 00 00 00 00 00 00 00 00 00     RBUTTON.........
     ecc:	00 00 00 00 c5 1b be 1b 52 42 55 54 54 4f 4e 5f     ........RBUTTON_
     edc:	4c 4f 4e 47 00 00 00 00 00 00 00 00 e1 1b da 1b     LONG............
     eec:	4c 42 55 54 54 4f 4e 00 00 00 00 00 00 00 00 00     LBUTTON.........
     efc:	00 00 00 00 fd 1b f6 1b 4c 42 55 54 54 4f 4e 5f     ........LBUTTON_
     f0c:	4c 4f 4e 47 00 00 00 00 00 00 00 00 19 1c 12 1c     LONG............
     f1c:	4c 45 44 47 52 45 45 4e 00 00 00 00 00 00 00 00     LEDGREEN........
     f2c:	00 00 00 00 35 1c 2e 1c 4c 45 44 52 45 44 00 00     ....5...LEDRED..
     f3c:	00 00 00 00 00 00 00 00 00 00 00 00 51 1c 4a 1c     ............Q.J.
     f4c:	4c 4f 47 4d 4f 44 45 00 00 00 00 00 00 00 00 00     LOGMODE.........
     f5c:	00 00 00 00 6b 1c 66 1c 4c 4f 47 4d 45 4d 00 00     ....k.f.LOGMEM..
     f6c:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 80 1c     ................
     f7c:	4c 4f 47 44 4f 57 4e 4c 4f 41 44 00 00 00 00 00     LOGDOWNLOAD.....
     f8c:	a5 1c 00 00 00 00 00 00 4c 4f 47 53 54 4f 52 45     ........LOGSTORE
     f9c:	00 00 00 00 00 00 00 00 aa 1c 00 00 00 00 00 00     ................
     fac:	4c 4f 47 43 4c 45 41 52 00 00 00 00 00 00 00 00     LOGCLEAR........
     fbc:	ad 1c 00 00 00 00 00 00 53 45 54 54 49 4e 47 00     ........SETTING.
     fcc:	00 00 00 00 00 00 00 00 00 00 00 00 b5 1c b0 1c     ................
     fdc:	43 4c 45 41 52 00 00 00 00 00 00 00 00 00 00 00     CLEAR...........
     fec:	bd 1c 00 00 00 00 00 00 53 54 4f 52 45 00 00 00     ........STORE...
     ffc:	00 00 00 00 00 00 00 00 c1 1c 00 00 00 00 00 00     ................
    100c:	52 45 43 41 4c 4c 00 00 00 00 00 00 00 00 00 00     RECALL..........
    101c:	c5 1c 00 00 00 00 00 00 43 48 41 52 47 49 4e 47     ........CHARGING
    102c:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 c9 1c     ................
    103c:	48 45 4c 50 00 00 00 00 00 00 00 00 00 00 00 00     HELP............
    104c:	d1 1c 00 00 00 00 00 00 52 53 53 49 00 00 00 00     ........RSSI....
    105c:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 0d 1d     ................
    106c:	53 59 53 54 49 43 4b 00 00 00 00 00 00 00 00 00     SYSTICK.........
    107c:	00 00 00 00 00 00 40 1d 53 45 4e 44 5f 52 41 57     ......@.SEND_RAW
    108c:	00 00 00 00 00 00 00 00 00 00 e6 1d 00 00 00 00     ................
    109c:	53 45 4e 44 00 00 00 00 00 00 00 00 00 00 00 00     SEND............
    10ac:	00 00 5c 1d 00 00 00 00 47 45 54 55 49 44 00 00     ..\.....GETUID..
    10bc:	00 00 00 00 00 00 00 00 a2 1e 00 00 00 00 00 00     ................
    10cc:	44 55 4d 50 5f 4d 46 55 00 00 00 00 00 00 00 00     DUMP_MFU........
    10dc:	85 1e 00 00 00 00 00 00 49 44 45 4e 54 49 46 59     ........IDENTIFY
    10ec:	00 00 00 00 00 00 00 00 bf 1e 00 00 00 00 00 00     ................
    10fc:	54 49 4d 45 4f 55 54 00 00 00 00 00 00 00 00 00     TIMEOUT.........
    110c:	00 00 00 00 fc 1e dc 1e 54 48 52 45 53 48 4f 4c     ........THRESHOL
    111c:	44 00 00 00 00 00 00 00 00 00 00 00 69 1f 4f 1f     D...........i.O.
    112c:	41 55 54 4f 43 41 4c 49 42 52 41 54 45 00 00 00     AUTOCALIBRATE...
    113c:	f8 1f 00 00 00 00 00 00 46 49 45 4c 44 00 00 00     ........FIELD...
    114c:	00 00 00 00 00 00 00 00 00 00 00 00 be 1f e8 1f     ................
    115c:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    116c:	00 00 00 00 00 00 00 00                             ........

00001174 <__c.7247>:
    1174:	53 41 4b 3a 09 00                                   SAK:..

0000117a <__c.7245>:
    117a:	55 49 44 3a 09 00                                   UID:..

00001180 <__c.7243>:
    1180:	41 54 51 41 3a 09 00                                ATQA:..

00001187 <__c.7241>:
    1187:	54 68 65 72 65 20 69 73 20 61 74 20 6c 65 61 73     There is at leas
    1197:	74 20 6f 6e 65 20 6d 6f 72 65 20 63 61 72 64 20     t one more card 
    11a7:	74 79 70 65 20 63 61 6e 64 69 64 61 74 65 2c 20     type candidate, 
    11b7:	62 75 74 20 74 68 65 72 65 20 77 61 73 20 6e 6f     but there was no
    11c7:	74 20 65 6e 6f 75 67 68 20 74 65 72 6d 69 6e 61     t enough termina
    11d7:	6c 20 62 75 66 66 65 72 20 73 70 61 63 65 2e 0d     l buffer space..
    11e7:	0a 00                                               ..

000011e9 <__c.7213>:
    11e9:	0d 0a 00                                            ...

000011ec <CardIdentificationList>:
    11ec:	04 00 01 09 01 00 00 00 00 00 00 00 00 00 00 00     ................
    11fc:	00 00 00 00 00 00 00 4e 58 50 00 00 00 00 00 00     .......NXP......
    120c:	00 00 00 00 00 00 00 4d 49 46 41 52 45 20 4d 69     .......MIFARE Mi
    121c:	6e 69 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ni..............
    122c:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    123c:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    124c:	00 00 00 00 00 00 00 04 00 01 08 01 00 00 00 00     ................
    125c:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 4e 58     ..............NX
    126c:	50 00 00 00 00 00 00 00 00 00 00 00 00 00 4d 49     P.............MI
    127c:	46 41 52 45 20 43 6c 61 73 73 69 63 20 31 6b 00     FARE Classic 1k.
    128c:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    129c:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    12ac:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 02 00     ................
    12bc:	01 18 01 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    12cc:	00 00 00 00 00 4e 58 50 00 00 00 00 00 00 00 00     .....NXP........
    12dc:	00 00 00 00 00 4d 49 46 41 52 45 20 43 6c 61 73     .....MIFARE Clas
    12ec:	73 69 63 20 34 6b 00 00 00 00 00 00 00 00 00 00     sic 4k..........
    12fc:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    130c:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    131c:	00 00 00 00 00 44 00 01 00 01 00 00 00 00 00 00     .....D..........
    132c:	00 00 00 00 00 00 00 00 00 00 00 00 4e 58 50 00     ............NXP.
    133c:	00 00 00 00 00 00 00 00 00 00 00 00 4d 49 46 41     ............MIFA
    134c:	52 45 20 55 6c 74 72 61 6c 69 67 68 74 00 00 00     RE Ultralight...
    135c:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    136c:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    137c:	00 00 00 00 00 00 00 00 00 00 00 00 44 03 01 20     ............D.. 
    138c:	01 75 77 81 02 80 00 00 00 00 00 00 00 00 00 00     .uw.............
    139c:	00 05 00 4e 58 50 00 00 00 00 00 00 00 00 00 00     ...NXP..........
    13ac:	00 00 00 4d 49 46 41 52 45 20 44 45 53 46 69 72     ...MIFARE DESFir
    13bc:	65 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     e...............
    13cc:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    13dc:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    13ec:	00 00 00 44 03 01 20 01 75 77 81 02 80 00 00 00     ...D.. .uw......
    13fc:	00 00 00 00 00 00 00 00 05 00 4e 58 50 00 00 00     ..........NXP...
    140c:	00 00 00 00 00 00 00 00 00 00 4d 49 46 41 52 45     ..........MIFARE
    141c:	20 44 45 53 46 69 72 65 20 45 56 31 00 00 00 00      DESFire EV1....
    142c:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    143c:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    144c:	00 00 00 00 00 00 00 00 00 00 04 03 01 28 01 38     .............(.8
    145c:	77 b1 4a 43 4f 50 33 31 00 00 00 00 00 00 00 09     w.JCOP31........
    146c:	01 49 42 4d 00 00 00 00 00 00 00 00 00 00 00 00     .IBM............
    147c:	00 4a 43 4f 50 33 31 00 00 00 00 00 00 00 00 00     .JCOP31.........
    148c:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    149c:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    14ac:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    14bc:	00 48 00 01 20 01 78 77 b1 02 4a 43 4f 50 76 32     .H.. .xw..JCOPv2
    14cc:	34 31 00 00 00 00 0c 01 49 42 4d 00 00 00 00 00     41......IBM.....
    14dc:	00 00 00 00 00 00 00 00 4a 43 4f 50 33 31 20 76     ........JCOP31 v
    14ec:	32 2e 34 2e 31 00 00 00 00 00 00 00 00 00 00 00     2.4.1...........
    14fc:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    150c:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    151c:	00 00 00 00 00 00 00 00 48 00 01 20 01 38 33 b1     ........H.. .83.
    152c:	4a 43 4f 50 34 31 56 32 32 00 00 00 00 0c 01 49     JCOP41V22......I
    153c:	42 4d 00 00 00 00 00 00 00 00 00 00 00 00 00 4a     BM.............J
    154c:	43 4f 50 34 31 20 76 32 2e 32 00 00 00 00 00 00     COP41 v2.2......
    155c:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    156c:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    157c:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 04     ................
    158c:	00 01 28 01 38 33 b1 4a 43 4f 50 34 31 56 32 33     ..(.83.JCOP41V23
    159c:	31 00 00 00 0d 01 49 42 4d 00 00 00 00 00 00 00     1.....IBM.......
    15ac:	00 00 00 00 00 00 4a 43 4f 50 34 31 20 76 32 2e     ......JCOP41 v2.
    15bc:	33 2e 31 00 00 00 00 00 00 00 00 00 00 00 00 00     3.1.............
    15cc:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    15dc:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    15ec:	00 00 00 00 00 00 04 00 01 88 01 00 00 00 00 00     ................
    15fc:	00 00 00 00 00 00 00 00 00 00 00 00 00 49 6e 66     .............Inf
    160c:	69 6e 65 6f 6e 00 00 00 00 00 00 00 00 4d 49 46     ineon........MIF
    161c:	41 52 45 20 43 6c 61 73 73 69 63 20 31 6b 00 00     ARE Classic 1k..
    162c:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    163c:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    164c:	00 00 00 00 00 00 00 00 00 00 00 00 00 02 00 01     ................
    165c:	98 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    166c:	00 00 00 00 47 65 6d 70 6c 75 73 00 00 00 00 00     ....Gemplus.....
    167c:	00 00 00 00 4d 50 43 4f 53 00 00 00 00 00 00 00     ....MPCOS.......
    168c:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    169c:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    16ac:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    16bc:	00 00 00 00 00 0c 01 00 00 00 00 00 00 00 00 00     ................
    16cc:	00 00 00 00 00 00 00 00 00 00 00 49 6e 6e 6f 76     ...........Innov
    16dc:	69 73 69 6f 6e 20 52 26 54 00 00 4a 65 77 65 6c     ision R&T..Jewel
    16ec:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    16fc:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    170c:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    171c:	00 00 00 00 00 00 00 00 00 00 00 02 00 01 38 01     ..............8.
    172c:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    173c:	00 00 4e 6f 6b 69 61 00 00 00 00 00 00 00 00 00     ..Nokia.........
    174c:	00 00 4d 49 46 41 52 45 20 43 6c 61 73 73 69 63     ..MIFARE Classic
    175c:	20 34 6b 20 2d 20 65 6d 75 6c 61 74 65 64 20 28      4k - emulated (
    176c:	36 32 31 32 20 43 6c 61 73 73 69 63 29 00 00 00     6212 Classic)...
    177c:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    178c:	00 00 08 00 01 38 01 00 00 00 00 00 00 00 00 00     .....8..........
    179c:	00 00 00 00 00 00 00 00 00 4e 6f 6b 69 61 00 00     .........Nokia..
    17ac:	00 00 00 00 00 00 00 00 00 4d 49 46 41 52 45 20     .........MIFARE 
    17bc:	43 6c 61 73 73 69 63 20 34 6b 20 2d 20 65 6d 75     Classic 4k - emu
    17cc:	6c 61 74 65 64 20 28 36 31 33 31 20 4e 46 43 29     lated (6131 NFC)
    17dc:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    17ec:	00 00 00 00 00 00 00 00 00                          .........

000017f5 <__c.2319>:
    17f5:	63 64 69 6e 6f 70 73 75 78 58 5b 00 00              cdinopsuxX[..

00001802 <__ctors_end>:
    1802:	11 24       	eor	r1, r1
    1804:	1f be       	out	0x3f, r1	; 63
    1806:	cf ef       	ldi	r28, 0xFF	; 255
    1808:	cd bf       	out	0x3d, r28	; 61
    180a:	df e3       	ldi	r29, 0x3F	; 63
    180c:	de bf       	out	0x3e, r29	; 62
    180e:	00 e0       	ldi	r16, 0x00	; 0
    1810:	0c bf       	out	0x3c, r16	; 60
    1812:	18 be       	out	0x38, r1	; 56
    1814:	19 be       	out	0x39, r1	; 57
    1816:	1a be       	out	0x3a, r1	; 58
    1818:	1b be       	out	0x3b, r1	; 59

0000181a <__do_copy_data>:
    181a:	14 e2       	ldi	r17, 0x24	; 36
    181c:	a0 e0       	ldi	r26, 0x00	; 0
    181e:	b0 e2       	ldi	r27, 0x20	; 32
    1820:	e6 ec       	ldi	r30, 0xC6	; 198
    1822:	f9 ed       	ldi	r31, 0xD9	; 217
    1824:	00 e0       	ldi	r16, 0x00	; 0
    1826:	0b bf       	out	0x3b, r16	; 59
    1828:	02 c0       	rjmp	.+4      	; 0x182e <__do_copy_data+0x14>
    182a:	07 90       	elpm	r0, Z+
    182c:	0d 92       	st	X+, r0
    182e:	a4 37       	cpi	r26, 0x74	; 116
    1830:	b1 07       	cpc	r27, r17
    1832:	d9 f7       	brne	.-10     	; 0x182a <__do_copy_data+0x10>
    1834:	1b be       	out	0x3b, r1	; 59

00001836 <__do_clear_bss>:
    1836:	27 e3       	ldi	r18, 0x37	; 55
    1838:	a4 e7       	ldi	r26, 0x74	; 116
    183a:	b4 e2       	ldi	r27, 0x24	; 36
    183c:	01 c0       	rjmp	.+2      	; 0x1840 <.do_clear_bss_start>

0000183e <.do_clear_bss_loop>:
    183e:	1d 92       	st	X+, r1

00001840 <.do_clear_bss_start>:
    1840:	a0 36       	cpi	r26, 0x60	; 96
    1842:	b2 07       	cpc	r27, r18
    1844:	e1 f7       	brne	.-8      	; 0x183e <.do_clear_bss_loop>
    1846:	7e d0       	rcall	.+252    	; 0x1944 <main>
    1848:	0c 94 e1 6c 	jmp	0xd9c2	; 0xd9c2 <_exit>

0000184c <__bad_interrupt>:
    184c:	6f c1       	rjmp	.+734    	; 0x1b2c <__vector_default>

0000184e <FlashReadWord>:
; Returns:
;     R25:R24 - Read word.
.section .text
.global FlashReadWord
FlashReadWord:
    in	r19, RAMPZ      ; Save RAMPZ.
    184e:	3b b7       	in	r19, 0x3b	; 59
    out	RAMPZ, r24      ; Load RAMPZ with the MSB of the address.
    1850:	8b bf       	out	0x3b, r24	; 59
    movw	ZL, r22     ; Move the low bytes to the Z pointer
    1852:	fb 01       	movw	r30, r22
    elpm	r24, Z+     ; Extended load byte from address pointed to by Z.
    1854:	87 91       	elpm	r24, Z+
    elpm	r25, Z      ; Extended load byte from address pointed to by Z.
    1856:	96 91       	elpm	r25, Z
    out	RAMPZ, r19      ; Restore RAMPZ register.
    1858:	3b bf       	out	0x3b, r19	; 59
    ret
    185a:	08 95       	ret

0000185c <FlashEraseApplicationPage>:
; Returns:
;     Nothing.
.section .text
.global FlashEraseApplicationPage
FlashEraseApplicationPage:
    in	r19, RAMPZ                      ; Save RAMPZ, which is restored in FlashCommonSPM.
    185c:	3b b7       	in	r19, 0x3b	; 59
    out	RAMPZ, r24                      ; Load RAMPZ with the MSB of the address.
    185e:	8b bf       	out	0x3b, r24	; 59
    movw    r24, r22                    ; Move low bytes for ZH:ZL to R25:R24
    1860:	cb 01       	movw	r24, r22
    ldi	r20, NVM_CMD_ERASE_APP_PAGE_gc  ; Prepare NVM command in R20.
    1862:	42 e2       	ldi	r20, 0x22	; 34
    jmp	FlashCommonSPM                  ; Jump to common SPM code.
    1864:	0d 94 f0 0f 	jmp	0x21fe0	; 0x21fe0 <FlashCommonSPM>

00001868 <FlashLoadFlashWord>:
; Returns:
;     Nothing.
.section .text
.global FlashLoadFlashWord
FlashLoadFlashWord:
    in	r19, RAMPZ                         ; Save RAMPZ, which is restored in FlashCommonSPM.
    1868:	3b b7       	in	r19, 0x3b	; 59
    movw	r0, r22                        ; Prepare flash word in R1:R0.
    186a:	0b 01       	movw	r0, r22
    ldi	r20, NVM_CMD_LOAD_FLASH_BUFFER_gc  ; Prepare NVM command in R20.
    186c:	43 e2       	ldi	r20, 0x23	; 35
    jmp	FlashCommonSPM                     ; Jump to common SPM code.
    186e:	0d 94 f0 0f 	jmp	0x21fe0	; 0x21fe0 <FlashCommonSPM>

00001872 <FlashEraseWriteApplicationPage>:
; Returns:
;     Nothing.
.section .text
.global FlashEraseWriteApplicationPage
FlashEraseWriteApplicationPage:
    in	r19, RAMPZ                            ; Save RAMPZ, which is restored in FlashCommonSPM.
    1872:	3b b7       	in	r19, 0x3b	; 59
    out	RAMPZ, r24                            ; Load RAMPZ with the MSB of the address.
    1874:	8b bf       	out	0x3b, r24	; 59
    movw	r24, r22                          ; Move low bytes of address to ZH:ZL from R23:R22
    1876:	cb 01       	movw	r24, r22
    ldi	r20, NVM_CMD_ERASE_WRITE_APP_PAGE_gc  ; Prepare NVM command in R20.
    1878:	45 e2       	ldi	r20, 0x25	; 37
    jmp	FlashCommonSPM                        ; Jump to common SPM code.
    187a:	0d 94 f0 0f 	jmp	0x21fe0	; 0x21fe0 <FlashCommonSPM>

0000187e <FlashEraseFlashBuffer>:
; Returns:
;     Nothing.
.section .text
.global FlashEraseFlashBuffer
FlashEraseFlashBuffer:
    in	r19, RAMPZ                          ; Save RAMPZ, which is restored in FlashCommonSPM.
    187e:	3b b7       	in	r19, 0x3b	; 59
    ldi	r20, NVM_CMD_ERASE_FLASH_BUFFER_gc  ; Prepare NVM command in R20.
    1880:	46 e2       	ldi	r20, 0x26	; 38
    ;jmp	FlashCommonSPM                  ; Jump to common SPM code.
    jmp	FlashCommonCMD
    1882:	08 c0       	rjmp	.+16     	; 0x1894 <FlashCommonCMD>

00001884 <FlashWaitForSPM>:
; Returns:
;     Nothing.
.section .text
.global FlashWaitForSPM
FlashWaitForSPM:
    lds	r18, NVM_STATUS     ; Load the NVM Status register.
    1884:	20 91 cf 01 	lds	r18, 0x01CF
    sbrc	r18, NVM_NVMBUSY_bp ; Check if bit is cleared.
    1888:	27 fd       	sbrc	r18, 7
    rjmp	FlashWaitForSPM       ; Repeat check if bit is not cleared.
    188a:	fc cf       	rjmp	.-8      	; 0x1884 <FlashWaitForSPM>
    clr	r18
    188c:	22 27       	eor	r18, r18
    sts	NVM_CMD, r18        ; Clear up command register to NO_OPERATION.
    188e:	20 93 ca 01 	sts	0x01CA, r18
    ret
    1892:	08 95       	ret

00001894 <FlashCommonCMD>:
;
; Returns:
;     R25:R24:R23:R22 - 32-bit result from NVM operation.
.section .text
FlashCommonCMD:
    sts	NVM_CMD, r20        ; Load command into NVM Command register.
    1894:	40 93 ca 01 	sts	0x01CA, r20
    ldi	r18, CCP_IOREG_gc   ; Prepare Protect IO-register signature in R18.
    1898:	28 ed       	ldi	r18, 0xD8	; 216
    ldi	r19, NVM_CMDEX_bm   ; Prepare bitmask for setting NVM Command Execute bit into R19.
    189a:	31 e0       	ldi	r19, 0x01	; 1
    sts	CCP, r18            ; Enable IO-register operation (this disables interrupts for 4 cycles).
    189c:	20 93 34 00 	sts	0x0034, r18
    sts	NVM_CTRLA, r19      ; Load bitmask into NVM Control Register A, which executes the command.
    18a0:	30 93 cb 01 	sts	0x01CB, r19
    lds	r22, NVM_DATA0      ; Load NVM Data Register 0 into R22.
    18a4:	60 91 c4 01 	lds	r22, 0x01C4
    lds	r23, NVM_DATA1      ; Load NVM Data Register 1 into R23.
    18a8:	70 91 c5 01 	lds	r23, 0x01C5
    lds	r24, NVM_DATA2      ; Load NVM Data Register 2 into R24.
    18ac:	80 91 c6 01 	lds	r24, 0x01C6
    clr	r25                 ; Clear R25 in order to return a clean 32-bit value.
    18b0:	99 27       	eor	r25, r25
    ret
    18b2:	08 95       	ret

000018b4 <FlashCommonLPM>:
;
; Returns:
;     R24     - Result from LPM operation.
.section .text
FlashCommonLPM:
    movw	ZL, r24         ; Load index into Z.
    18b4:	fc 01       	movw	r30, r24
    sts	NVM_CMD, r20        ; Load prepared command into NVM Command register.
    18b6:	40 93 ca 01 	sts	0x01CA, r20
    lpm	r24,Z
    18ba:	84 91       	lpm	r24, Z
    ret
    18bc:	08 95       	ret

000018be <__vector_80>:
#define CODEC_READER_TIMER__CTRLA   0x0800

; For sending reader bits to cards
.global TCD0_CCB_vect, Reader14443AMillerEOC
TCD0_CCB_vect:
push Zero                                                   ; 1
    18be:	0f 92       	push	r0
eor Zero, Zero                                              ; 1
    18c0:	00 24       	eor	r0, r0
push Tmp                                                    ; 1
    18c2:	0f 93       	push	r16
push BitCountL                                              ; 1
    18c4:	2f 93       	push	r18
push BitCountH                                              ; 1
    18c6:	3f 93       	push	r19
push NewLoad                                                ; 1
    18c8:	4f 93       	push	r20
push SampleRegister                                         ; 1
    18ca:	5f 93       	push	r21
in Tmp, 0x3f ; SREG                                         ; 1
    18cc:	0f b7       	in	r16, 0x3f	; 63
push Tmp                                                    ; 1
    18ce:	0f 93       	push	r16
push ZL                                                     ; 1
    18d0:	ef 93       	push	r30
push ZH                                                     ; 1
    18d2:	ff 93       	push	r31
                                                            ; SUM: 8
in ZL, CodecBufferPtrL
    18d4:	ea b1       	in	r30, 0x0a	; 10
in ZH, CodecBufferPtrH
    18d6:	fb b1       	in	r31, 0x0b	; 11
ld SampleRegister, Z+
    18d8:	51 91       	ld	r21, Z+
clr NewLoad
    18da:	44 27       	eor	r20, r20

in BitCountH, GPIORBitCountH
    18dc:	35 b1       	in	r19, 0x05	; 5
in BitCountL, GPIORBitCountL
    18de:	24 b1       	in	r18, 0x04	; 4

000018e0 <LOOP>:



LOOP:
; POINT ZERO
lsr SampleRegister                                          ; 1
    18e0:	56 95       	lsr	r21
brcc NO_TURNOFF_COMPENSATION                                ; 1 / 2
    18e2:	78 f4       	brcc	.+30     	; 0x1902 <NO_TURNOFF_COMPENSATION>

    sts AWEXC__OUTOVEN, Zero ; turn off field               ; 2
    18e4:	00 92 8c 08 	sts	0x088C, r0
    sts CODEC_READER_TIMER__CTRLA, Zero                     ; 2
    18e8:	00 92 00 08 	sts	0x0800, r0

    ldi Tmp, 0x16                                           ; 1
    18ec:	06 e1       	ldi	r16, 0x16	; 22

000018ee <TURNOFF_LOOP>:
    TURNOFF_LOOP:
        dec Tmp                                             ; 1
    18ee:	0a 95       	dec	r16
    brne TURNOFF_LOOP                                       ; 1 / 2 ; sums up to 21 * 3 + 2
    18f0:	f1 f7       	brne	.-4      	; 0x18ee <TURNOFF_LOOP>
    rjmp .+0 ; double nop                                   ; 2
    18f2:	00 c0       	rjmp	.+0      	; 0x18f4 <TURNOFF_LOOP+0x6>

    ldi Tmp, 0x01                                           ; 1
    18f4:	01 e0       	ldi	r16, 0x01	; 1
    sts CODEC_READER_TIMER__CTRLA, Tmp  ; turn on field     ; 2
    18f6:	00 93 00 08 	sts	0x0800, r16
    ldi Tmp, 0x03                                           ; 1
    18fa:	03 e0       	ldi	r16, 0x03	; 3
    sts AWEXC__OUTOVEN, Tmp                                 ; 2
    18fc:	00 93 8c 08 	sts	0x088C, r16

    rjmp NO_TURNOFF                                         ; 2
    1900:	04 c0       	rjmp	.+8      	; 0x190a <NO_TURNOFF>

00001902 <NO_TURNOFF_COMPENSATION>:
                                                            ; SUM: 82 until now


NO_TURNOFF_COMPENSATION:
ldi Tmp, 26                                                 ; 1
    1902:	0a e1       	ldi	r16, 0x1A	; 26

00001904 <NO_TURNOFF_COMPENSATION_LOOP>:
NO_TURNOFF_COMPENSATION_LOOP:
    dec Tmp                                                 ; 1
    1904:	0a 95       	dec	r16
    brne NO_TURNOFF_COMPENSATION_LOOP                       ; 1 / 2 sums up to 25 * 3 + 2
    1906:	f1 f7       	brne	.-4      	; 0x1904 <NO_TURNOFF_COMPENSATION_LOOP>
nop                                                         ; 1
    1908:	00 00       	nop

0000190a <NO_TURNOFF>:
NO_TURNOFF:                                                 ; 82 at this point
subi BitCountL, 1 ; decrement BitCount                      ; 1
    190a:	21 50       	subi	r18, 0x01	; 1
sbci BitCountH, 0                                           ; 1
    190c:	30 40       	sbci	r19, 0x00	; 0
brne NO_EOC                                                 ; 1 / 2
    190e:	19 f4       	brne	.+6      	; 0x1916 <NO_EOC>

    ; EOC:
    call Reader14443AMillerEOC
    1910:	0e 94 66 28 	call	0x50cc	; 0x50cc <Reader14443AMillerEOC>
    rjmp RETURN
    1914:	0c c0       	rjmp	.+24     	; 0x192e <RETURN>

00001916 <NO_EOC>:

NO_EOC:                                                     ; 86 at this point
subi NewLoad, 0xFF                                          ; 1
    1916:	4f 5f       	subi	r20, 0xFF	; 255
andi NewLoad, 0x07                                          ; 1
    1918:	47 70       	andi	r20, 0x07	; 7
brne LOAD_COMPENSATION                                      ; 1 / 2
    191a:	11 f4       	brne	.+4      	; 0x1920 <LOAD_COMPENSATION>
                                                            ; SUM: 4
    ld SampleRegister, Z+                                   ; 3
    191c:	51 91       	ld	r21, Z+
    rjmp NOP_LOOP_INIT                                      ; 2
    191e:	02 c0       	rjmp	.+4      	; 0x1924 <NOP_LOOP_INIT>

00001920 <LOAD_COMPENSATION>:

LOAD_COMPENSATION: ; 90 at this point
rjmp .+0 ; double nop                                       ; 2
    1920:	00 c0       	rjmp	.+0      	; 0x1922 <LOAD_COMPENSATION+0x2>
rjmp .+0 ; double nop                                       ; 2
    1922:	00 c0       	rjmp	.+0      	; 0x1924 <NOP_LOOP_INIT>

00001924 <NOP_LOOP_INIT>:
NOP_LOOP_INIT:
ldi Tmp, 10                                                 ; 1
    1924:	0a e0       	ldi	r16, 0x0A	; 10

00001926 <NOP_LOOP>:
NOP_LOOP:
    dec Tmp                                                 ; 1
    1926:	0a 95       	dec	r16
    brne NOP_LOOP                                           ; 1 / 2 sums up to 9 * 3 + 2
    1928:	f1 f7       	brne	.-4      	; 0x1926 <NOP_LOOP>
rjmp .+0                                                    ; 2
    192a:	00 c0       	rjmp	.+0      	; 0x192c <NOP_LOOP+0x6>
rjmp LOOP                                                   ; 2
    192c:	d9 cf       	rjmp	.-78     	; 0x18e0 <LOOP>

0000192e <RETURN>:

RETURN:
pop ZH
    192e:	ff 91       	pop	r31
pop ZL
    1930:	ef 91       	pop	r30
pop Tmp
    1932:	0f 91       	pop	r16
out 0x3f, Tmp ; SREG
    1934:	0f bf       	out	0x3f, r16	; 63
pop SampleRegister
    1936:	5f 91       	pop	r21
pop NewLoad
    1938:	4f 91       	pop	r20
pop BitCountH
    193a:	3f 91       	pop	r19
pop BitCountL
    193c:	2f 91       	pop	r18
pop Tmp
    193e:	0f 91       	pop	r16
pop Zero
    1940:	0f 90       	pop	r0
reti                                                        ; 2
    1942:	18 95       	reti

00001944 <main>:
#include "Chameleon-Mini.h"

int main(void)
{
    SystemInit();
    1944:	15 d1       	rcall	.+554    	; 0x1b70 <SystemInit>
    SettingsLoad();
    1946:	0e 94 95 17 	call	0x2f2a	; 0x2f2a <SettingsLoad>
    LEDInit();
    194a:	0e 94 14 18 	call	0x3028	; 0x3028 <LEDInit>
    MemoryInit();
    194e:	c9 d2       	rcall	.+1426   	; 0x1ee2 <MemoryInit>
{
    /* Configure CARRIER input pin and route it to EVSYS.
     * Multiply by 2 again by using both edges when externally
     * dividing by 2 */
#if CODEC_CARRIER_IN_DIV == 2
    CODEC_CARRIER_IN_PORT.CODEC_CARRIER_IN_PINCTRL = PORT_ISC_BOTHEDGES_gc;
    1950:	10 92 52 06 	sts	0x0652, r1
#else
#error Option not supported
#endif
    CODEC_CARRIER_IN_PORT.DIRCLR = CODEC_CARRIER_IN_MASK;
    1954:	84 e0       	ldi	r24, 0x04	; 4
    1956:	80 93 42 06 	sts	0x0642, r24
    EVSYS.CH6MUX = CODEC_CARRIER_IN_EVMUX;
    195a:	82 e6       	ldi	r24, 0x62	; 98
    195c:	80 93 86 01 	sts	0x0186, r24

    /* Configure two DEMOD pins for input.
     * Configure event channel 0 for rising edge (begin of modulation pause)
     * Configure event channel 1 for falling edge (end of modulation pause) */
    CODEC_DEMOD_POWER_PORT.OUTCLR = CODEC_DEMOD_POWER_MASK;
    1960:	c1 e0       	ldi	r28, 0x01	; 1
    1962:	c0 93 26 06 	sts	0x0626, r28
    CODEC_DEMOD_POWER_PORT.DIRSET = CODEC_DEMOD_POWER_MASK;
    1966:	c0 93 21 06 	sts	0x0621, r28
    CODEC_DEMOD_IN_PORT.DIRCLR = CODEC_DEMOD_IN_MASK;
    196a:	86 e0       	ldi	r24, 0x06	; 6
    196c:	80 93 22 06 	sts	0x0622, r24
    CODEC_DEMOD_IN_PORT.CODEC_DEMOD_IN_PINCTRL0 = PORT_ISC_RISING_gc;
    1970:	c0 93 31 06 	sts	0x0631, r28
    CODEC_DEMOD_IN_PORT.CODEC_DEMOD_IN_PINCTRL1 = PORT_ISC_FALLING_gc;
    1974:	12 e0       	ldi	r17, 0x02	; 2
    1976:	10 93 32 06 	sts	0x0632, r17
    CODEC_DEMOD_IN_PORT.INT0MASK = 0;
    197a:	10 92 2a 06 	sts	0x062A, r1
    CODEC_DEMOD_IN_PORT.INT1MASK = 0;
    197e:	10 92 2b 06 	sts	0x062B, r1
    CODEC_DEMOD_IN_PORT.INTCTRL = PORT_INT0LVL_HI_gc | PORT_INT1LVL_HI_gc;
    1982:	8f e0       	ldi	r24, 0x0F	; 15
    1984:	80 93 29 06 	sts	0x0629, r24
    EVSYS.CH0MUX = CODEC_DEMOD_IN_EVMUX0;
    1988:	89 e5       	ldi	r24, 0x59	; 89
    198a:	80 93 80 01 	sts	0x0180, r24
    EVSYS.CH1MUX = CODEC_DEMOD_IN_EVMUX1;
    198e:	9a e5       	ldi	r25, 0x5A	; 90
    1990:	90 93 81 01 	sts	0x0181, r25

    EVSYS.CH2MUX = CODEC_DEMOD_IN_EVMUX0;
    1994:	80 93 82 01 	sts	0x0182, r24


    /* Configure loadmod pin configuration and use a virtual port configuration
     * for single instruction cycle access */
    CODEC_LOADMOD_PORT.DIRSET = CODEC_LOADMOD_MASK;
    1998:	80 e4       	ldi	r24, 0x40	; 64
    199a:	80 93 41 06 	sts	0x0641, r24
    CODEC_LOADMOD_PORT.OUTCLR = CODEC_LOADMOD_MASK;
    199e:	80 93 46 06 	sts	0x0646, r24
    PORTCFG.VPCTRLA &= ~PORTCFG_VP0MAP_gm;
    19a2:	90 91 b2 00 	lds	r25, 0x00B2
    19a6:	90 7f       	andi	r25, 0xF0	; 240
    19a8:	90 93 b2 00 	sts	0x00B2, r25
    PORTCFG.VPCTRLA |= PORTCFG_VP02MAP_PORTC_gc;
    19ac:	90 91 b2 00 	lds	r25, 0x00B2
    19b0:	92 60       	ori	r25, 0x02	; 2
    19b2:	90 93 b2 00 	sts	0x00B2, r25

    /* Configure subcarrier pins for output */
    CODEC_SUBCARRIER_PORT.DIRSET = CODEC_SUBCARRIER_MASK;
    19b6:	90 e3       	ldi	r25, 0x30	; 48
    19b8:	90 93 41 06 	sts	0x0641, r25
    CODEC_SUBCARRIER_PORT.OUTCLR = CODEC_SUBCARRIER_MASK;
    19bc:	90 93 46 06 	sts	0x0646, r25

    /* Configure pins for reader field with the LEFT output being inverted
     * and all bridge outputs static high */
    CODEC_READER_PORT.CODEC_READER_PINCTRL_LEFT = PORT_INVEN_bm;
    19c0:	80 93 50 06 	sts	0x0650, r24
    CODEC_READER_PORT.OUTCLR = CODEC_READER_MASK_LEFT;
    19c4:	c0 93 46 06 	sts	0x0646, r28
    CODEC_READER_PORT.OUTSET = CODEC_READER_MASK_RIGHT;
    19c8:	10 93 45 06 	sts	0x0645, r17
    CODEC_READER_PORT.DIRSET = CODEC_READER_MASK;
    19cc:	03 e0       	ldi	r16, 0x03	; 3
    19ce:	00 93 41 06 	sts	0x0641, r16

    /* Configure timer for generating reader field and configure AWEX for outputting pattern
     * with disabled outputs. */
    CODEC_READER_TIMER.CTRLB = TC0_CCAEN_bm | TC_WGMODE_SINGLESLOPE_gc;
    19d2:	83 e1       	ldi	r24, 0x13	; 19
    19d4:	80 93 01 08 	sts	0x0801, r24
    CODEC_READER_TIMER.PER = F_CPU / CODEC_CARRIER_FREQ - 1;
    19d8:	21 e0       	ldi	r18, 0x01	; 1
    19da:	30 e0       	ldi	r19, 0x00	; 0
    19dc:	20 93 26 08 	sts	0x0826, r18
    19e0:	30 93 27 08 	sts	0x0827, r19
    CODEC_READER_TIMER.CCA = F_CPU / CODEC_CARRIER_FREQ / 2 ;
    19e4:	20 93 28 08 	sts	0x0828, r18
    19e8:	30 93 29 08 	sts	0x0829, r19

    AWEXC.OUTOVEN = 0x00;
    19ec:	10 92 8c 08 	sts	0x088C, r1
    AWEXC.CTRL = AWEX_CWCM_bm | AWEX_DTICCAEN_bm | AWEX_DTICCBEN_bm;
    19f0:	80 93 80 08 	sts	0x0880, r24

    /* Configure DAC for the reference voltage */
    DACB.EVCTRL = 0;
    19f4:	10 92 23 03 	sts	0x0323, r1
    DACB.CTRLB = DAC_CHSEL_SINGLE_gc;
    19f8:	10 92 21 03 	sts	0x0321, r1
    DACB.CTRLC = DAC_REFSEL_AVCC_gc;
    19fc:	d8 e0       	ldi	r29, 0x08	; 8
    19fe:	d0 93 22 03 	sts	0x0322, r29
    DACB.CTRLA = DAC_IDOEN_bm | DAC_ENABLE_bm;
    1a02:	81 e1       	ldi	r24, 0x11	; 17
    1a04:	80 93 20 03 	sts	0x0320, r24
    DACB.CH0DATA = GlobalSettings.ActiveSettingPtr->ReaderThreshold; // real threshold voltage can be calculated with ch0data * Vref / 0xFFF
    1a08:	e0 91 71 2f 	lds	r30, 0x2F71
    1a0c:	f0 91 72 2f 	lds	r31, 0x2F72
    1a10:	82 85       	ldd	r24, Z+10	; 0x0a
    1a12:	93 85       	ldd	r25, Z+11	; 0x0b
    1a14:	80 93 38 03 	sts	0x0338, r24
    1a18:	90 93 39 03 	sts	0x0339, r25

    /* Configure Analog Comparator 0 to detect changes in demodulated reader field */
    ACA.AC0MUXCTRL = AC_MUXPOS_DAC_gc | AC_MUXNEG_PIN7_gc;
    1a1c:	8c e3       	ldi	r24, 0x3C	; 60
    1a1e:	80 93 82 03 	sts	0x0382, r24
    ACA.AC0CTRL = CODEC_AC_DEMOD_SETTINGS;
    1a22:	d0 93 80 03 	sts	0x0380, r29

    /* Configure Analog Comparator 1 to detect SOC */
    ACA.AC1MUXCTRL = AC_MUXPOS_DAC_gc | AC_MUXNEG_PIN7_gc;
    1a26:	80 93 83 03 	sts	0x0383, r24
    ACA.AC1CTRL = CODEC_AC_DEMOD_SETTINGS;
    1a2a:	d0 93 81 03 	sts	0x0381, r29
    CodecInitCommon();
    ConfigurationInit();
    1a2e:	6f d1       	rcall	.+734    	; 0x1d0e <ConfigurationInit>
    TerminalInit();
    1a30:	0e 94 bf 19 	call	0x337e	; 0x337e <TerminalInit>
    RandomInit();
    1a34:	c0 d1       	rcall	.+896    	; 0x1db6 <RandomInit>
    ButtonInit();
    1a36:	3f d7       	rcall	.+3710   	; 0x28b6 <ButtonInit>
#define ANTENNA_LEVEL_DENOMINATOR (ANTENNA_LEVEL_SCALE)

static inline
void AntennaLevelInit(void)
{
    ADCA.CTRLA = ADC_ENABLE_bm;
    1a38:	c0 93 00 02 	sts	0x0200, r28
    ADCA.CTRLB = ADC_RESOLUTION_12BIT_gc;
    1a3c:	10 92 01 02 	sts	0x0201, r1
    ADCA.REFCTRL = ADC_REFSEL_INT1V_gc | ADC_BANDGAP_bm;
    1a40:	10 93 02 02 	sts	0x0202, r17
    ADCA.PRESCALER = ADC_PRESCALER_DIV32_gc;
    1a44:	00 93 04 02 	sts	0x0204, r16
    ADCA.CH0.CTRL = ADC_CH_INPUTMODE_SINGLEENDED_gc;
    1a48:	c0 93 20 02 	sts	0x0220, r28
    ADCA.CH0.MUXCTRL = ADC_CH_MUXPOS_PIN1_gc;
    1a4c:	d0 93 21 02 	sts	0x0221, r29
    AntennaLevelInit();
    LogInit();
    1a50:	0e 94 20 16 	call	0x2c40	; 0x2c40 <LogInit>
    SystemInterruptInit();
    1a54:	19 d1       	rcall	.+562    	; 0x1c88 <SystemInterruptInit>
{
    if (RTC.INTFLAGS & RTC_COMPIF_bm) {
        while(RTC.STATUS & RTC_SYNCBUSY_bm)
            ;

        RTC.INTFLAGS = RTC_COMPIF_bm;
    1a56:	d2 e0       	ldi	r29, 0x02	; 2
    if (GlobalSettings.ActiveSettingPtr->LEDGreenFunction == Func) {
        LEDGreenAction = Action;
    }

    if (GlobalSettings.ActiveSettingPtr->LEDRedFunction == Func) {
        LEDRedAction = Action;
    1a58:	c1 e1       	ldi	r28, 0x11	; 17
void SystemInterruptInit(void);
INLINE bool SystemTick100ms(void);

INLINE bool SystemTick100ms(void)
{
    if (RTC.INTFLAGS & RTC_COMPIF_bm) {
    1a5a:	80 91 03 04 	lds	r24, 0x0403
    1a5e:	81 ff       	sbrs	r24, 1
    1a60:	25 c0       	rjmp	.+74     	; 0x1aac <main+0x168>
        while(RTC.STATUS & RTC_SYNCBUSY_bm)
    1a62:	80 91 01 04 	lds	r24, 0x0401
    1a66:	80 fd       	sbrc	r24, 0
    1a68:	fc cf       	rjmp	.-8      	; 0x1a62 <main+0x11e>
            ;

        RTC.INTFLAGS = RTC_COMPIF_bm;
    1a6a:	d0 93 03 04 	sts	0x0403, r29

    while(1) {
        if (SystemTick100ms()) {
            LEDTick(); // this has to be the first function called here, since it is time-critical - the functions below may have non-negligible runtimes!
    1a6e:	0e 94 18 18 	call	0x3030	; 0x3030 <LEDTick>

            RandomTick();
    1a72:	b6 d1       	rcall	.+876    	; 0x1de0 <RandomTick>
            TerminalTick();
    1a74:	0e 94 f2 19 	call	0x33e4	; 0x33e4 <TerminalTick>
            ButtonTick();
    1a78:	26 d7       	rcall	.+3660   	; 0x28c6 <ButtonTick>
            LogTick();
    1a7a:	0e 94 90 17 	call	0x2f20	; 0x2f20 <LogTick>
INLINE void ApplicationTask(void) {
	ActiveConfiguration.ApplicationTaskFunc();
}

INLINE void ApplicationTick(void) {
	ActiveConfiguration.ApplicationTickFunc();
    1a7e:	e0 91 62 2f 	lds	r30, 0x2F62
    1a82:	f0 91 63 2f 	lds	r31, 0x2F63
    1a86:	19 95       	eicall
            ApplicationTick();
            CommandLineTick();
    1a88:	0e 94 fb 22 	call	0x45f6	; 0x45f6 <CommandLineTick>
            AntennaLevelTick();
    1a8c:	0e 94 5c 19 	call	0x32b8	; 0x32b8 <AntennaLevelTick>

INLINE void LEDHook(LEDHookEnum Func, LEDActionEnum Action) {
    extern LEDActionEnum LEDGreenAction;
    extern LEDActionEnum LEDRedAction;

    if (GlobalSettings.ActiveSettingPtr->LEDGreenFunction == Func) {
    1a90:	e0 91 71 2f 	lds	r30, 0x2F71
    1a94:	f0 91 72 2f 	lds	r31, 0x2F72
    1a98:	87 81       	ldd	r24, Z+7	; 0x07
    1a9a:	81 30       	cpi	r24, 0x01	; 1
    1a9c:	11 f4       	brne	.+4      	; 0x1aa2 <main+0x15e>
        LEDGreenAction = Action;
    1a9e:	c0 93 7d 2c 	sts	0x2C7D, r28
    }

    if (GlobalSettings.ActiveSettingPtr->LEDRedFunction == Func) {
    1aa2:	86 81       	ldd	r24, Z+6	; 0x06
    1aa4:	81 30       	cpi	r24, 0x01	; 1
    1aa6:	11 f4       	brne	.+4      	; 0x1aac <main+0x168>
        LEDRedAction = Action;
    1aa8:	c0 93 7c 2c 	sts	0x2C7C, r28

            LEDHook(LED_POWERED, LED_ON);
        }

        TerminalTask();
    1aac:	0e 94 c3 19 	call	0x3386	; 0x3386 <TerminalTask>
        LogTask();
    1ab0:	c8 d7       	rcall	.+3984   	; 0x2a42 <LogTask>
INLINE void ApplicationInit(void) {
    ActiveConfiguration.ApplicationInitFunc();
}

INLINE void ApplicationTask(void) {
	ActiveConfiguration.ApplicationTaskFunc();
    1ab2:	e0 91 60 2f 	lds	r30, 0x2F60
    1ab6:	f0 91 61 2f 	lds	r31, 0x2F61
    1aba:	19 95       	eicall
INLINE void CodecDeInit(void) {
    ActiveConfiguration.CodecDeInitFunc();
}

INLINE void CodecTask(void) {
    ActiveConfiguration.CodecTaskFunc();
    1abc:	e0 91 5a 2f 	lds	r30, 0x2F5A
    1ac0:	f0 91 5b 2f 	lds	r31, 0x2F5B
    1ac4:	19 95       	eicall
    1ac6:	c9 cf       	rjmp	.-110    	; 0x1a5a <main+0x116>

00001ac8 <CALLBACK_USB_GetDescriptor>:
 */
uint16_t CALLBACK_USB_GetDescriptor(const uint16_t wValue,
                                    const uint8_t wIndex,
                                    const void** const DescriptorAddress)
{
    const uint8_t  DescriptorType   = (wValue >> 8);
    1ac8:	29 2f       	mov	r18, r25
    1aca:	33 27       	eor	r19, r19
    const uint8_t  DescriptorNumber = (wValue & 0xFF);

    const void* Address = NULL;
    uint16_t    Size    = NO_DESCRIPTOR;

    switch (DescriptorType)
    1acc:	22 30       	cpi	r18, 0x02	; 2
    1ace:	31 05       	cpc	r19, r1
    1ad0:	59 f0       	breq	.+22     	; 0x1ae8 <CALLBACK_USB_GetDescriptor+0x20>
    1ad2:	23 30       	cpi	r18, 0x03	; 3
    1ad4:	31 05       	cpc	r19, r1
    1ad6:	69 f0       	breq	.+26     	; 0x1af2 <CALLBACK_USB_GetDescriptor+0x2a>
    1ad8:	21 30       	cpi	r18, 0x01	; 1
    1ada:	31 05       	cpc	r19, r1
    1adc:	f9 f4       	brne	.+62     	; 0x1b1c <CALLBACK_USB_GetDescriptor+0x54>
    {
        case DTYPE_Device:
            Address = &DeviceDescriptor;
            Size    = sizeof(USB_Descriptor_Device_t);
    1ade:	82 e1       	ldi	r24, 0x12	; 18
    1ae0:	90 e0       	ldi	r25, 0x00	; 0
    uint16_t    Size    = NO_DESCRIPTOR;

    switch (DescriptorType)
    {
        case DTYPE_Device:
            Address = &DeviceDescriptor;
    1ae2:	2a e8       	ldi	r18, 0x8A	; 138
    1ae4:	32 e0       	ldi	r19, 0x02	; 2
    1ae6:	1e c0       	rjmp	.+60     	; 0x1b24 <CALLBACK_USB_GetDescriptor+0x5c>
            Size    = sizeof(USB_Descriptor_Device_t);
            break;
        case DTYPE_Configuration:
            Address = &ConfigurationDescriptor;
            Size    = sizeof(USB_Descriptor_Configuration_t);
    1ae8:	8e e3       	ldi	r24, 0x3E	; 62
    1aea:	90 e0       	ldi	r25, 0x00	; 0
        case DTYPE_Device:
            Address = &DeviceDescriptor;
            Size    = sizeof(USB_Descriptor_Device_t);
            break;
        case DTYPE_Configuration:
            Address = &ConfigurationDescriptor;
    1aec:	2c e4       	ldi	r18, 0x4C	; 76
    1aee:	32 e0       	ldi	r19, 0x02	; 2
            Size    = sizeof(USB_Descriptor_Configuration_t);
            break;
    1af0:	19 c0       	rjmp	.+50     	; 0x1b24 <CALLBACK_USB_GetDescriptor+0x5c>
    1af2:	99 27       	eor	r25, r25
        case DTYPE_String:
            switch (DescriptorNumber)
    1af4:	81 30       	cpi	r24, 0x01	; 1
    1af6:	91 05       	cpc	r25, r1
    1af8:	41 f0       	breq	.+16     	; 0x1b0a <CALLBACK_USB_GetDescriptor+0x42>
    1afa:	82 30       	cpi	r24, 0x02	; 2
    1afc:	91 05       	cpc	r25, r1
    1afe:	41 f0       	breq	.+16     	; 0x1b10 <CALLBACK_USB_GetDescriptor+0x48>
    1b00:	89 2b       	or	r24, r25
    1b02:	61 f4       	brne	.+24     	; 0x1b1c <CALLBACK_USB_GetDescriptor+0x54>
            {
                case 0x00:
                    Address = &LanguageString;
                    Size    = pgm_read_byte(&LanguageString.Header.Size);
    1b04:	e8 e4       	ldi	r30, 0x48	; 72
    1b06:	f2 e0       	ldi	r31, 0x02	; 2
    1b08:	05 c0       	rjmp	.+10     	; 0x1b14 <CALLBACK_USB_GetDescriptor+0x4c>
                    break;
                case 0x01:
                    Address = &ManufacturerString;
                    Size    = pgm_read_byte(&ManufacturerString.Header.Size);
    1b0a:	ec e1       	ldi	r30, 0x1C	; 28
    1b0c:	f2 e0       	ldi	r31, 0x02	; 2
    1b0e:	02 c0       	rjmp	.+4      	; 0x1b14 <CALLBACK_USB_GetDescriptor+0x4c>
                    break;
                case 0x02:
                    Address = &ProductString;
                    Size    = pgm_read_byte(&ProductString.Header.Size);
    1b10:	ec ef       	ldi	r30, 0xFC	; 252
    1b12:	f1 e0       	ldi	r31, 0x01	; 1
    1b14:	84 91       	lpm	r24, Z
    1b16:	90 e0       	ldi	r25, 0x00	; 0
                case 0x01:
                    Address = &ManufacturerString;
                    Size    = pgm_read_byte(&ManufacturerString.Header.Size);
                    break;
                case 0x02:
                    Address = &ProductString;
    1b18:	9f 01       	movw	r18, r30
                    Size    = pgm_read_byte(&ProductString.Header.Size);
                    break;
    1b1a:	04 c0       	rjmp	.+8      	; 0x1b24 <CALLBACK_USB_GetDescriptor+0x5c>
{
    const uint8_t  DescriptorType   = (wValue >> 8);
    const uint8_t  DescriptorNumber = (wValue & 0xFF);

    const void* Address = NULL;
    uint16_t    Size    = NO_DESCRIPTOR;
    1b1c:	80 e0       	ldi	r24, 0x00	; 0
    1b1e:	90 e0       	ldi	r25, 0x00	; 0
                                    const void** const DescriptorAddress)
{
    const uint8_t  DescriptorType   = (wValue >> 8);
    const uint8_t  DescriptorNumber = (wValue & 0xFF);

    const void* Address = NULL;
    1b20:	20 e0       	ldi	r18, 0x00	; 0
    1b22:	30 e0       	ldi	r19, 0x00	; 0
            }

            break;
    }

    *DescriptorAddress = Address;
    1b24:	fa 01       	movw	r30, r20
    1b26:	20 83       	st	Z, r18
    1b28:	31 83       	std	Z+1, r19	; 0x01
    return Size;
}
    1b2a:	08 95       	ret

00001b2c <__vector_default>:
#ifndef WDT_PER_500CLK_gc
#define WDT_PER_500CLK_gc WDT_PER_512CLK_gc
#endif

ISR(BADISR_vect)
{
    1b2c:	1f 92       	push	r1
    1b2e:	0f 92       	push	r0
    1b30:	0f b6       	in	r0, 0x3f	; 63
    1b32:	0f 92       	push	r0
    1b34:	11 24       	eor	r1, r1
    1b36:	08 b6       	in	r0, 0x38	; 56
    1b38:	0f 92       	push	r0
    1b3a:	18 be       	out	0x38, r1	; 56
    //LED_PORT.OUTSET = LED_RED;
    while(1);
    1b3c:	ff cf       	rjmp	.-2      	; 0x1b3c <__vector_default+0x10>

00001b3e <__vector_10>:
}

ISR(RTC_OVF_vect)
{
    1b3e:	1f 92       	push	r1
    1b40:	0f 92       	push	r0
    1b42:	0f b6       	in	r0, 0x3f	; 63
    1b44:	0f 92       	push	r0
    1b46:	11 24       	eor	r1, r1
    1b48:	08 b6       	in	r0, 0x38	; 56
    1b4a:	0f 92       	push	r0
    1b4c:	18 be       	out	0x38, r1	; 56
    1b4e:	8f 93       	push	r24
    1b50:	9f 93       	push	r25
    SYSTEM_TICK_REGISTER += SYSTEM_TICK_PERIOD;
    1b52:	8e b1       	in	r24, 0x0e	; 14
    1b54:	9f b1       	in	r25, 0x0f	; 15
    1b56:	80 58       	subi	r24, 0x80	; 128
    1b58:	9f 4f       	sbci	r25, 0xFF	; 255
    1b5a:	8e b9       	out	0x0e, r24	; 14
    1b5c:	9f b9       	out	0x0f, r25	; 15
}
    1b5e:	9f 91       	pop	r25
    1b60:	8f 91       	pop	r24
    1b62:	0f 90       	pop	r0
    1b64:	08 be       	out	0x38, r0	; 56
    1b66:	0f 90       	pop	r0
    1b68:	0f be       	out	0x3f, r0	; 63
    1b6a:	0f 90       	pop	r0
    1b6c:	1f 90       	pop	r1
    1b6e:	18 95       	reti

00001b70 <SystemInit>:

void SystemInit(void)
{
    if (RST.STATUS & RST_WDRF_bm) {
    1b70:	80 91 78 00 	lds	r24, 0x0078
    1b74:	83 ff       	sbrs	r24, 3
    1b76:	0a c0       	rjmp	.+20     	; 0x1b8c <SystemInit+0x1c>
        /* On Watchdog reset clear WDRF bit, disable watchdog
         * and jump into bootloader */
        RST.STATUS = RST_WDRF_bm;
    1b78:	88 e0       	ldi	r24, 0x08	; 8
    1b7a:	80 93 78 00 	sts	0x0078, r24

        CCP = CCP_IOREG_gc;
    1b7e:	88 ed       	ldi	r24, 0xD8	; 216
    1b80:	84 bf       	out	0x34, r24	; 52
        WDT.CTRL = WDT_CEN_bm;
    1b82:	81 e0       	ldi	r24, 0x01	; 1
    1b84:	80 93 80 00 	sts	0x0080, r24

        asm volatile ("jmp %0"::"i" (BOOT_SECTION_START + 0x1FC));
    1b88:	0d 94 fe 00 	jmp	0x201fc	; 0x201fc <__data_load_end+0x123c2>
    }

    /* XTAL x 2 as SysCLK */
    OSC.XOSCCTRL = OSC_FRQRANGE_12TO16_gc | OSC_XOSCSEL_XTAL_16KCLK_gc;
    1b8c:	8b ec       	ldi	r24, 0xCB	; 203
    1b8e:	80 93 52 00 	sts	0x0052, r24
    OSC.CTRL |= OSC_XOSCEN_bm;
    1b92:	80 91 50 00 	lds	r24, 0x0050
    1b96:	88 60       	ori	r24, 0x08	; 8
    1b98:	80 93 50 00 	sts	0x0050, r24
    while(!(OSC.STATUS & OSC_XOSCRDY_bm))
    1b9c:	80 91 51 00 	lds	r24, 0x0051
    1ba0:	83 ff       	sbrs	r24, 3
    1ba2:	fc cf       	rjmp	.-8      	; 0x1b9c <SystemInit+0x2c>
        ;

    OSC.PLLCTRL = OSC_PLLSRC_XOSC_gc | (2 << OSC_PLLFAC_gp);
    1ba4:	82 ec       	ldi	r24, 0xC2	; 194
    1ba6:	80 93 55 00 	sts	0x0055, r24
    OSC.CTRL |= OSC_PLLEN_bm;
    1baa:	80 91 50 00 	lds	r24, 0x0050
    1bae:	80 61       	ori	r24, 0x10	; 16
    1bb0:	80 93 50 00 	sts	0x0050, r24

    while(!(OSC.STATUS & OSC_PLLRDY_bm))
    1bb4:	80 91 51 00 	lds	r24, 0x0051
    1bb8:	84 ff       	sbrs	r24, 4
    1bba:	fc cf       	rjmp	.-8      	; 0x1bb4 <SystemInit+0x44>
        ;

    /* Set PLL as main clock */
    CCP = CCP_IOREG_gc;
    1bbc:	88 ed       	ldi	r24, 0xD8	; 216
    1bbe:	84 bf       	out	0x34, r24	; 52
    CLK.CTRL = CLK_SCLKSEL_PLL_gc;
    1bc0:	84 e0       	ldi	r24, 0x04	; 4
    1bc2:	80 93 40 00 	sts	0x0040, r24

    SYSTEM_TICK_REGISTER = 0;
    1bc6:	1e b8       	out	0x0e, r1	; 14
    1bc8:	1f b8       	out	0x0f, r1	; 15

    /* Enable RTC with roughly 1kHz clock for system tick
     * and to wake up while sleeping. */
    CLK.RTCCTRL = CLK_RTCSRC_ULP_gc | CLK_RTCEN_bm;
    1bca:	81 e0       	ldi	r24, 0x01	; 1
    1bcc:	80 93 43 00 	sts	0x0043, r24
    RTC.PER = SYSTEM_TICK_PERIOD - 1;
    1bd0:	2f e7       	ldi	r18, 0x7F	; 127
    1bd2:	30 e0       	ldi	r19, 0x00	; 0
    1bd4:	20 93 0a 04 	sts	0x040A, r18
    1bd8:	30 93 0b 04 	sts	0x040B, r19
    RTC.COMP = SYSTEM_TICK_PERIOD - 1;
    1bdc:	20 93 0c 04 	sts	0x040C, r18
    1be0:	30 93 0d 04 	sts	0x040D, r19
    RTC.CTRL = RTC_PRESCALER_DIV1_gc;
    1be4:	80 93 00 04 	sts	0x0400, r24
    RTC.INTCTRL = RTC_OVFINTLVL_LO_gc;
    1be8:	80 93 02 04 	sts	0x0402, r24

    /* Enable EEPROM data memory mapping */
    //NVM.CTRLB |= NVM_EEMAPEN_bm;

    /* Enable DMA */
    DMA.CTRL = DMA_ENABLE_bm | DMA_DBUFMODE_DISABLED_gc | DMA_PRIMODE_RR0123_gc;
    1bec:	80 e8       	ldi	r24, 0x80	; 128
    1bee:	80 93 00 01 	sts	0x0100, r24
    1bf2:	08 95       	ret

00001bf4 <SystemReset>:

}

void SystemReset(void)
{
    CCP = CCP_IOREG_gc;
    1bf4:	88 ed       	ldi	r24, 0xD8	; 216
    1bf6:	84 bf       	out	0x34, r24	; 52
    RST.CTRL = RST_SWRST_bm;
    1bf8:	81 e0       	ldi	r24, 0x01	; 1
    1bfa:	80 93 79 00 	sts	0x0079, r24
    1bfe:	08 95       	ret

00001c00 <SystemEnterBootloader>:
}

void SystemEnterBootloader(void)
{
    /* Use Watchdog timer to reset into bootloader. */
    CCP = CCP_IOREG_gc;
    1c00:	88 ed       	ldi	r24, 0xD8	; 216
    1c02:	84 bf       	out	0x34, r24	; 52
    WDT.CTRL = WDT_PER_500CLK_gc | WDT_ENABLE_bm | WDT_CEN_bm;
    1c04:	8b e1       	ldi	r24, 0x1B	; 27
    1c06:	80 93 80 00 	sts	0x0080, r24
    1c0a:	08 95       	ret

00001c0c <SystemStartUSBClock>:
    OSC.CTRL |= OSC_PLLEN_bm;
    while(!(OSC.STATUS & OSC_PLLRDY_bm))
        ;
#else
    /* Use internal HS RC for USB */
    OSC.CTRL |= OSC_RC32MEN_bm;
    1c0c:	80 91 50 00 	lds	r24, 0x0050
    1c10:	82 60       	ori	r24, 0x02	; 2
    1c12:	80 93 50 00 	sts	0x0050, r24
    while(!(OSC.STATUS & OSC_RC32MRDY_bm))
    1c16:	80 91 51 00 	lds	r24, 0x0051
    1c1a:	81 ff       	sbrs	r24, 1
    1c1c:	fc cf       	rjmp	.-8      	; 0x1c16 <SystemStartUSBClock+0xa>
        ;

    /* Load RC32 CAL values for 48MHz use */
    NVM.CMD  = NVM_CMD_READ_CALIB_ROW_gc;
    1c1e:	82 e0       	ldi	r24, 0x02	; 2
    1c20:	80 93 ca 01 	sts	0x01CA, r24
    DFLLRC32M.CALA = pgm_read_byte(offsetof(NVM_PROD_SIGNATURES_t, USBRCOSCA));
    1c24:	ed e1       	ldi	r30, 0x1D	; 29
    1c26:	f0 e0       	ldi	r31, 0x00	; 0
    1c28:	e4 91       	lpm	r30, Z
    1c2a:	e0 93 62 00 	sts	0x0062, r30
    DFLLRC32M.CALB = pgm_read_byte(offsetof(NVM_PROD_SIGNATURES_t, USBRCOSC));
    1c2e:	ec e1       	ldi	r30, 0x1C	; 28
    1c30:	f0 e0       	ldi	r31, 0x00	; 0
    1c32:	e4 91       	lpm	r30, Z
    1c34:	e0 93 63 00 	sts	0x0063, r30
    NVM.CMD  = NVM_CMD_NO_OPERATION_gc;
    1c38:	10 92 ca 01 	sts	0x01CA, r1

    /* For USBSOF operation, whe need to use COMP = 48MHz/1kHz = 0xBB80 */
    DFLLRC32M.COMP1 = 0x80;
    1c3c:	80 e8       	ldi	r24, 0x80	; 128
    1c3e:	80 93 65 00 	sts	0x0065, r24
    DFLLRC32M.COMP2 = 0xBB;
    1c42:	8b eb       	ldi	r24, 0xBB	; 187
    1c44:	80 93 66 00 	sts	0x0066, r24

    /* Select USBSOF as DFLL source */
    OSC.DFLLCTRL &= ~OSC_RC32MCREF_gm;
    1c48:	80 91 56 00 	lds	r24, 0x0056
    1c4c:	89 7f       	andi	r24, 0xF9	; 249
    1c4e:	80 93 56 00 	sts	0x0056, r24
    OSC.DFLLCTRL |= OSC_RC32MCREF_USBSOF_gc;
    1c52:	80 91 56 00 	lds	r24, 0x0056
    1c56:	84 60       	ori	r24, 0x04	; 4
    1c58:	80 93 56 00 	sts	0x0056, r24

    /* Enable DFLL */
    DFLLRC32M.CTRL |= DFLL_ENABLE_bm;
    1c5c:	80 91 60 00 	lds	r24, 0x0060
    1c60:	81 60       	ori	r24, 0x01	; 1
    1c62:	80 93 60 00 	sts	0x0060, r24
    1c66:	08 95       	ret

00001c68 <SystemStopUSBClock>:
    CLK.USBCTRL &= ~CLK_USBSEN_bm;
    OSC.CTRL &= ~OSC_PLLEN_bm;
    OSC.CTRL &= ~OSC_XOSCEN_bm;
#else
    /* Disable USB Clock to minimize power consumption */
    CLK.USBCTRL &= ~CLK_USBSEN_bm;
    1c68:	e0 e4       	ldi	r30, 0x40	; 64
    1c6a:	f0 e0       	ldi	r31, 0x00	; 0
    1c6c:	84 81       	ldd	r24, Z+4	; 0x04
    1c6e:	8e 7f       	andi	r24, 0xFE	; 254
    1c70:	84 83       	std	Z+4, r24	; 0x04
    DFLLRC32M.CTRL &= ~DFLL_ENABLE_bm;
    1c72:	e0 e6       	ldi	r30, 0x60	; 96
    1c74:	f0 e0       	ldi	r31, 0x00	; 0
    1c76:	80 81       	ld	r24, Z
    1c78:	8e 7f       	andi	r24, 0xFE	; 254
    1c7a:	80 83       	st	Z, r24
    OSC.CTRL &= ~OSC_RC32MEN_bm;
    1c7c:	e0 e5       	ldi	r30, 0x50	; 80
    1c7e:	f0 e0       	ldi	r31, 0x00	; 0
    1c80:	80 81       	ld	r24, Z
    1c82:	8d 7f       	andi	r24, 0xFD	; 253
    1c84:	80 83       	st	Z, r24
    1c86:	08 95       	ret

00001c88 <SystemInterruptInit>:
}

void SystemInterruptInit(void)
{
    /* Enable all interrupt levels */
    PMIC.CTRL = PMIC_LOLVLEN_bm | PMIC_MEDLVLEN_bm | PMIC_HILVLEN_bm;
    1c88:	87 e0       	ldi	r24, 0x07	; 7
    1c8a:	80 93 a2 00 	sts	0x00A2, r24
    sei();
    1c8e:	78 94       	sei
    1c90:	08 95       	ret

00001c92 <CodecInitDummy>:

/* Include all Codecs and Applications */
#include "Codec/Codec.h"
#include "Application/Application.h"

static void CodecInitDummy(void) { }
    1c92:	08 95       	ret

00001c94 <CodecDeInitDummy>:
static void CodecDeInitDummy(void) { }
    1c94:	08 95       	ret

00001c96 <CodecTaskDummy>:
static void CodecTaskDummy(void) { }
    1c96:	08 95       	ret

00001c98 <ApplicationInitDummy>:
static void ApplicationInitDummy(void) {}
    1c98:	08 95       	ret

00001c9a <ApplicationResetDummy>:
static void ApplicationResetDummy(void) {}
    1c9a:	08 95       	ret

00001c9c <ApplicationTaskDummy>:
static void ApplicationTaskDummy(void) {}
    1c9c:	08 95       	ret

00001c9e <ApplicationTickDummy>:
static void ApplicationTickDummy(void) {}
    1c9e:	08 95       	ret

00001ca0 <ApplicationProcessDummy>:
static uint16_t ApplicationProcessDummy(uint8_t* ByteBuffer, uint16_t ByteCount) { return 0; }
    1ca0:	80 e0       	ldi	r24, 0x00	; 0
    1ca2:	90 e0       	ldi	r25, 0x00	; 0
    1ca4:	08 95       	ret

00001ca6 <ApplicationGetUidDummy>:
static void ApplicationGetUidDummy(ConfigurationUidType Uid) { }
    1ca6:	08 95       	ret

00001ca8 <ApplicationSetUidDummy>:
static void ApplicationSetUidDummy(ConfigurationUidType Uid) { }
    1ca8:	08 95       	ret

00001caa <ConfigurationSetById>:

    ConfigurationSetById(GlobalSettings.ActiveSettingPtr->Configuration);
}

void ConfigurationSetById( ConfigurationEnum Configuration )
{
    1caa:	0f 93       	push	r16
    1cac:	1f 93       	push	r17
    1cae:	cf 93       	push	r28
    1cb0:	df 93       	push	r29
    1cb2:	1f 92       	push	r1
    1cb4:	cd b7       	in	r28, 0x3d	; 61
    1cb6:	de b7       	in	r29, 0x3e	; 62
INLINE void CodecInit(void) {
    ActiveConfiguration.CodecInitFunc();
}

INLINE void CodecDeInit(void) {
    ActiveConfiguration.CodecDeInitFunc();
    1cb8:	06 e5       	ldi	r16, 0x56	; 86
    1cba:	1f e2       	ldi	r17, 0x2F	; 47
    1cbc:	d8 01       	movw	r26, r16
    1cbe:	12 96       	adiw	r26, 0x02	; 2
    1cc0:	ed 91       	ld	r30, X+
    1cc2:	fc 91       	ld	r31, X
    1cc4:	13 97       	sbiw	r26, 0x03	; 3
    1cc6:	89 83       	std	Y+1, r24	; 0x01
    1cc8:	19 95       	eicall
    CodecDeInit();

    CommandLinePendingTaskBreak(); // break possibly pending task
    1cca:	0e 94 33 23 	call	0x4666	; 0x4666 <CommandLinePendingTaskBreak>

    GlobalSettings.ActiveSettingPtr->Configuration = Configuration;
    1cce:	e0 91 71 2f 	lds	r30, 0x2F71
    1cd2:	f0 91 72 2f 	lds	r31, 0x2F72
    1cd6:	89 81       	ldd	r24, Y+1	; 0x01
    1cd8:	85 83       	std	Z+5, r24	; 0x05

    /* Copy struct from PROGMEM to RAM */
    memcpy_P(&ActiveConfiguration,
            &ConfigurationTable[Configuration], sizeof(ConfigurationType));
    1cda:	b8 e1       	ldi	r27, 0x18	; 24
    1cdc:	8b 9f       	mul	r24, r27
    1cde:	b0 01       	movw	r22, r0
    1ce0:	11 24       	eor	r1, r1
    1ce2:	64 56       	subi	r22, 0x64	; 100
    1ce4:	7d 4f       	sbci	r23, 0xFD	; 253
    CommandLinePendingTaskBreak(); // break possibly pending task

    GlobalSettings.ActiveSettingPtr->Configuration = Configuration;

    /* Copy struct from PROGMEM to RAM */
    memcpy_P(&ActiveConfiguration,
    1ce6:	48 e1       	ldi	r20, 0x18	; 24
    1ce8:	50 e0       	ldi	r21, 0x00	; 0
    1cea:	c8 01       	movw	r24, r16
    1cec:	0e 94 b9 65 	call	0xcb72	; 0xcb72 <memcpy_P>
volatile void (*isr_func_CODEC_TIMER_LOADMOD_CCB_VECT)(void);
void isr_ISO15693_CODEC_TIMER_LOADMOD_CCB_VECT(void);
void isr_SniffISO14443_2A_CODEC_TIMER_LOADMOD_CCB_VECT(void);

INLINE void CodecInit(void) {
    ActiveConfiguration.CodecInitFunc();
    1cf0:	d8 01       	movw	r26, r16
    1cf2:	ed 91       	ld	r30, X+
    1cf4:	fc 91       	ld	r31, X
    1cf6:	19 95       	eicall
#include "Sniff14443A.h"


/* Function wrappers */
INLINE void ApplicationInit(void) {
    ActiveConfiguration.ApplicationInitFunc();
    1cf8:	d8 01       	movw	r26, r16
    1cfa:	16 96       	adiw	r26, 0x06	; 6
    1cfc:	ed 91       	ld	r30, X+
    1cfe:	fc 91       	ld	r31, X
    1d00:	17 97       	sbiw	r26, 0x07	; 7
            &ConfigurationTable[Configuration], sizeof(ConfigurationType));

    CodecInit();
    ApplicationInit();
}
    1d02:	0f 90       	pop	r0
    1d04:	df 91       	pop	r29
    1d06:	cf 91       	pop	r28
    1d08:	1f 91       	pop	r17
    1d0a:	0f 91       	pop	r16
    1d0c:	19 94       	eijmp

00001d0e <ConfigurationInit>:

ConfigurationType ActiveConfiguration;

void ConfigurationInit(void)
{
    memcpy_P(&ActiveConfiguration,
    1d0e:	48 e1       	ldi	r20, 0x18	; 24
    1d10:	50 e0       	ldi	r21, 0x00	; 0
    1d12:	6c e9       	ldi	r22, 0x9C	; 156
    1d14:	72 e0       	ldi	r23, 0x02	; 2
    1d16:	86 e5       	ldi	r24, 0x56	; 86
    1d18:	9f e2       	ldi	r25, 0x2F	; 47
    1d1a:	0e 94 b9 65 	call	0xcb72	; 0xcb72 <memcpy_P>
            &ConfigurationTable[CONFIG_NONE], sizeof(ConfigurationType));

    ConfigurationSetById(GlobalSettings.ActiveSettingPtr->Configuration);
    1d1e:	e0 91 71 2f 	lds	r30, 0x2F71
    1d22:	f0 91 72 2f 	lds	r31, 0x2F72
    1d26:	85 81       	ldd	r24, Z+5	; 0x05
    1d28:	c0 cf       	rjmp	.-128    	; 0x1caa <ConfigurationSetById>

00001d2a <ConfigurationGetByName>:
    CodecInit();
    ApplicationInit();
}

void ConfigurationGetByName(char* Configuration, uint16_t BufferSize)
{
    1d2a:	0f 93       	push	r16
    1d2c:	1f 93       	push	r17
    MapIdToText(ConfigurationMap, ARRAY_COUNT(ConfigurationMap), GlobalSettings.ActiveSettingPtr->Configuration, Configuration, BufferSize);
    1d2e:	e0 91 71 2f 	lds	r30, 0x2F71
    1d32:	f0 91 72 2f 	lds	r31, 0x2F72
    1d36:	8b 01       	movw	r16, r22
    1d38:	9c 01       	movw	r18, r24
    1d3a:	45 81       	ldd	r20, Z+5	; 0x05
    1d3c:	6e e0       	ldi	r22, 0x0E	; 14
    1d3e:	8c ee       	ldi	r24, 0xEC	; 236
    1d40:	93 e0       	ldi	r25, 0x03	; 3
    1d42:	0e 94 f9 18 	call	0x31f2	; 0x31f2 <MapIdToText>
}
    1d46:	1f 91       	pop	r17
    1d48:	0f 91       	pop	r16
    1d4a:	08 95       	ret

00001d4c <ConfigurationSetByName>:

bool ConfigurationSetByName(const char* Configuration)
{
    1d4c:	ff 92       	push	r15
    1d4e:	0f 93       	push	r16
    1d50:	1f 93       	push	r17
    1d52:	cf 93       	push	r28
    1d54:	df 93       	push	r29
    1d56:	1f 92       	push	r1
    1d58:	cd b7       	in	r28, 0x3d	; 61
    1d5a:	de b7       	in	r29, 0x3e	; 62
    1d5c:	8c 01       	movw	r16, r24
    MapIdType Id;

    if (MapTextToId(ConfigurationMap, ARRAY_COUNT(ConfigurationMap), Configuration, &Id)) {
    1d5e:	9e 01       	movw	r18, r28
    1d60:	2f 5f       	subi	r18, 0xFF	; 255
    1d62:	3f 4f       	sbci	r19, 0xFF	; 255
    1d64:	ac 01       	movw	r20, r24
    1d66:	6e e0       	ldi	r22, 0x0E	; 14
    1d68:	8c ee       	ldi	r24, 0xEC	; 236
    1d6a:	93 e0       	ldi	r25, 0x03	; 3
    1d6c:	0e 94 11 19 	call	0x3222	; 0x3222 <MapTextToId>
    1d70:	f8 2e       	mov	r15, r24
    1d72:	88 23       	and	r24, r24
    1d74:	89 f0       	breq	.+34     	; 0x1d98 <ConfigurationSetByName+0x4c>
        ConfigurationSetById(Id);
    1d76:	89 81       	ldd	r24, Y+1	; 0x01
    1d78:	98 df       	rcall	.-208    	; 0x1caa <ConfigurationSetById>
    1d7a:	f8 01       	movw	r30, r16
    return pgm_read_byte(&OddParityByteTable[Byte]);
}

INLINE uint8_t StringLength(const char* Str, uint8_t MaxLen)
{
    uint8_t StrLen = 0;
    1d7c:	40 e0       	ldi	r20, 0x00	; 0

    while(MaxLen > 0) {
        if (*Str++ == '\0')
    1d7e:	81 91       	ld	r24, Z+
    1d80:	88 23       	and	r24, r24
    1d82:	19 f0       	breq	.+6      	; 0x1d8a <ConfigurationSetByName+0x3e>
            break;

        MaxLen--;
        StrLen++;
    1d84:	4f 5f       	subi	r20, 0xFF	; 255

INLINE uint8_t StringLength(const char* Str, uint8_t MaxLen)
{
    uint8_t StrLen = 0;

    while(MaxLen > 0) {
    1d86:	4f 31       	cpi	r20, 0x1F	; 31
    1d88:	d1 f7       	brne	.-12     	; 0x1d7e <ConfigurationSetByName+0x32>
void LogGetModeByName(char* Mode, uint16_t BufferSize);
void LogGetModeList(char* List, uint16_t BufferSize);
void LogSRAMToFRAM(void);

/* Wrapper function to call current logging function */
INLINE void LogEntry(LogEntryEnum Entry, const void* Data, uint8_t Length) { CurrentLogFunc(Entry, Data, Length); }
    1d8a:	e0 91 6e 2f 	lds	r30, 0x2F6E
    1d8e:	f0 91 6f 2f 	lds	r31, 0x2F6F
    1d92:	b8 01       	movw	r22, r16
    1d94:	81 e1       	ldi	r24, 0x11	; 17
    1d96:	19 95       	eicall
        LogEntry(LOG_INFO_CONFIG_SET, Configuration, StringLength(Configuration, CONFIGURATION_NAME_LENGTH_MAX-1));
        return true;
    } else {
        return false;
    }
}
    1d98:	8f 2d       	mov	r24, r15
    1d9a:	0f 90       	pop	r0
    1d9c:	df 91       	pop	r29
    1d9e:	cf 91       	pop	r28
    1da0:	1f 91       	pop	r17
    1da2:	0f 91       	pop	r16
    1da4:	ff 90       	pop	r15
    1da6:	08 95       	ret

00001da8 <ConfigurationGetList>:

void ConfigurationGetList(char* List, uint16_t BufferSize)
{
    1da8:	9b 01       	movw	r18, r22
    MapToString(ConfigurationMap, ARRAY_COUNT(ConfigurationMap), List, BufferSize);
    1daa:	ac 01       	movw	r20, r24
    1dac:	6e e0       	ldi	r22, 0x0E	; 14
    1dae:	8c ee       	ldi	r24, 0xEC	; 236
    1db0:	93 e0       	ldi	r25, 0x03	; 3
    1db2:	0c 94 38 19 	jmp	0x3270	; 0x3270 <MapToString>

00001db6 <RandomInit>:
#include "Random.h"

#include <stdlib.h>

void RandomInit(void)
{
    1db6:	08 95       	ret

00001db8 <RandomGetByte>:

}

uint8_t RandomGetByte(void)
{
    return rand() & 0xFF;
    1db8:	0c 94 ab 65 	jmp	0xcb56	; 0xcb56 <rand>
}
    1dbc:	08 95       	ret

00001dbe <RandomGetBuffer>:

void RandomGetBuffer(void* Buffer, uint8_t ByteCount)
{
    1dbe:	1f 93       	push	r17
    1dc0:	cf 93       	push	r28
    1dc2:	df 93       	push	r29
    uint8_t* BufferPtr = (uint8_t*) Buffer;

    while(ByteCount--) {
    1dc4:	c8 2f       	mov	r28, r24
    1dc6:	d9 2f       	mov	r29, r25
    1dc8:	16 2f       	mov	r17, r22
    1dca:	18 0f       	add	r17, r24
    1dcc:	1c 17       	cp	r17, r28
    1dce:	21 f0       	breq	.+8      	; 0x1dd8 <RandomGetBuffer+0x1a>

}

uint8_t RandomGetByte(void)
{
    return rand() & 0xFF;
    1dd0:	0e 94 ab 65 	call	0xcb56	; 0xcb56 <rand>
void RandomGetBuffer(void* Buffer, uint8_t ByteCount)
{
    uint8_t* BufferPtr = (uint8_t*) Buffer;

    while(ByteCount--) {
        *BufferPtr++ = RandomGetByte();
    1dd4:	89 93       	st	Y+, r24
    1dd6:	fa cf       	rjmp	.-12     	; 0x1dcc <RandomGetBuffer+0xe>
    }
}
    1dd8:	df 91       	pop	r29
    1dda:	cf 91       	pop	r28
    1ddc:	1f 91       	pop	r17
    1dde:	08 95       	ret

00001de0 <RandomTick>:

void RandomTick(void)
{
    rand();
    1de0:	0e 94 ab 65 	call	0xcb56	; 0xcb56 <rand>
    rand();
    1de4:	0e 94 ab 65 	call	0xcb56	; 0xcb56 <rand>
    rand();
    1de8:	0e 94 ab 65 	call	0xcb56	; 0xcb56 <rand>
    rand();
    1dec:	0c 94 ab 65 	jmp	0xcb56	; 0xcb56 <rand>

00001df0 <BufferToHexString>:
    0,	1,	1,	0,	1,	0,	0,	1,	1,	0,	0,	1,	0,	1,	1,	0,
    1,	0,	0,	1,	0,	1,	1,	0,	0,	1,	1,	0,	1,	0,	0,	1,
};

uint16_t BufferToHexString(char* HexOut, uint16_t MaxChars, const void* Buffer, uint16_t ByteCount)
{
    1df0:	ef 92       	push	r14
    1df2:	ff 92       	push	r15
    1df4:	0f 93       	push	r16
    1df6:	1f 93       	push	r17
    1df8:	cf 93       	push	r28
    1dfa:	df 93       	push	r29
    1dfc:	7c 01       	movw	r14, r24
    uint8_t* ByteBuffer = (uint8_t*) Buffer;
    uint16_t CharCount = 0;

    /* Account for '\0' at the end */
    MaxChars--;
    1dfe:	61 50       	subi	r22, 0x01	; 1
    1e00:	71 09       	sbc	r23, r1
    1e02:	fa 01       	movw	r30, r20
    1e04:	8a 01       	movw	r16, r20
    1e06:	02 0f       	add	r16, r18
    1e08:	13 1f       	adc	r17, r19

    while( (ByteCount > 0) && (MaxChars >= 2) ) {
    1e0a:	dc 01       	movw	r26, r24
};

uint16_t BufferToHexString(char* HexOut, uint16_t MaxChars, const void* Buffer, uint16_t ByteCount)
{
    uint8_t* ByteBuffer = (uint8_t*) Buffer;
    uint16_t CharCount = 0;
    1e0c:	40 e0       	ldi	r20, 0x00	; 0
    1e0e:	50 e0       	ldi	r21, 0x00	; 0

    /* Account for '\0' at the end */
    MaxChars--;

    while( (ByteCount > 0) && (MaxChars >= 2) ) {
    1e10:	e0 17       	cp	r30, r16
    1e12:	f1 07       	cpc	r31, r17
    1e14:	f1 f0       	breq	.+60     	; 0x1e52 <BufferToHexString+0x62>
    1e16:	62 30       	cpi	r22, 0x02	; 2
    1e18:	71 05       	cpc	r23, r1
    1e1a:	d8 f0       	brcs	.+54     	; 0x1e52 <BufferToHexString+0x62>
        uint8_t Byte = *ByteBuffer;
    1e1c:	91 91       	ld	r25, Z+

        HexOut[0] = NIBBLE_TO_HEXCHAR( (Byte >> 4) & 0x0F );
    1e1e:	39 2f       	mov	r19, r25
    1e20:	32 95       	swap	r19
    1e22:	3f 70       	andi	r19, 0x0F	; 15
    1e24:	3a 30       	cpi	r19, 0x0A	; 10
    1e26:	10 f4       	brcc	.+4      	; 0x1e2c <BufferToHexString+0x3c>
    1e28:	30 5d       	subi	r19, 0xD0	; 208
    1e2a:	01 c0       	rjmp	.+2      	; 0x1e2e <BufferToHexString+0x3e>
    1e2c:	39 5c       	subi	r19, 0xC9	; 201
    1e2e:	3c 93       	st	X, r19
        HexOut[1] = NIBBLE_TO_HEXCHAR( (Byte >> 0) & 0x0F );
    1e30:	9f 70       	andi	r25, 0x0F	; 15
    1e32:	9a 30       	cpi	r25, 0x0A	; 10
    1e34:	10 f4       	brcc	.+4      	; 0x1e3a <BufferToHexString+0x4a>
    1e36:	90 5d       	subi	r25, 0xD0	; 208
    1e38:	01 c0       	rjmp	.+2      	; 0x1e3c <BufferToHexString+0x4c>
    1e3a:	99 5c       	subi	r25, 0xC9	; 201
    1e3c:	97 01       	movw	r18, r14
    1e3e:	24 0f       	add	r18, r20
    1e40:	35 1f       	adc	r19, r21
    1e42:	e9 01       	movw	r28, r18
    1e44:	99 83       	std	Y+1, r25	; 0x01

        HexOut += 2;
    1e46:	12 96       	adiw	r26, 0x02	; 2
        MaxChars -= 2;
    1e48:	62 50       	subi	r22, 0x02	; 2
    1e4a:	71 09       	sbc	r23, r1
        CharCount += 2;
    1e4c:	4e 5f       	subi	r20, 0xFE	; 254
    1e4e:	5f 4f       	sbci	r21, 0xFF	; 255
    1e50:	df cf       	rjmp	.-66     	; 0x1e10 <BufferToHexString+0x20>
        ByteBuffer++;
        ByteCount -= 1;
    }

    *HexOut = '\0';
    1e52:	1c 92       	st	X, r1

    return CharCount;
}
    1e54:	ca 01       	movw	r24, r20
    1e56:	df 91       	pop	r29
    1e58:	cf 91       	pop	r28
    1e5a:	1f 91       	pop	r17
    1e5c:	0f 91       	pop	r16
    1e5e:	ff 90       	pop	r15
    1e60:	ef 90       	pop	r14
    1e62:	08 95       	ret

00001e64 <HexStringToBuffer>:

uint16_t HexStringToBuffer(void* Buffer, uint16_t MaxBytes, const char* HexIn)
{
    1e64:	cf 93       	push	r28
    1e66:	df 93       	push	r29
    1e68:	ec 01       	movw	r28, r24
    1e6a:	da 01       	movw	r26, r20
    uint8_t* ByteBuffer = (uint8_t*) Buffer;
    uint16_t ByteCount = 0;
    1e6c:	e0 e0       	ldi	r30, 0x00	; 0
    1e6e:	f0 e0       	ldi	r31, 0x00	; 0

    while( (HexIn[0] != '\0') && (HexIn[1] != '\0') && (MaxBytes > 0) ) {
    1e70:	4c 91       	ld	r20, X
    1e72:	44 23       	and	r20, r20
    1e74:	91 f1       	breq	.+100    	; 0x1eda <HexStringToBuffer+0x76>
    1e76:	11 96       	adiw	r26, 0x01	; 1
    1e78:	9c 91       	ld	r25, X
    1e7a:	11 97       	sbiw	r26, 0x01	; 1
    1e7c:	99 23       	and	r25, r25
    1e7e:	39 f1       	breq	.+78     	; 0x1ece <HexStringToBuffer+0x6a>
    1e80:	e6 17       	cp	r30, r22
    1e82:	f7 07       	cpc	r31, r23
    1e84:	21 f1       	breq	.+72     	; 0x1ece <HexStringToBuffer+0x6a>
        if (VALID_HEXCHAR(HexIn[0]) && VALID_HEXCHAR(HexIn[1])) {
    1e86:	80 ed       	ldi	r24, 0xD0	; 208
    1e88:	84 0f       	add	r24, r20
    1e8a:	8a 30       	cpi	r24, 0x0A	; 10
    1e8c:	20 f0       	brcs	.+8      	; 0x1e96 <HexStringToBuffer+0x32>
    1e8e:	8f eb       	ldi	r24, 0xBF	; 191
    1e90:	84 0f       	add	r24, r20
    1e92:	86 30       	cpi	r24, 0x06	; 6
    1e94:	d0 f4       	brcc	.+52     	; 0x1eca <HexStringToBuffer+0x66>
    1e96:	80 ed       	ldi	r24, 0xD0	; 208
    1e98:	89 0f       	add	r24, r25
    1e9a:	8a 30       	cpi	r24, 0x0A	; 10
    1e9c:	20 f0       	brcs	.+8      	; 0x1ea6 <HexStringToBuffer+0x42>
    1e9e:	2f eb       	ldi	r18, 0xBF	; 191
    1ea0:	29 0f       	add	r18, r25
    1ea2:	26 30       	cpi	r18, 0x06	; 6
    1ea4:	90 f4       	brcc	.+36     	; 0x1eca <HexStringToBuffer+0x66>
    1ea6:	24 2f       	mov	r18, r20
    1ea8:	30 e0       	ldi	r19, 0x00	; 0
            uint8_t Byte = 0;

            Byte |= HEXCHAR_TO_NIBBLE(HexIn[0]) << 4;
    1eaa:	41 34       	cpi	r20, 0x41	; 65
    1eac:	10 f0       	brcs	.+4      	; 0x1eb2 <HexStringToBuffer+0x4e>
    1eae:	27 53       	subi	r18, 0x37	; 55
    1eb0:	31 09       	sbc	r19, r1
    1eb2:	22 95       	swap	r18
    1eb4:	20 7f       	andi	r18, 0xF0	; 240
            Byte |= HEXCHAR_TO_NIBBLE(HexIn[1]) << 0;
    1eb6:	91 34       	cpi	r25, 0x41	; 65
    1eb8:	10 f4       	brcc	.+4      	; 0x1ebe <HexStringToBuffer+0x5a>
    1eba:	98 2f       	mov	r25, r24
    1ebc:	01 c0       	rjmp	.+2      	; 0x1ec0 <HexStringToBuffer+0x5c>
    1ebe:	97 53       	subi	r25, 0x37	; 55
    1ec0:	29 2b       	or	r18, r25

            *ByteBuffer = Byte;
    1ec2:	29 93       	st	Y+, r18

            ByteBuffer++;
            MaxBytes--;
            ByteCount++;
    1ec4:	31 96       	adiw	r30, 0x01	; 1
            HexIn += 2;
    1ec6:	12 96       	adiw	r26, 0x02	; 2
{
    uint8_t* ByteBuffer = (uint8_t*) Buffer;
    uint16_t ByteCount = 0;

    while( (HexIn[0] != '\0') && (HexIn[1] != '\0') && (MaxBytes > 0) ) {
        if (VALID_HEXCHAR(HexIn[0]) && VALID_HEXCHAR(HexIn[1])) {
    1ec8:	d3 cf       	rjmp	.-90     	; 0x1e70 <HexStringToBuffer+0xc>
            MaxBytes--;
            ByteCount++;
            HexIn += 2;
        } else {
            /* HEX chars only */
            return 0;
    1eca:	80 e0       	ldi	r24, 0x00	; 0
    1ecc:	04 c0       	rjmp	.+8      	; 0x1ed6 <HexStringToBuffer+0x72>
        }
    }

    if ( (HexIn[0] != '\0') && (HexIn[1] == '\0') ) {
    1ece:	11 96       	adiw	r26, 0x01	; 1
    1ed0:	8c 91       	ld	r24, X
    1ed2:	81 11       	cpse	r24, r1
    1ed4:	02 c0       	rjmp	.+4      	; 0x1eda <HexStringToBuffer+0x76>
            MaxBytes--;
            ByteCount++;
            HexIn += 2;
        } else {
            /* HEX chars only */
            return 0;
    1ed6:	90 e0       	ldi	r25, 0x00	; 0
    1ed8:	01 c0       	rjmp	.+2      	; 0x1edc <HexStringToBuffer+0x78>
uint16_t HexStringToBuffer(void* Buffer, uint16_t MaxBytes, const char* HexIn)
{
    uint8_t* ByteBuffer = (uint8_t*) Buffer;
    uint16_t ByteCount = 0;

    while( (HexIn[0] != '\0') && (HexIn[1] != '\0') && (MaxBytes > 0) ) {
    1eda:	cf 01       	movw	r24, r30
        /* Odd number of characters */
        return 0;
    }

    return ByteCount;
}
    1edc:	df 91       	pop	r29
    1ede:	cf 91       	pop	r28
    1ee0:	08 95       	ret

00001ee2 <MemoryInit>:
}

void MemoryInit(void)
{
    /* Configure FRAM_USART for SPI master mode 0 with maximum clock frequency */
    FRAM_PORT.OUTSET = FRAM_CS;
    1ee2:	e0 e6       	ldi	r30, 0x60	; 96
    1ee4:	f6 e0       	ldi	r31, 0x06	; 6
    1ee6:	80 e1       	ldi	r24, 0x10	; 16
    1ee8:	85 83       	std	Z+5, r24	; 0x05
    
    FRAM_PORT.OUTCLR = FRAM_SCK;
    1eea:	82 e0       	ldi	r24, 0x02	; 2
    1eec:	86 83       	std	Z+6, r24	; 0x06
    FRAM_PORT.OUTSET = FRAM_MOSI;
    1eee:	88 e0       	ldi	r24, 0x08	; 8
    1ef0:	85 83       	std	Z+5, r24	; 0x05
    
    FRAM_PORT.DIRSET = FRAM_SCK | FRAM_MOSI | FRAM_CS;
    1ef2:	8a e1       	ldi	r24, 0x1A	; 26
    1ef4:	81 83       	std	Z+1, r24	; 0x01

    FRAM_USART.BAUDCTRLA = 0;
    1ef6:	e0 ea       	ldi	r30, 0xA0	; 160
    1ef8:	f9 e0       	ldi	r31, 0x09	; 9
    1efa:	16 82       	std	Z+6, r1	; 0x06
    FRAM_USART.BAUDCTRLB = 0;
    1efc:	17 82       	std	Z+7, r1	; 0x07
    FRAM_USART.CTRLC = USART_CMODE_MSPI_gc;
    1efe:	80 ec       	ldi	r24, 0xC0	; 192
    1f00:	85 83       	std	Z+5, r24	; 0x05
    FRAM_USART.CTRLB = USART_RXEN_bm | USART_TXEN_bm;
    1f02:	88 e1       	ldi	r24, 0x18	; 24
    1f04:	84 83       	std	Z+4, r24	; 0x04

    /* Init DMAs for reading and writing */
    RECV_DMA.ADDRCTRL = DMA_CH_SRCRELOAD_NONE_gc | DMA_CH_SRCDIR_FIXED_gc | DMA_CH_DESTRELOAD_NONE_gc | DMA_CH_DESTDIR_FIXED_gc;
    1f06:	e0 e0       	ldi	r30, 0x00	; 0
    1f08:	f1 e0       	ldi	r31, 0x01	; 1
    1f0a:	12 8a       	std	Z+18, r1	; 0x12
    RECV_DMA.TRIGSRC = DMA_CH_TRIGSRC_USARTD0_RXC_gc;
    1f0c:	8b e6       	ldi	r24, 0x6B	; 107
    1f0e:	83 8b       	std	Z+19, r24	; 0x13
    RECV_DMA.TRFCNT = 0;
    1f10:	14 8a       	std	Z+20, r1	; 0x14
    1f12:	15 8a       	std	Z+21, r1	; 0x15
    RECV_DMA.SRCADDR0 = ((uintptr_t) &FRAM_USART.DATA >> 0) & 0xFF;
    1f14:	20 ea       	ldi	r18, 0xA0	; 160
    1f16:	20 8f       	std	Z+24, r18	; 0x18
    RECV_DMA.SRCADDR1 = ((uintptr_t) &FRAM_USART.DATA >> 8) & 0xFF;
    1f18:	99 e0       	ldi	r25, 0x09	; 9
    1f1a:	91 8f       	std	Z+25, r25	; 0x19
    RECV_DMA.SRCADDR2 = 0;
    1f1c:	12 8e       	std	Z+26, r1	; 0x1a
    RECV_DMA.DESTADDR0 = 0;
    1f1e:	14 8e       	std	Z+28, r1	; 0x1c
    RECV_DMA.DESTADDR1 = 0;
    1f20:	15 8e       	std	Z+29, r1	; 0x1d
    RECV_DMA.DESTADDR2 = 0;
    1f22:	16 8e       	std	Z+30, r1	; 0x1e
    RECV_DMA.CTRLA = DMA_CH_SINGLE_bm | DMA_CH_BURSTLEN_1BYTE_gc;
    1f24:	84 e0       	ldi	r24, 0x04	; 4
    1f26:	80 8b       	std	Z+16, r24	; 0x10

    SEND_DMA.ADDRCTRL = DMA_CH_SRCRELOAD_NONE_gc | DMA_CH_SRCDIR_FIXED_gc | DMA_CH_DESTRELOAD_NONE_gc | DMA_CH_DESTDIR_FIXED_gc;
    1f28:	12 a2       	std	Z+34, r1	; 0x22
    SEND_DMA.TRIGSRC = DMA_CH_TRIGSRC_USARTD0_DRE_gc;
    1f2a:	3c e6       	ldi	r19, 0x6C	; 108
    1f2c:	33 a3       	std	Z+35, r19	; 0x23
    SEND_DMA.TRFCNT = 0;
    1f2e:	14 a2       	std	Z+36, r1	; 0x24
    1f30:	15 a2       	std	Z+37, r1	; 0x25
    SEND_DMA.SRCADDR0 = 0;
    1f32:	10 a6       	std	Z+40, r1	; 0x28
    SEND_DMA.SRCADDR1 = 0;
    1f34:	11 a6       	std	Z+41, r1	; 0x29
    SEND_DMA.SRCADDR2 = 0;
    1f36:	12 a6       	std	Z+42, r1	; 0x2a
    SEND_DMA.DESTADDR0 = ((uintptr_t) &FRAM_USART.DATA >> 0) & 0xFF;
    1f38:	24 a7       	std	Z+44, r18	; 0x2c
    SEND_DMA.DESTADDR1 = ((uintptr_t) &FRAM_USART.DATA >> 8) & 0xFF;
    1f3a:	95 a7       	std	Z+45, r25	; 0x2d
    SEND_DMA.DESTADDR2 = 0;
    1f3c:	16 a6       	std	Z+46, r1	; 0x2e
    SEND_DMA.CTRLA = DMA_CH_SINGLE_bm | DMA_CH_BURSTLEN_1BYTE_gc;
    1f3e:	80 a3       	std	Z+32, r24	; 0x20
    1f40:	08 95       	ret

00001f42 <MemoryReadBlock>:
}

void MemoryReadBlock(void* Buffer, uint16_t Address, uint16_t ByteCount)
{
    if (ByteCount == 0)
    1f42:	41 15       	cp	r20, r1
    1f44:	51 05       	cpc	r21, r1
    1f46:	09 f4       	brne	.+2      	; 0x1f4a <MemoryReadBlock+0x8>
    1f48:	49 c0       	rjmp	.+146    	; 0x1fdc <MemoryReadBlock+0x9a>
}
#endif

INLINE void FRAMRead(void* Buffer, uint16_t Address, uint16_t ByteCount)
{
    FRAM_PORT.OUTCLR = FRAM_CS;
    1f4a:	20 e1       	ldi	r18, 0x10	; 16
    1f4c:	20 93 66 06 	sts	0x0666, r18

static uint8_t ScrapBuffer[] = {0};

INLINE uint8_t SPITransferByte(uint8_t Data)
{
    FRAM_USART.DATA = Data;
    1f50:	23 e0       	ldi	r18, 0x03	; 3
    1f52:	20 93 a0 09 	sts	0x09A0, r18

    while (!(FRAM_USART.STATUS & USART_RXCIF_bm));
    1f56:	20 91 a1 09 	lds	r18, 0x09A1
    1f5a:	27 ff       	sbrs	r18, 7
    1f5c:	fc cf       	rjmp	.-8      	; 0x1f56 <MemoryReadBlock+0x14>

    return FRAM_USART.DATA;
    1f5e:	20 91 a0 09 	lds	r18, 0x09A0

static uint8_t ScrapBuffer[] = {0};

INLINE uint8_t SPITransferByte(uint8_t Data)
{
    FRAM_USART.DATA = Data;
    1f62:	70 93 a0 09 	sts	0x09A0, r23

    while (!(FRAM_USART.STATUS & USART_RXCIF_bm));
    1f66:	20 91 a1 09 	lds	r18, 0x09A1
    1f6a:	27 ff       	sbrs	r18, 7
    1f6c:	fc cf       	rjmp	.-8      	; 0x1f66 <MemoryReadBlock+0x24>

    return FRAM_USART.DATA;
    1f6e:	20 91 a0 09 	lds	r18, 0x09A0

static uint8_t ScrapBuffer[] = {0};

INLINE uint8_t SPITransferByte(uint8_t Data)
{
    FRAM_USART.DATA = Data;
    1f72:	60 93 a0 09 	sts	0x09A0, r22

    while (!(FRAM_USART.STATUS & USART_RXCIF_bm));
    1f76:	20 91 a1 09 	lds	r18, 0x09A1
    1f7a:	27 ff       	sbrs	r18, 7
    1f7c:	fc cf       	rjmp	.-8      	; 0x1f76 <MemoryReadBlock+0x34>

    return FRAM_USART.DATA;
    1f7e:	20 91 a0 09 	lds	r18, 0x09A0

#ifdef USE_DMA
INLINE void SPIReadBlock(void* Buffer, uint16_t ByteCount)
{
    /* Set up read and write transfers */
    RECV_DMA.ADDRCTRL = DMA_CH_SRCRELOAD_NONE_gc | DMA_CH_SRCDIR_FIXED_gc | DMA_CH_DESTRELOAD_NONE_gc | DMA_CH_DESTDIR_INC_gc;
    1f82:	21 e0       	ldi	r18, 0x01	; 1
    1f84:	20 93 12 01 	sts	0x0112, r18
    RECV_DMA.DESTADDR0 = ((uintptr_t) Buffer >> 0) & 0xFF;
    1f88:	80 93 1c 01 	sts	0x011C, r24
    RECV_DMA.DESTADDR1 = ((uintptr_t) Buffer >> 8) & 0xFF;
    1f8c:	90 93 1d 01 	sts	0x011D, r25
    RECV_DMA.TRFCNT = ByteCount;
    1f90:	40 93 14 01 	sts	0x0114, r20
    1f94:	50 93 15 01 	sts	0x0115, r21
    SEND_DMA.ADDRCTRL = DMA_CH_SRCRELOAD_NONE_gc | DMA_CH_SRCDIR_FIXED_gc | DMA_CH_DESTRELOAD_NONE_gc | DMA_CH_DESTDIR_FIXED_gc;
    1f98:	10 92 22 01 	sts	0x0122, r1
    SEND_DMA.SRCADDR0 = ((uintptr_t) ScrapBuffer >> 0) & 0xFF;
    1f9c:	84 e7       	ldi	r24, 0x74	; 116
    1f9e:	94 e2       	ldi	r25, 0x24	; 36
    1fa0:	80 93 28 01 	sts	0x0128, r24
    SEND_DMA.SRCADDR1 = ((uintptr_t) ScrapBuffer >> 8) & 0xFF;
    1fa4:	90 93 29 01 	sts	0x0129, r25
    SEND_DMA.TRFCNT = ByteCount;
    1fa8:	40 93 24 01 	sts	0x0124, r20
    1fac:	50 93 25 01 	sts	0x0125, r21


    /* Enable read and write transfers */
    RECV_DMA.CTRLA |= DMA_CH_ENABLE_bm;
    1fb0:	80 91 10 01 	lds	r24, 0x0110
    1fb4:	80 68       	ori	r24, 0x80	; 128
    1fb6:	80 93 10 01 	sts	0x0110, r24
    SEND_DMA.CTRLA |= DMA_CH_ENABLE_bm;
    1fba:	80 91 20 01 	lds	r24, 0x0120
    1fbe:	80 68       	ori	r24, 0x80	; 128
    1fc0:	80 93 20 01 	sts	0x0120, r24

    /* Wait for DMA to finish */
    while( RECV_DMA.CTRLA & DMA_CH_ENABLE_bm )
    1fc4:	80 91 10 01 	lds	r24, 0x0110
    1fc8:	87 fd       	sbrc	r24, 7
    1fca:	fc cf       	rjmp	.-8      	; 0x1fc4 <MemoryReadBlock+0x82>
        ;

    /* Clear Interrupt flag */
    RECV_DMA.CTRLB = DMA_CH_TRNIF_bm | DMA_CH_ERRIF_bm;
    1fcc:	80 e3       	ldi	r24, 0x30	; 48
    1fce:	80 93 11 01 	sts	0x0111, r24
    SEND_DMA.CTRLB = DMA_CH_TRNIF_bm | DMA_CH_ERRIF_bm;
    1fd2:	80 93 21 01 	sts	0x0121, r24
    SPITransferByte( (Address >> 8) & 0xFF ); /* Address hi and lo byte */
    SPITransferByte( (Address >> 0) & 0xFF );

    SPIReadBlock(Buffer, ByteCount);

    FRAM_PORT.OUTSET = FRAM_CS;
    1fd6:	80 e1       	ldi	r24, 0x10	; 16
    1fd8:	80 93 65 06 	sts	0x0665, r24
    1fdc:	08 95       	ret

00001fde <MemoryWriteBlock>:
    FRAMRead(Buffer, Address, ByteCount);
}

void MemoryWriteBlock(const void* Buffer, uint16_t Address, uint16_t ByteCount)
{
    if (ByteCount == 0)
    1fde:	41 15       	cp	r20, r1
    1fe0:	51 05       	cpc	r21, r1
    1fe2:	09 f4       	brne	.+2      	; 0x1fe6 <MemoryWriteBlock+0x8>
    1fe4:	69 c0       	rjmp	.+210    	; 0x20b8 <MemoryWriteBlock+0xda>
    FRAM_PORT.OUTSET = FRAM_CS;
}

INLINE void FRAMWrite(const void* Buffer, uint16_t Address, uint16_t ByteCount)
{
    FRAM_PORT.OUTCLR = FRAM_CS;
    1fe6:	20 e1       	ldi	r18, 0x10	; 16
    1fe8:	20 93 66 06 	sts	0x0666, r18

static uint8_t ScrapBuffer[] = {0};

INLINE uint8_t SPITransferByte(uint8_t Data)
{
    FRAM_USART.DATA = Data;
    1fec:	26 e0       	ldi	r18, 0x06	; 6
    1fee:	20 93 a0 09 	sts	0x09A0, r18

    while (!(FRAM_USART.STATUS & USART_RXCIF_bm));
    1ff2:	20 91 a1 09 	lds	r18, 0x09A1
    1ff6:	27 ff       	sbrs	r18, 7
    1ff8:	fc cf       	rjmp	.-8      	; 0x1ff2 <MemoryWriteBlock+0x14>

    return FRAM_USART.DATA;
    1ffa:	20 91 a0 09 	lds	r18, 0x09A0

INLINE void FRAMWrite(const void* Buffer, uint16_t Address, uint16_t ByteCount)
{
    FRAM_PORT.OUTCLR = FRAM_CS;
    SPITransferByte(0x06); /* Write Enable */
    FRAM_PORT.OUTSET = FRAM_CS;
    1ffe:	20 e1       	ldi	r18, 0x10	; 16
    2000:	20 93 65 06 	sts	0x0665, r18

    asm volatile ("nop");
    2004:	00 00       	nop
    asm volatile ("nop");
    2006:	00 00       	nop

    FRAM_PORT.OUTCLR = FRAM_CS;
    2008:	20 93 66 06 	sts	0x0666, r18

static uint8_t ScrapBuffer[] = {0};

INLINE uint8_t SPITransferByte(uint8_t Data)
{
    FRAM_USART.DATA = Data;
    200c:	22 e0       	ldi	r18, 0x02	; 2
    200e:	20 93 a0 09 	sts	0x09A0, r18

    while (!(FRAM_USART.STATUS & USART_RXCIF_bm));
    2012:	20 91 a1 09 	lds	r18, 0x09A1
    2016:	27 ff       	sbrs	r18, 7
    2018:	fc cf       	rjmp	.-8      	; 0x2012 <MemoryWriteBlock+0x34>

    return FRAM_USART.DATA;
    201a:	20 91 a0 09 	lds	r18, 0x09A0

static uint8_t ScrapBuffer[] = {0};

INLINE uint8_t SPITransferByte(uint8_t Data)
{
    FRAM_USART.DATA = Data;
    201e:	70 93 a0 09 	sts	0x09A0, r23

    while (!(FRAM_USART.STATUS & USART_RXCIF_bm));
    2022:	20 91 a1 09 	lds	r18, 0x09A1
    2026:	27 ff       	sbrs	r18, 7
    2028:	fc cf       	rjmp	.-8      	; 0x2022 <MemoryWriteBlock+0x44>

    return FRAM_USART.DATA;
    202a:	20 91 a0 09 	lds	r18, 0x09A0

static uint8_t ScrapBuffer[] = {0};

INLINE uint8_t SPITransferByte(uint8_t Data)
{
    FRAM_USART.DATA = Data;
    202e:	60 93 a0 09 	sts	0x09A0, r22

    while (!(FRAM_USART.STATUS & USART_RXCIF_bm));
    2032:	20 91 a1 09 	lds	r18, 0x09A1
    2036:	27 ff       	sbrs	r18, 7
    2038:	fc cf       	rjmp	.-8      	; 0x2032 <MemoryWriteBlock+0x54>

    return FRAM_USART.DATA;
    203a:	20 91 a0 09 	lds	r18, 0x09A0

#ifdef USE_DMA
INLINE void SPIWriteBlock(const void* Buffer, uint16_t ByteCount)
{
    /* Set up read and write transfers */
    RECV_DMA.ADDRCTRL = DMA_CH_SRCRELOAD_NONE_gc | DMA_CH_SRCDIR_FIXED_gc | DMA_CH_DESTRELOAD_NONE_gc | DMA_CH_DESTDIR_FIXED_gc;
    203e:	10 92 12 01 	sts	0x0112, r1
    RECV_DMA.DESTADDR0 = ((uintptr_t) ScrapBuffer >> 0) & 0xFF;
    2042:	24 e7       	ldi	r18, 0x74	; 116
    2044:	34 e2       	ldi	r19, 0x24	; 36
    2046:	20 93 1c 01 	sts	0x011C, r18
    RECV_DMA.DESTADDR1 = ((uintptr_t) ScrapBuffer >> 8) & 0xFF;
    204a:	30 93 1d 01 	sts	0x011D, r19
    RECV_DMA.TRFCNT = ByteCount;
    204e:	40 93 14 01 	sts	0x0114, r20
    2052:	50 93 15 01 	sts	0x0115, r21
    SEND_DMA.ADDRCTRL = DMA_CH_SRCRELOAD_NONE_gc | DMA_CH_SRCDIR_INC_gc | DMA_CH_DESTRELOAD_NONE_gc | DMA_CH_DESTDIR_FIXED_gc;
    2056:	20 e1       	ldi	r18, 0x10	; 16
    2058:	20 93 22 01 	sts	0x0122, r18
    SEND_DMA.SRCADDR0 = ((uintptr_t) Buffer >> 0) & 0xFF;
    205c:	80 93 28 01 	sts	0x0128, r24
    SEND_DMA.SRCADDR1 = ((uintptr_t) Buffer >> 8) & 0xFF;
    2060:	90 93 29 01 	sts	0x0129, r25
    SEND_DMA.TRFCNT = ByteCount;
    2064:	40 93 24 01 	sts	0x0124, r20
    2068:	50 93 25 01 	sts	0x0125, r21

    /* Enable read and write transfers */
    RECV_DMA.CTRLA |= DMA_CH_ENABLE_bm;
    206c:	80 91 10 01 	lds	r24, 0x0110
    2070:	80 68       	ori	r24, 0x80	; 128
    2072:	80 93 10 01 	sts	0x0110, r24
    SEND_DMA.CTRLA |= DMA_CH_ENABLE_bm;
    2076:	80 91 20 01 	lds	r24, 0x0120
    207a:	80 68       	ori	r24, 0x80	; 128
    207c:	80 93 20 01 	sts	0x0120, r24

    /* Wait for DMA to finish */
    while( RECV_DMA.CTRLA & DMA_CH_ENABLE_bm )
    2080:	80 91 10 01 	lds	r24, 0x0110
    2084:	87 fd       	sbrc	r24, 7
    2086:	fc cf       	rjmp	.-8      	; 0x2080 <MemoryWriteBlock+0xa2>
        ;

    /* Clear Interrupt flag */
    RECV_DMA.CTRLB = DMA_CH_TRNIF_bm | DMA_CH_ERRIF_bm;
    2088:	80 e3       	ldi	r24, 0x30	; 48
    208a:	80 93 11 01 	sts	0x0111, r24
    SEND_DMA.CTRLB = DMA_CH_TRNIF_bm | DMA_CH_ERRIF_bm;
    208e:	80 93 21 01 	sts	0x0121, r24
    SPITransferByte( (Address >> 8) & 0xFF ); /* Address hi and lo byte */
    SPITransferByte( (Address >> 0) & 0xFF );

    SPIWriteBlock(Buffer, ByteCount);

    FRAM_PORT.OUTSET = FRAM_CS;
    2092:	80 e1       	ldi	r24, 0x10	; 16
    2094:	80 93 65 06 	sts	0x0665, r24

INLINE void LEDHook(LEDHookEnum Func, LEDActionEnum Action) {
    extern LEDActionEnum LEDGreenAction;
    extern LEDActionEnum LEDRedAction;

    if (GlobalSettings.ActiveSettingPtr->LEDGreenFunction == Func) {
    2098:	e0 91 71 2f 	lds	r30, 0x2F71
    209c:	f0 91 72 2f 	lds	r31, 0x2F72
    20a0:	87 81       	ldd	r24, Z+7	; 0x07
    20a2:	86 30       	cpi	r24, 0x06	; 6
    20a4:	19 f4       	brne	.+6      	; 0x20ac <MemoryWriteBlock+0xce>
        LEDGreenAction = Action;
    20a6:	81 e1       	ldi	r24, 0x11	; 17
    20a8:	80 93 7d 2c 	sts	0x2C7D, r24
    }

    if (GlobalSettings.ActiveSettingPtr->LEDRedFunction == Func) {
    20ac:	86 81       	ldd	r24, Z+6	; 0x06
    20ae:	86 30       	cpi	r24, 0x06	; 6
    20b0:	19 f4       	brne	.+6      	; 0x20b8 <MemoryWriteBlock+0xda>
        LEDRedAction = Action;
    20b2:	81 e1       	ldi	r24, 0x11	; 17
    20b4:	80 93 7c 2c 	sts	0x2C7C, r24
    20b8:	08 95       	ret

000020ba <MemoryRecall>:

    MemoryRecall();
}

void MemoryRecall(void)
{
    20ba:	cf 92       	push	r12
    20bc:	df 92       	push	r13
    20be:	ef 92       	push	r14
    20c0:	ff 92       	push	r15
    20c2:	cf 93       	push	r28
    20c4:	df 93       	push	r29
    /* Recall memory from permanent flash */
    FlashToFRAM((uint32_t) GlobalSettings.ActiveSettingIdx * MEMORY_SIZE_PER_SETTING, MEMORY_SIZE_PER_SETTING);
    20c6:	c0 90 70 2f 	lds	r12, 0x2F70
    20ca:	d1 2c       	mov	r13, r1
    20cc:	e1 2c       	mov	r14, r1
    20ce:	f1 2c       	mov	r15, r1
    20d0:	8d e0       	ldi	r24, 0x0D	; 13
    20d2:	cc 0c       	add	r12, r12
    20d4:	dd 1c       	adc	r13, r13
    20d6:	ee 1c       	adc	r14, r14
    20d8:	ff 1c       	adc	r15, r15
    20da:	8a 95       	dec	r24
    20dc:	d1 f7       	brne	.-12     	; 0x20d2 <MemoryRecall+0x18>
INLINE void FlashToFRAM(uint32_t Address, uint16_t ByteCount)
{
    /* We assume that ByteCount is a multiple of 2 */
    uint32_t PhysicalAddress = Address + FLASH_DATA_ADDR;

    if ( (PhysicalAddress >= FLASH_DATA_START) && (PhysicalAddress <= FLASH_DATA_END) ) {
    20de:	c1 14       	cp	r12, r1
    20e0:	d1 04       	cpc	r13, r1
    20e2:	81 e0       	ldi	r24, 0x01	; 1
    20e4:	e8 06       	cpc	r14, r24
    20e6:	f1 04       	cpc	r15, r1
    20e8:	08 f0       	brcs	.+2      	; 0x20ec <MemoryRecall+0x32>
    20ea:	4e c0       	rjmp	.+156    	; 0x2188 <MemoryRecall+0xce>
        /* Sanity check to limit access to the allocated area.
         * Set up FRAM memory for writing. */
        FRAM_PORT.OUTCLR = FRAM_CS;
    20ec:	80 e1       	ldi	r24, 0x10	; 16
    20ee:	80 93 66 06 	sts	0x0666, r24

static uint8_t ScrapBuffer[] = {0};

INLINE uint8_t SPITransferByte(uint8_t Data)
{
    FRAM_USART.DATA = Data;
    20f2:	86 e0       	ldi	r24, 0x06	; 6
    20f4:	80 93 a0 09 	sts	0x09A0, r24

    while (!(FRAM_USART.STATUS & USART_RXCIF_bm));
    20f8:	80 91 a1 09 	lds	r24, 0x09A1
    20fc:	87 ff       	sbrs	r24, 7
    20fe:	fc cf       	rjmp	.-8      	; 0x20f8 <MemoryRecall+0x3e>

    return FRAM_USART.DATA;
    2100:	80 91 a0 09 	lds	r24, 0x09A0
    if ( (PhysicalAddress >= FLASH_DATA_START) && (PhysicalAddress <= FLASH_DATA_END) ) {
        /* Sanity check to limit access to the allocated area.
         * Set up FRAM memory for writing. */
        FRAM_PORT.OUTCLR = FRAM_CS;
        SPITransferByte(0x06); /* Write Enable */
        FRAM_PORT.OUTSET = FRAM_CS;
    2104:	80 e1       	ldi	r24, 0x10	; 16
    2106:	80 93 65 06 	sts	0x0665, r24

        asm volatile ("nop");
    210a:	00 00       	nop
        asm volatile ("nop");
    210c:	00 00       	nop

        FRAM_PORT.OUTCLR = FRAM_CS;
    210e:	80 93 66 06 	sts	0x0666, r24

static uint8_t ScrapBuffer[] = {0};

INLINE uint8_t SPITransferByte(uint8_t Data)
{
    FRAM_USART.DATA = Data;
    2112:	82 e0       	ldi	r24, 0x02	; 2
    2114:	80 93 a0 09 	sts	0x09A0, r24

    while (!(FRAM_USART.STATUS & USART_RXCIF_bm));
    2118:	80 91 a1 09 	lds	r24, 0x09A1
    211c:	87 ff       	sbrs	r24, 7
    211e:	fc cf       	rjmp	.-8      	; 0x2118 <MemoryRecall+0x5e>

    return FRAM_USART.DATA;
    2120:	80 91 a0 09 	lds	r24, 0x09A0

static uint8_t ScrapBuffer[] = {0};

INLINE uint8_t SPITransferByte(uint8_t Data)
{
    FRAM_USART.DATA = Data;
    2124:	10 92 a0 09 	sts	0x09A0, r1

    while (!(FRAM_USART.STATUS & USART_RXCIF_bm));
    2128:	80 91 a1 09 	lds	r24, 0x09A1
    212c:	87 ff       	sbrs	r24, 7
    212e:	fc cf       	rjmp	.-8      	; 0x2128 <MemoryRecall+0x6e>

    return FRAM_USART.DATA;
    2130:	80 91 a0 09 	lds	r24, 0x09A0

static uint8_t ScrapBuffer[] = {0};

INLINE uint8_t SPITransferByte(uint8_t Data)
{
    FRAM_USART.DATA = Data;
    2134:	10 92 a0 09 	sts	0x09A0, r1

    while (!(FRAM_USART.STATUS & USART_RXCIF_bm));
    2138:	80 91 a1 09 	lds	r24, 0x09A1
    213c:	87 ff       	sbrs	r24, 7
    213e:	fc cf       	rjmp	.-8      	; 0x2138 <MemoryRecall+0x7e>
}

INLINE void FlashToFRAM(uint32_t Address, uint16_t ByteCount)
{
    /* We assume that ByteCount is a multiple of 2 */
    uint32_t PhysicalAddress = Address + FLASH_DATA_ADDR;
    2140:	8f ef       	ldi	r24, 0xFF	; 255
    2142:	e8 1a       	sub	r14, r24
    2144:	f8 0a       	sbc	r15, r24
{
    FRAM_USART.DATA = Data;

    while (!(FRAM_USART.STATUS & USART_RXCIF_bm));

    return FRAM_USART.DATA;
    2146:	80 91 a0 09 	lds	r24, 0x09A0
    214a:	c0 e0       	ldi	r28, 0x00	; 0
    214c:	d0 e1       	ldi	r29, 0x10	; 16
        SPITransferByte(0);

        /* Loop through bytes, read words from flash and write
         * double byte into FRAM. */
        while(ByteCount > 1) {
            uint16_t Word = FlashReadWord(PhysicalAddress);
    214e:	c7 01       	movw	r24, r14
    2150:	b6 01       	movw	r22, r12
    2152:	7d db       	rcall	.-2310   	; 0x184e <FlashReadWord>

static uint8_t ScrapBuffer[] = {0};

INLINE uint8_t SPITransferByte(uint8_t Data)
{
    FRAM_USART.DATA = Data;
    2154:	80 93 a0 09 	sts	0x09A0, r24

    while (!(FRAM_USART.STATUS & USART_RXCIF_bm));
    2158:	80 91 a1 09 	lds	r24, 0x09A1
    215c:	87 ff       	sbrs	r24, 7
    215e:	fc cf       	rjmp	.-8      	; 0x2158 <MemoryRecall+0x9e>

    return FRAM_USART.DATA;
    2160:	80 91 a0 09 	lds	r24, 0x09A0

static uint8_t ScrapBuffer[] = {0};

INLINE uint8_t SPITransferByte(uint8_t Data)
{
    FRAM_USART.DATA = Data;
    2164:	90 93 a0 09 	sts	0x09A0, r25

    while (!(FRAM_USART.STATUS & USART_RXCIF_bm));
    2168:	80 91 a1 09 	lds	r24, 0x09A1
    216c:	87 ff       	sbrs	r24, 7
    216e:	fc cf       	rjmp	.-8      	; 0x2168 <MemoryRecall+0xae>

    return FRAM_USART.DATA;
    2170:	80 91 a0 09 	lds	r24, 0x09A0
            uint16_t Word = FlashReadWord(PhysicalAddress);

            SPITransferByte( (Word >> 0) & 0xFF );
            SPITransferByte( (Word >> 8) & 0xFF );

            PhysicalAddress += 2;
    2174:	82 e0       	ldi	r24, 0x02	; 2
    2176:	c8 0e       	add	r12, r24
    2178:	d1 1c       	adc	r13, r1
    217a:	e1 1c       	adc	r14, r1
    217c:	f1 1c       	adc	r15, r1
    217e:	21 97       	sbiw	r28, 0x01	; 1
        SPITransferByte(0); /* Address hi and lo byte */
        SPITransferByte(0);

        /* Loop through bytes, read words from flash and write
         * double byte into FRAM. */
        while(ByteCount > 1) {
    2180:	31 f7       	brne	.-52     	; 0x214e <MemoryRecall+0x94>
            PhysicalAddress += 2;
            ByteCount -= 2;
        }

        /* End write procedure of FRAM */
        FRAM_PORT.OUTSET = FRAM_CS;
    2182:	80 e1       	ldi	r24, 0x10	; 16
    2184:	80 93 65 06 	sts	0x0665, r24
    return false;
}

INLINE void SystemTickClearFlag(void)
{
    while(RTC.STATUS & RTC_SYNCBUSY_bm)
    2188:	80 91 01 04 	lds	r24, 0x0401
    218c:	80 fd       	sbrc	r24, 0
    218e:	fc cf       	rjmp	.-8      	; 0x2188 <MemoryRecall+0xce>
        ;

    RTC.INTFLAGS = RTC_COMPIF_bm;
    2190:	82 e0       	ldi	r24, 0x02	; 2
    2192:	80 93 03 04 	sts	0x0403, r24
{
    /* Recall memory from permanent flash */
    FlashToFRAM((uint32_t) GlobalSettings.ActiveSettingIdx * MEMORY_SIZE_PER_SETTING, MEMORY_SIZE_PER_SETTING);

    SystemTickClearFlag();
}
    2196:	df 91       	pop	r29
    2198:	cf 91       	pop	r28
    219a:	ff 90       	pop	r15
    219c:	ef 90       	pop	r14
    219e:	df 90       	pop	r13
    21a0:	cf 90       	pop	r12
    21a2:	08 95       	ret

000021a4 <MemoryClear>:

    LEDHook(LED_MEMORY_CHANGED, LED_ON);
}

void MemoryClear(void)
{
    21a4:	cf 92       	push	r12
    21a6:	df 92       	push	r13
    21a8:	ef 92       	push	r14
    21aa:	ff 92       	push	r15
    21ac:	cf 93       	push	r28
    21ae:	df 93       	push	r29
    FlashErase((uint32_t) GlobalSettings.ActiveSettingIdx * MEMORY_SIZE_PER_SETTING, MEMORY_SIZE_PER_SETTING);
    21b0:	c0 90 70 2f 	lds	r12, 0x2F70
    21b4:	d1 2c       	mov	r13, r1
    21b6:	e1 2c       	mov	r14, r1
    21b8:	f1 2c       	mov	r15, r1
    21ba:	8d e0       	ldi	r24, 0x0D	; 13
    21bc:	cc 0c       	add	r12, r12
    21be:	dd 1c       	adc	r13, r13
    21c0:	ee 1c       	adc	r14, r14
    21c2:	ff 1c       	adc	r15, r15
    21c4:	8a 95       	dec	r24
    21c6:	d1 f7       	brne	.-12     	; 0x21bc <MemoryClear+0x18>
INLINE void FlashErase(uint32_t Address, uint16_t ByteCount)
{
    uint16_t PageCount = ByteCount / APP_SECTION_PAGE_SIZE;
    uint32_t PhysicalAddress = Address + FLASH_DATA_ADDR;

    if ( (PhysicalAddress >= FLASH_DATA_START) && (PhysicalAddress <= FLASH_DATA_END) ) {
    21c8:	c1 14       	cp	r12, r1
    21ca:	d1 04       	cpc	r13, r1
    21cc:	81 e0       	ldi	r24, 0x01	; 1
    21ce:	e8 06       	cpc	r14, r24
    21d0:	f1 04       	cpc	r15, r1
    21d2:	38 f0       	brcs	.+14     	; 0x21e2 <MemoryClear+0x3e>
void MemoryClear(void)
{
    FlashErase((uint32_t) GlobalSettings.ActiveSettingIdx * MEMORY_SIZE_PER_SETTING, MEMORY_SIZE_PER_SETTING);

    MemoryRecall();
}
    21d4:	df 91       	pop	r29
    21d6:	cf 91       	pop	r28
    21d8:	ff 90       	pop	r15
    21da:	ef 90       	pop	r14
    21dc:	df 90       	pop	r13
    21de:	cf 90       	pop	r12

void MemoryClear(void)
{
    FlashErase((uint32_t) GlobalSettings.ActiveSettingIdx * MEMORY_SIZE_PER_SETTING, MEMORY_SIZE_PER_SETTING);

    MemoryRecall();
    21e0:	6c cf       	rjmp	.-296    	; 0x20ba <MemoryRecall>
}

INLINE void FlashErase(uint32_t Address, uint16_t ByteCount)
{
    uint16_t PageCount = ByteCount / APP_SECTION_PAGE_SIZE;
    uint32_t PhysicalAddress = Address + FLASH_DATA_ADDR;
    21e2:	8f ef       	ldi	r24, 0xFF	; 255
    21e4:	e8 1a       	sub	r14, r24
    21e6:	f8 0a       	sbc	r15, r24
    21e8:	c1 e2       	ldi	r28, 0x21	; 33
    21ea:	d0 e0       	ldi	r29, 0x00	; 0
    21ec:	21 97       	sbiw	r28, 0x01	; 1

    if ( (PhysicalAddress >= FLASH_DATA_START) && (PhysicalAddress <= FLASH_DATA_END) ) {
        /* Sanity check to limit access to the allocated area */
        while(PageCount-- > 0) {
    21ee:	91 f3       	breq	.-28     	; 0x21d4 <MemoryClear+0x30>
            FlashWaitForSPM();
    21f0:	49 db       	rcall	.-2414   	; 0x1884 <FlashWaitForSPM>

            FlashEraseApplicationPage(PhysicalAddress);
    21f2:	c7 01       	movw	r24, r14
    21f4:	b6 01       	movw	r22, r12
    21f6:	32 db       	rcall	.-2460   	; 0x185c <FlashEraseApplicationPage>
            FlashWaitForSPM();
    21f8:	45 db       	rcall	.-2422   	; 0x1884 <FlashWaitForSPM>

            PhysicalAddress += APP_SECTION_PAGE_SIZE;
    21fa:	8f ef       	ldi	r24, 0xFF	; 255
    21fc:	d8 1a       	sub	r13, r24
    21fe:	e8 0a       	sbc	r14, r24
    2200:	f8 0a       	sbc	r15, r24
    2202:	f4 cf       	rjmp	.-24     	; 0x21ec <MemoryClear+0x48>

00002204 <MemoryStore>:

    SystemTickClearFlag();
}

void MemoryStore(void)
{
    2204:	cf 92       	push	r12
    2206:	df 92       	push	r13
    2208:	ef 92       	push	r14
    220a:	ff 92       	push	r15
    220c:	0f 93       	push	r16
    220e:	1f 93       	push	r17
    2210:	cf 93       	push	r28
    2212:	df 93       	push	r29
    /* Store current memory into permanent flash */
    FRAMToFlash((uint32_t) GlobalSettings.ActiveSettingIdx * MEMORY_SIZE_PER_SETTING, MEMORY_SIZE_PER_SETTING);
    2214:	c0 90 70 2f 	lds	r12, 0x2F70
    2218:	d1 2c       	mov	r13, r1
    221a:	e1 2c       	mov	r14, r1
    221c:	f1 2c       	mov	r15, r1
    221e:	8d e0       	ldi	r24, 0x0D	; 13
    2220:	cc 0c       	add	r12, r12
    2222:	dd 1c       	adc	r13, r13
    2224:	ee 1c       	adc	r14, r14
    2226:	ff 1c       	adc	r15, r15
    2228:	8a 95       	dec	r24
    222a:	d1 f7       	brne	.-12     	; 0x2220 <MemoryStore+0x1c>
     * aligned to APP_SECTION_PAGE_SIZE and a multiple of APP_SECTION_PAGE_SIZE.
     * Thus only full pages are written into the flash. */
    uint16_t PageCount = ByteCount / APP_SECTION_PAGE_SIZE;
    uint32_t PhysicalAddress = Address + FLASH_DATA_ADDR;

    if ( (PhysicalAddress >= FLASH_DATA_START) && (PhysicalAddress <= FLASH_DATA_END) ) {
    222c:	c1 14       	cp	r12, r1
    222e:	d1 04       	cpc	r13, r1
    2230:	81 e0       	ldi	r24, 0x01	; 1
    2232:	e8 06       	cpc	r14, r24
    2234:	f1 04       	cpc	r15, r1
    2236:	08 f0       	brcs	.+2      	; 0x223a <MemoryStore+0x36>
    2238:	4f c0       	rjmp	.+158    	; 0x22d8 <MemoryStore+0xd4>
        /* Sanity check to limit access to the allocated area and setup FRAM
         * read. */
        FRAM_PORT.OUTCLR = FRAM_CS;
    223a:	80 e1       	ldi	r24, 0x10	; 16
    223c:	80 93 66 06 	sts	0x0666, r24

static uint8_t ScrapBuffer[] = {0};

INLINE uint8_t SPITransferByte(uint8_t Data)
{
    FRAM_USART.DATA = Data;
    2240:	83 e0       	ldi	r24, 0x03	; 3
    2242:	80 93 a0 09 	sts	0x09A0, r24

    while (!(FRAM_USART.STATUS & USART_RXCIF_bm));
    2246:	80 91 a1 09 	lds	r24, 0x09A1
    224a:	87 ff       	sbrs	r24, 7
    224c:	fc cf       	rjmp	.-8      	; 0x2246 <MemoryStore+0x42>

    return FRAM_USART.DATA;
    224e:	80 91 a0 09 	lds	r24, 0x09A0

static uint8_t ScrapBuffer[] = {0};

INLINE uint8_t SPITransferByte(uint8_t Data)
{
    FRAM_USART.DATA = Data;
    2252:	10 92 a0 09 	sts	0x09A0, r1

    while (!(FRAM_USART.STATUS & USART_RXCIF_bm));
    2256:	80 91 a1 09 	lds	r24, 0x09A1
    225a:	87 ff       	sbrs	r24, 7
    225c:	fc cf       	rjmp	.-8      	; 0x2256 <MemoryStore+0x52>

    return FRAM_USART.DATA;
    225e:	80 91 a0 09 	lds	r24, 0x09A0

static uint8_t ScrapBuffer[] = {0};

INLINE uint8_t SPITransferByte(uint8_t Data)
{
    FRAM_USART.DATA = Data;
    2262:	10 92 a0 09 	sts	0x09A0, r1

    while (!(FRAM_USART.STATUS & USART_RXCIF_bm));
    2266:	80 91 a1 09 	lds	r24, 0x09A1
    226a:	87 ff       	sbrs	r24, 7
    226c:	fc cf       	rjmp	.-8      	; 0x2266 <MemoryStore+0x62>
{
    /* We assume that FlashWrite is always called for write actions that are
     * aligned to APP_SECTION_PAGE_SIZE and a multiple of APP_SECTION_PAGE_SIZE.
     * Thus only full pages are written into the flash. */
    uint16_t PageCount = ByteCount / APP_SECTION_PAGE_SIZE;
    uint32_t PhysicalAddress = Address + FLASH_DATA_ADDR;
    226e:	8f ef       	ldi	r24, 0xFF	; 255
    2270:	e8 1a       	sub	r14, r24
    2272:	f8 0a       	sbc	r15, r24
{
    FRAM_USART.DATA = Data;

    while (!(FRAM_USART.STATUS & USART_RXCIF_bm));

    return FRAM_USART.DATA;
    2274:	80 91 a0 09 	lds	r24, 0x09A0
    2278:	c1 e2       	ldi	r28, 0x21	; 33
    227a:	d0 e0       	ldi	r29, 0x00	; 0
    227c:	21 97       	sbiw	r28, 0x01	; 1

        SPITransferByte(0x03); /* Read command */
        SPITransferByte(0); /* Address hi and lo byte */
        SPITransferByte(0);

        while(PageCount-- > 0) {
    227e:	49 f1       	breq	.+82     	; 0x22d2 <MemoryStore+0xce>
            /* For each page to program, wait for NVM to get ready,
             * erase the flash page buffer, program all data to the
             * flash page buffer and write buffer to flash using
             * the atomic erase and write operation. */

            FlashWaitForSPM();
    2280:	01 db       	rcall	.-2558   	; 0x1884 <FlashWaitForSPM>

            FlashEraseFlashBuffer();
    2282:	fd da       	rcall	.-2566   	; 0x187e <FlashEraseFlashBuffer>
            FlashWaitForSPM();
    2284:	ff da       	rcall	.-2562   	; 0x1884 <FlashWaitForSPM>

            /* Write one page worth of data into flash buffer */
            for (uint16_t i=0; i<APP_SECTION_PAGE_SIZE; i += 2) {
    2286:	00 e0       	ldi	r16, 0x00	; 0
    2288:	10 e0       	ldi	r17, 0x00	; 0

static uint8_t ScrapBuffer[] = {0};

INLINE uint8_t SPITransferByte(uint8_t Data)
{
    FRAM_USART.DATA = Data;
    228a:	10 92 a0 09 	sts	0x09A0, r1

    while (!(FRAM_USART.STATUS & USART_RXCIF_bm));
    228e:	80 91 a1 09 	lds	r24, 0x09A1
    2292:	87 ff       	sbrs	r24, 7
    2294:	fc cf       	rjmp	.-8      	; 0x228e <MemoryStore+0x8a>

    return FRAM_USART.DATA;
    2296:	60 91 a0 09 	lds	r22, 0x09A0

            /* Write one page worth of data into flash buffer */
            for (uint16_t i=0; i<APP_SECTION_PAGE_SIZE; i += 2) {
                uint16_t Word = 0;

                Word |= ( (uint16_t) SPITransferByte(0) << 0);
    229a:	70 e0       	ldi	r23, 0x00	; 0

static uint8_t ScrapBuffer[] = {0};

INLINE uint8_t SPITransferByte(uint8_t Data)
{
    FRAM_USART.DATA = Data;
    229c:	10 92 a0 09 	sts	0x09A0, r1

    while (!(FRAM_USART.STATUS & USART_RXCIF_bm));
    22a0:	80 91 a1 09 	lds	r24, 0x09A1
    22a4:	87 ff       	sbrs	r24, 7
    22a6:	fc cf       	rjmp	.-8      	; 0x22a0 <MemoryStore+0x9c>

    return FRAM_USART.DATA;
    22a8:	80 91 a0 09 	lds	r24, 0x09A0
            /* Write one page worth of data into flash buffer */
            for (uint16_t i=0; i<APP_SECTION_PAGE_SIZE; i += 2) {
                uint16_t Word = 0;

                Word |= ( (uint16_t) SPITransferByte(0) << 0);
                Word |= ( (uint16_t) SPITransferByte(0) << 8);
    22ac:	78 2b       	or	r23, r24

                FlashLoadFlashWord(i, Word);
    22ae:	c8 01       	movw	r24, r16
    22b0:	db da       	rcall	.-2634   	; 0x1868 <FlashLoadFlashWord>
                FlashWaitForSPM();
    22b2:	e8 da       	rcall	.-2608   	; 0x1884 <FlashWaitForSPM>

            FlashEraseFlashBuffer();
            FlashWaitForSPM();

            /* Write one page worth of data into flash buffer */
            for (uint16_t i=0; i<APP_SECTION_PAGE_SIZE; i += 2) {
    22b4:	0e 5f       	subi	r16, 0xFE	; 254
    22b6:	1f 4f       	sbci	r17, 0xFF	; 255
    22b8:	01 15       	cp	r16, r1
    22ba:	81 e0       	ldi	r24, 0x01	; 1
    22bc:	18 07       	cpc	r17, r24
    22be:	29 f7       	brne	.-54     	; 0x228a <MemoryStore+0x86>
                FlashLoadFlashWord(i, Word);
                FlashWaitForSPM();
            }

            /* Program flash buffer into flash */
            FlashEraseWriteApplicationPage(PhysicalAddress);
    22c0:	c7 01       	movw	r24, r14
    22c2:	b6 01       	movw	r22, r12
    22c4:	d6 da       	rcall	.-2644   	; 0x1872 <FlashEraseWriteApplicationPage>
            FlashWaitForSPM();
    22c6:	de da       	rcall	.-2628   	; 0x1884 <FlashWaitForSPM>

            PhysicalAddress += APP_SECTION_PAGE_SIZE;
    22c8:	8f ef       	ldi	r24, 0xFF	; 255
    22ca:	d8 1a       	sub	r13, r24
    22cc:	e8 0a       	sbc	r14, r24
    22ce:	f8 0a       	sbc	r15, r24
    22d0:	d5 cf       	rjmp	.-86     	; 0x227c <MemoryStore+0x78>
        }

        /* End read procedure of FRAM */
        FRAM_PORT.OUTSET = FRAM_CS;
    22d2:	80 e1       	ldi	r24, 0x10	; 16
    22d4:	80 93 65 06 	sts	0x0665, r24

INLINE void LEDHook(LEDHookEnum Func, LEDActionEnum Action) {
    extern LEDActionEnum LEDGreenAction;
    extern LEDActionEnum LEDRedAction;

    if (GlobalSettings.ActiveSettingPtr->LEDGreenFunction == Func) {
    22d8:	e0 91 71 2f 	lds	r30, 0x2F71
    22dc:	f0 91 72 2f 	lds	r31, 0x2F72
    22e0:	87 81       	ldd	r24, Z+7	; 0x07
    22e2:	86 30       	cpi	r24, 0x06	; 6
    22e4:	19 f4       	brne	.+6      	; 0x22ec <MemoryStore+0xe8>
        LEDGreenAction = Action;
    22e6:	90 e1       	ldi	r25, 0x10	; 16
    22e8:	90 93 7d 2c 	sts	0x2C7D, r25
    }

    if (GlobalSettings.ActiveSettingPtr->LEDRedFunction == Func) {
    22ec:	96 81       	ldd	r25, Z+6	; 0x06
    22ee:	96 30       	cpi	r25, 0x06	; 6
    22f0:	49 f4       	brne	.+18     	; 0x2304 <MemoryStore+0x100>
        LEDRedAction = Action;
    22f2:	20 e1       	ldi	r18, 0x10	; 16
    22f4:	20 93 7c 2c 	sts	0x2C7C, r18

INLINE void LEDHook(LEDHookEnum Func, LEDActionEnum Action) {
    extern LEDActionEnum LEDGreenAction;
    extern LEDActionEnum LEDRedAction;

    if (GlobalSettings.ActiveSettingPtr->LEDGreenFunction == Func) {
    22f8:	85 30       	cpi	r24, 0x05	; 5
    22fa:	59 f4       	brne	.+22     	; 0x2312 <MemoryStore+0x10e>
        LEDGreenAction = Action;
    22fc:	83 e1       	ldi	r24, 0x13	; 19
    22fe:	80 93 7d 2c 	sts	0x2C7D, r24
    2302:	02 c0       	rjmp	.+4      	; 0x2308 <MemoryStore+0x104>

INLINE void LEDHook(LEDHookEnum Func, LEDActionEnum Action) {
    extern LEDActionEnum LEDGreenAction;
    extern LEDActionEnum LEDRedAction;

    if (GlobalSettings.ActiveSettingPtr->LEDGreenFunction == Func) {
    2304:	85 30       	cpi	r24, 0x05	; 5
    2306:	d1 f3       	breq	.-12     	; 0x22fc <MemoryStore+0xf8>
        LEDGreenAction = Action;
    }

    if (GlobalSettings.ActiveSettingPtr->LEDRedFunction == Func) {
    2308:	95 30       	cpi	r25, 0x05	; 5
    230a:	19 f4       	brne	.+6      	; 0x2312 <MemoryStore+0x10e>
        LEDRedAction = Action;
    230c:	83 e1       	ldi	r24, 0x13	; 19
    230e:	80 93 7c 2c 	sts	0x2C7C, r24
    return false;
}

INLINE void SystemTickClearFlag(void)
{
    while(RTC.STATUS & RTC_SYNCBUSY_bm)
    2312:	80 91 01 04 	lds	r24, 0x0401
    2316:	80 fd       	sbrc	r24, 0
    2318:	fc cf       	rjmp	.-8      	; 0x2312 <MemoryStore+0x10e>
        ;

    RTC.INTFLAGS = RTC_COMPIF_bm;
    231a:	82 e0       	ldi	r24, 0x02	; 2
    231c:	80 93 03 04 	sts	0x0403, r24

    LEDHook(LED_MEMORY_CHANGED, LED_OFF);
    LEDHook(LED_MEMORY_STORED, LED_PULSE);

    SystemTickClearFlag();
}
    2320:	df 91       	pop	r29
    2322:	cf 91       	pop	r28
    2324:	1f 91       	pop	r17
    2326:	0f 91       	pop	r16
    2328:	ff 90       	pop	r15
    232a:	ef 90       	pop	r14
    232c:	df 90       	pop	r13
    232e:	cf 90       	pop	r12
    2330:	08 95       	ret

00002332 <MemoryUploadBlock>:

bool MemoryUploadBlock(void* Buffer, uint32_t BlockAddress, uint16_t ByteCount)
{
    2332:	cf 92       	push	r12
    2334:	df 92       	push	r13
    2336:	ef 92       	push	r14
    2338:	ff 92       	push	r15
    233a:	0f 93       	push	r16
    233c:	1f 93       	push	r17
    if (BlockAddress >= MEMORY_SIZE_PER_SETTING) {
    233e:	41 15       	cp	r20, r1
    2340:	e0 e2       	ldi	r30, 0x20	; 32
    2342:	5e 07       	cpc	r21, r30
    2344:	61 05       	cpc	r22, r1
    2346:	71 05       	cpc	r23, r1
    2348:	08 f0       	brcs	.+2      	; 0x234c <MemoryUploadBlock+0x1a>
    234a:	6b c0       	rjmp	.+214    	; 0x2422 <MemoryUploadBlock+0xf0>
        /* Prevent writing out of bounds by silently ignoring it */
        return true;
    } else {
        /* Calculate bytes left in memory and start writing */
        uint32_t BytesLeft = MEMORY_SIZE_PER_SETTING - BlockAddress;
        ByteCount = MIN(ByteCount, BytesLeft);
    234c:	69 01       	movw	r12, r18
    234e:	e1 2c       	mov	r14, r1
    2350:	f1 2c       	mov	r15, r1
    2352:	00 e0       	ldi	r16, 0x00	; 0
    2354:	10 e2       	ldi	r17, 0x20	; 32
    2356:	20 e0       	ldi	r18, 0x00	; 0
    2358:	30 e0       	ldi	r19, 0x00	; 0
    235a:	04 1b       	sub	r16, r20
    235c:	15 0b       	sbc	r17, r21
    235e:	26 0b       	sbc	r18, r22
    2360:	37 0b       	sbc	r19, r23
    2362:	c0 16       	cp	r12, r16
    2364:	d1 06       	cpc	r13, r17
    2366:	e2 06       	cpc	r14, r18
    2368:	f3 06       	cpc	r15, r19
    236a:	10 f4       	brcc	.+4      	; 0x2370 <MemoryUploadBlock+0x3e>
    236c:	97 01       	movw	r18, r14
    236e:	86 01       	movw	r16, r12
    FRAM_PORT.OUTSET = FRAM_CS;
}

INLINE void FRAMWrite(const void* Buffer, uint16_t Address, uint16_t ByteCount)
{
    FRAM_PORT.OUTCLR = FRAM_CS;
    2370:	20 e1       	ldi	r18, 0x10	; 16
    2372:	20 93 66 06 	sts	0x0666, r18

static uint8_t ScrapBuffer[] = {0};

INLINE uint8_t SPITransferByte(uint8_t Data)
{
    FRAM_USART.DATA = Data;
    2376:	26 e0       	ldi	r18, 0x06	; 6
    2378:	20 93 a0 09 	sts	0x09A0, r18

    while (!(FRAM_USART.STATUS & USART_RXCIF_bm));
    237c:	20 91 a1 09 	lds	r18, 0x09A1
    2380:	27 ff       	sbrs	r18, 7
    2382:	fc cf       	rjmp	.-8      	; 0x237c <MemoryUploadBlock+0x4a>

    return FRAM_USART.DATA;
    2384:	20 91 a0 09 	lds	r18, 0x09A0

INLINE void FRAMWrite(const void* Buffer, uint16_t Address, uint16_t ByteCount)
{
    FRAM_PORT.OUTCLR = FRAM_CS;
    SPITransferByte(0x06); /* Write Enable */
    FRAM_PORT.OUTSET = FRAM_CS;
    2388:	20 e1       	ldi	r18, 0x10	; 16
    238a:	20 93 65 06 	sts	0x0665, r18

    asm volatile ("nop");
    238e:	00 00       	nop
    asm volatile ("nop");
    2390:	00 00       	nop

    FRAM_PORT.OUTCLR = FRAM_CS;
    2392:	20 93 66 06 	sts	0x0666, r18

static uint8_t ScrapBuffer[] = {0};

INLINE uint8_t SPITransferByte(uint8_t Data)
{
    FRAM_USART.DATA = Data;
    2396:	22 e0       	ldi	r18, 0x02	; 2
    2398:	20 93 a0 09 	sts	0x09A0, r18

    while (!(FRAM_USART.STATUS & USART_RXCIF_bm));
    239c:	20 91 a1 09 	lds	r18, 0x09A1
    23a0:	27 ff       	sbrs	r18, 7
    23a2:	fc cf       	rjmp	.-8      	; 0x239c <MemoryUploadBlock+0x6a>

    return FRAM_USART.DATA;
    23a4:	20 91 a0 09 	lds	r18, 0x09A0

static uint8_t ScrapBuffer[] = {0};

INLINE uint8_t SPITransferByte(uint8_t Data)
{
    FRAM_USART.DATA = Data;
    23a8:	50 93 a0 09 	sts	0x09A0, r21

    while (!(FRAM_USART.STATUS & USART_RXCIF_bm));
    23ac:	20 91 a1 09 	lds	r18, 0x09A1
    23b0:	27 ff       	sbrs	r18, 7
    23b2:	fc cf       	rjmp	.-8      	; 0x23ac <MemoryUploadBlock+0x7a>

    return FRAM_USART.DATA;
    23b4:	20 91 a0 09 	lds	r18, 0x09A0

static uint8_t ScrapBuffer[] = {0};

INLINE uint8_t SPITransferByte(uint8_t Data)
{
    FRAM_USART.DATA = Data;
    23b8:	40 93 a0 09 	sts	0x09A0, r20

    while (!(FRAM_USART.STATUS & USART_RXCIF_bm));
    23bc:	20 91 a1 09 	lds	r18, 0x09A1
    23c0:	27 ff       	sbrs	r18, 7
    23c2:	fc cf       	rjmp	.-8      	; 0x23bc <MemoryUploadBlock+0x8a>

    return FRAM_USART.DATA;
    23c4:	20 91 a0 09 	lds	r18, 0x09A0

#ifdef USE_DMA
INLINE void SPIWriteBlock(const void* Buffer, uint16_t ByteCount)
{
    /* Set up read and write transfers */
    RECV_DMA.ADDRCTRL = DMA_CH_SRCRELOAD_NONE_gc | DMA_CH_SRCDIR_FIXED_gc | DMA_CH_DESTRELOAD_NONE_gc | DMA_CH_DESTDIR_FIXED_gc;
    23c8:	10 92 12 01 	sts	0x0112, r1
    RECV_DMA.DESTADDR0 = ((uintptr_t) ScrapBuffer >> 0) & 0xFF;
    23cc:	24 e7       	ldi	r18, 0x74	; 116
    23ce:	34 e2       	ldi	r19, 0x24	; 36
    23d0:	20 93 1c 01 	sts	0x011C, r18
    RECV_DMA.DESTADDR1 = ((uintptr_t) ScrapBuffer >> 8) & 0xFF;
    23d4:	30 93 1d 01 	sts	0x011D, r19
    RECV_DMA.TRFCNT = ByteCount;
    23d8:	00 93 14 01 	sts	0x0114, r16
    23dc:	10 93 15 01 	sts	0x0115, r17
    SEND_DMA.ADDRCTRL = DMA_CH_SRCRELOAD_NONE_gc | DMA_CH_SRCDIR_INC_gc | DMA_CH_DESTRELOAD_NONE_gc | DMA_CH_DESTDIR_FIXED_gc;
    23e0:	20 e1       	ldi	r18, 0x10	; 16
    23e2:	20 93 22 01 	sts	0x0122, r18
    SEND_DMA.SRCADDR0 = ((uintptr_t) Buffer >> 0) & 0xFF;
    23e6:	80 93 28 01 	sts	0x0128, r24
    SEND_DMA.SRCADDR1 = ((uintptr_t) Buffer >> 8) & 0xFF;
    23ea:	90 93 29 01 	sts	0x0129, r25
    SEND_DMA.TRFCNT = ByteCount;
    23ee:	00 93 24 01 	sts	0x0124, r16
    23f2:	10 93 25 01 	sts	0x0125, r17

    /* Enable read and write transfers */
    RECV_DMA.CTRLA |= DMA_CH_ENABLE_bm;
    23f6:	80 91 10 01 	lds	r24, 0x0110
    23fa:	80 68       	ori	r24, 0x80	; 128
    23fc:	80 93 10 01 	sts	0x0110, r24
    SEND_DMA.CTRLA |= DMA_CH_ENABLE_bm;
    2400:	80 91 20 01 	lds	r24, 0x0120
    2404:	80 68       	ori	r24, 0x80	; 128
    2406:	80 93 20 01 	sts	0x0120, r24

    /* Wait for DMA to finish */
    while( RECV_DMA.CTRLA & DMA_CH_ENABLE_bm )
    240a:	80 91 10 01 	lds	r24, 0x0110
    240e:	87 fd       	sbrc	r24, 7
    2410:	fc cf       	rjmp	.-8      	; 0x240a <MemoryUploadBlock+0xd8>
        ;

    /* Clear Interrupt flag */
    RECV_DMA.CTRLB = DMA_CH_TRNIF_bm | DMA_CH_ERRIF_bm;
    2412:	80 e3       	ldi	r24, 0x30	; 48
    2414:	80 93 11 01 	sts	0x0111, r24
    SEND_DMA.CTRLB = DMA_CH_TRNIF_bm | DMA_CH_ERRIF_bm;
    2418:	80 93 21 01 	sts	0x0121, r24
    SPITransferByte( (Address >> 8) & 0xFF ); /* Address hi and lo byte */
    SPITransferByte( (Address >> 0) & 0xFF );

    SPIWriteBlock(Buffer, ByteCount);

    FRAM_PORT.OUTSET = FRAM_CS;
    241c:	80 e1       	ldi	r24, 0x10	; 16
    241e:	80 93 65 06 	sts	0x0665, r24
        /* Store to local memory */
        FRAMWrite(Buffer, BlockAddress, ByteCount);

        return true;
    }
}
    2422:	81 e0       	ldi	r24, 0x01	; 1
    2424:	1f 91       	pop	r17
    2426:	0f 91       	pop	r16
    2428:	ff 90       	pop	r15
    242a:	ef 90       	pop	r14
    242c:	df 90       	pop	r13
    242e:	cf 90       	pop	r12
    2430:	08 95       	ret

00002432 <MemoryDownloadBlock>:

bool MemoryDownloadBlock(void* Buffer, uint32_t BlockAddress, uint16_t ByteCount)
{
    2432:	cf 92       	push	r12
    2434:	df 92       	push	r13
    2436:	ef 92       	push	r14
    2438:	ff 92       	push	r15
    243a:	0f 93       	push	r16
    243c:	1f 93       	push	r17
    if (BlockAddress >= MEMORY_SIZE_PER_SETTING) {
    243e:	41 15       	cp	r20, r1
    2440:	e0 e2       	ldi	r30, 0x20	; 32
    2442:	5e 07       	cpc	r21, r30
    2444:	61 05       	cpc	r22, r1
    2446:	71 05       	cpc	r23, r1
    2448:	08 f0       	brcs	.+2      	; 0x244c <MemoryDownloadBlock+0x1a>
    244a:	5d c0       	rjmp	.+186    	; 0x2506 <MemoryDownloadBlock+0xd4>
        /* There are bytes out of bounds to be read. Notify that we are done. */
        return false;
    } else {
        /* Calculate bytes left in memory and issue reading */
        uint32_t BytesLeft = MEMORY_SIZE_PER_SETTING - BlockAddress;
        ByteCount = MIN(ByteCount, BytesLeft);
    244c:	69 01       	movw	r12, r18
    244e:	e1 2c       	mov	r14, r1
    2450:	f1 2c       	mov	r15, r1
    2452:	00 e0       	ldi	r16, 0x00	; 0
    2454:	10 e2       	ldi	r17, 0x20	; 32
    2456:	20 e0       	ldi	r18, 0x00	; 0
    2458:	30 e0       	ldi	r19, 0x00	; 0
    245a:	04 1b       	sub	r16, r20
    245c:	15 0b       	sbc	r17, r21
    245e:	26 0b       	sbc	r18, r22
    2460:	37 0b       	sbc	r19, r23
    2462:	c0 16       	cp	r12, r16
    2464:	d1 06       	cpc	r13, r17
    2466:	e2 06       	cpc	r14, r18
    2468:	f3 06       	cpc	r15, r19
    246a:	10 f4       	brcc	.+4      	; 0x2470 <MemoryDownloadBlock+0x3e>
    246c:	97 01       	movw	r18, r14
    246e:	86 01       	movw	r16, r12
}
#endif

INLINE void FRAMRead(void* Buffer, uint16_t Address, uint16_t ByteCount)
{
    FRAM_PORT.OUTCLR = FRAM_CS;
    2470:	20 e1       	ldi	r18, 0x10	; 16
    2472:	20 93 66 06 	sts	0x0666, r18

static uint8_t ScrapBuffer[] = {0};

INLINE uint8_t SPITransferByte(uint8_t Data)
{
    FRAM_USART.DATA = Data;
    2476:	23 e0       	ldi	r18, 0x03	; 3
    2478:	20 93 a0 09 	sts	0x09A0, r18

    while (!(FRAM_USART.STATUS & USART_RXCIF_bm));
    247c:	20 91 a1 09 	lds	r18, 0x09A1
    2480:	27 ff       	sbrs	r18, 7
    2482:	fc cf       	rjmp	.-8      	; 0x247c <MemoryDownloadBlock+0x4a>

    return FRAM_USART.DATA;
    2484:	20 91 a0 09 	lds	r18, 0x09A0

static uint8_t ScrapBuffer[] = {0};

INLINE uint8_t SPITransferByte(uint8_t Data)
{
    FRAM_USART.DATA = Data;
    2488:	50 93 a0 09 	sts	0x09A0, r21

    while (!(FRAM_USART.STATUS & USART_RXCIF_bm));
    248c:	20 91 a1 09 	lds	r18, 0x09A1
    2490:	27 ff       	sbrs	r18, 7
    2492:	fc cf       	rjmp	.-8      	; 0x248c <MemoryDownloadBlock+0x5a>

    return FRAM_USART.DATA;
    2494:	20 91 a0 09 	lds	r18, 0x09A0

static uint8_t ScrapBuffer[] = {0};

INLINE uint8_t SPITransferByte(uint8_t Data)
{
    FRAM_USART.DATA = Data;
    2498:	40 93 a0 09 	sts	0x09A0, r20

    while (!(FRAM_USART.STATUS & USART_RXCIF_bm));
    249c:	20 91 a1 09 	lds	r18, 0x09A1
    24a0:	27 ff       	sbrs	r18, 7
    24a2:	fc cf       	rjmp	.-8      	; 0x249c <MemoryDownloadBlock+0x6a>

    return FRAM_USART.DATA;
    24a4:	20 91 a0 09 	lds	r18, 0x09A0

#ifdef USE_DMA
INLINE void SPIReadBlock(void* Buffer, uint16_t ByteCount)
{
    /* Set up read and write transfers */
    RECV_DMA.ADDRCTRL = DMA_CH_SRCRELOAD_NONE_gc | DMA_CH_SRCDIR_FIXED_gc | DMA_CH_DESTRELOAD_NONE_gc | DMA_CH_DESTDIR_INC_gc;
    24a8:	21 e0       	ldi	r18, 0x01	; 1
    24aa:	20 93 12 01 	sts	0x0112, r18
    RECV_DMA.DESTADDR0 = ((uintptr_t) Buffer >> 0) & 0xFF;
    24ae:	80 93 1c 01 	sts	0x011C, r24
    RECV_DMA.DESTADDR1 = ((uintptr_t) Buffer >> 8) & 0xFF;
    24b2:	90 93 1d 01 	sts	0x011D, r25
    RECV_DMA.TRFCNT = ByteCount;
    24b6:	00 93 14 01 	sts	0x0114, r16
    24ba:	10 93 15 01 	sts	0x0115, r17
    SEND_DMA.ADDRCTRL = DMA_CH_SRCRELOAD_NONE_gc | DMA_CH_SRCDIR_FIXED_gc | DMA_CH_DESTRELOAD_NONE_gc | DMA_CH_DESTDIR_FIXED_gc;
    24be:	10 92 22 01 	sts	0x0122, r1
    SEND_DMA.SRCADDR0 = ((uintptr_t) ScrapBuffer >> 0) & 0xFF;
    24c2:	84 e7       	ldi	r24, 0x74	; 116
    24c4:	94 e2       	ldi	r25, 0x24	; 36
    24c6:	80 93 28 01 	sts	0x0128, r24
    SEND_DMA.SRCADDR1 = ((uintptr_t) ScrapBuffer >> 8) & 0xFF;
    24ca:	90 93 29 01 	sts	0x0129, r25
    SEND_DMA.TRFCNT = ByteCount;
    24ce:	00 93 24 01 	sts	0x0124, r16
    24d2:	10 93 25 01 	sts	0x0125, r17


    /* Enable read and write transfers */
    RECV_DMA.CTRLA |= DMA_CH_ENABLE_bm;
    24d6:	80 91 10 01 	lds	r24, 0x0110
    24da:	80 68       	ori	r24, 0x80	; 128
    24dc:	80 93 10 01 	sts	0x0110, r24
    SEND_DMA.CTRLA |= DMA_CH_ENABLE_bm;
    24e0:	80 91 20 01 	lds	r24, 0x0120
    24e4:	80 68       	ori	r24, 0x80	; 128
    24e6:	80 93 20 01 	sts	0x0120, r24

    /* Wait for DMA to finish */
    while( RECV_DMA.CTRLA & DMA_CH_ENABLE_bm )
    24ea:	80 91 10 01 	lds	r24, 0x0110
    24ee:	87 fd       	sbrc	r24, 7
    24f0:	fc cf       	rjmp	.-8      	; 0x24ea <MemoryDownloadBlock+0xb8>
        ;

    /* Clear Interrupt flag */
    RECV_DMA.CTRLB = DMA_CH_TRNIF_bm | DMA_CH_ERRIF_bm;
    24f2:	80 e3       	ldi	r24, 0x30	; 48
    24f4:	80 93 11 01 	sts	0x0111, r24
    SEND_DMA.CTRLB = DMA_CH_TRNIF_bm | DMA_CH_ERRIF_bm;
    24f8:	80 93 21 01 	sts	0x0121, r24
    SPITransferByte( (Address >> 8) & 0xFF ); /* Address hi and lo byte */
    SPITransferByte( (Address >> 0) & 0xFF );

    SPIReadBlock(Buffer, ByteCount);

    FRAM_PORT.OUTSET = FRAM_CS;
    24fc:	80 e1       	ldi	r24, 0x10	; 16
    24fe:	80 93 65 06 	sts	0x0665, r24
        ByteCount = MIN(ByteCount, BytesLeft);

        /* Output local memory contents */
        FRAMRead(Buffer, BlockAddress, ByteCount);

        return true;
    2502:	81 e0       	ldi	r24, 0x01	; 1
    2504:	01 c0       	rjmp	.+2      	; 0x2508 <MemoryDownloadBlock+0xd6>

bool MemoryDownloadBlock(void* Buffer, uint32_t BlockAddress, uint16_t ByteCount)
{
    if (BlockAddress >= MEMORY_SIZE_PER_SETTING) {
        /* There are bytes out of bounds to be read. Notify that we are done. */
        return false;
    2506:	80 e0       	ldi	r24, 0x00	; 0
        /* Output local memory contents */
        FRAMRead(Buffer, BlockAddress, ByteCount);

        return true;
    }
}
    2508:	1f 91       	pop	r17
    250a:	0f 91       	pop	r16
    250c:	ff 90       	pop	r15
    250e:	ef 90       	pop	r14
    2510:	df 90       	pop	r13
    2512:	cf 90       	pop	r12
    2514:	08 95       	ret

00002516 <WaitForNVM>:
                 );
}

void WaitForNVM(void)
{
        while (NVM.STATUS & NVM_NVMBUSY_bm) { };
    2516:	80 91 cf 01 	lds	r24, 0x01CF
    251a:	87 fd       	sbrc	r24, 7
    251c:	fc cf       	rjmp	.-8      	; 0x2516 <WaitForNVM>
}
    251e:	08 95       	ret

00002520 <FlushNVMBuffer>:

void FlushNVMBuffer(void)
{
    WaitForNVM();
    2520:	fa df       	rcall	.-12     	; 0x2516 <WaitForNVM>

    if ((NVM.STATUS & NVM_EELOAD_bm) != 0) {
    2522:	80 91 cf 01 	lds	r24, 0x01CF
    2526:	81 ff       	sbrs	r24, 1
    2528:	0b c0       	rjmp	.+22     	; 0x2540 <FlushNVMBuffer+0x20>
        NVM.CMD = NVM_CMD_ERASE_EEPROM_BUFFER_gc;
    252a:	86 e3       	ldi	r24, 0x36	; 54
    252c:	80 93 ca 01 	sts	0x01CA, r24

static inline void NVM_EXEC(void)
{
    void *z = (void *)&NVM_CTRLA;

    __asm__ volatile("out %[ccp], %[ioreg]"  "\n\t"
    2530:	eb ec       	ldi	r30, 0xCB	; 203
    2532:	f1 e0       	ldi	r31, 0x01	; 1
    2534:	21 e0       	ldi	r18, 0x01	; 1
    2536:	30 e0       	ldi	r19, 0x00	; 0
    2538:	88 ed       	ldi	r24, 0xD8	; 216
    253a:	90 e0       	ldi	r25, 0x00	; 0
    253c:	84 bf       	out	0x34, r24	; 52
    253e:	20 83       	st	Z, r18
    2540:	08 95       	ret

00002542 <ReadEEPBlock>:
        NVM_EXEC();
    }
}

uint16_t ReadEEPBlock(uint16_t Address, void *DestPtr, uint16_t ByteCount)
{
    2542:	ef 92       	push	r14
    2544:	ff 92       	push	r15
    2546:	0f 93       	push	r16
    2548:	1f 93       	push	r17
    254a:	cf 93       	push	r28
    254c:	df 93       	push	r29
    254e:	1f 92       	push	r1
    2550:	1f 92       	push	r1
    2552:	cd b7       	in	r28, 0x3d	; 61
    2554:	de b7       	in	r29, 0x3e	; 62
    2556:	7c 01       	movw	r14, r24
    2558:	8a 01       	movw	r16, r20
    uint16_t BytesRead = 0;
    uint8_t* BytePtr = (uint8_t*) DestPtr;
    NVM.ADDR2 = 0;
    255a:	10 92 c2 01 	sts	0x01C2, r1

    WaitForNVM();
    255e:	69 83       	std	Y+1, r22	; 0x01
    2560:	7a 83       	std	Y+2, r23	; 0x02
    2562:	d9 df       	rcall	.-78     	; 0x2516 <WaitForNVM>
    2564:	69 81       	ldd	r22, Y+1	; 0x01
    2566:	a6 2f       	mov	r26, r22
    2568:	7a 81       	ldd	r23, Y+2	; 0x02
    256a:	b7 2f       	mov	r27, r23
    256c:	c7 01       	movw	r24, r14
    256e:	80 0f       	add	r24, r16
    2570:	91 1f       	adc	r25, r17
    while (ByteCount > 0)
    {
            NVM.ADDR0 = Address & 0xFF;
            NVM.ADDR1 = (Address >> 8) & 0x1F;

            NVM.CMD = NVM_CMD_READ_EEPROM_gc;
    2572:	26 e0       	ldi	r18, 0x06	; 6

static inline void NVM_EXEC(void)
{
    void *z = (void *)&NVM_CTRLA;

    __asm__ volatile("out %[ccp], %[ioreg]"  "\n\t"
    2574:	48 ed       	ldi	r20, 0xD8	; 216
    2576:	50 e0       	ldi	r21, 0x00	; 0
    2578:	61 e0       	ldi	r22, 0x01	; 1
    257a:	70 e0       	ldi	r23, 0x00	; 0
    257c:	eb ec       	ldi	r30, 0xCB	; 203
    257e:	f1 e0       	ldi	r31, 0x01	; 1
    uint8_t* BytePtr = (uint8_t*) DestPtr;
    NVM.ADDR2 = 0;

    WaitForNVM();

    while (ByteCount > 0)
    2580:	e8 16       	cp	r14, r24
    2582:	f9 06       	cpc	r15, r25
    2584:	89 f0       	breq	.+34     	; 0x25a8 <ReadEEPBlock+0x66>
    {
            NVM.ADDR0 = Address & 0xFF;
    2586:	e0 92 c0 01 	sts	0x01C0, r14
            NVM.ADDR1 = (Address >> 8) & 0x1F;
    258a:	3f 2d       	mov	r19, r15
    258c:	3f 71       	andi	r19, 0x1F	; 31
    258e:	30 93 c1 01 	sts	0x01C1, r19

            NVM.CMD = NVM_CMD_READ_EEPROM_gc;
    2592:	20 93 ca 01 	sts	0x01CA, r18

static inline void NVM_EXEC(void)
{
    void *z = (void *)&NVM_CTRLA;

    __asm__ volatile("out %[ccp], %[ioreg]"  "\n\t"
    2596:	44 bf       	out	0x34, r20	; 52
    2598:	60 83       	st	Z, r22
            NVM.ADDR1 = (Address >> 8) & 0x1F;

            NVM.CMD = NVM_CMD_READ_EEPROM_gc;
            NVM_EXEC();

            *BytePtr++ = NVM.DATA0;
    259a:	30 91 c4 01 	lds	r19, 0x01C4
    259e:	3d 93       	st	X+, r19
            Address++;
    25a0:	3f ef       	ldi	r19, 0xFF	; 255
    25a2:	e3 1a       	sub	r14, r19
    25a4:	f3 0a       	sbc	r15, r19
    25a6:	ec cf       	rjmp	.-40     	; 0x2580 <ReadEEPBlock+0x3e>
            ByteCount--;
            BytesRead++;
    }

    return BytesRead;
}
    25a8:	c8 01       	movw	r24, r16
    25aa:	0f 90       	pop	r0
    25ac:	0f 90       	pop	r0
    25ae:	df 91       	pop	r29
    25b0:	cf 91       	pop	r28
    25b2:	1f 91       	pop	r17
    25b4:	0f 91       	pop	r16
    25b6:	ff 90       	pop	r15
    25b8:	ef 90       	pop	r14
    25ba:	08 95       	ret

000025bc <WriteEEPBlock>:


uint16_t WriteEEPBlock(uint16_t Address, const void *SrcPtr, uint16_t ByteCount)
{
    25bc:	2f 92       	push	r2
    25be:	3f 92       	push	r3
    25c0:	4f 92       	push	r4
    25c2:	5f 92       	push	r5
    25c4:	6f 92       	push	r6
    25c6:	7f 92       	push	r7
    25c8:	8f 92       	push	r8
    25ca:	9f 92       	push	r9
    25cc:	af 92       	push	r10
    25ce:	bf 92       	push	r11
    25d0:	cf 92       	push	r12
    25d2:	df 92       	push	r13
    25d4:	ef 92       	push	r14
    25d6:	ff 92       	push	r15
    25d8:	0f 93       	push	r16
    25da:	1f 93       	push	r17
    25dc:	cf 93       	push	r28
    25de:	df 93       	push	r29
    25e0:	00 d0       	rcall	.+0      	; 0x25e2 <WriteEEPBlock+0x26>
    25e2:	cd b7       	in	r28, 0x3d	; 61
    25e4:	de b7       	in	r29, 0x3e	; 62
    25e6:	6a 01       	movw	r12, r20
    const uint8_t* BytePtr = (const uint8_t*) SrcPtr;
    uint8_t ByteAddress = Address % EEPROM_PAGE_SIZE;
    25e8:	28 2f       	mov	r18, r24
    25ea:	2f 71       	andi	r18, 0x1F	; 31
    uint16_t PageAddress = Address - ByteAddress;
    25ec:	1c 01       	movw	r2, r24
    25ee:	22 1a       	sub	r2, r18
    25f0:	31 08       	sbc	r3, r1
    uint16_t BytesWritten = 0;

    FlushNVMBuffer();
    25f2:	29 83       	std	Y+1, r18	; 0x01
    25f4:	6a 83       	std	Y+2, r22	; 0x02
    25f6:	7b 83       	std	Y+3, r23	; 0x03
    25f8:	93 df       	rcall	.-218    	; 0x2520 <FlushNVMBuffer>
    WaitForNVM();
    25fa:	8d df       	rcall	.-230    	; 0x2516 <WaitForNVM>
    NVM.CMD = NVM_CMD_LOAD_EEPROM_BUFFER_gc;
    25fc:	83 e3       	ldi	r24, 0x33	; 51
    25fe:	80 93 ca 01 	sts	0x01CA, r24

    NVM.ADDR1 = 0;
    2602:	10 92 c1 01 	sts	0x01C1, r1
    NVM.ADDR2 = 0;
    2606:	10 92 c2 01 	sts	0x01C2, r1
    260a:	6a 81       	ldd	r22, Y+2	; 0x02
    260c:	e6 2e       	mov	r14, r22
    260e:	7b 81       	ldd	r23, Y+3	; 0x03
    2610:	f7 2e       	mov	r15, r23

    while (ByteCount > 0)
    2612:	86 01       	movw	r16, r12
        if (ByteCount == 0 || ByteAddress >= EEPROM_PAGE_SIZE)
        {
            NVM.ADDR0 = PageAddress & 0xFF;
            NVM.ADDR1 = (PageAddress >> 8) & 0x1F;

            NVM.CMD = NVM_CMD_ERASE_WRITE_EEPROM_PAGE_gc;
    2614:	85 e3       	ldi	r24, 0x35	; 53
    2616:	58 2e       	mov	r5, r24

static inline void NVM_EXEC(void)
{
    void *z = (void *)&NVM_CTRLA;

    __asm__ volatile("out %[ccp], %[ioreg]"  "\n\t"
    2618:	98 ed       	ldi	r25, 0xD8	; 216
    261a:	89 2e       	mov	r8, r25
    261c:	91 2c       	mov	r9, r1
    261e:	66 24       	eor	r6, r6
    2620:	63 94       	inc	r6
    2622:	71 2c       	mov	r7, r1
    2624:	3b ec       	ldi	r19, 0xCB	; 203
    2626:	a3 2e       	mov	r10, r19
    2628:	bb 24       	eor	r11, r11
    262a:	b3 94       	inc	r11
            PageAddress += EEPROM_PAGE_SIZE;
            ByteAddress = 0;

            WaitForNVM();

            NVM.CMD = NVM_CMD_LOAD_EEPROM_BUFFER_gc;
    262c:	43 e3       	ldi	r20, 0x33	; 51
    262e:	44 2e       	mov	r4, r20
    NVM.CMD = NVM_CMD_LOAD_EEPROM_BUFFER_gc;

    NVM.ADDR1 = 0;
    NVM.ADDR2 = 0;

    while (ByteCount > 0)
    2630:	29 81       	ldd	r18, Y+1	; 0x01
    2632:	01 15       	cp	r16, r1
    2634:	11 05       	cpc	r17, r1
    2636:	09 f1       	breq	.+66     	; 0x267a <WriteEEPBlock+0xbe>
    {
        NVM.ADDR0 = ByteAddress;
    2638:	20 93 c0 01 	sts	0x01C0, r18

        NVM.DATA0 = *BytePtr++;
    263c:	f7 01       	movw	r30, r14
    263e:	81 91       	ld	r24, Z+
    2640:	7f 01       	movw	r14, r30
    2642:	80 93 c4 01 	sts	0x01C4, r24

        ByteAddress++;
        ByteCount--;
    2646:	01 50       	subi	r16, 0x01	; 1
    2648:	11 09       	sbc	r17, r1

        if (ByteCount == 0 || ByteAddress >= EEPROM_PAGE_SIZE)
    264a:	19 f0       	breq	.+6      	; 0x2652 <WriteEEPBlock+0x96>
    {
        NVM.ADDR0 = ByteAddress;

        NVM.DATA0 = *BytePtr++;

        ByteAddress++;
    264c:	2f 5f       	subi	r18, 0xFF	; 255
        ByteCount--;

        if (ByteCount == 0 || ByteAddress >= EEPROM_PAGE_SIZE)
    264e:	20 32       	cpi	r18, 0x20	; 32
    2650:	81 f7       	brne	.-32     	; 0x2632 <WriteEEPBlock+0x76>
        {
            NVM.ADDR0 = PageAddress & 0xFF;
    2652:	20 92 c0 01 	sts	0x01C0, r2
            NVM.ADDR1 = (PageAddress >> 8) & 0x1F;
    2656:	83 2d       	mov	r24, r3
    2658:	8f 71       	andi	r24, 0x1F	; 31
    265a:	80 93 c1 01 	sts	0x01C1, r24

            NVM.CMD = NVM_CMD_ERASE_WRITE_EEPROM_PAGE_gc;
    265e:	50 92 ca 01 	sts	0x01CA, r5

static inline void NVM_EXEC(void)
{
    void *z = (void *)&NVM_CTRLA;

    __asm__ volatile("out %[ccp], %[ioreg]"  "\n\t"
    2662:	c4 01       	movw	r24, r8
    2664:	f5 01       	movw	r30, r10
    2666:	84 bf       	out	0x34, r24	; 52
    2668:	60 82       	st	Z, r6
            NVM.ADDR1 = (PageAddress >> 8) & 0x1F;

            NVM.CMD = NVM_CMD_ERASE_WRITE_EEPROM_PAGE_gc;
            NVM_EXEC();

            PageAddress += EEPROM_PAGE_SIZE;
    266a:	90 e2       	ldi	r25, 0x20	; 32
    266c:	29 0e       	add	r2, r25
    266e:	31 1c       	adc	r3, r1
            ByteAddress = 0;

            WaitForNVM();
    2670:	52 df       	rcall	.-348    	; 0x2516 <WaitForNVM>

            NVM.CMD = NVM_CMD_LOAD_EEPROM_BUFFER_gc;
    2672:	40 92 ca 01 	sts	0x01CA, r4

            NVM.CMD = NVM_CMD_ERASE_WRITE_EEPROM_PAGE_gc;
            NVM_EXEC();

            PageAddress += EEPROM_PAGE_SIZE;
            ByteAddress = 0;
    2676:	20 e0       	ldi	r18, 0x00	; 0
    2678:	dc cf       	rjmp	.-72     	; 0x2632 <WriteEEPBlock+0x76>

        BytesWritten++;
    }

    return BytesWritten;
}
    267a:	c6 01       	movw	r24, r12
    267c:	23 96       	adiw	r28, 0x03	; 3
    267e:	cd bf       	out	0x3d, r28	; 61
    2680:	de bf       	out	0x3e, r29	; 62
    2682:	df 91       	pop	r29
    2684:	cf 91       	pop	r28
    2686:	1f 91       	pop	r17
    2688:	0f 91       	pop	r16
    268a:	ff 90       	pop	r15
    268c:	ef 90       	pop	r14
    268e:	df 90       	pop	r13
    2690:	cf 90       	pop	r12
    2692:	bf 90       	pop	r11
    2694:	af 90       	pop	r10
    2696:	9f 90       	pop	r9
    2698:	8f 90       	pop	r8
    269a:	7f 90       	pop	r7
    269c:	6f 90       	pop	r6
    269e:	5f 90       	pop	r5
    26a0:	4f 90       	pop	r4
    26a2:	3f 90       	pop	r3
    26a4:	2f 90       	pop	r2
    26a6:	08 95       	ret

000026a8 <ExecuteButtonAction>:
	{ .Id = BUTTON_ACTION_TOGGLE_FIELD,			.Text = "TOGGLE_FIELD" },
	{ .Id = BUTTON_ACTION_STORE_LOG,			.Text = "STORE_LOG" },
};

static void ExecuteButtonAction(ButtonActionEnum ButtonAction)
{
    26a8:	1f 93       	push	r17
    26aa:	cf 93       	push	r28
    26ac:	df 93       	push	r29
    26ae:	cd b7       	in	r28, 0x3d	; 61
    26b0:	de b7       	in	r29, 0x3e	; 62
    26b2:	a0 97       	sbiw	r28, 0x20	; 32
    26b4:	cd bf       	out	0x3d, r28	; 61
    26b6:	de bf       	out	0x3e, r29	; 62
    uint8_t UidBuffer[32];

    switch (ButtonAction)
    26b8:	85 30       	cpi	r24, 0x05	; 5
    26ba:	09 f4       	brne	.+2      	; 0x26be <ExecuteButtonAction+0x16>
    26bc:	ae c0       	rjmp	.+348    	; 0x281a <ExecuteButtonAction+0x172>
    26be:	78 f4       	brcc	.+30     	; 0x26de <ExecuteButtonAction+0x36>
    26c0:	82 30       	cpi	r24, 0x02	; 2
    26c2:	81 f1       	breq	.+96     	; 0x2724 <ExecuteButtonAction+0x7c>
    26c4:	28 f4       	brcc	.+10     	; 0x26d0 <ExecuteButtonAction+0x28>
    26c6:	81 30       	cpi	r24, 0x01	; 1
    26c8:	09 f0       	breq	.+2      	; 0x26cc <ExecuteButtonAction+0x24>
    26ca:	ee c0       	rjmp	.+476    	; 0x28a8 <ExecuteButtonAction+0x200>
    26cc:	10 e0       	ldi	r17, 0x00	; 0
    26ce:	1b c0       	rjmp	.+54     	; 0x2706 <ExecuteButtonAction+0x5e>
    26d0:	83 30       	cpi	r24, 0x03	; 3
    26d2:	09 f4       	brne	.+2      	; 0x26d6 <ExecuteButtonAction+0x2e>
    26d4:	53 c0       	rjmp	.+166    	; 0x277c <ExecuteButtonAction+0xd4>
    26d6:	84 30       	cpi	r24, 0x04	; 4
    26d8:	09 f4       	brne	.+2      	; 0x26dc <ExecuteButtonAction+0x34>
    26da:	75 c0       	rjmp	.+234    	; 0x27c6 <ExecuteButtonAction+0x11e>
    26dc:	e5 c0       	rjmp	.+458    	; 0x28a8 <ExecuteButtonAction+0x200>
    26de:	88 30       	cpi	r24, 0x08	; 8
    26e0:	09 f4       	brne	.+2      	; 0x26e4 <ExecuteButtonAction+0x3c>
    26e2:	d3 c0       	rjmp	.+422    	; 0x288a <ExecuteButtonAction+0x1e2>
    26e4:	40 f4       	brcc	.+16     	; 0x26f6 <ExecuteButtonAction+0x4e>
    26e6:	86 30       	cpi	r24, 0x06	; 6
    26e8:	09 f4       	brne	.+2      	; 0x26ec <ExecuteButtonAction+0x44>
    26ea:	cd c0       	rjmp	.+410    	; 0x2886 <ExecuteButtonAction+0x1de>
    26ec:	87 30       	cpi	r24, 0x07	; 7
    26ee:	09 f0       	breq	.+2      	; 0x26f2 <ExecuteButtonAction+0x4a>
    26f0:	db c0       	rjmp	.+438    	; 0x28a8 <ExecuteButtonAction+0x200>
        break;
    }

    case BUTTON_ACTION_STORE_MEM:
    {
    	MemoryStore();
    26f2:	88 dd       	rcall	.-1264   	; 0x2204 <MemoryStore>
        break;
    26f4:	d9 c0       	rjmp	.+434    	; 0x28a8 <ExecuteButtonAction+0x200>

static void ExecuteButtonAction(ButtonActionEnum ButtonAction)
{
    uint8_t UidBuffer[32];

    switch (ButtonAction)
    26f6:	89 30       	cpi	r24, 0x09	; 9
    26f8:	09 f4       	brne	.+2      	; 0x26fc <ExecuteButtonAction+0x54>
    26fa:	c9 c0       	rjmp	.+402    	; 0x288e <ExecuteButtonAction+0x1e6>
    26fc:	8a 30       	cpi	r24, 0x0A	; 10
    26fe:	09 f0       	breq	.+2      	; 0x2702 <ExecuteButtonAction+0x5a>
    2700:	d3 c0       	rjmp	.+422    	; 0x28a8 <ExecuteButtonAction+0x200>
    	break;
    }

    case BUTTON_ACTION_STORE_LOG:
    {
    	LogSRAMToFRAM();
    2702:	80 d3       	rcall	.+1792   	; 0x2e04 <LogSRAMToFRAM>
    	break;
    2704:	d1 c0       	rjmp	.+418    	; 0x28a8 <ExecuteButtonAction+0x200>

    switch (ButtonAction)
    {
    case BUTTON_ACTION_UID_RANDOM:
    {
        for (uint8_t i=0; i<ActiveConfiguration.UidSize; i++) {
    2706:	80 91 6c 2f 	lds	r24, 0x2F6C
    270a:	18 17       	cp	r17, r24
    270c:	08 f0       	brcs	.+2      	; 0x2710 <ExecuteButtonAction+0x68>
    270e:	a8 c0       	rjmp	.+336    	; 0x2860 <ExecuteButtonAction+0x1b8>
            UidBuffer[i] = RandomGetByte();
    2710:	53 db       	rcall	.-2394   	; 0x1db8 <RandomGetByte>
    2712:	e1 e0       	ldi	r30, 0x01	; 1
    2714:	f0 e0       	ldi	r31, 0x00	; 0
    2716:	ec 0f       	add	r30, r28
    2718:	fd 1f       	adc	r31, r29
    271a:	e1 0f       	add	r30, r17
    271c:	f1 1d       	adc	r31, r1
    271e:	80 83       	st	Z, r24

    switch (ButtonAction)
    {
    case BUTTON_ACTION_UID_RANDOM:
    {
        for (uint8_t i=0; i<ActiveConfiguration.UidSize; i++) {
    2720:	1f 5f       	subi	r17, 0xFF	; 255
    2722:	f1 cf       	rjmp	.-30     	; 0x2706 <ExecuteButtonAction+0x5e>

    case BUTTON_ACTION_UID_LEFT_INCREMENT:
    {
        uint8_t offset = 0;
#ifdef SUPPORT_UID7_FIX_MANUFACTURER_BYTE
        if (ActiveConfiguration.UidSize == 7) {
    2724:	11 e0       	ldi	r17, 0x01	; 1
    2726:	80 91 6c 2f 	lds	r24, 0x2F6C
    272a:	87 30       	cpi	r24, 0x07	; 7
    272c:	09 f0       	breq	.+2      	; 0x2730 <ExecuteButtonAction+0x88>
    272e:	10 e0       	ldi	r17, 0x00	; 0
    ActiveConfiguration.ApplicationResetFunc();
    //LogEntry(LOG_INFO_RESET_APP, NULL, 0);
}

INLINE void ApplicationGetUid(ConfigurationUidType Uid) {
    ActiveConfiguration.ApplicationGetUidFunc(Uid);
    2730:	e0 91 66 2f 	lds	r30, 0x2F66
    2734:	f0 91 67 2f 	lds	r31, 0x2F67
    2738:	ce 01       	movw	r24, r28
    273a:	01 96       	adiw	r24, 0x01	; 1
    273c:	19 95       	eicall
#endif
        ApplicationGetUid(UidBuffer);
        bool Carry = 1;
        uint8_t i;

        for (i=offset; i<ActiveConfiguration.UidSize; i++) {
    273e:	40 91 6c 2f 	lds	r20, 0x2F6C
        if (ActiveConfiguration.UidSize == 7) {
            offset = 1;
        }
#endif
        ApplicationGetUid(UidBuffer);
        bool Carry = 1;
    2742:	31 e0       	ldi	r19, 0x01	; 1
        uint8_t i;

        for (i=offset; i<ActiveConfiguration.UidSize; i++) {
    2744:	14 17       	cp	r17, r20
    2746:	08 f0       	brcs	.+2      	; 0x274a <ExecuteButtonAction+0xa2>
    2748:	8b c0       	rjmp	.+278    	; 0x2860 <ExecuteButtonAction+0x1b8>
            if (Carry) {
    274a:	33 23       	and	r19, r19
    274c:	a9 f0       	breq	.+42     	; 0x2778 <ExecuteButtonAction+0xd0>
                if (UidBuffer[i] == 0xFF) {
    274e:	81 2f       	mov	r24, r17
    2750:	90 e0       	ldi	r25, 0x00	; 0
    2752:	e1 e0       	ldi	r30, 0x01	; 1
    2754:	f0 e0       	ldi	r31, 0x00	; 0
    2756:	ec 0f       	add	r30, r28
    2758:	fd 1f       	adc	r31, r29
    275a:	e8 0f       	add	r30, r24
    275c:	f9 1f       	adc	r31, r25
    275e:	20 81       	ld	r18, Z
    2760:	31 e0       	ldi	r19, 0x01	; 1
    2762:	2f 3f       	cpi	r18, 0xFF	; 255
    2764:	09 f0       	breq	.+2      	; 0x2768 <ExecuteButtonAction+0xc0>
    2766:	30 e0       	ldi	r19, 0x00	; 0
                    Carry = 1;
                } else {
                    Carry = 0;
                }

                UidBuffer[i] = (UidBuffer[i] + 1) & 0xFF;
    2768:	e1 e0       	ldi	r30, 0x01	; 1
    276a:	f0 e0       	ldi	r31, 0x00	; 0
    276c:	ec 0f       	add	r30, r28
    276e:	fd 1f       	adc	r31, r29
    2770:	e8 0f       	add	r30, r24
    2772:	f9 1f       	adc	r31, r25
    2774:	2f 5f       	subi	r18, 0xFF	; 255
    2776:	20 83       	st	Z, r18
#endif
        ApplicationGetUid(UidBuffer);
        bool Carry = 1;
        uint8_t i;

        for (i=offset; i<ActiveConfiguration.UidSize; i++) {
    2778:	1f 5f       	subi	r17, 0xFF	; 255
    277a:	e4 cf       	rjmp	.-56     	; 0x2744 <ExecuteButtonAction+0x9c>
    277c:	e0 91 66 2f 	lds	r30, 0x2F66
    2780:	f0 91 67 2f 	lds	r31, 0x2F67
    2784:	ce 01       	movw	r24, r28
    2786:	01 96       	adiw	r24, 0x01	; 1
    2788:	19 95       	eicall

    case BUTTON_ACTION_UID_RIGHT_INCREMENT:
    {
        ApplicationGetUid(UidBuffer);
        bool Carry = 1;
        uint8_t i = ActiveConfiguration.UidSize;
    278a:	80 91 6c 2f 	lds	r24, 0x2F6C
    }

    case BUTTON_ACTION_UID_RIGHT_INCREMENT:
    {
        ApplicationGetUid(UidBuffer);
        bool Carry = 1;
    278e:	41 e0       	ldi	r20, 0x01	; 1
        uint8_t i = ActiveConfiguration.UidSize;

        while(i-- > 0) {
    2790:	81 50       	subi	r24, 0x01	; 1
    2792:	08 f4       	brcc	.+2      	; 0x2796 <ExecuteButtonAction+0xee>
    2794:	65 c0       	rjmp	.+202    	; 0x2860 <ExecuteButtonAction+0x1b8>
            if (Carry) {
    2796:	44 23       	and	r20, r20
    2798:	d9 f3       	breq	.-10     	; 0x2790 <ExecuteButtonAction+0xe8>
                if (UidBuffer[i] == 0xFF) {
    279a:	28 2f       	mov	r18, r24
    279c:	30 e0       	ldi	r19, 0x00	; 0
    279e:	e1 e0       	ldi	r30, 0x01	; 1
    27a0:	f0 e0       	ldi	r31, 0x00	; 0
    27a2:	ec 0f       	add	r30, r28
    27a4:	fd 1f       	adc	r31, r29
    27a6:	e2 0f       	add	r30, r18
    27a8:	f3 1f       	adc	r31, r19
    27aa:	90 81       	ld	r25, Z
    27ac:	41 e0       	ldi	r20, 0x01	; 1
    27ae:	9f 3f       	cpi	r25, 0xFF	; 255
    27b0:	09 f0       	breq	.+2      	; 0x27b4 <ExecuteButtonAction+0x10c>
    27b2:	40 e0       	ldi	r20, 0x00	; 0
                    Carry = 1;
                } else {
                    Carry = 0;
                }

                UidBuffer[i] = (UidBuffer[i] + 1) & 0xFF;
    27b4:	e1 e0       	ldi	r30, 0x01	; 1
    27b6:	f0 e0       	ldi	r31, 0x00	; 0
    27b8:	ec 0f       	add	r30, r28
    27ba:	fd 1f       	adc	r31, r29
    27bc:	e2 0f       	add	r30, r18
    27be:	f3 1f       	adc	r31, r19
    27c0:	9f 5f       	subi	r25, 0xFF	; 255
    27c2:	90 83       	st	Z, r25
    27c4:	e5 cf       	rjmp	.-54     	; 0x2790 <ExecuteButtonAction+0xe8>

    case BUTTON_ACTION_UID_LEFT_DECREMENT:
    {
        uint8_t offset = 0;
#ifdef SUPPORT_UID7_FIX_MANUFACTURER_BYTE
        if (ActiveConfiguration.UidSize == 7) {
    27c6:	11 e0       	ldi	r17, 0x01	; 1
    27c8:	80 91 6c 2f 	lds	r24, 0x2F6C
    27cc:	87 30       	cpi	r24, 0x07	; 7
    27ce:	09 f0       	breq	.+2      	; 0x27d2 <ExecuteButtonAction+0x12a>
    27d0:	10 e0       	ldi	r17, 0x00	; 0
    27d2:	e0 91 66 2f 	lds	r30, 0x2F66
    27d6:	f0 91 67 2f 	lds	r31, 0x2F67
    27da:	ce 01       	movw	r24, r28
    27dc:	01 96       	adiw	r24, 0x01	; 1
    27de:	19 95       	eicall
#endif
        ApplicationGetUid(UidBuffer);
        bool Carry = 1;
        uint8_t i;

        for (i=offset; i<ActiveConfiguration.UidSize; i++) {
    27e0:	40 91 6c 2f 	lds	r20, 0x2F6C
        if (ActiveConfiguration.UidSize == 7) {
            offset = 1;
        }
#endif
        ApplicationGetUid(UidBuffer);
        bool Carry = 1;
    27e4:	31 e0       	ldi	r19, 0x01	; 1
        uint8_t i;

        for (i=offset; i<ActiveConfiguration.UidSize; i++) {
    27e6:	14 17       	cp	r17, r20
    27e8:	d8 f5       	brcc	.+118    	; 0x2860 <ExecuteButtonAction+0x1b8>
            if (Carry) {
    27ea:	33 23       	and	r19, r19
    27ec:	a1 f0       	breq	.+40     	; 0x2816 <ExecuteButtonAction+0x16e>
                if (UidBuffer[i] == 0x00) {
    27ee:	81 2f       	mov	r24, r17
    27f0:	90 e0       	ldi	r25, 0x00	; 0
    27f2:	e1 e0       	ldi	r30, 0x01	; 1
    27f4:	f0 e0       	ldi	r31, 0x00	; 0
    27f6:	ec 0f       	add	r30, r28
    27f8:	fd 1f       	adc	r31, r29
    27fa:	e8 0f       	add	r30, r24
    27fc:	f9 1f       	adc	r31, r25
    27fe:	20 81       	ld	r18, Z
    2800:	31 e0       	ldi	r19, 0x01	; 1
    2802:	21 11       	cpse	r18, r1
    2804:	30 e0       	ldi	r19, 0x00	; 0
                    Carry = 1;
                } else {
                    Carry = 0;
                }

                UidBuffer[i] = (UidBuffer[i] - 1) & 0xFF;
    2806:	e1 e0       	ldi	r30, 0x01	; 1
    2808:	f0 e0       	ldi	r31, 0x00	; 0
    280a:	ec 0f       	add	r30, r28
    280c:	fd 1f       	adc	r31, r29
    280e:	e8 0f       	add	r30, r24
    2810:	f9 1f       	adc	r31, r25
    2812:	21 50       	subi	r18, 0x01	; 1
    2814:	20 83       	st	Z, r18
#endif
        ApplicationGetUid(UidBuffer);
        bool Carry = 1;
        uint8_t i;

        for (i=offset; i<ActiveConfiguration.UidSize; i++) {
    2816:	1f 5f       	subi	r17, 0xFF	; 255
    2818:	e6 cf       	rjmp	.-52     	; 0x27e6 <ExecuteButtonAction+0x13e>
    281a:	e0 91 66 2f 	lds	r30, 0x2F66
    281e:	f0 91 67 2f 	lds	r31, 0x2F67
    2822:	ce 01       	movw	r24, r28
    2824:	01 96       	adiw	r24, 0x01	; 1
    2826:	19 95       	eicall

    case BUTTON_ACTION_UID_RIGHT_DECREMENT:
    {
        ApplicationGetUid(UidBuffer);
        bool Carry = 1;
        uint8_t i = ActiveConfiguration.UidSize;
    2828:	80 91 6c 2f 	lds	r24, 0x2F6C
    }

    case BUTTON_ACTION_UID_RIGHT_DECREMENT:
    {
        ApplicationGetUid(UidBuffer);
        bool Carry = 1;
    282c:	41 e0       	ldi	r20, 0x01	; 1
        uint8_t i = ActiveConfiguration.UidSize;

        while(i-- > 0) {
    282e:	81 50       	subi	r24, 0x01	; 1
    2830:	b8 f0       	brcs	.+46     	; 0x2860 <ExecuteButtonAction+0x1b8>
            if (Carry) {
    2832:	44 23       	and	r20, r20
    2834:	e1 f3       	breq	.-8      	; 0x282e <ExecuteButtonAction+0x186>
                if (UidBuffer[i] == 0x00) {
    2836:	28 2f       	mov	r18, r24
    2838:	30 e0       	ldi	r19, 0x00	; 0
    283a:	e1 e0       	ldi	r30, 0x01	; 1
    283c:	f0 e0       	ldi	r31, 0x00	; 0
    283e:	ec 0f       	add	r30, r28
    2840:	fd 1f       	adc	r31, r29
    2842:	e2 0f       	add	r30, r18
    2844:	f3 1f       	adc	r31, r19
    2846:	90 81       	ld	r25, Z
    2848:	41 e0       	ldi	r20, 0x01	; 1
    284a:	91 11       	cpse	r25, r1
    284c:	40 e0       	ldi	r20, 0x00	; 0
                    Carry = 1;
                } else {
                    Carry = 0;
                }

                UidBuffer[i] = (UidBuffer[i] - 1) & 0xFF;
    284e:	e1 e0       	ldi	r30, 0x01	; 1
    2850:	f0 e0       	ldi	r31, 0x00	; 0
    2852:	ec 0f       	add	r30, r28
    2854:	fd 1f       	adc	r31, r29
    2856:	e2 0f       	add	r30, r18
    2858:	f3 1f       	adc	r31, r19
    285a:	91 50       	subi	r25, 0x01	; 1
    285c:	90 83       	st	Z, r25
    285e:	e7 cf       	rjmp	.-50     	; 0x282e <ExecuteButtonAction+0x186>
}

INLINE void ApplicationSetUid(ConfigurationUidType Uid) {
    ActiveConfiguration.ApplicationSetUidFunc(Uid);
    2860:	e0 91 68 2f 	lds	r30, 0x2F68
    2864:	f0 91 69 2f 	lds	r31, 0x2F69
    2868:	ce 01       	movw	r24, r28
    286a:	01 96       	adiw	r24, 0x01	; 1
    286c:	19 95       	eicall
    286e:	e0 91 6e 2f 	lds	r30, 0x2F6E
    2872:	f0 91 6f 2f 	lds	r31, 0x2F6F
    2876:	40 91 6c 2f 	lds	r20, 0x2F6C
    287a:	be 01       	movw	r22, r28
    287c:	6f 5f       	subi	r22, 0xFF	; 255
    287e:	7f 4f       	sbci	r23, 0xFF	; 255
    2880:	83 e1       	ldi	r24, 0x13	; 19
    2882:	19 95       	eicall
    2884:	11 c0       	rjmp	.+34     	; 0x28a8 <ExecuteButtonAction+0x200>
        break;
    }

    case BUTTON_ACTION_CYCLE_SETTINGS:
    {
    	SettingsCycle();
    2886:	9a d3       	rcall	.+1844   	; 0x2fbc <SettingsCycle>
        break;
    2888:	0f c0       	rjmp	.+30     	; 0x28a8 <ExecuteButtonAction+0x200>
        break;
    }

    case BUTTON_ACTION_RECALL_MEM:
    {
    	MemoryRecall();
    288a:	17 dc       	rcall	.-2002   	; 0x20ba <MemoryRecall>
        break;
    288c:	0d c0       	rjmp	.+26     	; 0x28a8 <ExecuteButtonAction+0x200>
    }
}

// Get the status of the reader field
INLINE bool CodecGetReaderField(void) {
    return (CODEC_READER_TIMER.CTRLA == TC_CLKSEL_DIV1_gc) && (AWEXC.OUTOVEN == CODEC_READER_MASK);
    288e:	80 91 00 08 	lds	r24, 0x0800
    2892:	81 30       	cpi	r24, 0x01	; 1
    2894:	21 f4       	brne	.+8      	; 0x289e <ExecuteButtonAction+0x1f6>
    2896:	80 91 8c 08 	lds	r24, 0x088C
    289a:	83 30       	cpi	r24, 0x03	; 3
    289c:	19 f0       	breq	.+6      	; 0x28a4 <ExecuteButtonAction+0x1fc>

    case BUTTON_ACTION_TOGGLE_FIELD:
    {
    	if (!CodecGetReaderField())
    	{
    		CodecReaderFieldStart();
    289e:	0e 94 bf 23 	call	0x477e	; 0x477e <CodecReaderFieldStart>
    28a2:	02 c0       	rjmp	.+4      	; 0x28a8 <ExecuteButtonAction+0x200>
    	} else {
    		CodecReaderFieldStop();
    28a4:	0e 94 e4 23 	call	0x47c8	; 0x47c8 <CodecReaderFieldStop>

    default:
    	break;

    }
}
    28a8:	a0 96       	adiw	r28, 0x20	; 32
    28aa:	cd bf       	out	0x3d, r28	; 61
    28ac:	de bf       	out	0x3e, r29	; 62
    28ae:	df 91       	pop	r29
    28b0:	cf 91       	pop	r28
    28b2:	1f 91       	pop	r17
    28b4:	08 95       	ret

000028b6 <ButtonInit>:

void ButtonInit(void)
{
	BUTTON_PORT.DIRCLR = BUTTON_MASK;
    28b6:	e0 e0       	ldi	r30, 0x00	; 0
    28b8:	f6 e0       	ldi	r31, 0x06	; 6
    28ba:	80 e6       	ldi	r24, 0x60	; 96
    28bc:	82 83       	std	Z+2, r24	; 0x02
	BUTTON_PORT.BUTTON_R_PINCTRL = PORT_OPC_PULLUP_gc;
    28be:	88 e1       	ldi	r24, 0x18	; 24
    28c0:	86 8b       	std	Z+22, r24	; 0x16
	BUTTON_PORT.BUTTON_L_PINCTRL = PORT_OPC_PULLUP_gc;
    28c2:	85 8b       	std	Z+21, r24	; 0x15
    28c4:	08 95       	ret

000028c6 <ButtonTick>:
}

void ButtonTick(void)
{
    28c6:	cf 93       	push	r28
    static uint8_t ButtonRPressTick = 0;
    static uint8_t ButtonLPressTick = 0;
    uint8_t ThisButtonState = ~BUTTON_PORT.IN;
    28c8:	c0 91 08 06 	lds	r28, 0x0608
    28cc:	c0 95       	com	r28

    if (ThisButtonState & BUTTON_R) {
    28ce:	c6 ff       	sbrs	r28, 6
    28d0:	12 c0       	rjmp	.+36     	; 0x28f6 <ButtonTick+0x30>
    	/* Button is currently pressed */
    	if (ButtonRPressTick < LONG_PRESS_TICK_COUNT) {
    28d2:	80 91 76 24 	lds	r24, 0x2476
    28d6:	8a 30       	cpi	r24, 0x0A	; 10
    28d8:	50 f0       	brcs	.+20     	; 0x28ee <ButtonTick+0x28>
    		/* Count ticks while button is being pressed */
    		ButtonRPressTick++;
    	} else if (ButtonRPressTick == LONG_PRESS_TICK_COUNT) {
    28da:	8a 30       	cpi	r24, 0x0A	; 10
    28dc:	e1 f4       	brne	.+56     	; 0x2916 <ButtonTick+0x50>
    		/* Long button press detected execute button action and advance PressTickCounter
    		 * to an invalid state. */
    		ExecuteButtonAction(GlobalSettings.ActiveSettingPtr->ButtonActions[BUTTON_R_PRESS_LONG]);
    28de:	e0 91 71 2f 	lds	r30, 0x2F71
    28e2:	f0 91 72 2f 	lds	r31, 0x2F72
    28e6:	81 81       	ldd	r24, Z+1	; 0x01
    28e8:	df de       	rcall	.-578    	; 0x26a8 <ExecuteButtonAction>
    		ButtonRPressTick++;
    28ea:	80 91 76 24 	lds	r24, 0x2476
    28ee:	8f 5f       	subi	r24, 0xFF	; 255
    28f0:	80 93 76 24 	sts	0x2476, r24
    28f4:	10 c0       	rjmp	.+32     	; 0x2916 <ButtonTick+0x50>
    	} else {
    		/* Button is still pressed, ignore */
    	}
    } else if (!(ThisButtonState & BUTTON_MASK)) {
    28f6:	8c 2f       	mov	r24, r28
    28f8:	80 76       	andi	r24, 0x60	; 96
    28fa:	69 f4       	brne	.+26     	; 0x2916 <ButtonTick+0x50>
    	/* Button is currently not being pressed. Check if PressTickCounter contains
    	 * a recent short button press. */
    	if ( (ButtonRPressTick > 0) && (ButtonRPressTick <= LONG_PRESS_TICK_COUNT) ) {
    28fc:	80 91 76 24 	lds	r24, 0x2476
    2900:	81 50       	subi	r24, 0x01	; 1
    2902:	8a 30       	cpi	r24, 0x0A	; 10
    2904:	30 f4       	brcc	.+12     	; 0x2912 <ButtonTick+0x4c>
    		/* We have a short button press */
    		ExecuteButtonAction(GlobalSettings.ActiveSettingPtr->ButtonActions[BUTTON_R_PRESS_SHORT]);
    2906:	e0 91 71 2f 	lds	r30, 0x2F71
    290a:	f0 91 72 2f 	lds	r31, 0x2F72
    290e:	80 81       	ld	r24, Z
    2910:	cb de       	rcall	.-618    	; 0x26a8 <ExecuteButtonAction>
    	}

    	ButtonRPressTick = 0;
    2912:	10 92 76 24 	sts	0x2476, r1
    }

    if (ThisButtonState & BUTTON_L) {
    2916:	c5 ff       	sbrs	r28, 5
    2918:	12 c0       	rjmp	.+36     	; 0x293e <ButtonTick+0x78>
    	/* Button is currently pressed */
    	if (ButtonLPressTick < LONG_PRESS_TICK_COUNT) {
    291a:	80 91 75 24 	lds	r24, 0x2475
    291e:	8a 30       	cpi	r24, 0x0A	; 10
    2920:	50 f0       	brcs	.+20     	; 0x2936 <ButtonTick+0x70>
    		/* Count ticks while button is being pressed */
    		ButtonLPressTick++;
    	} else if (ButtonLPressTick == LONG_PRESS_TICK_COUNT) {
    2922:	8a 30       	cpi	r24, 0x0A	; 10
    2924:	d9 f4       	brne	.+54     	; 0x295c <ButtonTick+0x96>
    		/* Long button press detected execute button action and advance PressTickCounter
    		 * to an invalid state. */
    		ExecuteButtonAction(GlobalSettings.ActiveSettingPtr->ButtonActions[BUTTON_L_PRESS_LONG]);
    2926:	e0 91 71 2f 	lds	r30, 0x2F71
    292a:	f0 91 72 2f 	lds	r31, 0x2F72
    292e:	83 81       	ldd	r24, Z+3	; 0x03
    2930:	bb de       	rcall	.-650    	; 0x26a8 <ExecuteButtonAction>
    		ButtonLPressTick++;
    2932:	80 91 75 24 	lds	r24, 0x2475
    2936:	8f 5f       	subi	r24, 0xFF	; 255
    2938:	80 93 75 24 	sts	0x2475, r24
    293c:	0f c0       	rjmp	.+30     	; 0x295c <ButtonTick+0x96>
    	} else {
    		/* Button is still pressed, ignore */
    	}
    } else if (!(ThisButtonState & BUTTON_MASK)) {
    293e:	c0 76       	andi	r28, 0x60	; 96
    2940:	69 f4       	brne	.+26     	; 0x295c <ButtonTick+0x96>
    	/* Button is currently not being pressed. Check if PressTickCounter contains
    	 * a recent short button press. */
    	if ( (ButtonLPressTick > 0) && (ButtonLPressTick <= LONG_PRESS_TICK_COUNT) ) {
    2942:	80 91 75 24 	lds	r24, 0x2475
    2946:	81 50       	subi	r24, 0x01	; 1
    2948:	8a 30       	cpi	r24, 0x0A	; 10
    294a:	30 f4       	brcc	.+12     	; 0x2958 <ButtonTick+0x92>
    		/* We have a short button press */
    		ExecuteButtonAction(GlobalSettings.ActiveSettingPtr->ButtonActions[BUTTON_L_PRESS_SHORT]);
    294c:	e0 91 71 2f 	lds	r30, 0x2F71
    2950:	f0 91 72 2f 	lds	r31, 0x2F72
    2954:	82 81       	ldd	r24, Z+2	; 0x02
    2956:	a8 de       	rcall	.-688    	; 0x26a8 <ExecuteButtonAction>
    	}

    	ButtonLPressTick = 0;
    2958:	10 92 75 24 	sts	0x2475, r1
    }
}
    295c:	cf 91       	pop	r28
    295e:	08 95       	ret

00002960 <ButtonGetActionList>:

void ButtonGetActionList(char* List, uint16_t BufferSize)
{
    2960:	9b 01       	movw	r18, r22
	MapToString(ButtonActionMap, ARRAY_COUNT(ButtonActionMap), List, BufferSize);
    2962:	ac 01       	movw	r20, r24
    2964:	6b e0       	ldi	r22, 0x0B	; 11
    2966:	8a eb       	ldi	r24, 0xBA	; 186
    2968:	97 e0       	ldi	r25, 0x07	; 7
    296a:	82 c4       	rjmp	.+2308   	; 0x3270 <MapToString>

0000296c <ButtonSetActionById>:
}

void ButtonSetActionById(ButtonTypeEnum Type, ButtonActionEnum Action)
{
    296c:	20 e0       	ldi	r18, 0x00	; 0
    296e:	30 e0       	ldi	r19, 0x00	; 0
    2970:	90 e0       	ldi	r25, 0x00	; 0
    2972:	f9 01       	movw	r30, r18
    2974:	e8 0f       	add	r30, r24
    2976:	f9 1f       	adc	r31, r25
    2978:	e0 59       	subi	r30, 0x90	; 144
    297a:	f0 4d       	sbci	r31, 0xD0	; 208
#ifndef BUTTON_SETTING_GLOBAL
	GlobalSettings.ActiveSettingPtr->ButtonActions[Type] = Action;
#else
	/* Write button action to all settings when using global settings */
	for (uint8_t i=0; i<SETTINGS_COUNT; i++) {
		GlobalSettings.Settings[i].ButtonActions[Type] = Action;
    297c:	63 83       	std	Z+3, r22	; 0x03
    297e:	24 5f       	subi	r18, 0xF4	; 244
    2980:	3f 4f       	sbci	r19, 0xFF	; 255
{
#ifndef BUTTON_SETTING_GLOBAL
	GlobalSettings.ActiveSettingPtr->ButtonActions[Type] = Action;
#else
	/* Write button action to all settings when using global settings */
	for (uint8_t i=0; i<SETTINGS_COUNT; i++) {
    2982:	20 36       	cpi	r18, 0x60	; 96
    2984:	31 05       	cpc	r19, r1
    2986:	a9 f7       	brne	.-22     	; 0x2972 <ButtonSetActionById+0x6>
		GlobalSettings.Settings[i].ButtonActions[Type] = Action;
	}
#endif
}
    2988:	08 95       	ret

0000298a <ButtonGetActionByName>:

void ButtonGetActionByName(ButtonTypeEnum Type, char* Action, uint16_t BufferSize)
{
    298a:	0f 93       	push	r16
    298c:	1f 93       	push	r17
    298e:	9b 01       	movw	r18, r22
	MapIdToText(ButtonActionMap, ARRAY_COUNT(ButtonActionMap),
			GlobalSettings.ActiveSettingPtr->ButtonActions[Type], Action, BufferSize);
    2990:	e0 91 71 2f 	lds	r30, 0x2F71
    2994:	f0 91 72 2f 	lds	r31, 0x2F72
    2998:	e8 0f       	add	r30, r24
    299a:	f1 1d       	adc	r31, r1
#endif
}

void ButtonGetActionByName(ButtonTypeEnum Type, char* Action, uint16_t BufferSize)
{
	MapIdToText(ButtonActionMap, ARRAY_COUNT(ButtonActionMap),
    299c:	8a 01       	movw	r16, r20
    299e:	40 81       	ld	r20, Z
    29a0:	6b e0       	ldi	r22, 0x0B	; 11
    29a2:	8a eb       	ldi	r24, 0xBA	; 186
    29a4:	97 e0       	ldi	r25, 0x07	; 7
    29a6:	25 d4       	rcall	.+2122   	; 0x31f2 <MapIdToText>
			GlobalSettings.ActiveSettingPtr->ButtonActions[Type], Action, BufferSize);
}
    29a8:	1f 91       	pop	r17
    29aa:	0f 91       	pop	r16
    29ac:	08 95       	ret

000029ae <ButtonSetActionByName>:

bool ButtonSetActionByName(ButtonTypeEnum Type, const char* Action)
{
    29ae:	0f 93       	push	r16
    29b0:	1f 93       	push	r17
    29b2:	cf 93       	push	r28
    29b4:	df 93       	push	r29
    29b6:	1f 92       	push	r1
    29b8:	cd b7       	in	r28, 0x3d	; 61
    29ba:	de b7       	in	r29, 0x3e	; 62
    29bc:	08 2f       	mov	r16, r24
    29be:	ab 01       	movw	r20, r22
	MapIdType Id;

	if (MapTextToId(ButtonActionMap, ARRAY_COUNT(ButtonActionMap), Action, &Id)) {
    29c0:	9e 01       	movw	r18, r28
    29c2:	2f 5f       	subi	r18, 0xFF	; 255
    29c4:	3f 4f       	sbci	r19, 0xFF	; 255
    29c6:	6b e0       	ldi	r22, 0x0B	; 11
    29c8:	8a eb       	ldi	r24, 0xBA	; 186
    29ca:	97 e0       	ldi	r25, 0x07	; 7
    29cc:	2a d4       	rcall	.+2132   	; 0x3222 <MapTextToId>
    29ce:	18 2f       	mov	r17, r24
    29d0:	88 23       	and	r24, r24
    29d2:	19 f0       	breq	.+6      	; 0x29da <ButtonSetActionByName+0x2c>
		ButtonSetActionById(Type, Id);
    29d4:	69 81       	ldd	r22, Y+1	; 0x01
    29d6:	80 2f       	mov	r24, r16
    29d8:	c9 df       	rcall	.-110    	; 0x296c <ButtonSetActionById>
		return true;
	} else {
		return false;
	}
}
    29da:	81 2f       	mov	r24, r17
    29dc:	0f 90       	pop	r0
    29de:	df 91       	pop	r29
    29e0:	cf 91       	pop	r28
    29e2:	1f 91       	pop	r17
    29e4:	0f 91       	pop	r16
    29e6:	08 95       	ret

000029e8 <LogFuncOff>:
    { .Id = LOG_MODE_MEMORY, 	.Text = "MEMORY" 	},
    { .Id = LOG_MODE_LIVE, 	.Text = "LIVE" 	}
};

static void LogFuncOff(LogEntryEnum Entry, const void* Data, uint8_t Length)
{
    29e8:	08 95       	ret

000029ea <LogFuncLive>:
        LEDHook(LED_LOG_MEM_FULL, LED_ON);
    }
}

static void LogFuncLive(LogEntryEnum Entry, const void* Data, uint8_t Length)
{
    29ea:	ef 92       	push	r14
    29ec:	ff 92       	push	r15
    29ee:	0f 93       	push	r16
    29f0:	1f 93       	push	r17
    29f2:	cf 93       	push	r28
    29f4:	7b 01       	movw	r14, r22
    29f6:	c4 2f       	mov	r28, r20
}

INLINE uint16_t SystemGetSysTick(void) {
    return SYSTEM_TICK_REGISTER | RTC.CNT;
    29f8:	2e b1       	in	r18, 0x0e	; 14
    29fa:	3f b1       	in	r19, 0x0f	; 15
    29fc:	00 91 08 04 	lds	r16, 0x0408
    2a00:	10 91 09 04 	lds	r17, 0x0409
    2a04:	02 2b       	or	r16, r18
    2a06:	13 2b       	or	r17, r19
void EVENT_USB_Device_Disconnect(void);
void EVENT_USB_Device_ConfigurationChanged(void);
void EVENT_USB_Device_ControlRequest(void);

INLINE void TerminalSendChar(char c) { CDC_Device_SendByte(&TerminalHandle, c); }
INLINE void TerminalSendByte(uint8_t Byte) { CDC_Device_SendByte(&TerminalHandle, Byte); }
    2a08:	68 2f       	mov	r22, r24
    2a0a:	83 e0       	ldi	r24, 0x03	; 3
    2a0c:	90 e2       	ldi	r25, 0x20	; 32
    2a0e:	0e 94 bf 63 	call	0xc77e	; 0xc77e <CDC_Device_SendByte>
    2a12:	6c 2f       	mov	r22, r28
    2a14:	83 e0       	ldi	r24, 0x03	; 3
    2a16:	90 e2       	ldi	r25, 0x20	; 32
    2a18:	0e 94 bf 63 	call	0xc77e	; 0xc77e <CDC_Device_SendByte>
    2a1c:	61 2f       	mov	r22, r17
    2a1e:	83 e0       	ldi	r24, 0x03	; 3
    2a20:	90 e2       	ldi	r25, 0x20	; 32
    2a22:	0e 94 bf 63 	call	0xc77e	; 0xc77e <CDC_Device_SendByte>
    2a26:	60 2f       	mov	r22, r16
    2a28:	83 e0       	ldi	r24, 0x03	; 3
    2a2a:	90 e2       	ldi	r25, 0x20	; 32
    2a2c:	0e 94 bf 63 	call	0xc77e	; 0xc77e <CDC_Device_SendByte>

    TerminalSendByte((uint8_t) Entry);
    TerminalSendByte((uint8_t) Length);
    TerminalSendByte((uint8_t) (SysTick >> 8));
    TerminalSendByte((uint8_t) (SysTick >> 0));
    TerminalSendBlock(Data, Length);
    2a30:	6c 2f       	mov	r22, r28
    2a32:	70 e0       	ldi	r23, 0x00	; 0
    2a34:	c7 01       	movw	r24, r14
}
    2a36:	cf 91       	pop	r28
    2a38:	1f 91       	pop	r17
    2a3a:	0f 91       	pop	r16
    2a3c:	ff 90       	pop	r15
    2a3e:	ef 90       	pop	r14

    TerminalSendByte((uint8_t) Entry);
    TerminalSendByte((uint8_t) Length);
    TerminalSendByte((uint8_t) (SysTick >> 8));
    TerminalSendByte((uint8_t) (SysTick >> 0));
    TerminalSendBlock(Data, Length);
    2a40:	98 c4       	rjmp	.+2352   	; 0x3372 <TerminalSendBlock>

00002a42 <LogTask>:
    if (EnableLogSRAMtoFRAM)
        LogSRAMToFRAM();
}

void LogTask(void)
{
    2a42:	08 95       	ret

00002a44 <LogMemLoadBlock>:

}

bool LogMemLoadBlock(void* Buffer, uint32_t BlockAddress, uint16_t ByteCount)
{
    2a44:	3f 92       	push	r3
    2a46:	4f 92       	push	r4
    2a48:	5f 92       	push	r5
    2a4a:	6f 92       	push	r6
    2a4c:	7f 92       	push	r7
    2a4e:	8f 92       	push	r8
    2a50:	9f 92       	push	r9
    2a52:	af 92       	push	r10
    2a54:	bf 92       	push	r11
    2a56:	cf 92       	push	r12
    2a58:	df 92       	push	r13
    2a5a:	ef 92       	push	r14
    2a5c:	ff 92       	push	r15
    2a5e:	0f 93       	push	r16
    2a60:	1f 93       	push	r17
    2a62:	cf 93       	push	r28
    2a64:	df 93       	push	r29
    2a66:	7c 01       	movw	r14, r24
    2a68:	e9 01       	movw	r28, r18
    if (BlockAddress < sizeof(LogMem) + (LogFRAMAddr - FRAM_LOG_START_ADDR))
    2a6a:	c0 90 00 20 	lds	r12, 0x2000
    2a6e:	d0 90 01 20 	lds	r13, 0x2001
    2a72:	96 01       	movw	r18, r12
    2a74:	22 50       	subi	r18, 0x02	; 2
    2a76:	38 43       	sbci	r19, 0x38	; 56
    2a78:	c9 01       	movw	r24, r18
    2a7a:	a0 e0       	ldi	r26, 0x00	; 0
    2a7c:	b0 e0       	ldi	r27, 0x00	; 0
    2a7e:	48 17       	cp	r20, r24
    2a80:	59 07       	cpc	r21, r25
    2a82:	6a 07       	cpc	r22, r26
    2a84:	7b 07       	cpc	r23, r27
    2a86:	08 f0       	brcs	.+2      	; 0x2a8a <LogMemLoadBlock+0x46>
    2a88:	5c c0       	rjmp	.+184    	; 0x2b42 <LogMemLoadBlock+0xfe>
    {
        bool overflow = false;
        uint16_t remainderByteCount = 0;
        uint16_t SizeInFRAMStored = LogFRAMAddr - FRAM_LOG_START_ADDR;
    2a8a:	e2 e0       	ldi	r30, 0x02	; 2
    2a8c:	ce 1a       	sub	r12, r30
    2a8e:	e0 e4       	ldi	r30, 0x40	; 64
    2a90:	de 0a       	sbc	r13, r30
        // prevent buffer overflows:
        if ((BlockAddress + ByteCount) >= sizeof(LogMem) + SizeInFRAMStored)
    2a92:	2a 01       	movw	r4, r20
    2a94:	3b 01       	movw	r6, r22
    2a96:	4c 0e       	add	r4, r28
    2a98:	5d 1e       	adc	r5, r29
    2a9a:	61 1c       	adc	r6, r1
    2a9c:	71 1c       	adc	r7, r1
    2a9e:	48 16       	cp	r4, r24
    2aa0:	59 06       	cpc	r5, r25
    2aa2:	6a 06       	cpc	r6, r26
    2aa4:	7b 06       	cpc	r7, r27
    2aa6:	48 f0       	brcs	.+18     	; 0x2aba <LogMemLoadBlock+0x76>
        {
            overflow = true;
            uint16_t tmp = sizeof(LogMem) + SizeInFRAMStored - BlockAddress;
    2aa8:	24 1b       	sub	r18, r20
    2aaa:	35 0b       	sbc	r19, r21
            remainderByteCount = ByteCount - tmp;
    2aac:	8e 01       	movw	r16, r28
    2aae:	02 1b       	sub	r16, r18
    2ab0:	13 0b       	sbc	r17, r19
            ByteCount = tmp;
    2ab2:	e9 01       	movw	r28, r18
        uint16_t remainderByteCount = 0;
        uint16_t SizeInFRAMStored = LogFRAMAddr - FRAM_LOG_START_ADDR;
        // prevent buffer overflows:
        if ((BlockAddress + ByteCount) >= sizeof(LogMem) + SizeInFRAMStored)
        {
            overflow = true;
    2ab4:	33 24       	eor	r3, r3
    2ab6:	33 94       	inc	r3
    2ab8:	03 c0       	rjmp	.+6      	; 0x2ac0 <LogMemLoadBlock+0x7c>
bool LogMemLoadBlock(void* Buffer, uint32_t BlockAddress, uint16_t ByteCount)
{
    if (BlockAddress < sizeof(LogMem) + (LogFRAMAddr - FRAM_LOG_START_ADDR))
    {
        bool overflow = false;
        uint16_t remainderByteCount = 0;
    2aba:	00 e0       	ldi	r16, 0x00	; 0
    2abc:	10 e0       	ldi	r17, 0x00	; 0

bool LogMemLoadBlock(void* Buffer, uint32_t BlockAddress, uint16_t ByteCount)
{
    if (BlockAddress < sizeof(LogMem) + (LogFRAMAddr - FRAM_LOG_START_ADDR))
    {
        bool overflow = false;
    2abe:	31 2c       	mov	r3, r1
        /*
         * 1. case: The whole block is in FRAM.
         * 2. case: The block wraps from FRAM to SRAM
         * 3. case: The whole block is in SRAM.
         */
        if (BlockAddress < SizeInFRAMStored && (BlockAddress + ByteCount) < SizeInFRAMStored)
    2ac0:	46 01       	movw	r8, r12
    2ac2:	a1 2c       	mov	r10, r1
    2ac4:	b1 2c       	mov	r11, r1
    2ac6:	48 15       	cp	r20, r8
    2ac8:	59 05       	cpc	r21, r9
    2aca:	6a 05       	cpc	r22, r10
    2acc:	7b 05       	cpc	r23, r11
    2ace:	10 f5       	brcc	.+68     	; 0x2b14 <LogMemLoadBlock+0xd0>
    2ad0:	ca 01       	movw	r24, r20
    2ad2:	8e 5f       	subi	r24, 0xFE	; 254
    2ad4:	9f 4b       	sbci	r25, 0xBF	; 191
    2ad6:	2a 01       	movw	r4, r20
    2ad8:	3b 01       	movw	r6, r22
    2ada:	4c 0e       	add	r4, r28
    2adc:	5d 1e       	adc	r5, r29
    2ade:	61 1c       	adc	r6, r1
    2ae0:	71 1c       	adc	r7, r1
    2ae2:	48 14       	cp	r4, r8
    2ae4:	59 04       	cpc	r5, r9
    2ae6:	6a 04       	cpc	r6, r10
    2ae8:	7b 04       	cpc	r7, r11
    2aea:	28 f4       	brcc	.+10     	; 0x2af6 <LogMemLoadBlock+0xb2>
        {
            MemoryReadBlock(Buffer, BlockAddress + FRAM_LOG_START_ADDR, ByteCount);
    2aec:	ae 01       	movw	r20, r28
    2aee:	bc 01       	movw	r22, r24
    2af0:	c7 01       	movw	r24, r14
    2af2:	27 da       	rcall	.-2994   	; 0x1f42 <MemoryReadBlock>
    2af4:	18 c0       	rjmp	.+48     	; 0x2b26 <LogMemLoadBlock+0xe2>
        } else if (BlockAddress < SizeInFRAMStored) {
            uint16_t FramByteCount = SizeInFRAMStored - BlockAddress;
    2af6:	c4 1a       	sub	r12, r20
    2af8:	d5 0a       	sbc	r13, r21
            MemoryReadBlock(Buffer, BlockAddress + FRAM_LOG_START_ADDR, FramByteCount);
    2afa:	a6 01       	movw	r20, r12
    2afc:	bc 01       	movw	r22, r24
    2afe:	c7 01       	movw	r24, r14
    2b00:	20 da       	rcall	.-3008   	; 0x1f42 <MemoryReadBlock>
            memcpy(Buffer + FramByteCount, LogMem, ByteCount - FramByteCount);
    2b02:	ae 01       	movw	r20, r28
    2b04:	4c 19       	sub	r20, r12
    2b06:	5d 09       	sbc	r21, r13
    2b08:	6c e7       	ldi	r22, 0x7C	; 124
    2b0a:	74 e2       	ldi	r23, 0x24	; 36
    2b0c:	c7 01       	movw	r24, r14
    2b0e:	8c 0d       	add	r24, r12
    2b10:	9d 1d       	adc	r25, r13
    2b12:	07 c0       	rjmp	.+14     	; 0x2b22 <LogMemLoadBlock+0xde>
        } else {
            memcpy(Buffer, LogMem + BlockAddress - SizeInFRAMStored, ByteCount);
    2b14:	4c 19       	sub	r20, r12
    2b16:	5d 09       	sbc	r21, r13
    2b18:	ba 01       	movw	r22, r20
    2b1a:	64 58       	subi	r22, 0x84	; 132
    2b1c:	7b 4d       	sbci	r23, 0xDB	; 219
    2b1e:	ae 01       	movw	r20, r28
    2b20:	c7 01       	movw	r24, r14
    2b22:	0e 94 e7 65 	call	0xcbce	; 0xcbce <memcpy>
        }

        if (overflow)
    2b26:	31 10       	cpse	r3, r1
    2b28:	02 c0       	rjmp	.+4      	; 0x2b2e <LogMemLoadBlock+0xea>
        {
            while (remainderByteCount--)
                ((uint8_t*) Buffer)[ByteCount + remainderByteCount] = 0x00;
        }

        return true;
    2b2a:	81 e0       	ldi	r24, 0x01	; 1
    2b2c:	0b c0       	rjmp	.+22     	; 0x2b44 <LogMemLoadBlock+0x100>
            memcpy(Buffer, LogMem + BlockAddress - SizeInFRAMStored, ByteCount);
        }

        if (overflow)
        {
            while (remainderByteCount--)
    2b2e:	01 50       	subi	r16, 0x01	; 1
    2b30:	11 09       	sbc	r17, r1
    2b32:	d8 f3       	brcs	.-10     	; 0x2b2a <LogMemLoadBlock+0xe6>
    2b34:	f8 01       	movw	r30, r16
    2b36:	ec 0f       	add	r30, r28
    2b38:	fd 1f       	adc	r31, r29
    2b3a:	ee 0d       	add	r30, r14
    2b3c:	ff 1d       	adc	r31, r15
                ((uint8_t*) Buffer)[ByteCount + remainderByteCount] = 0x00;
    2b3e:	10 82       	st	Z, r1
    2b40:	f6 cf       	rjmp	.-20     	; 0x2b2e <LogMemLoadBlock+0xea>
        }

        return true;
    } else {
        return false;
    2b42:	80 e0       	ldi	r24, 0x00	; 0
    }
}
    2b44:	df 91       	pop	r29
    2b46:	cf 91       	pop	r28
    2b48:	1f 91       	pop	r17
    2b4a:	0f 91       	pop	r16
    2b4c:	ff 90       	pop	r15
    2b4e:	ef 90       	pop	r14
    2b50:	df 90       	pop	r13
    2b52:	cf 90       	pop	r12
    2b54:	bf 90       	pop	r11
    2b56:	af 90       	pop	r10
    2b58:	9f 90       	pop	r9
    2b5a:	8f 90       	pop	r8
    2b5c:	7f 90       	pop	r7
    2b5e:	6f 90       	pop	r6
    2b60:	5f 90       	pop	r5
    2b62:	4f 90       	pop	r4
    2b64:	3f 90       	pop	r3
    2b66:	08 95       	ret

00002b68 <LogMemClear>:

INLINE void LogSRAMClear(void)
{
    uint16_t i, until = LOG_SIZE - LogMemLeft;
    2b68:	20 91 78 24 	lds	r18, 0x2478
    2b6c:	30 91 79 24 	lds	r19, 0x2479
    2b70:	80 e0       	ldi	r24, 0x00	; 0
    2b72:	98 e0       	ldi	r25, 0x08	; 8
    2b74:	82 1b       	sub	r24, r18
    2b76:	93 0b       	sbc	r25, r19
    2b78:	ec e7       	ldi	r30, 0x7C	; 124
    2b7a:	f4 e2       	ldi	r31, 0x24	; 36
    2b7c:	9f 01       	movw	r18, r30
    2b7e:	2c 57       	subi	r18, 0x7C	; 124
    2b80:	34 42       	sbci	r19, 0x24	; 36

    for (i=0; i < until; i++) {
    2b82:	28 17       	cp	r18, r24
    2b84:	39 07       	cpc	r19, r25
    2b86:	10 f4       	brcc	.+4      	; 0x2b8c <LogMemClear+0x24>
        LogMem[i] = (uint8_t) LOG_EMPTY;
    2b88:	11 92       	st	Z+, r1
    2b8a:	f8 cf       	rjmp	.-16     	; 0x2b7c <LogMemClear+0x14>
    }

    LogMemPtr = LogMem;
    2b8c:	8c e7       	ldi	r24, 0x7C	; 124
    2b8e:	94 e2       	ldi	r25, 0x24	; 36
    2b90:	80 93 7a 24 	sts	0x247A, r24
    2b94:	90 93 7b 24 	sts	0x247B, r25
    LogMemLeft = sizeof(LogMem);
    2b98:	80 e0       	ldi	r24, 0x00	; 0
    2b9a:	98 e0       	ldi	r25, 0x08	; 8
    2b9c:	80 93 78 24 	sts	0x2478, r24
    2ba0:	90 93 79 24 	sts	0x2479, r25
}

void LogMemClear(void)
{
    LogSRAMClear();
    LogFRAMAddr = FRAM_LOG_START_ADDR;
    2ba4:	82 e0       	ldi	r24, 0x02	; 2
    2ba6:	90 e4       	ldi	r25, 0x40	; 64
    2ba8:	80 93 00 20 	sts	0x2000, r24
    2bac:	90 93 01 20 	sts	0x2001, r25
    MemoryWriteBlock(&LogFRAMAddr, FRAM_LOG_ADDR_ADDR, 2);
    2bb0:	42 e0       	ldi	r20, 0x02	; 2
    2bb2:	50 e0       	ldi	r21, 0x00	; 0
    2bb4:	60 e0       	ldi	r22, 0x00	; 0
    2bb6:	70 e4       	ldi	r23, 0x40	; 64
    2bb8:	80 e0       	ldi	r24, 0x00	; 0
    2bba:	90 e2       	ldi	r25, 0x20	; 32
    2bbc:	10 da       	rcall	.-3040   	; 0x1fde <MemoryWriteBlock>

INLINE void LEDHook(LEDHookEnum Func, LEDActionEnum Action) {
    extern LEDActionEnum LEDGreenAction;
    extern LEDActionEnum LEDRedAction;

    if (GlobalSettings.ActiveSettingPtr->LEDGreenFunction == Func) {
    2bbe:	e0 91 71 2f 	lds	r30, 0x2F71
    2bc2:	f0 91 72 2f 	lds	r31, 0x2F72
    2bc6:	87 81       	ldd	r24, Z+7	; 0x07
    2bc8:	8a 30       	cpi	r24, 0x0A	; 10
    2bca:	19 f4       	brne	.+6      	; 0x2bd2 <LogMemClear+0x6a>
        LEDGreenAction = Action;
    2bcc:	80 e1       	ldi	r24, 0x10	; 16
    2bce:	80 93 7d 2c 	sts	0x2C7D, r24
    }

    if (GlobalSettings.ActiveSettingPtr->LEDRedFunction == Func) {
    2bd2:	86 81       	ldd	r24, Z+6	; 0x06
    2bd4:	8a 30       	cpi	r24, 0x0A	; 10
    2bd6:	19 f4       	brne	.+6      	; 0x2bde <LogMemClear+0x76>
        LEDRedAction = Action;
    2bd8:	80 e1       	ldi	r24, 0x10	; 16
    2bda:	80 93 7c 2c 	sts	0x2C7C, r24
    2bde:	08 95       	ret

00002be0 <LogMemFree>:
    LEDHook(LED_LOG_MEM_FULL, LED_OFF);
}

uint16_t LogMemFree(void)
{
    2be0:	80 91 78 24 	lds	r24, 0x2478
    2be4:	90 91 79 24 	lds	r25, 0x2479
    2be8:	90 58       	subi	r25, 0x80	; 128
    return LogMemLeft + FRAM_LOG_SIZE - LogFRAMAddr + FRAM_LOG_START_ADDR;
    2bea:	20 91 00 20 	lds	r18, 0x2000
    2bee:	30 91 01 20 	lds	r19, 0x2001
}
    2bf2:	82 1b       	sub	r24, r18
    2bf4:	93 0b       	sbc	r25, r19
    2bf6:	08 95       	ret

00002bf8 <LogSetModeById>:


void LogSetModeById(LogModeEnum Mode)
{
    2bf8:	20 e0       	ldi	r18, 0x00	; 0
    2bfa:	30 e0       	ldi	r19, 0x00	; 0
    2bfc:	f9 01       	movw	r30, r18
    2bfe:	e0 59       	subi	r30, 0x90	; 144
    2c00:	f0 4d       	sbci	r31, 0xD0	; 208
#ifndef LOG_SETTING_GLOBAL
    GlobalSettings.ActiveSettingPtr->LogMode = Mode;
#else
    /* Write Log settings globally */
    for (uint8_t i=0; i<SETTINGS_COUNT; i++) {
         GlobalSettings.Settings[i].LogMode = Mode;
    2c02:	87 83       	std	Z+7, r24	; 0x07
    2c04:	24 5f       	subi	r18, 0xF4	; 244
    2c06:	3f 4f       	sbci	r19, 0xFF	; 255
{
#ifndef LOG_SETTING_GLOBAL
    GlobalSettings.ActiveSettingPtr->LogMode = Mode;
#else
    /* Write Log settings globally */
    for (uint8_t i=0; i<SETTINGS_COUNT; i++) {
    2c08:	20 36       	cpi	r18, 0x60	; 96
    2c0a:	31 05       	cpc	r19, r1
    2c0c:	b9 f7       	brne	.-18     	; 0x2bfc <LogSetModeById+0x4>
         GlobalSettings.Settings[i].LogMode = Mode;
    }
#endif

    switch(Mode) {
    2c0e:	81 30       	cpi	r24, 0x01	; 1
    2c10:	49 f0       	breq	.+18     	; 0x2c24 <LogSetModeById+0x2c>
    2c12:	18 f0       	brcs	.+6      	; 0x2c1a <LogSetModeById+0x22>
    2c14:	82 30       	cpi	r24, 0x02	; 2
    2c16:	59 f0       	breq	.+22     	; 0x2c2e <LogSetModeById+0x36>
    2c18:	08 95       	ret
    case LOG_MODE_OFF:
        EnableLogSRAMtoFRAM = false;
    2c1a:	10 92 77 24 	sts	0x2477, r1
        CurrentLogFunc = LogFuncOff;
    2c1e:	84 ef       	ldi	r24, 0xF4	; 244
    2c20:	94 e1       	ldi	r25, 0x14	; 20
    2c22:	09 c0       	rjmp	.+18     	; 0x2c36 <LogSetModeById+0x3e>
        break;

    case LOG_MODE_MEMORY:
        EnableLogSRAMtoFRAM = true;
    2c24:	80 93 77 24 	sts	0x2477, r24
        CurrentLogFunc = LogFuncMemory;
    2c28:	8b e7       	ldi	r24, 0x7B	; 123
    2c2a:	96 e1       	ldi	r25, 0x16	; 22
    2c2c:	04 c0       	rjmp	.+8      	; 0x2c36 <LogSetModeById+0x3e>
        break;

    case LOG_MODE_LIVE:
        EnableLogSRAMtoFRAM = false;
    2c2e:	10 92 77 24 	sts	0x2477, r1
        CurrentLogFunc = LogFuncLive;
    2c32:	85 ef       	ldi	r24, 0xF5	; 245
    2c34:	94 e1       	ldi	r25, 0x14	; 20
    2c36:	80 93 6e 2f 	sts	0x2F6E, r24
    2c3a:	90 93 6f 2f 	sts	0x2F6F, r25
    2c3e:	08 95       	ret

00002c40 <LogInit>:
    TerminalSendByte((uint8_t) (SysTick >> 0));
    TerminalSendBlock(Data, Length);
}

void LogInit(void)
{
    2c40:	0f 93       	push	r16
    2c42:	1f 93       	push	r17
    2c44:	cf 93       	push	r28
    2c46:	df 93       	push	r29
    2c48:	1f 92       	push	r1
    2c4a:	cd b7       	in	r28, 0x3d	; 61
    2c4c:	de b7       	in	r29, 0x3e	; 62
    LogSetModeById(GlobalSettings.ActiveSettingPtr->LogMode);
    2c4e:	e0 91 71 2f 	lds	r30, 0x2F71
    2c52:	f0 91 72 2f 	lds	r31, 0x2F72
    2c56:	84 81       	ldd	r24, Z+4	; 0x04
    2c58:	cf df       	rcall	.-98     	; 0x2bf8 <LogSetModeById>
    LogMemPtr = LogMem;
    2c5a:	8c e7       	ldi	r24, 0x7C	; 124
    2c5c:	94 e2       	ldi	r25, 0x24	; 36
    2c5e:	80 93 7a 24 	sts	0x247A, r24
    2c62:	90 93 7b 24 	sts	0x247B, r25
    LogMemLeft = sizeof(LogMem);
    2c66:	00 e0       	ldi	r16, 0x00	; 0
    2c68:	18 e0       	ldi	r17, 0x08	; 8
    2c6a:	00 93 78 24 	sts	0x2478, r16
    2c6e:	10 93 79 24 	sts	0x2479, r17

    uint8_t result;
    ReadEEPBlock((uint16_t) &LogFRAMAddrValid, &result, 1);
    2c72:	41 e0       	ldi	r20, 0x01	; 1
    2c74:	50 e0       	ldi	r21, 0x00	; 0
    2c76:	be 01       	movw	r22, r28
    2c78:	6f 5f       	subi	r22, 0xFF	; 255
    2c7a:	7f 4f       	sbci	r23, 0xFF	; 255
    2c7c:	80 e0       	ldi	r24, 0x00	; 0
    2c7e:	90 e0       	ldi	r25, 0x00	; 0
    2c80:	60 dc       	rcall	.-1856   	; 0x2542 <ReadEEPBlock>
    memset(LogMemPtr, LOG_EMPTY, LOG_SIZE);
    2c82:	e0 91 7a 24 	lds	r30, 0x247A
    2c86:	f0 91 7b 24 	lds	r31, 0x247B
    2c8a:	df 01       	movw	r26, r30
    2c8c:	c8 01       	movw	r24, r16
    2c8e:	1d 92       	st	X+, r1
    2c90:	01 97       	sbiw	r24, 0x01	; 1
    2c92:	e9 f7       	brne	.-6      	; 0x2c8e <LogInit+0x4e>
    if (result)
    2c94:	89 81       	ldd	r24, Y+1	; 0x01
    2c96:	88 23       	and	r24, r24
    2c98:	41 f0       	breq	.+16     	; 0x2caa <LogInit+0x6a>
    {
        MemoryReadBlock(&LogFRAMAddr, FRAM_LOG_ADDR_ADDR, 2);
    2c9a:	42 e0       	ldi	r20, 0x02	; 2
    2c9c:	50 e0       	ldi	r21, 0x00	; 0
    2c9e:	60 e0       	ldi	r22, 0x00	; 0
    2ca0:	70 e4       	ldi	r23, 0x40	; 64
    2ca2:	80 e0       	ldi	r24, 0x00	; 0
    2ca4:	90 e2       	ldi	r25, 0x20	; 32
    2ca6:	4d d9       	rcall	.-3430   	; 0x1f42 <MemoryReadBlock>
    2ca8:	17 c0       	rjmp	.+46     	; 0x2cd8 <LogInit+0x98>
    } else {
        LogFRAMAddr = FRAM_LOG_START_ADDR;
    2caa:	82 e0       	ldi	r24, 0x02	; 2
    2cac:	90 e4       	ldi	r25, 0x40	; 64
    2cae:	80 93 00 20 	sts	0x2000, r24
    2cb2:	90 93 01 20 	sts	0x2001, r25
        MemoryWriteBlock(&LogFRAMAddr, FRAM_LOG_ADDR_ADDR, 2);
    2cb6:	42 e0       	ldi	r20, 0x02	; 2
    2cb8:	50 e0       	ldi	r21, 0x00	; 0
    2cba:	60 e0       	ldi	r22, 0x00	; 0
    2cbc:	70 e4       	ldi	r23, 0x40	; 64
    2cbe:	80 e0       	ldi	r24, 0x00	; 0
    2cc0:	90 e2       	ldi	r25, 0x20	; 32
    2cc2:	8d d9       	rcall	.-3302   	; 0x1fde <MemoryWriteBlock>
        result = true;
    2cc4:	81 e0       	ldi	r24, 0x01	; 1
    2cc6:	89 83       	std	Y+1, r24	; 0x01
        WriteEEPBlock((uint16_t) &LogFRAMAddrValid, &result, 1);
    2cc8:	41 e0       	ldi	r20, 0x01	; 1
    2cca:	50 e0       	ldi	r21, 0x00	; 0
    2ccc:	be 01       	movw	r22, r28
    2cce:	6f 5f       	subi	r22, 0xFF	; 255
    2cd0:	7f 4f       	sbci	r23, 0xFF	; 255
    2cd2:	80 e0       	ldi	r24, 0x00	; 0
    2cd4:	90 e0       	ldi	r25, 0x00	; 0
    2cd6:	72 dc       	rcall	.-1820   	; 0x25bc <WriteEEPBlock>
    2cd8:	e0 91 6e 2f 	lds	r30, 0x2F6E
    2cdc:	f0 91 6f 2f 	lds	r31, 0x2F6F
    2ce0:	40 e0       	ldi	r20, 0x00	; 0
    2ce2:	60 e0       	ldi	r22, 0x00	; 0
    2ce4:	70 e0       	ldi	r23, 0x00	; 0
    2ce6:	8f ef       	ldi	r24, 0xFF	; 255
    2ce8:	19 95       	eicall
    }

    LogEntry(LOG_INFO_SYSTEM_BOOT, NULL, 0);
}
    2cea:	0f 90       	pop	r0
    2cec:	df 91       	pop	r29
    2cee:	cf 91       	pop	r28
    2cf0:	1f 91       	pop	r17
    2cf2:	0f 91       	pop	r16
    2cf4:	08 95       	ret

00002cf6 <LogFuncMemory>:
{
    /* Do nothing */
}

static void LogFuncMemory(LogEntryEnum Entry, const void* Data, uint8_t Length)
{
    2cf6:	0f 93       	push	r16
    2cf8:	1f 93       	push	r17
    2cfa:	cf 93       	push	r28
    2cfc:	df 93       	push	r29
    2cfe:	ae b1       	in	r26, 0x0e	; 14
    2d00:	bf b1       	in	r27, 0x0f	; 15
    2d02:	c0 91 08 04 	lds	r28, 0x0408
    2d06:	d0 91 09 04 	lds	r29, 0x0409
    uint16_t SysTick = SystemGetSysTick();

    if (LogMemLeft >= (Length + 4)) {
    2d0a:	20 91 78 24 	lds	r18, 0x2478
    2d0e:	30 91 79 24 	lds	r19, 0x2479
    2d12:	e4 2f       	mov	r30, r20
    2d14:	f0 e0       	ldi	r31, 0x00	; 0
    2d16:	8f 01       	movw	r16, r30
    2d18:	0c 5f       	subi	r16, 0xFC	; 252
    2d1a:	1f 4f       	sbci	r17, 0xFF	; 255
    2d1c:	20 17       	cp	r18, r16
    2d1e:	31 07       	cpc	r19, r17
    2d20:	58 f1       	brcs	.+86     	; 0x2d78 <LogFuncMemory+0x82>
    2d22:	ca 2b       	or	r28, r26
    2d24:	db 2b       	or	r29, r27
    2d26:	24 50       	subi	r18, 0x04	; 4
    2d28:	31 09       	sbc	r19, r1
        LogMemLeft -= Length + 4;
    2d2a:	2e 1b       	sub	r18, r30
    2d2c:	3f 0b       	sbc	r19, r31
    2d2e:	20 93 78 24 	sts	0x2478, r18
    2d32:	30 93 79 24 	sts	0x2479, r19

        uint8_t* DataPtr = (uint8_t*) Data;

        /* Write down Entry Id, Data length and Timestamp */
        *LogMemPtr++ = (uint8_t) Entry;
    2d36:	a0 91 7a 24 	lds	r26, 0x247A
    2d3a:	b0 91 7b 24 	lds	r27, 0x247B
    2d3e:	8c 93       	st	X, r24
        *LogMemPtr++ = (uint8_t) Length;
    2d40:	11 96       	adiw	r26, 0x01	; 1
    2d42:	4c 93       	st	X, r20
    2d44:	11 97       	sbiw	r26, 0x01	; 1
        *LogMemPtr++ = (uint8_t) (SysTick >> 8);
    2d46:	12 96       	adiw	r26, 0x02	; 2
    2d48:	dc 93       	st	X, r29
    2d4a:	12 97       	sbiw	r26, 0x02	; 2
        *LogMemPtr++ = (uint8_t) (SysTick >> 0);
    2d4c:	cd 01       	movw	r24, r26
    2d4e:	04 96       	adiw	r24, 0x04	; 4
    2d50:	80 93 7a 24 	sts	0x247A, r24
    2d54:	90 93 7b 24 	sts	0x247B, r25
    2d58:	13 96       	adiw	r26, 0x03	; 3
    2d5a:	cc 93       	st	X, r28
    2d5c:	db 01       	movw	r26, r22
    2d5e:	ec 01       	movw	r28, r24

        /* Write down data bytes */
        while(Length--) {
    2d60:	41 50       	subi	r20, 0x01	; 1
    2d62:	18 f0       	brcs	.+6      	; 0x2d6a <LogFuncMemory+0x74>
            *LogMemPtr++ = *DataPtr++;
    2d64:	2d 91       	ld	r18, X+
    2d66:	29 93       	st	Y+, r18
    2d68:	fb cf       	rjmp	.-10     	; 0x2d60 <LogFuncMemory+0x6a>
    2d6a:	e8 0f       	add	r30, r24
    2d6c:	f9 1f       	adc	r31, r25
    2d6e:	e0 93 7a 24 	sts	0x247A, r30
    2d72:	f0 93 7b 24 	sts	0x247B, r31
    2d76:	12 c0       	rjmp	.+36     	; 0x2d9c <LogFuncMemory+0xa6>
        }
    } else {
        /* If memory full. Deactivate logmode */
        LogSetModeById(LOG_MODE_OFF);
    2d78:	80 e0       	ldi	r24, 0x00	; 0
    2d7a:	3e df       	rcall	.-388    	; 0x2bf8 <LogSetModeById>

INLINE void LEDHook(LEDHookEnum Func, LEDActionEnum Action) {
    extern LEDActionEnum LEDGreenAction;
    extern LEDActionEnum LEDRedAction;

    if (GlobalSettings.ActiveSettingPtr->LEDGreenFunction == Func) {
    2d7c:	e0 91 71 2f 	lds	r30, 0x2F71
    2d80:	f0 91 72 2f 	lds	r31, 0x2F72
    2d84:	87 81       	ldd	r24, Z+7	; 0x07
    2d86:	8a 30       	cpi	r24, 0x0A	; 10
    2d88:	19 f4       	brne	.+6      	; 0x2d90 <LogFuncMemory+0x9a>
        LEDGreenAction = Action;
    2d8a:	81 e1       	ldi	r24, 0x11	; 17
    2d8c:	80 93 7d 2c 	sts	0x2C7D, r24
    }

    if (GlobalSettings.ActiveSettingPtr->LEDRedFunction == Func) {
    2d90:	86 81       	ldd	r24, Z+6	; 0x06
    2d92:	8a 30       	cpi	r24, 0x0A	; 10
    2d94:	19 f4       	brne	.+6      	; 0x2d9c <LogFuncMemory+0xa6>
        LEDRedAction = Action;
    2d96:	81 e1       	ldi	r24, 0x11	; 17
    2d98:	80 93 7c 2c 	sts	0x2C7C, r24
        LEDHook(LED_LOG_MEM_FULL, LED_ON);
    }
}
    2d9c:	df 91       	pop	r29
    2d9e:	cf 91       	pop	r28
    2da0:	1f 91       	pop	r17
    2da2:	0f 91       	pop	r16
    2da4:	08 95       	ret

00002da6 <LogSetModeByName>:
    }

}

bool LogSetModeByName(const char* Mode)
{
    2da6:	1f 93       	push	r17
    2da8:	cf 93       	push	r28
    2daa:	df 93       	push	r29
    2dac:	1f 92       	push	r1
    2dae:	cd b7       	in	r28, 0x3d	; 61
    2db0:	de b7       	in	r29, 0x3e	; 62
    MapIdType Id;

    if (MapTextToId(LogModeMap, ARRAY_COUNT(LogModeMap), Mode, &Id)) {
    2db2:	9e 01       	movw	r18, r28
    2db4:	2f 5f       	subi	r18, 0xFF	; 255
    2db6:	3f 4f       	sbci	r19, 0xFF	; 255
    2db8:	ac 01       	movw	r20, r24
    2dba:	63 e0       	ldi	r22, 0x03	; 3
    2dbc:	85 e2       	ldi	r24, 0x25	; 37
    2dbe:	99 e0       	ldi	r25, 0x09	; 9
    2dc0:	30 d2       	rcall	.+1120   	; 0x3222 <MapTextToId>
    2dc2:	18 2f       	mov	r17, r24
    2dc4:	88 23       	and	r24, r24
    2dc6:	11 f0       	breq	.+4      	; 0x2dcc <LogSetModeByName+0x26>
        LogSetModeById(Id);
    2dc8:	89 81       	ldd	r24, Y+1	; 0x01
    2dca:	16 df       	rcall	.-468    	; 0x2bf8 <LogSetModeById>
        return true;
    }

    return false;
}
    2dcc:	81 2f       	mov	r24, r17
    2dce:	0f 90       	pop	r0
    2dd0:	df 91       	pop	r29
    2dd2:	cf 91       	pop	r28
    2dd4:	1f 91       	pop	r17
    2dd6:	08 95       	ret

00002dd8 <LogGetModeByName>:

void LogGetModeByName(char* Mode, uint16_t BufferSize)
{
    2dd8:	0f 93       	push	r16
    2dda:	1f 93       	push	r17
    MapIdToText(LogModeMap, ARRAY_COUNT(LogModeMap),
            GlobalSettings.ActiveSettingPtr->LogMode, Mode, BufferSize);
    2ddc:	e0 91 71 2f 	lds	r30, 0x2F71
    2de0:	f0 91 72 2f 	lds	r31, 0x2F72
    return false;
}

void LogGetModeByName(char* Mode, uint16_t BufferSize)
{
    MapIdToText(LogModeMap, ARRAY_COUNT(LogModeMap),
    2de4:	8b 01       	movw	r16, r22
    2de6:	9c 01       	movw	r18, r24
    2de8:	44 81       	ldd	r20, Z+4	; 0x04
    2dea:	63 e0       	ldi	r22, 0x03	; 3
    2dec:	85 e2       	ldi	r24, 0x25	; 37
    2dee:	99 e0       	ldi	r25, 0x09	; 9
    2df0:	00 d2       	rcall	.+1024   	; 0x31f2 <MapIdToText>
            GlobalSettings.ActiveSettingPtr->LogMode, Mode, BufferSize);
}
    2df2:	1f 91       	pop	r17
    2df4:	0f 91       	pop	r16
    2df6:	08 95       	ret

00002df8 <LogGetModeList>:

void LogGetModeList(char* List, uint16_t BufferSize)
{
    2df8:	9b 01       	movw	r18, r22
    MapToString(LogModeMap, ARRAY_COUNT(LogModeMap), List, BufferSize);
    2dfa:	ac 01       	movw	r20, r24
    2dfc:	63 e0       	ldi	r22, 0x03	; 3
    2dfe:	85 e2       	ldi	r24, 0x25	; 37
    2e00:	99 e0       	ldi	r25, 0x09	; 9
    2e02:	36 c2       	rjmp	.+1132   	; 0x3270 <MapToString>

00002e04 <LogSRAMToFRAM>:
}

void LogSRAMToFRAM(void)
{
    2e04:	ef 92       	push	r14
    2e06:	ff 92       	push	r15
    2e08:	0f 93       	push	r16
    2e0a:	1f 93       	push	r17
    2e0c:	cf 93       	push	r28
    2e0e:	df 93       	push	r29
    if (LogMemLeft < LOG_SIZE)
    2e10:	80 91 78 24 	lds	r24, 0x2478
    2e14:	90 91 79 24 	lds	r25, 0x2479
    2e18:	81 15       	cp	r24, r1
    2e1a:	28 e0       	ldi	r18, 0x08	; 8
    2e1c:	92 07       	cpc	r25, r18
    2e1e:	08 f0       	brcs	.+2      	; 0x2e22 <LogSRAMToFRAM+0x1e>
    2e20:	78 c0       	rjmp	.+240    	; 0x2f12 <LogSRAMToFRAM+0x10e>
    {
        uint16_t FRAM_Free = FRAM_LOG_SIZE - (LogFRAMAddr - FRAM_LOG_START_ADDR);
    2e22:	00 91 00 20 	lds	r16, 0x2000
    2e26:	10 91 01 20 	lds	r17, 0x2001
    2e2a:	c0 e0       	ldi	r28, 0x00	; 0
    2e2c:	d0 e8       	ldi	r29, 0x80	; 128
    2e2e:	c0 1b       	sub	r28, r16
    2e30:	d1 0b       	sbc	r29, r17

        if (FRAM_Free >= LOG_SIZE - LogMemLeft)
    2e32:	e1 2c       	mov	r14, r1
    2e34:	28 e0       	ldi	r18, 0x08	; 8
    2e36:	f2 2e       	mov	r15, r18
    2e38:	a7 01       	movw	r20, r14
    2e3a:	48 1b       	sub	r20, r24
    2e3c:	59 0b       	sbc	r21, r25
    2e3e:	c4 17       	cp	r28, r20
    2e40:	d5 07       	cpc	r29, r21
    2e42:	60 f1       	brcs	.+88     	; 0x2e9c <LogSRAMToFRAM+0x98>
        {
            MemoryWriteBlock(LogMem, LogFRAMAddr, LOG_SIZE - LogMemLeft);
    2e44:	b8 01       	movw	r22, r16
    2e46:	8c e7       	ldi	r24, 0x7C	; 124
    2e48:	94 e2       	ldi	r25, 0x24	; 36
    2e4a:	c9 d8       	rcall	.-3694   	; 0x1fde <MemoryWriteBlock>
            LogFRAMAddr += LOG_SIZE - LogMemLeft;
    2e4c:	20 91 78 24 	lds	r18, 0x2478
    2e50:	30 91 79 24 	lds	r19, 0x2479
    2e54:	80 91 00 20 	lds	r24, 0x2000
    2e58:	90 91 01 20 	lds	r25, 0x2001
    2e5c:	98 5f       	subi	r25, 0xF8	; 248
    2e5e:	82 1b       	sub	r24, r18
    2e60:	93 0b       	sbc	r25, r19
    2e62:	80 93 00 20 	sts	0x2000, r24
    2e66:	90 93 01 20 	sts	0x2001, r25
    }
}

INLINE void LogSRAMClear(void)
{
    uint16_t i, until = LOG_SIZE - LogMemLeft;
    2e6a:	e2 1a       	sub	r14, r18
    2e6c:	f3 0a       	sbc	r15, r19
    2e6e:	ec e7       	ldi	r30, 0x7C	; 124
    2e70:	f4 e2       	ldi	r31, 0x24	; 36
    2e72:	cf 01       	movw	r24, r30
    2e74:	8c 57       	subi	r24, 0x7C	; 124
    2e76:	94 42       	sbci	r25, 0x24	; 36

    for (i=0; i < until; i++) {
    2e78:	8e 15       	cp	r24, r14
    2e7a:	9f 05       	cpc	r25, r15
    2e7c:	10 f4       	brcc	.+4      	; 0x2e82 <LogSRAMToFRAM+0x7e>
        LogMem[i] = (uint8_t) LOG_EMPTY;
    2e7e:	11 92       	st	Z+, r1
    2e80:	f8 cf       	rjmp	.-16     	; 0x2e72 <LogSRAMToFRAM+0x6e>
    }

    LogMemPtr = LogMem;
    2e82:	8c e7       	ldi	r24, 0x7C	; 124
    2e84:	94 e2       	ldi	r25, 0x24	; 36
    2e86:	80 93 7a 24 	sts	0x247A, r24
    2e8a:	90 93 7b 24 	sts	0x247B, r25
    LogMemLeft = sizeof(LogMem);
    2e8e:	80 e0       	ldi	r24, 0x00	; 0
    2e90:	98 e0       	ldi	r25, 0x08	; 8
    2e92:	80 93 78 24 	sts	0x2478, r24
    2e96:	90 93 79 24 	sts	0x2479, r25
    2e9a:	2e c0       	rjmp	.+92     	; 0x2ef8 <LogSRAMToFRAM+0xf4>
        {
            MemoryWriteBlock(LogMem, LogFRAMAddr, LOG_SIZE - LogMemLeft);
            LogFRAMAddr += LOG_SIZE - LogMemLeft;
            LogSRAMClear();
            MemoryWriteBlock(&LogFRAMAddr, FRAM_LOG_ADDR_ADDR, 2);
        } else if (FRAM_Free > 0) {
    2e9c:	20 97       	sbiw	r28, 0x00	; 0
    2e9e:	c9 f1       	breq	.+114    	; 0x2f12 <LogSRAMToFRAM+0x10e>
            // not everything fits in FRAM, simply write as much as possible to FRAM
            MemoryWriteBlock(LogMem, LogFRAMAddr, FRAM_Free);
    2ea0:	ae 01       	movw	r20, r28
    2ea2:	b8 01       	movw	r22, r16
    2ea4:	8c e7       	ldi	r24, 0x7C	; 124
    2ea6:	94 e2       	ldi	r25, 0x24	; 36
    2ea8:	9a d8       	rcall	.-3788   	; 0x1fde <MemoryWriteBlock>
            memmove(LogMem, LogMem + FRAM_Free, LOG_SIZE - FRAM_Free); // FRAM_Free is < LOG_SIZE - LogMemLeft and thus also < LOG_SIZE
    2eaa:	a8 01       	movw	r20, r16
    2eac:	58 57       	subi	r21, 0x78	; 120
    2eae:	be 01       	movw	r22, r28
    2eb0:	64 58       	subi	r22, 0x84	; 132
    2eb2:	7b 4d       	sbci	r23, 0xDB	; 219
    2eb4:	8c e7       	ldi	r24, 0x7C	; 124
    2eb6:	94 e2       	ldi	r25, 0x24	; 36
    2eb8:	0e 94 f0 65 	call	0xcbe0	; 0xcbe0 <memmove>

            LogMemPtr -= FRAM_Free;
    2ebc:	80 91 7a 24 	lds	r24, 0x247A
    2ec0:	90 91 7b 24 	lds	r25, 0x247B
    2ec4:	8c 1b       	sub	r24, r28
    2ec6:	9d 0b       	sbc	r25, r29
    2ec8:	80 93 7a 24 	sts	0x247A, r24
    2ecc:	90 93 7b 24 	sts	0x247B, r25
            LogMemLeft += FRAM_Free;
    2ed0:	80 91 78 24 	lds	r24, 0x2478
    2ed4:	90 91 79 24 	lds	r25, 0x2479
    2ed8:	8c 0f       	add	r24, r28
    2eda:	9d 1f       	adc	r25, r29
    2edc:	80 93 78 24 	sts	0x2478, r24
    2ee0:	90 93 79 24 	sts	0x2479, r25
            LogFRAMAddr += FRAM_Free;
    2ee4:	80 91 00 20 	lds	r24, 0x2000
    2ee8:	90 91 01 20 	lds	r25, 0x2001
    2eec:	c8 0f       	add	r28, r24
    2eee:	d9 1f       	adc	r29, r25
    2ef0:	c0 93 00 20 	sts	0x2000, r28
    2ef4:	d0 93 01 20 	sts	0x2001, r29
            MemoryWriteBlock(&LogFRAMAddr, FRAM_LOG_ADDR_ADDR, 2);
    2ef8:	42 e0       	ldi	r20, 0x02	; 2
    2efa:	50 e0       	ldi	r21, 0x00	; 0
    2efc:	60 e0       	ldi	r22, 0x00	; 0
    2efe:	70 e4       	ldi	r23, 0x40	; 64
    2f00:	80 e0       	ldi	r24, 0x00	; 0
    2f02:	90 e2       	ldi	r25, 0x20	; 32
        } else {
            // TODO handle the case in which the FRAM is full
        }
    }
}
    2f04:	df 91       	pop	r29
    2f06:	cf 91       	pop	r28
    2f08:	1f 91       	pop	r17
    2f0a:	0f 91       	pop	r16
    2f0c:	ff 90       	pop	r15
    2f0e:	ef 90       	pop	r14
            memmove(LogMem, LogMem + FRAM_Free, LOG_SIZE - FRAM_Free); // FRAM_Free is < LOG_SIZE - LogMemLeft and thus also < LOG_SIZE

            LogMemPtr -= FRAM_Free;
            LogMemLeft += FRAM_Free;
            LogFRAMAddr += FRAM_Free;
            MemoryWriteBlock(&LogFRAMAddr, FRAM_LOG_ADDR_ADDR, 2);
    2f10:	66 c8       	rjmp	.-3892   	; 0x1fde <MemoryWriteBlock>
        } else {
            // TODO handle the case in which the FRAM is full
        }
    }
}
    2f12:	df 91       	pop	r29
    2f14:	cf 91       	pop	r28
    2f16:	1f 91       	pop	r17
    2f18:	0f 91       	pop	r16
    2f1a:	ff 90       	pop	r15
    2f1c:	ef 90       	pop	r14
    2f1e:	08 95       	ret

00002f20 <LogTick>:
    LogEntry(LOG_INFO_SYSTEM_BOOT, NULL, 0);
}

void LogTick(void)
{
    if (EnableLogSRAMtoFRAM)
    2f20:	80 91 77 24 	lds	r24, 0x2477
    2f24:	81 11       	cpse	r24, r1
        LogSRAMToFRAM();
    2f26:	6e cf       	rjmp	.-292    	; 0x2e04 <LogSRAMToFRAM>
    2f28:	08 95       	ret

00002f2a <SettingsLoad>:
	}
}

uint8_t SettingsGetActiveById(void) {
	return INDEX_TO_SETTING(GlobalSettings.ActiveSettingIdx);
}
    2f2a:	43 e6       	ldi	r20, 0x63	; 99
    2f2c:	50 e0       	ldi	r21, 0x00	; 0
    2f2e:	60 e7       	ldi	r22, 0x70	; 112
    2f30:	7f e2       	ldi	r23, 0x2F	; 47
    2f32:	81 e0       	ldi	r24, 0x01	; 1
    2f34:	90 e0       	ldi	r25, 0x00	; 0
    2f36:	05 cb       	rjmp	.-2550   	; 0x2542 <ReadEEPBlock>

00002f38 <SettingsSave>:
    2f38:	43 e6       	ldi	r20, 0x63	; 99
    2f3a:	50 e0       	ldi	r21, 0x00	; 0
    2f3c:	60 e7       	ldi	r22, 0x70	; 112
    2f3e:	7f e2       	ldi	r23, 0x2F	; 47
    2f40:	81 e0       	ldi	r24, 0x01	; 1
    2f42:	90 e0       	ldi	r25, 0x00	; 0
    2f44:	3b cb       	rjmp	.-2442   	; 0x25bc <WriteEEPBlock>

00002f46 <SettingsSetActiveById>:
    2f46:	cf 93       	push	r28
    2f48:	df 93       	push	r29
    2f4a:	cf ef       	ldi	r28, 0xFF	; 255
    2f4c:	c8 0f       	add	r28, r24
    2f4e:	c8 30       	cpi	r28, 0x08	; 8
    2f50:	78 f5       	brcc	.+94     	; 0x2fb0 <SettingsSetActiveById+0x6a>
    2f52:	d8 2f       	mov	r29, r24
    2f54:	0e 94 33 23 	call	0x4666	; 0x4666 <CommandLinePendingTaskBreak>
    2f58:	55 d9       	rcall	.-3414   	; 0x2204 <MemoryStore>
    2f5a:	c0 93 70 2f 	sts	0x2F70, r28
    2f5e:	8c e0       	ldi	r24, 0x0C	; 12
    2f60:	c8 9f       	mul	r28, r24
    2f62:	90 01       	movw	r18, r0
    2f64:	11 24       	eor	r1, r1
    2f66:	c9 01       	movw	r24, r18
    2f68:	8d 58       	subi	r24, 0x8D	; 141
    2f6a:	90 4d       	sbci	r25, 0xD0	; 208
    2f6c:	80 93 71 2f 	sts	0x2F71, r24
    2f70:	90 93 72 2f 	sts	0x2F72, r25
    2f74:	f9 01       	movw	r30, r18
    2f76:	e0 59       	subi	r30, 0x90	; 144
    2f78:	f0 4d       	sbci	r31, 0xD0	; 208
    2f7a:	80 85       	ldd	r24, Z+8	; 0x08
    2f7c:	0e 94 55 0e 	call	0x1caa	; 0x1caa <ConfigurationSetById>
    2f80:	e0 91 71 2f 	lds	r30, 0x2F71
    2f84:	f0 91 72 2f 	lds	r31, 0x2F72
    2f88:	84 81       	ldd	r24, Z+4	; 0x04
    2f8a:	36 de       	rcall	.-916    	; 0x2bf8 <LogSetModeById>
    2f8c:	96 d8       	rcall	.-3796   	; 0x20ba <MemoryRecall>
    2f8e:	8f e1       	ldi	r24, 0x1F	; 31
    2f90:	8d 0f       	add	r24, r29
    2f92:	e0 91 71 2f 	lds	r30, 0x2F71
    2f96:	f0 91 72 2f 	lds	r31, 0x2F72
    2f9a:	97 81       	ldd	r25, Z+7	; 0x07
    2f9c:	94 30       	cpi	r25, 0x04	; 4
    2f9e:	11 f4       	brne	.+4      	; 0x2fa4 <SettingsSetActiveById+0x5e>
    2fa0:	80 93 7d 2c 	sts	0x2C7D, r24
    2fa4:	96 81       	ldd	r25, Z+6	; 0x06
    2fa6:	94 30       	cpi	r25, 0x04	; 4
    2fa8:	29 f4       	brne	.+10     	; 0x2fb4 <SettingsSetActiveById+0x6e>
    2faa:	80 93 7c 2c 	sts	0x2C7C, r24
    2fae:	02 c0       	rjmp	.+4      	; 0x2fb4 <SettingsSetActiveById+0x6e>
    2fb0:	80 e0       	ldi	r24, 0x00	; 0
    2fb2:	01 c0       	rjmp	.+2      	; 0x2fb6 <SettingsSetActiveById+0x70>
    2fb4:	81 e0       	ldi	r24, 0x01	; 1
    2fb6:	df 91       	pop	r29
    2fb8:	cf 91       	pop	r28
    2fba:	08 95       	ret

00002fbc <SettingsCycle>:
    2fbc:	80 91 70 2f 	lds	r24, 0x2F70
    2fc0:	99 e0       	ldi	r25, 0x09	; 9
    2fc2:	4c e0       	ldi	r20, 0x0C	; 12
    2fc4:	91 50       	subi	r25, 0x01	; 1
    2fc6:	99 f0       	breq	.+38     	; 0x2fee <SettingsCycle+0x32>
    2fc8:	28 2f       	mov	r18, r24
    2fca:	30 e0       	ldi	r19, 0x00	; 0
    2fcc:	2f 5f       	subi	r18, 0xFF	; 255
    2fce:	3f 4f       	sbci	r19, 0xFF	; 255
    2fd0:	27 70       	andi	r18, 0x07	; 7
    2fd2:	33 27       	eor	r19, r19
    2fd4:	82 2f       	mov	r24, r18
    2fd6:	42 9f       	mul	r20, r18
    2fd8:	f0 01       	movw	r30, r0
    2fda:	43 9f       	mul	r20, r19
    2fdc:	f0 0d       	add	r31, r0
    2fde:	11 24       	eor	r1, r1
    2fe0:	e0 59       	subi	r30, 0x90	; 144
    2fe2:	f0 4d       	sbci	r31, 0xD0	; 208
    2fe4:	20 85       	ldd	r18, Z+8	; 0x08
    2fe6:	22 23       	and	r18, r18
    2fe8:	69 f3       	breq	.-38     	; 0x2fc4 <SettingsCycle+0x8>
    2fea:	8f 5f       	subi	r24, 0xFF	; 255
    2fec:	ac cf       	rjmp	.-168    	; 0x2f46 <SettingsSetActiveById>
    2fee:	08 95       	ret

00002ff0 <SettingsGetActiveByName>:

void SettingsGetActiveByName(char* SettingOut, uint16_t BufferSize) {
    2ff0:	fc 01       	movw	r30, r24
	SettingOut[0] = SettingsGetActiveById() + '0';
    2ff2:	90 91 70 2f 	lds	r25, 0x2F70
    2ff6:	9f 5c       	subi	r25, 0xCF	; 207
    2ff8:	90 83       	st	Z, r25
	SettingOut[1] = '\0';
    2ffa:	11 82       	std	Z+1, r1	; 0x01
    2ffc:	08 95       	ret

00002ffe <SettingsSetActiveByName>:
}

bool SettingsSetActiveByName(const char* Setting) {
    2ffe:	cf 93       	push	r28
    3000:	fc 01       	movw	r30, r24
	uint8_t SettingNr = Setting[0] - '0';
    3002:	c0 81       	ld	r28, Z

	if (Setting[1] == '\0') {
    3004:	81 81       	ldd	r24, Z+1	; 0x01
    3006:	81 11       	cpse	r24, r1
    3008:	0c c0       	rjmp	.+24     	; 0x3022 <SettingsSetActiveByName+0x24>
    300a:	bf 01       	movw	r22, r30
    300c:	e0 91 6e 2f 	lds	r30, 0x2F6E
    3010:	f0 91 6f 2f 	lds	r31, 0x2F6F
    3014:	41 e0       	ldi	r20, 0x01	; 1
    3016:	82 e1       	ldi	r24, 0x12	; 18
    3018:	19 95       	eicall
		LogEntry(LOG_INFO_SETTING_SET, Setting, 1);
		return SettingsSetActiveById(SettingNr);
    301a:	80 ed       	ldi	r24, 0xD0	; 208
    301c:	8c 0f       	add	r24, r28
	} else {
		return false;
	}
}
    301e:	cf 91       	pop	r28
bool SettingsSetActiveByName(const char* Setting) {
	uint8_t SettingNr = Setting[0] - '0';

	if (Setting[1] == '\0') {
		LogEntry(LOG_INFO_SETTING_SET, Setting, 1);
		return SettingsSetActiveById(SettingNr);
    3020:	92 cf       	rjmp	.-220    	; 0x2f46 <SettingsSetActiveById>
	} else {
		return false;
	}
}
    3022:	80 e0       	ldi	r24, 0x00	; 0
    3024:	cf 91       	pop	r28
    3026:	08 95       	ret

00003028 <LEDInit>:
    }
}

void LEDInit(void)
{
    LED_PORT.DIRSET = LED_MASK;
    3028:	88 e1       	ldi	r24, 0x18	; 24
    302a:	80 93 01 06 	sts	0x0601, r24
    302e:	08 95       	ret

00003030 <LEDTick>:
{
    static uint8_t LEDRedBlinkPrescaler = 0;
    static uint8_t LEDGreenBlinkPrescaler = 0;
    uint8_t * BlinkPrescaler = (Action == &LEDGreenAction) ? &LEDGreenBlinkPrescaler : &LEDRedBlinkPrescaler;

    switch (*Action)
    3030:	80 91 7c 2c 	lds	r24, 0x2C7C
    3034:	82 31       	cpi	r24, 0x12	; 18
    3036:	91 f0       	breq	.+36     	; 0x305c <LEDTick+0x2c>
    3038:	30 f4       	brcc	.+12     	; 0x3046 <LEDTick+0x16>
    303a:	80 31       	cpi	r24, 0x10	; 16
    303c:	b9 f0       	breq	.+46     	; 0x306c <LEDTick+0x3c>
    303e:	50 f4       	brcc	.+20     	; 0x3054 <LEDTick+0x24>
    3040:	88 23       	and	r24, r24
    3042:	a9 f1       	breq	.+106    	; 0x30ae <LEDTick+0x7e>
    3044:	32 c0       	rjmp	.+100    	; 0x30aa <LEDTick+0x7a>
    3046:	83 31       	cpi	r24, 0x13	; 19
    3048:	69 f0       	breq	.+26     	; 0x3064 <LEDTick+0x34>
    304a:	90 ee       	ldi	r25, 0xE0	; 224
    304c:	98 0f       	add	r25, r24
    304e:	98 30       	cpi	r25, 0x08	; 8
    3050:	88 f0       	brcs	.+34     	; 0x3074 <LEDTick+0x44>
    3052:	2b c0       	rjmp	.+86     	; 0x30aa <LEDTick+0x7a>
            LED_PORT.OUTCLR = Mask;
            *Action = LED_NO_ACTION;
            break;

        case LED_ON:
            LED_PORT.OUTSET = Mask;
    3054:	88 e0       	ldi	r24, 0x08	; 8
    3056:	80 93 05 06 	sts	0x0605, r24
    305a:	27 c0       	rjmp	.+78     	; 0x30aa <LEDTick+0x7a>
            *Action = LED_NO_ACTION;
            break;

        case LED_TOGGLE:
            LED_PORT.OUTTGL = Mask;
    305c:	88 e0       	ldi	r24, 0x08	; 8
    305e:	80 93 07 06 	sts	0x0607, r24
    3062:	23 c0       	rjmp	.+70     	; 0x30aa <LEDTick+0x7a>
            *Action = LED_NO_ACTION;
            break;

        case LED_PULSE:
            if (!(LED_PORT.OUT & Mask)) {
    3064:	80 91 04 06 	lds	r24, 0x0604
    3068:	83 ff       	sbrs	r24, 3
    306a:	12 c0       	rjmp	.+36     	; 0x3090 <LEDTick+0x60>
                LED_PORT.OUTSET = Mask;
            } else {
                LED_PORT.OUTCLR = Mask;
    306c:	88 e0       	ldi	r24, 0x08	; 8
    306e:	80 93 06 06 	sts	0x0606, r24
    3072:	1b c0       	rjmp	.+54     	; 0x30aa <LEDTick+0x7a>
                *Action = LED_NO_ACTION;
            }
            break;

        case LED_BLINK_1X ... LED_BLINK_8X:
            if (++(*BlinkPrescaler) == BLINK_PRESCALER) {
    3074:	90 91 7e 2c 	lds	r25, 0x2C7E
    3078:	9f 5f       	subi	r25, 0xFF	; 255
    307a:	91 30       	cpi	r25, 0x01	; 1
    307c:	19 f0       	breq	.+6      	; 0x3084 <LEDTick+0x54>
    307e:	90 93 7e 2c 	sts	0x2C7E, r25
    3082:	15 c0       	rjmp	.+42     	; 0x30ae <LEDTick+0x7e>
                *BlinkPrescaler = 0;
    3084:	10 92 7e 2c 	sts	0x2C7E, r1

                /* Blink functionality occurs at slower speed than Tick-frequency */
                if (!(LED_PORT.OUT & Mask)) {
    3088:	90 91 04 06 	lds	r25, 0x0604
    308c:	93 fd       	sbrc	r25, 3
    308e:	04 c0       	rjmp	.+8      	; 0x3098 <LEDTick+0x68>
                    /* LED is off, turn it on */
                    LED_PORT.OUTSET = Mask;
    3090:	88 e0       	ldi	r24, 0x08	; 8
    3092:	80 93 05 06 	sts	0x0605, r24
    3096:	0b c0       	rjmp	.+22     	; 0x30ae <LEDTick+0x7e>
                } else {
                    /* LED is on, turn it off and change state */
                    LED_PORT.OUTCLR = Mask;
    3098:	98 e0       	ldi	r25, 0x08	; 8
    309a:	90 93 06 06 	sts	0x0606, r25

                    if (*Action == LED_BLINK_1X) {
    309e:	80 32       	cpi	r24, 0x20	; 32
    30a0:	21 f0       	breq	.+8      	; 0x30aa <LEDTick+0x7a>
                        *Action = LED_NO_ACTION;
                    } else {
                        /* Still some blinks to do. Use the fact that LED_BLINK_XY are ordered sequentially */
                        *Action = *Action - 1;
    30a2:	81 50       	subi	r24, 0x01	; 1
    30a4:	80 93 7c 2c 	sts	0x2C7C, r24
    30a8:	02 c0       	rjmp	.+4      	; 0x30ae <LEDTick+0x7e>
            }
            break;

        default:
            /* Should not happen (TM) */
            *Action = LED_NO_ACTION;
    30aa:	10 92 7c 2c 	sts	0x2C7C, r1
{
    static uint8_t LEDRedBlinkPrescaler = 0;
    static uint8_t LEDGreenBlinkPrescaler = 0;
    uint8_t * BlinkPrescaler = (Action == &LEDGreenAction) ? &LEDGreenBlinkPrescaler : &LEDRedBlinkPrescaler;

    switch (*Action)
    30ae:	80 91 7d 2c 	lds	r24, 0x2C7D
    30b2:	82 31       	cpi	r24, 0x12	; 18
    30b4:	91 f0       	breq	.+36     	; 0x30da <LEDTick+0xaa>
    30b6:	30 f4       	brcc	.+12     	; 0x30c4 <LEDTick+0x94>
    30b8:	80 31       	cpi	r24, 0x10	; 16
    30ba:	c1 f0       	breq	.+48     	; 0x30ec <LEDTick+0xbc>
    30bc:	50 f4       	brcc	.+20     	; 0x30d2 <LEDTick+0xa2>
    30be:	88 23       	and	r24, r24
    30c0:	a9 f1       	breq	.+106    	; 0x312c <LEDTick+0xfc>
    30c2:	32 c0       	rjmp	.+100    	; 0x3128 <LEDTick+0xf8>
    30c4:	83 31       	cpi	r24, 0x13	; 19
    30c6:	69 f0       	breq	.+26     	; 0x30e2 <LEDTick+0xb2>
    30c8:	90 ee       	ldi	r25, 0xE0	; 224
    30ca:	98 0f       	add	r25, r24
    30cc:	98 30       	cpi	r25, 0x08	; 8
    30ce:	88 f0       	brcs	.+34     	; 0x30f2 <LEDTick+0xc2>
    30d0:	2b c0       	rjmp	.+86     	; 0x3128 <LEDTick+0xf8>
            LED_PORT.OUTCLR = Mask;
            *Action = LED_NO_ACTION;
            break;

        case LED_ON:
            LED_PORT.OUTSET = Mask;
    30d2:	80 e1       	ldi	r24, 0x10	; 16
    30d4:	80 93 05 06 	sts	0x0605, r24
    30d8:	27 c0       	rjmp	.+78     	; 0x3128 <LEDTick+0xf8>
            *Action = LED_NO_ACTION;
            break;

        case LED_TOGGLE:
            LED_PORT.OUTTGL = Mask;
    30da:	80 e1       	ldi	r24, 0x10	; 16
    30dc:	80 93 07 06 	sts	0x0607, r24
    30e0:	23 c0       	rjmp	.+70     	; 0x3128 <LEDTick+0xf8>
            *Action = LED_NO_ACTION;
            break;

        case LED_PULSE:
            if (!(LED_PORT.OUT & Mask)) {
    30e2:	80 91 04 06 	lds	r24, 0x0604
    30e6:	84 ff       	sbrs	r24, 4
    30e8:	12 c0       	rjmp	.+36     	; 0x310e <LEDTick+0xde>
                LED_PORT.OUTSET = Mask;
            } else {
                LED_PORT.OUTCLR = Mask;
    30ea:	80 e1       	ldi	r24, 0x10	; 16
    30ec:	80 93 06 06 	sts	0x0606, r24
    30f0:	1b c0       	rjmp	.+54     	; 0x3128 <LEDTick+0xf8>
                *Action = LED_NO_ACTION;
            }
            break;

        case LED_BLINK_1X ... LED_BLINK_8X:
            if (++(*BlinkPrescaler) == BLINK_PRESCALER) {
    30f2:	90 91 7f 2c 	lds	r25, 0x2C7F
    30f6:	9f 5f       	subi	r25, 0xFF	; 255
    30f8:	91 30       	cpi	r25, 0x01	; 1
    30fa:	19 f0       	breq	.+6      	; 0x3102 <LEDTick+0xd2>
    30fc:	90 93 7f 2c 	sts	0x2C7F, r25
    3100:	08 95       	ret
                *BlinkPrescaler = 0;
    3102:	10 92 7f 2c 	sts	0x2C7F, r1

                /* Blink functionality occurs at slower speed than Tick-frequency */
                if (!(LED_PORT.OUT & Mask)) {
    3106:	90 91 04 06 	lds	r25, 0x0604
    310a:	94 fd       	sbrc	r25, 4
    310c:	04 c0       	rjmp	.+8      	; 0x3116 <LEDTick+0xe6>
                    /* LED is off, turn it on */
                    LED_PORT.OUTSET = Mask;
    310e:	80 e1       	ldi	r24, 0x10	; 16
    3110:	80 93 05 06 	sts	0x0605, r24
    3114:	08 95       	ret
                } else {
                    /* LED is on, turn it off and change state */
                    LED_PORT.OUTCLR = Mask;
    3116:	90 e1       	ldi	r25, 0x10	; 16
    3118:	90 93 06 06 	sts	0x0606, r25

                    if (*Action == LED_BLINK_1X) {
    311c:	80 32       	cpi	r24, 0x20	; 32
    311e:	21 f0       	breq	.+8      	; 0x3128 <LEDTick+0xf8>
                        *Action = LED_NO_ACTION;
                    } else {
                        /* Still some blinks to do. Use the fact that LED_BLINK_XY are ordered sequentially */
                        *Action = *Action - 1;
    3120:	81 50       	subi	r24, 0x01	; 1
    3122:	80 93 7d 2c 	sts	0x2C7D, r24
    3126:	08 95       	ret
            }
            break;

        default:
            /* Should not happen (TM) */
            *Action = LED_NO_ACTION;
    3128:	10 92 7d 2c 	sts	0x2C7D, r1
    312c:	08 95       	ret

0000312e <LEDGetFuncList>:
    Tick(LED_RED, &LEDRedAction);
    Tick(LED_GREEN, &LEDGreenAction);
}

void LEDGetFuncList(char* List, uint16_t BufferSize)
{
    312e:	9b 01       	movw	r18, r22
    MapToString(LEDFunctionMap, ARRAY_COUNT(LEDFunctionMap), List, BufferSize);
    3130:	ac 01       	movw	r20, r24
    3132:	6b e0       	ldi	r22, 0x0B	; 11
    3134:	88 e8       	ldi	r24, 0x88	; 136
    3136:	99 e0       	ldi	r25, 0x09	; 9
    3138:	9b c0       	rjmp	.+310    	; 0x3270 <MapToString>

0000313a <LEDSetFuncById>:
}

void LEDSetFuncById(uint8_t Mask, LEDHookEnum Function)
{
    313a:	20 e0       	ldi	r18, 0x00	; 0
    313c:	30 e0       	ldi	r19, 0x00	; 0
        GlobalSettings.ActiveSettingPtr->LEDRedFunction = Function;
    }
#else
    /* Write LED func to all settings when using global settings */
    for (uint8_t i=0; i<SETTINGS_COUNT; i++) {
        if (Mask & LED_GREEN) {
    313e:	98 2f       	mov	r25, r24
    3140:	90 71       	andi	r25, 0x10	; 16
            GlobalSettings.Settings[i].LEDGreenFunction = Function;
        }

        if (Mask & LED_RED) {
    3142:	88 70       	andi	r24, 0x08	; 8
        GlobalSettings.ActiveSettingPtr->LEDRedFunction = Function;
    }
#else
    /* Write LED func to all settings when using global settings */
    for (uint8_t i=0; i<SETTINGS_COUNT; i++) {
        if (Mask & LED_GREEN) {
    3144:	99 23       	and	r25, r25
    3146:	21 f0       	breq	.+8      	; 0x3150 <LEDSetFuncById+0x16>
    3148:	f9 01       	movw	r30, r18
    314a:	e0 59       	subi	r30, 0x90	; 144
    314c:	f0 4d       	sbci	r31, 0xD0	; 208
            GlobalSettings.Settings[i].LEDGreenFunction = Function;
    314e:	62 87       	std	Z+10, r22	; 0x0a
        }

        if (Mask & LED_RED) {
    3150:	88 23       	and	r24, r24
    3152:	21 f0       	breq	.+8      	; 0x315c <LEDSetFuncById+0x22>
    3154:	f9 01       	movw	r30, r18
    3156:	e0 59       	subi	r30, 0x90	; 144
    3158:	f0 4d       	sbci	r31, 0xD0	; 208
            GlobalSettings.Settings[i].LEDRedFunction = Function;
    315a:	61 87       	std	Z+9, r22	; 0x09
    315c:	24 5f       	subi	r18, 0xF4	; 244
    315e:	3f 4f       	sbci	r19, 0xFF	; 255
    if (Mask & LED_RED) {
        GlobalSettings.ActiveSettingPtr->LEDRedFunction = Function;
    }
#else
    /* Write LED func to all settings when using global settings */
    for (uint8_t i=0; i<SETTINGS_COUNT; i++) {
    3160:	20 36       	cpi	r18, 0x60	; 96
    3162:	31 05       	cpc	r19, r1
    3164:	79 f7       	brne	.-34     	; 0x3144 <LEDSetFuncById+0xa>
        }
    }
#endif

    /* Clear modified LED and remove any pending actions */
    if (Mask & LED_GREEN) {
    3166:	99 23       	and	r25, r25
    3168:	29 f0       	breq	.+10     	; 0x3174 <LEDSetFuncById+0x3a>
        LED_PORT.OUTCLR = LED_GREEN;
    316a:	90 e1       	ldi	r25, 0x10	; 16
    316c:	90 93 06 06 	sts	0x0606, r25
        LEDGreenAction = LED_NO_ACTION;
    3170:	10 92 7d 2c 	sts	0x2C7D, r1
    }

    if (Mask & LED_RED) {
    3174:	88 23       	and	r24, r24
    3176:	29 f0       	breq	.+10     	; 0x3182 <LEDSetFuncById+0x48>
        LED_PORT.OUTCLR = LED_RED;
    3178:	88 e0       	ldi	r24, 0x08	; 8
    317a:	80 93 06 06 	sts	0x0606, r24
        LEDRedAction = LED_NO_ACTION;
    317e:	10 92 7c 2c 	sts	0x2C7C, r1
    3182:	08 95       	ret

00003184 <LEDGetFuncByName>:
    }

}

void LEDGetFuncByName(uint8_t Mask, char* Function, uint16_t BufferSize)
{
    3184:	0f 93       	push	r16
    3186:	1f 93       	push	r17
    3188:	9b 01       	movw	r18, r22
    318a:	8a 01       	movw	r16, r20
    if (Mask == LED_GREEN) {
    318c:	80 31       	cpi	r24, 0x10	; 16
    318e:	31 f4       	brne	.+12     	; 0x319c <LEDGetFuncByName+0x18>
        MapIdToText(LEDFunctionMap, ARRAY_COUNT(LEDFunctionMap),
                GlobalSettings.ActiveSettingPtr->LEDGreenFunction, Function, BufferSize);
    3190:	e0 91 71 2f 	lds	r30, 0x2F71
    3194:	f0 91 72 2f 	lds	r31, 0x2F72
}

void LEDGetFuncByName(uint8_t Mask, char* Function, uint16_t BufferSize)
{
    if (Mask == LED_GREEN) {
        MapIdToText(LEDFunctionMap, ARRAY_COUNT(LEDFunctionMap),
    3198:	47 81       	ldd	r20, Z+7	; 0x07
    319a:	07 c0       	rjmp	.+14     	; 0x31aa <LEDGetFuncByName+0x26>
                GlobalSettings.ActiveSettingPtr->LEDGreenFunction, Function, BufferSize);
    } else if (Mask == LED_RED) {
    319c:	88 30       	cpi	r24, 0x08	; 8
    319e:	49 f4       	brne	.+18     	; 0x31b2 <LEDGetFuncByName+0x2e>
        MapIdToText(LEDFunctionMap, ARRAY_COUNT(LEDFunctionMap),
                GlobalSettings.ActiveSettingPtr->LEDRedFunction, Function, BufferSize);
    31a0:	e0 91 71 2f 	lds	r30, 0x2F71
    31a4:	f0 91 72 2f 	lds	r31, 0x2F72
{
    if (Mask == LED_GREEN) {
        MapIdToText(LEDFunctionMap, ARRAY_COUNT(LEDFunctionMap),
                GlobalSettings.ActiveSettingPtr->LEDGreenFunction, Function, BufferSize);
    } else if (Mask == LED_RED) {
        MapIdToText(LEDFunctionMap, ARRAY_COUNT(LEDFunctionMap),
    31a8:	46 81       	ldd	r20, Z+6	; 0x06
    31aa:	6b e0       	ldi	r22, 0x0B	; 11
    31ac:	88 e8       	ldi	r24, 0x88	; 136
    31ae:	99 e0       	ldi	r25, 0x09	; 9
    31b0:	20 d0       	rcall	.+64     	; 0x31f2 <MapIdToText>
                GlobalSettings.ActiveSettingPtr->LEDRedFunction, Function, BufferSize);
    }
}
    31b2:	1f 91       	pop	r17
    31b4:	0f 91       	pop	r16
    31b6:	08 95       	ret

000031b8 <LEDSetFuncByName>:

bool LEDSetFuncByName(uint8_t Mask, const char* Function)
{
    31b8:	0f 93       	push	r16
    31ba:	1f 93       	push	r17
    31bc:	cf 93       	push	r28
    31be:	df 93       	push	r29
    31c0:	1f 92       	push	r1
    31c2:	cd b7       	in	r28, 0x3d	; 61
    31c4:	de b7       	in	r29, 0x3e	; 62
    31c6:	08 2f       	mov	r16, r24
    31c8:	ab 01       	movw	r20, r22
    MapIdType Id;

    if (MapTextToId(LEDFunctionMap, ARRAY_COUNT(LEDFunctionMap), Function, &Id)) {
    31ca:	9e 01       	movw	r18, r28
    31cc:	2f 5f       	subi	r18, 0xFF	; 255
    31ce:	3f 4f       	sbci	r19, 0xFF	; 255
    31d0:	6b e0       	ldi	r22, 0x0B	; 11
    31d2:	88 e8       	ldi	r24, 0x88	; 136
    31d4:	99 e0       	ldi	r25, 0x09	; 9
    31d6:	25 d0       	rcall	.+74     	; 0x3222 <MapTextToId>
    31d8:	18 2f       	mov	r17, r24
    31da:	88 23       	and	r24, r24
    31dc:	19 f0       	breq	.+6      	; 0x31e4 <LEDSetFuncByName+0x2c>
        LEDSetFuncById(Mask, Id);
    31de:	69 81       	ldd	r22, Y+1	; 0x01
    31e0:	80 2f       	mov	r24, r16
    31e2:	ab df       	rcall	.-170    	; 0x313a <LEDSetFuncById>
        return true;
    } else {
        return false;
    }
}
    31e4:	81 2f       	mov	r24, r17
    31e6:	0f 90       	pop	r0
    31e8:	df 91       	pop	r29
    31ea:	cf 91       	pop	r28
    31ec:	1f 91       	pop	r17
    31ee:	0f 91       	pop	r16
    31f0:	08 95       	ret

000031f2 <MapIdToText>:
#include "Map.h"

bool MapIdToText(const MapEntryType* MapPtr, uint8_t MapSize, MapIdType Id, char* Text, uint16_t MaxBufferSize)
{
    31f2:	0f 93       	push	r16
    31f4:	1f 93       	push	r17
    31f6:	fc 01       	movw	r30, r24
    while (MapSize--) {
    31f8:	66 23       	and	r22, r22
    31fa:	79 f0       	breq	.+30     	; 0x321a <MapIdToText+0x28>
        if (pgm_read_byte(&MapPtr->Id) == Id) {
    31fc:	94 91       	lpm	r25, Z
    31fe:	61 50       	subi	r22, 0x01	; 1
    3200:	94 13       	cpse	r25, r20
    3202:	09 c0       	rjmp	.+18     	; 0x3216 <MapIdToText+0x24>
            strncpy_P(Text, MapPtr->Text, MaxBufferSize);
    3204:	bf 01       	movw	r22, r30
    3206:	6f 5f       	subi	r22, 0xFF	; 255
    3208:	7f 4f       	sbci	r23, 0xFF	; 255
    320a:	a8 01       	movw	r20, r16
    320c:	c9 01       	movw	r24, r18
    320e:	0e 94 cb 65 	call	0xcb96	; 0xcb96 <strncpy_P>
            return true;
    3212:	81 e0       	ldi	r24, 0x01	; 1
    3214:	03 c0       	rjmp	.+6      	; 0x321c <MapIdToText+0x2a>
        }

        MapPtr++;
    3216:	b1 96       	adiw	r30, 0x21	; 33
    3218:	ef cf       	rjmp	.-34     	; 0x31f8 <MapIdToText+0x6>
    }

    return false;
    321a:	80 e0       	ldi	r24, 0x00	; 0
}
    321c:	1f 91       	pop	r17
    321e:	0f 91       	pop	r16
    3220:	08 95       	ret

00003222 <MapTextToId>:

bool MapTextToId(const MapEntryType* MapPtr, uint8_t MapSize, MapTextPtrType Text, MapIdType* IdPtr)
{
    3222:	cf 92       	push	r12
    3224:	df 92       	push	r13
    3226:	ef 92       	push	r14
    3228:	ff 92       	push	r15
    322a:	1f 93       	push	r17
    322c:	cf 93       	push	r28
    322e:	df 93       	push	r29
    3230:	ec 01       	movw	r28, r24
    3232:	7a 01       	movw	r14, r20
    3234:	69 01       	movw	r12, r18
    while (MapSize--) {
    3236:	16 2f       	mov	r17, r22
    3238:	11 23       	and	r17, r17
    323a:	89 f0       	breq	.+34     	; 0x325e <MapTextToId+0x3c>
    323c:	be 01       	movw	r22, r28
    323e:	6f 5f       	subi	r22, 0xFF	; 255
    3240:	7f 4f       	sbci	r23, 0xFF	; 255
        if (strcmp_P(Text, MapPtr->Text) == 0) {
    3242:	c7 01       	movw	r24, r14
    3244:	0e 94 c2 65 	call	0xcb84	; 0xcb84 <strcmp_P>
    3248:	11 50       	subi	r17, 0x01	; 1
    324a:	89 2b       	or	r24, r25
    324c:	31 f4       	brne	.+12     	; 0x325a <MapTextToId+0x38>
            if (sizeof(MapIdType) == 1) {
                *IdPtr = pgm_read_byte(&MapPtr->Id);
    324e:	fe 01       	movw	r30, r28
    3250:	c4 91       	lpm	r28, Z
    3252:	f6 01       	movw	r30, r12
    3254:	c0 83       	st	Z, r28
            } else if (sizeof(MapIdType) == 2) {
                *IdPtr = pgm_read_word(&MapPtr->Id);
            }
            return true;
    3256:	81 e0       	ldi	r24, 0x01	; 1
    3258:	03 c0       	rjmp	.+6      	; 0x3260 <MapTextToId+0x3e>
        }

        MapPtr++;
    325a:	a1 96       	adiw	r28, 0x21	; 33
    325c:	ed cf       	rjmp	.-38     	; 0x3238 <MapTextToId+0x16>
    }

    return false;
    325e:	80 e0       	ldi	r24, 0x00	; 0
}
    3260:	df 91       	pop	r29
    3262:	cf 91       	pop	r28
    3264:	1f 91       	pop	r17
    3266:	ff 90       	pop	r15
    3268:	ef 90       	pop	r14
    326a:	df 90       	pop	r13
    326c:	cf 90       	pop	r12
    326e:	08 95       	ret

00003270 <MapToString>:

void MapToString(MapEntryType* MapPtr, uint8_t MapSize, char* String, uint16_t MaxBufferSize)
{
    3270:	cf 93       	push	r28
    3272:	01 96       	adiw	r24, 0x01	; 1
            /* More than one map entries left */
            if (BytesLeft == 0) {
                return;
            }

            *String++ = ',';
    3274:	cc e2       	ldi	r28, 0x2C	; 44
void MapToString(MapEntryType* MapPtr, uint8_t MapSize, char* String, uint16_t MaxBufferSize)
{
    uint8_t EntriesLeft = MapSize;
    uint16_t BytesLeft = MaxBufferSize;

    while (EntriesLeft > 0) {
    3276:	66 23       	and	r22, r22
    3278:	c9 f0       	breq	.+50     	; 0x32ac <MapToString+0x3c>
        const char* Text = MapPtr->Text;
    327a:	fc 01       	movw	r30, r24
    327c:	da 01       	movw	r26, r20
    327e:	ad 01       	movw	r20, r26
        char c;

        while( (c = pgm_read_byte(Text)) != '\0') {
    3280:	74 91       	lpm	r23, Z
    3282:	77 23       	and	r23, r23
    3284:	41 f0       	breq	.+16     	; 0x3296 <MapToString+0x26>
            if (BytesLeft == 0) {
    3286:	21 15       	cp	r18, r1
    3288:	31 05       	cpc	r19, r1
    328a:	a1 f0       	breq	.+40     	; 0x32b4 <MapToString+0x44>
                return;
            }

            *String++ = c;
    328c:	7d 93       	st	X+, r23
            Text++;
    328e:	31 96       	adiw	r30, 0x01	; 1
            BytesLeft--;
    3290:	21 50       	subi	r18, 0x01	; 1
    3292:	31 09       	sbc	r19, r1
    3294:	f4 cf       	rjmp	.-24     	; 0x327e <MapToString+0xe>
        }

        if (EntriesLeft > 1) {
    3296:	62 30       	cpi	r22, 0x02	; 2
    3298:	30 f0       	brcs	.+12     	; 0x32a6 <MapToString+0x36>
            /* More than one map entries left */
            if (BytesLeft == 0) {
    329a:	21 15       	cp	r18, r1
    329c:	31 05       	cpc	r19, r1
    329e:	51 f0       	breq	.+20     	; 0x32b4 <MapToString+0x44>
                return;
            }

            *String++ = ',';
    32a0:	4f 5f       	subi	r20, 0xFF	; 255
    32a2:	5f 4f       	sbci	r21, 0xFF	; 255
    32a4:	cc 93       	st	X, r28
        }

        MapPtr++;
        EntriesLeft--;
    32a6:	61 50       	subi	r22, 0x01	; 1
    32a8:	81 96       	adiw	r24, 0x21	; 33
    32aa:	e5 cf       	rjmp	.-54     	; 0x3276 <MapToString+0x6>
    }

    /* Terminate string */
    if (BytesLeft > 0) {
    32ac:	23 2b       	or	r18, r19
    32ae:	11 f0       	breq	.+4      	; 0x32b4 <MapToString+0x44>
        *String++ = '\0';
    32b0:	fa 01       	movw	r30, r20
    32b2:	10 82       	st	Z, r1
        BytesLeft--;
    }
}
    32b4:	cf 91       	pop	r28
    32b6:	08 95       	ret

000032b8 <AntennaLevelTick>:
}

static inline
uint16_t AntennaLevelGet(void)
{
    ADCA.CH0.CTRL |= ADC_CH_START_bm;
    32b8:	80 91 20 02 	lds	r24, 0x0220
    32bc:	80 68       	ori	r24, 0x80	; 128
    32be:	80 93 20 02 	sts	0x0220, r24
    while( !(ADCA.CH0.INTFLAGS & ADC_CH_CHIF_bm) );
    32c2:	80 91 23 02 	lds	r24, 0x0223
    32c6:	80 ff       	sbrs	r24, 0
    32c8:	fc cf       	rjmp	.-8      	; 0x32c2 <AntennaLevelTick+0xa>

    ADCA.CH0.INTFLAGS = ADC_CH_CHIF_bm;
    32ca:	81 e0       	ldi	r24, 0x01	; 1
    32cc:	80 93 23 02 	sts	0x0223, r24

    int16_t Result = ADCA.CH0RES - ANTENNA_LEVEL_OFFSET;
    32d0:	a0 91 10 02 	lds	r26, 0x0210
    32d4:	b0 91 11 02 	lds	r27, 0x0211
    32d8:	ae 5b       	subi	r26, 0xBE	; 190
    32da:	b1 09       	sbc	r27, r1
    32dc:	b7 ff       	sbrs	r27, 7
    32de:	02 c0       	rjmp	.+4      	; 0x32e4 <AntennaLevelTick+0x2c>
    32e0:	a0 e0       	ldi	r26, 0x00	; 0
    32e2:	b0 e0       	ldi	r27, 0x00	; 0
    if (Result < 0) Result = 0;

    return (uint16_t) (((uint32_t) Result * ANTENNA_LEVEL_NUMERATOR) / ANTENNA_LEVEL_DENOMINATOR);
    32e4:	20 e0       	ldi	r18, 0x00	; 0
    32e6:	38 eb       	ldi	r19, 0xB8	; 184
    32e8:	4b e0       	ldi	r20, 0x0B	; 11
    32ea:	50 e0       	ldi	r21, 0x00	; 0
    32ec:	0e 94 45 65 	call	0xca8a	; 0xca8a <__mulshisi3>
    32f0:	e0 91 71 2f 	lds	r30, 0x2F71
    32f4:	f0 91 72 2f 	lds	r31, 0x2F72

void AntennaLevelTick(void)
{
    uint16_t rssi = AntennaLevelGet();

    if (rssi < FIELD_MIN_RSSI)
    32f8:	61 15       	cp	r22, r1
    32fa:	71 05       	cpc	r23, r1
    32fc:	84 4f       	sbci	r24, 0xF4	; 244
    32fe:	91 40       	sbci	r25, 0x01	; 1
    3300:	a8 f4       	brcc	.+42     	; 0x332c <AntennaLevelTick+0x74>

INLINE void LEDHook(LEDHookEnum Func, LEDActionEnum Action) {
    extern LEDActionEnum LEDGreenAction;
    extern LEDActionEnum LEDRedAction;

    if (GlobalSettings.ActiveSettingPtr->LEDGreenFunction == Func) {
    3302:	87 81       	ldd	r24, Z+7	; 0x07
    3304:	87 30       	cpi	r24, 0x07	; 7
    3306:	19 f4       	brne	.+6      	; 0x330e <AntennaLevelTick+0x56>
        LEDGreenAction = Action;
    3308:	80 e1       	ldi	r24, 0x10	; 16
    330a:	80 93 7d 2c 	sts	0x2C7D, r24
    }

    if (GlobalSettings.ActiveSettingPtr->LEDRedFunction == Func) {
    330e:	86 81       	ldd	r24, Z+6	; 0x06
    3310:	87 30       	cpi	r24, 0x07	; 7
    3312:	19 f4       	brne	.+6      	; 0x331a <AntennaLevelTick+0x62>
        LEDRedAction = Action;
    3314:	80 e1       	ldi	r24, 0x10	; 16
    3316:	80 93 7c 2c 	sts	0x2C7C, r24
    {
        LEDHook(LED_FIELD_DETECTED, LED_OFF);
        if (ActiveConfiguration.UidSize != 0) // this implies that we are emulating right now
    331a:	80 91 6c 2f 	lds	r24, 0x2F6C
    331e:	88 23       	and	r24, r24
    3320:	89 f0       	breq	.+34     	; 0x3344 <AntennaLevelTick+0x8c>
INLINE uint16_t ApplicationProcess(uint8_t* ByteBuffer, uint16_t ByteCount) {
    return ActiveConfiguration.ApplicationProcessFunc(ByteBuffer, ByteCount);
}

INLINE void ApplicationReset(void) {
    ActiveConfiguration.ApplicationResetFunc();
    3322:	e0 91 5e 2f 	lds	r30, 0x2F5E
    3326:	f0 91 5f 2f 	lds	r31, 0x2F5F
    332a:	19 94       	eijmp

INLINE void LEDHook(LEDHookEnum Func, LEDActionEnum Action) {
    extern LEDActionEnum LEDGreenAction;
    extern LEDActionEnum LEDRedAction;

    if (GlobalSettings.ActiveSettingPtr->LEDGreenFunction == Func) {
    332c:	87 81       	ldd	r24, Z+7	; 0x07
    332e:	87 30       	cpi	r24, 0x07	; 7
    3330:	19 f4       	brne	.+6      	; 0x3338 <AntennaLevelTick+0x80>
        LEDGreenAction = Action;
    3332:	81 e1       	ldi	r24, 0x11	; 17
    3334:	80 93 7d 2c 	sts	0x2C7D, r24
    }

    if (GlobalSettings.ActiveSettingPtr->LEDRedFunction == Func) {
    3338:	86 81       	ldd	r24, Z+6	; 0x06
    333a:	87 30       	cpi	r24, 0x07	; 7
    333c:	19 f4       	brne	.+6      	; 0x3344 <AntennaLevelTick+0x8c>
        LEDRedAction = Action;
    333e:	81 e1       	ldi	r24, 0x11	; 17
    3340:	80 93 7c 2c 	sts	0x2C7C, r24
    3344:	08 95       	ret

00003346 <TerminalSendString>:
uint8_t TerminalBuffer[TERMINAL_BUFFER_SIZE];
TerminalStateEnum TerminalState = TERMINAL_UNINITIALIZED;
static uint8_t TerminalInitDelay = INIT_DELAY;

void TerminalSendString(const char* s) {
    CDC_Device_SendString(&TerminalHandle, s);
    3346:	bc 01       	movw	r22, r24
    3348:	83 e0       	ldi	r24, 0x03	; 3
    334a:	90 e2       	ldi	r25, 0x20	; 32
    334c:	0c 94 71 63 	jmp	0xc6e2	; 0xc6e2 <CDC_Device_SendString>

00003350 <TerminalSendStringP>:
}

void TerminalSendStringP(const char* s) {
    3350:	cf 93       	push	r28
    3352:	df 93       	push	r29
    char c;

    while( (c = pgm_read_byte(s++)) != '\0' ) {
    3354:	fc 01       	movw	r30, r24
    3356:	64 91       	lpm	r22, Z
    3358:	ec 01       	movw	r28, r24
    335a:	21 96       	adiw	r28, 0x01	; 1
    335c:	66 23       	and	r22, r22
    335e:	31 f0       	breq	.+12     	; 0x336c <TerminalSendStringP+0x1c>
void EVENT_USB_Device_Connect(void);
void EVENT_USB_Device_Disconnect(void);
void EVENT_USB_Device_ConfigurationChanged(void);
void EVENT_USB_Device_ControlRequest(void);

INLINE void TerminalSendChar(char c) { CDC_Device_SendByte(&TerminalHandle, c); }
    3360:	83 e0       	ldi	r24, 0x03	; 3
    3362:	90 e2       	ldi	r25, 0x20	; 32
    3364:	0e 94 bf 63 	call	0xc77e	; 0xc77e <CDC_Device_SendByte>
    3368:	ce 01       	movw	r24, r28
    336a:	f4 cf       	rjmp	.-24     	; 0x3354 <TerminalSendStringP+0x4>
        TerminalSendChar(c);
    }
}
    336c:	df 91       	pop	r29
    336e:	cf 91       	pop	r28
    3370:	08 95       	ret

00003372 <TerminalSendBlock>:

*/


void TerminalSendBlock(const void* Buffer, uint16_t ByteCount)
{
    3372:	ab 01       	movw	r20, r22
    CDC_Device_SendData(&TerminalHandle, Buffer, ByteCount);
    3374:	bc 01       	movw	r22, r24
    3376:	83 e0       	ldi	r24, 0x03	; 3
    3378:	90 e2       	ldi	r25, 0x20	; 32
    337a:	0c 94 9b 63 	jmp	0xc736	; 0xc736 <CDC_Device_SendData>

0000337e <TerminalInit>:
    }
}

void TerminalInit(void)
{
    TERMINAL_VBUS_PORT.DIRCLR = TERMINAL_VBUS_MASK;
    337e:	80 e2       	ldi	r24, 0x20	; 32
    3380:	80 93 62 06 	sts	0x0662, r24
    3384:	08 95       	ret

00003386 <TerminalTask>:
}

void TerminalTask(void)
{
    3386:	cf 93       	push	r28
    3388:	df 93       	push	r29
    if (TerminalState == TERMINAL_INITIALIZED) {
    338a:	80 91 80 2c 	lds	r24, 0x2C80
    338e:	82 30       	cpi	r24, 0x02	; 2
    3390:	31 f5       	brne	.+76     	; 0x33de <TerminalTask+0x58>
        CDC_Device_USBTask(&TerminalHandle);
    3392:	83 e0       	ldi	r24, 0x03	; 3
    3394:	90 e2       	ldi	r25, 0x20	; 32
    3396:	0e 94 24 64 	call	0xc848	; 0xc848 <CDC_Device_USBTask>
        USB_USBTask();
    339a:	0e 94 f3 5e 	call	0xbde6	; 0xbde6 <USB_USBTask>
    CDC_Device_SendData(&TerminalHandle, Buffer, ByteCount);
}


static void ProcessByte(void) {
    int16_t Byte = CDC_Device_ReceiveByte(&TerminalHandle);
    339e:	83 e0       	ldi	r24, 0x03	; 3
    33a0:	90 e2       	ldi	r25, 0x20	; 32
    33a2:	0e 94 40 64 	call	0xc880	; 0xc880 <CDC_Device_ReceiveByte>
    33a6:	ec 01       	movw	r28, r24

    if (Byte >= 0) {
    33a8:	97 fd       	sbrc	r25, 7
    33aa:	19 c0       	rjmp	.+50     	; 0x33de <TerminalTask+0x58>

INLINE void LEDHook(LEDHookEnum Func, LEDActionEnum Action) {
    extern LEDActionEnum LEDGreenAction;
    extern LEDActionEnum LEDRedAction;

    if (GlobalSettings.ActiveSettingPtr->LEDGreenFunction == Func) {
    33ac:	e0 91 71 2f 	lds	r30, 0x2F71
    33b0:	f0 91 72 2f 	lds	r31, 0x2F72
    33b4:	87 81       	ldd	r24, Z+7	; 0x07
    33b6:	83 30       	cpi	r24, 0x03	; 3
    33b8:	19 f4       	brne	.+6      	; 0x33c0 <TerminalTask+0x3a>
        LEDGreenAction = Action;
    33ba:	83 e1       	ldi	r24, 0x13	; 19
    33bc:	80 93 7d 2c 	sts	0x2C7D, r24
    }

    if (GlobalSettings.ActiveSettingPtr->LEDRedFunction == Func) {
    33c0:	86 81       	ldd	r24, Z+6	; 0x06
    33c2:	83 30       	cpi	r24, 0x03	; 3
    33c4:	19 f4       	brne	.+6      	; 0x33cc <TerminalTask+0x46>
        LEDRedAction = Action;
    33c6:	83 e1       	ldi	r24, 0x13	; 19
    33c8:	80 93 7c 2c 	sts	0x2C7C, r24
        /* Byte received */
        LEDHook(LED_TERMINAL_RXTX, LED_PULSE);

        if (XModemProcessByte(Byte)) {
    33cc:	8c 2f       	mov	r24, r28
    33ce:	6d d6       	rcall	.+3290   	; 0x40aa <XModemProcessByte>
    33d0:	81 11       	cpse	r24, r1
    33d2:	05 c0       	rjmp	.+10     	; 0x33de <TerminalTask+0x58>
            /* XModem handled the byte */
        } else if (CommandLineProcessByte(Byte)) {
    33d4:	8c 2f       	mov	r24, r28
        CDC_Device_USBTask(&TerminalHandle);
        USB_USBTask();

        ProcessByte();
    }
}
    33d6:	df 91       	pop	r29
    33d8:	cf 91       	pop	r28
        /* Byte received */
        LEDHook(LED_TERMINAL_RXTX, LED_PULSE);

        if (XModemProcessByte(Byte)) {
            /* XModem handled the byte */
        } else if (CommandLineProcessByte(Byte)) {
    33da:	0c 94 f9 21 	jmp	0x43f2	; 0x43f2 <CommandLineProcessByte>
        CDC_Device_USBTask(&TerminalHandle);
        USB_USBTask();

        ProcessByte();
    }
}
    33de:	df 91       	pop	r29
    33e0:	cf 91       	pop	r28
    33e2:	08 95       	ret

000033e4 <TerminalTick>:
    }
}

static void SenseVBus(void)
{
    switch(TerminalState) {
    33e4:	80 91 80 2c 	lds	r24, 0x2C80
    33e8:	81 30       	cpi	r24, 0x01	; 1
    33ea:	79 f0       	breq	.+30     	; 0x340a <TerminalTick+0x26>
    33ec:	28 f0       	brcs	.+10     	; 0x33f8 <TerminalTick+0x14>
    33ee:	82 30       	cpi	r24, 0x02	; 2
    33f0:	d9 f0       	breq	.+54     	; 0x3428 <TerminalTick+0x44>
    33f2:	83 30       	cpi	r24, 0x03	; 3
    33f4:	11 f1       	breq	.+68     	; 0x343a <TerminalTick+0x56>
    33f6:	2e c0       	rjmp	.+92     	; 0x3454 <TerminalTick+0x70>
    case TERMINAL_UNINITIALIZED:
        if (TERMINAL_VBUS_PORT.IN & TERMINAL_VBUS_MASK) {
    33f8:	80 91 68 06 	lds	r24, 0x0668
    33fc:	85 ff       	sbrs	r24, 5
    33fe:	2a c0       	rjmp	.+84     	; 0x3454 <TerminalTick+0x70>
            /* Not initialized and VBUS sense high */
            TerminalInitDelay = INIT_DELAY;
    3400:	8f e0       	ldi	r24, 0x0F	; 15
    3402:	80 93 02 20 	sts	0x2002, r24
            TerminalState = TERMINAL_INITIALIZING;
    3406:	81 e0       	ldi	r24, 0x01	; 1
    3408:	0c c0       	rjmp	.+24     	; 0x3422 <TerminalTick+0x3e>
        }
    break;

    case TERMINAL_INITIALIZING:
        if (--TerminalInitDelay == 0) {
    340a:	80 91 02 20 	lds	r24, 0x2002
    340e:	81 50       	subi	r24, 0x01	; 1
    3410:	80 93 02 20 	sts	0x2002, r24
    3414:	81 11       	cpse	r24, r1
    3416:	1e c0       	rjmp	.+60     	; 0x3454 <TerminalTick+0x70>
            SystemStartUSBClock();
    3418:	0e 94 06 0e 	call	0x1c0c	; 0x1c0c <SystemStartUSBClock>
            USB_Init();
    341c:	0e 94 9e 62 	call	0xc53c	; 0xc53c <USB_Init>
            TerminalState = TERMINAL_INITIALIZED;
    3420:	82 e0       	ldi	r24, 0x02	; 2
    3422:	80 93 80 2c 	sts	0x2C80, r24
    3426:	16 c0       	rjmp	.+44     	; 0x3454 <TerminalTick+0x70>
        }
        break;

    case TERMINAL_INITIALIZED:
        if (!(TERMINAL_VBUS_PORT.IN & TERMINAL_VBUS_MASK)) {
    3428:	80 91 68 06 	lds	r24, 0x0668
    342c:	85 fd       	sbrc	r24, 5
    342e:	12 c0       	rjmp	.+36     	; 0x3454 <TerminalTick+0x70>
            /* Initialized and VBUS sense low */
            TerminalInitDelay = INIT_DELAY;
    3430:	8f e0       	ldi	r24, 0x0F	; 15
    3432:	80 93 02 20 	sts	0x2002, r24
            TerminalState = TERMINAL_UNITIALIZING;
    3436:	83 e0       	ldi	r24, 0x03	; 3
    3438:	f4 cf       	rjmp	.-24     	; 0x3422 <TerminalTick+0x3e>
        }
        break;

    case TERMINAL_UNITIALIZING:
        if (--TerminalInitDelay == 0) {
    343a:	80 91 02 20 	lds	r24, 0x2002
    343e:	81 50       	subi	r24, 0x01	; 1
    3440:	80 93 02 20 	sts	0x2002, r24
    3444:	81 11       	cpse	r24, r1
    3446:	06 c0       	rjmp	.+12     	; 0x3454 <TerminalTick+0x70>
            USB_Disable();
    3448:	0e 94 63 62 	call	0xc4c6	; 0xc4c6 <USB_Disable>
            SystemStopUSBClock();
    344c:	0e 94 34 0e 	call	0x1c68	; 0x1c68 <SystemStopUSBClock>
            TerminalState = TERMINAL_UNINITIALIZED;
    3450:	10 92 80 2c 	sts	0x2C80, r1

void TerminalTick(void)
{
    SenseVBus();

    if (TerminalState == TERMINAL_INITIALIZED) {
    3454:	80 91 80 2c 	lds	r24, 0x2C80
    3458:	82 30       	cpi	r24, 0x02	; 2
    345a:	19 f4       	brne	.+6      	; 0x3462 <TerminalTick+0x7e>
        XModemTick();
    345c:	76 d7       	rcall	.+3820   	; 0x434a <XModemTick>
        CommandLineTick();
    345e:	0c 94 fb 22 	jmp	0x45f6	; 0x45f6 <CommandLineTick>
    3462:	08 95       	ret

00003464 <EVENT_USB_Device_Connect>:

INLINE void LEDHook(LEDHookEnum Func, LEDActionEnum Action) {
    extern LEDActionEnum LEDGreenAction;
    extern LEDActionEnum LEDRedAction;

    if (GlobalSettings.ActiveSettingPtr->LEDGreenFunction == Func) {
    3464:	e0 91 71 2f 	lds	r30, 0x2F71
    3468:	f0 91 72 2f 	lds	r31, 0x2F72
    346c:	87 81       	ldd	r24, Z+7	; 0x07
    346e:	82 30       	cpi	r24, 0x02	; 2
    3470:	19 f4       	brne	.+6      	; 0x3478 <EVENT_USB_Device_Connect+0x14>
        LEDGreenAction = Action;
    3472:	81 e1       	ldi	r24, 0x11	; 17
    3474:	80 93 7d 2c 	sts	0x2C7D, r24
    }

    if (GlobalSettings.ActiveSettingPtr->LEDRedFunction == Func) {
    3478:	86 81       	ldd	r24, Z+6	; 0x06
    347a:	82 30       	cpi	r24, 0x02	; 2
    347c:	19 f4       	brne	.+6      	; 0x3484 <EVENT_USB_Device_Connect+0x20>
        LEDRedAction = Action;
    347e:	81 e1       	ldi	r24, 0x11	; 17
    3480:	80 93 7c 2c 	sts	0x2C7C, r24
    3484:	08 95       	ret

00003486 <EVENT_USB_Device_Disconnect>:

INLINE void LEDHook(LEDHookEnum Func, LEDActionEnum Action) {
    extern LEDActionEnum LEDGreenAction;
    extern LEDActionEnum LEDRedAction;

    if (GlobalSettings.ActiveSettingPtr->LEDGreenFunction == Func) {
    3486:	e0 91 71 2f 	lds	r30, 0x2F71
    348a:	f0 91 72 2f 	lds	r31, 0x2F72
    348e:	87 81       	ldd	r24, Z+7	; 0x07
    3490:	82 30       	cpi	r24, 0x02	; 2
    3492:	19 f4       	brne	.+6      	; 0x349a <EVENT_USB_Device_Disconnect+0x14>
        LEDGreenAction = Action;
    3494:	80 e1       	ldi	r24, 0x10	; 16
    3496:	80 93 7d 2c 	sts	0x2C7D, r24
    }

    if (GlobalSettings.ActiveSettingPtr->LEDRedFunction == Func) {
    349a:	86 81       	ldd	r24, Z+6	; 0x06
    349c:	82 30       	cpi	r24, 0x02	; 2
    349e:	19 f4       	brne	.+6      	; 0x34a6 <EVENT_USB_Device_Disconnect+0x20>
        LEDRedAction = Action;
    34a0:	80 e1       	ldi	r24, 0x10	; 16
    34a2:	80 93 7c 2c 	sts	0x2C7C, r24
    34a6:	08 95       	ret

000034a8 <EVENT_USB_Device_ConfigurationChanged>:


/** Event handler for the library USB Configuration Changed event. */
void EVENT_USB_Device_ConfigurationChanged(void)
{
    CDC_Device_ConfigureEndpoints(&TerminalHandle);
    34a8:	83 e0       	ldi	r24, 0x03	; 3
    34aa:	90 e2       	ldi	r25, 0x20	; 32
    34ac:	0c 94 4c 63 	jmp	0xc698	; 0xc698 <CDC_Device_ConfigureEndpoints>

000034b0 <EVENT_USB_Device_ControlRequest>:
}

/** Event handler for the library USB Control Request reception event. */
void EVENT_USB_Device_ControlRequest(void)
{
    CDC_Device_ProcessControlRequest(&TerminalHandle);
    34b0:	83 e0       	ldi	r24, 0x03	; 3
    34b2:	90 e2       	ldi	r25, 0x20	; 32
    34b4:	0c 94 93 64 	jmp	0xc926	; 0xc926 <CDC_Device_ProcessControlRequest>

000034b8 <CommandGetVersion>:

extern const PROGMEM CommandEntryType CommandTable[];

CommandStatusIdType CommandGetVersion(char* OutParam)
{
  snprintf_P(OutParam, TERMINAL_BUFFER_SIZE, PSTR(
    34b8:	29 e8       	ldi	r18, 0x89	; 137
    34ba:	3c e0       	ldi	r19, 0x0C	; 12
    34bc:	3f 93       	push	r19
    34be:	2f 93       	push	r18
    34c0:	23 e8       	ldi	r18, 0x83	; 131
    34c2:	3c e0       	ldi	r19, 0x0C	; 12
    34c4:	3f 93       	push	r19
    34c6:	2f 93       	push	r18
    34c8:	2c e7       	ldi	r18, 0x7C	; 124
    34ca:	3c e0       	ldi	r19, 0x0C	; 12
    34cc:	3f 93       	push	r19
    34ce:	2f 93       	push	r18
    34d0:	25 e7       	ldi	r18, 0x75	; 117
    34d2:	3c e0       	ldi	r19, 0x0C	; 12
    34d4:	3f 93       	push	r19
    34d6:	2f 93       	push	r18
    34d8:	25 ed       	ldi	r18, 0xD5	; 213
    34da:	3b e0       	ldi	r19, 0x0B	; 11
    34dc:	3f 93       	push	r19
    34de:	2f 93       	push	r18
    34e0:	22 e0       	ldi	r18, 0x02	; 2
    34e2:	2f 93       	push	r18
    34e4:	1f 92       	push	r1
    34e6:	9f 93       	push	r25
    34e8:	8f 93       	push	r24
    34ea:	0e 94 50 66 	call	0xcca0	; 0xcca0 <snprintf_P>
    "ChameleonMini RevG %S using LUFA %S compiled with AVR-GCC %S. Based on the open-source NFC tool ChameleonMini. https://github.com/emsec/ChameleonMini commit %S"
    ), PSTR(CHAMELEON_MINI_VERSION_STRING), PSTR(LUFA_VERSION_STRING), PSTR(__VERSION__), PSTR(COMMIT_ID)
  );

  return COMMAND_INFO_OK_WITH_TEXT_ID;
    34ee:	8d b7       	in	r24, 0x3d	; 61
    34f0:	9e b7       	in	r25, 0x3e	; 62
    34f2:	0e 96       	adiw	r24, 0x0e	; 14
    34f4:	8d bf       	out	0x3d, r24	; 61
    34f6:	9e bf       	out	0x3e, r25	; 62
}
    34f8:	85 e6       	ldi	r24, 0x65	; 101
    34fa:	08 95       	ret

000034fc <CommandGetConfig>:

CommandStatusIdType CommandGetConfig(char* OutParam)
{
  ConfigurationGetByName(OutParam, TERMINAL_BUFFER_SIZE);
    34fc:	60 e0       	ldi	r22, 0x00	; 0
    34fe:	72 e0       	ldi	r23, 0x02	; 2
    3500:	0e 94 95 0e 	call	0x1d2a	; 0x1d2a <ConfigurationGetByName>

  return COMMAND_INFO_OK_WITH_TEXT_ID;
}
    3504:	85 e6       	ldi	r24, 0x65	; 101
    3506:	08 95       	ret

00003508 <CommandSetConfig>:

CommandStatusIdType CommandSetConfig(char* OutMessage, const char* InParam)
{
    if (COMMAND_IS_SUGGEST_STRING(InParam)) {
    3508:	fb 01       	movw	r30, r22
    350a:	20 81       	ld	r18, Z
    350c:	2f 33       	cpi	r18, 0x3F	; 63
    350e:	49 f4       	brne	.+18     	; 0x3522 <CommandSetConfig+0x1a>
    3510:	21 81       	ldd	r18, Z+1	; 0x01
    3512:	21 11       	cpse	r18, r1
    3514:	06 c0       	rjmp	.+12     	; 0x3522 <CommandSetConfig+0x1a>
        ConfigurationGetList(OutMessage, TERMINAL_BUFFER_SIZE);
    3516:	60 e0       	ldi	r22, 0x00	; 0
    3518:	72 e0       	ldi	r23, 0x02	; 2
    351a:	0e 94 d4 0e 	call	0x1da8	; 0x1da8 <ConfigurationGetList>
        return COMMAND_INFO_OK_WITH_TEXT_ID;
    351e:	85 e6       	ldi	r24, 0x65	; 101
    3520:	08 95       	ret
    } else if (ConfigurationSetByName(InParam)) {
    3522:	cb 01       	movw	r24, r22
    3524:	0e 94 a6 0e 	call	0x1d4c	; 0x1d4c <ConfigurationSetByName>
    3528:	88 23       	and	r24, r24
    352a:	71 f0       	breq	.+28     	; 0x3548 <CommandSetConfig+0x40>
        SETTING_UPDATE(GlobalSettings.ActiveSettingPtr->Configuration);
    352c:	e0 91 71 2f 	lds	r30, 0x2F71
    3530:	f0 91 72 2f 	lds	r31, 0x2F72
    3534:	cf 01       	movw	r24, r30
    3536:	8b 56       	subi	r24, 0x6B	; 107
    3538:	9f 42       	sbci	r25, 0x2F	; 47
#if ENABLE_EEPROM_SETTINGS
    uintptr_t EEAddr = (uintptr_t)addr - (uintptr_t)&GlobalSettings + (uintptr_t)&StoredSettings;
    switch (size)
    {
    case 1:
        eeprom_update_byte((uint8_t *)EEAddr, *(uint8_t*)addr);
    353a:	65 81       	ldd	r22, Z+5	; 0x05
    353c:	8f 5f       	subi	r24, 0xFF	; 255
    353e:	9f 4f       	sbci	r25, 0xFF	; 255
    3540:	0e 94 73 6c 	call	0xd8e6	; 0xd8e6 <eeprom_update_byte>
        return COMMAND_INFO_OK_ID;
    3544:	84 e6       	ldi	r24, 0x64	; 100
    3546:	08 95       	ret
    } else {
        return COMMAND_ERR_INVALID_PARAM_ID;
    3548:	8a ec       	ldi	r24, 0xCA	; 202
    }
}
    354a:	08 95       	ret

0000354c <CommandGetUid>:

CommandStatusIdType CommandGetUid(char* OutParam)
{
    354c:	ef 92       	push	r14
    354e:	ff 92       	push	r15
    3550:	0f 93       	push	r16
    3552:	1f 93       	push	r17
    3554:	cf 93       	push	r28
    3556:	df 93       	push	r29
    3558:	cd b7       	in	r28, 0x3d	; 61
    355a:	de b7       	in	r29, 0x3e	; 62
    355c:	a0 97       	sbiw	r28, 0x20	; 32
    355e:	cd bf       	out	0x3d, r28	; 61
    3560:	de bf       	out	0x3e, r29	; 62
    3562:	7c 01       	movw	r14, r24
  uint8_t UidBuffer[COMMAND_UID_BUFSIZE];
  uint16_t UidSize = ActiveConfiguration.UidSize;
    3564:	00 91 6c 2f 	lds	r16, 0x2F6C
    3568:	10 e0       	ldi	r17, 0x00	; 0

  if (UidSize == 0)
    356a:	01 15       	cp	r16, r1
    356c:	11 05       	cpc	r17, r1
    356e:	91 f4       	brne	.+36     	; 0x3594 <CommandGetUid+0x48>
  {
      snprintf_P(OutParam, TERMINAL_BUFFER_SIZE, PSTR("NO UID."));
    3570:	8d ec       	ldi	r24, 0xCD	; 205
    3572:	9b e0       	ldi	r25, 0x0B	; 11
    3574:	9f 93       	push	r25
    3576:	8f 93       	push	r24
    3578:	82 e0       	ldi	r24, 0x02	; 2
    357a:	8f 93       	push	r24
    357c:	1f 92       	push	r1
    357e:	ff 92       	push	r15
    3580:	ef 92       	push	r14
    3582:	0e 94 50 66 	call	0xcca0	; 0xcca0 <snprintf_P>
      return COMMAND_INFO_OK_WITH_TEXT_ID;
    3586:	0f 90       	pop	r0
    3588:	0f 90       	pop	r0
    358a:	0f 90       	pop	r0
    358c:	0f 90       	pop	r0
    358e:	0f 90       	pop	r0
    3590:	0f 90       	pop	r0
    3592:	10 c0       	rjmp	.+32     	; 0x35b4 <CommandGetUid+0x68>
    ActiveConfiguration.ApplicationResetFunc();
    //LogEntry(LOG_INFO_RESET_APP, NULL, 0);
}

INLINE void ApplicationGetUid(ConfigurationUidType Uid) {
    ActiveConfiguration.ApplicationGetUidFunc(Uid);
    3594:	e0 91 66 2f 	lds	r30, 0x2F66
    3598:	f0 91 67 2f 	lds	r31, 0x2F67
    359c:	ce 01       	movw	r24, r28
    359e:	01 96       	adiw	r24, 0x01	; 1
    35a0:	19 95       	eicall
  }

  ApplicationGetUid(UidBuffer);

  BufferToHexString(OutParam, TERMINAL_BUFFER_SIZE,
    35a2:	98 01       	movw	r18, r16
    35a4:	ae 01       	movw	r20, r28
    35a6:	4f 5f       	subi	r20, 0xFF	; 255
    35a8:	5f 4f       	sbci	r21, 0xFF	; 255
    35aa:	60 e0       	ldi	r22, 0x00	; 0
    35ac:	72 e0       	ldi	r23, 0x02	; 2
    35ae:	c7 01       	movw	r24, r14
    35b0:	0e 94 f8 0e 	call	0x1df0	; 0x1df0 <BufferToHexString>
    UidBuffer, UidSize);

  return COMMAND_INFO_OK_WITH_TEXT_ID;
}
    35b4:	85 e6       	ldi	r24, 0x65	; 101
    35b6:	a0 96       	adiw	r28, 0x20	; 32
    35b8:	cd bf       	out	0x3d, r28	; 61
    35ba:	de bf       	out	0x3e, r29	; 62
    35bc:	df 91       	pop	r29
    35be:	cf 91       	pop	r28
    35c0:	1f 91       	pop	r17
    35c2:	0f 91       	pop	r16
    35c4:	ff 90       	pop	r15
    35c6:	ef 90       	pop	r14
    35c8:	08 95       	ret

000035ca <CommandSetUid>:

CommandStatusIdType CommandSetUid(char* OutMessage, const char* InParam)
{
    35ca:	df 92       	push	r13
    35cc:	ef 92       	push	r14
    35ce:	ff 92       	push	r15
    35d0:	0f 93       	push	r16
    35d2:	1f 93       	push	r17
    35d4:	cf 93       	push	r28
    35d6:	df 93       	push	r29
    35d8:	cd b7       	in	r28, 0x3d	; 61
    35da:	de b7       	in	r29, 0x3e	; 62
    35dc:	a0 97       	sbiw	r28, 0x20	; 32
    35de:	cd bf       	out	0x3d, r28	; 61
    35e0:	de bf       	out	0x3e, r29	; 62
    35e2:	7b 01       	movw	r14, r22
  uint8_t UidBuffer[COMMAND_UID_BUFSIZE];
  uint16_t UidSize = ActiveConfiguration.UidSize;
    35e4:	00 91 6c 2f 	lds	r16, 0x2F6C
    35e8:	10 e0       	ldi	r17, 0x00	; 0

  if (strcmp_P(InParam, PSTR(COMMAND_UID_RANDOM)) == 0) {
    35ea:	66 ec       	ldi	r22, 0xC6	; 198
    35ec:	7b e0       	ldi	r23, 0x0B	; 11
    35ee:	c7 01       	movw	r24, r14
    35f0:	0e 94 c2 65 	call	0xcb84	; 0xcb84 <strcmp_P>
    35f4:	89 2b       	or	r24, r25
    35f6:	29 f5       	brne	.+74     	; 0x3642 <CommandSetUid+0x78>
    35f8:	d1 2c       	mov	r13, r1
    /* Load with random bytes */
    for (uint8_t i=0; i<UidSize; i++) {
    35fa:	ed 2c       	mov	r14, r13
    35fc:	f1 2c       	mov	r15, r1
    35fe:	e0 16       	cp	r14, r16
    3600:	f1 06       	cpc	r15, r17
    3602:	58 f4       	brcc	.+22     	; 0x361a <CommandSetUid+0x50>
      UidBuffer[i] = RandomGetByte();
    3604:	0e 94 dc 0e 	call	0x1db8	; 0x1db8 <RandomGetByte>
    3608:	e1 e0       	ldi	r30, 0x01	; 1
    360a:	f0 e0       	ldi	r31, 0x00	; 0
    360c:	ec 0f       	add	r30, r28
    360e:	fd 1f       	adc	r31, r29
    3610:	ee 0d       	add	r30, r14
    3612:	ff 1d       	adc	r31, r15
    3614:	80 83       	st	Z, r24
  uint8_t UidBuffer[COMMAND_UID_BUFSIZE];
  uint16_t UidSize = ActiveConfiguration.UidSize;

  if (strcmp_P(InParam, PSTR(COMMAND_UID_RANDOM)) == 0) {
    /* Load with random bytes */
    for (uint8_t i=0; i<UidSize; i++) {
    3616:	d3 94       	inc	r13
    3618:	f0 cf       	rjmp	.-32     	; 0x35fa <CommandSetUid+0x30>
}

INLINE void ApplicationSetUid(ConfigurationUidType Uid) {
    ActiveConfiguration.ApplicationSetUidFunc(Uid);
    361a:	e0 91 68 2f 	lds	r30, 0x2F68
    361e:	f0 91 69 2f 	lds	r31, 0x2F69
    3622:	ce 01       	movw	r24, r28
    3624:	01 96       	adiw	r24, 0x01	; 1
    3626:	19 95       	eicall
void LogGetModeByName(char* Mode, uint16_t BufferSize);
void LogGetModeList(char* List, uint16_t BufferSize);
void LogSRAMToFRAM(void);

/* Wrapper function to call current logging function */
INLINE void LogEntry(LogEntryEnum Entry, const void* Data, uint8_t Length) { CurrentLogFunc(Entry, Data, Length); }
    3628:	e0 91 6e 2f 	lds	r30, 0x2F6E
    362c:	f0 91 6f 2f 	lds	r31, 0x2F6F
    3630:	40 91 6c 2f 	lds	r20, 0x2F6C
    3634:	be 01       	movw	r22, r28
    3636:	6f 5f       	subi	r22, 0xFF	; 255
    3638:	7f 4f       	sbci	r23, 0xFF	; 255
    363a:	83 e1       	ldi	r24, 0x13	; 19
    363c:	19 95       	eicall
    }
  }

  ApplicationSetUid(UidBuffer);

  return COMMAND_INFO_OK_ID;
    363e:	84 e6       	ldi	r24, 0x64	; 100
    3640:	0b c0       	rjmp	.+22     	; 0x3658 <CommandSetUid+0x8e>
    for (uint8_t i=0; i<UidSize; i++) {
      UidBuffer[i] = RandomGetByte();
    }
  } else {
    /* Convert to Bytes */
    if (HexStringToBuffer(UidBuffer, sizeof(UidBuffer), InParam) != UidSize) {
    3642:	a7 01       	movw	r20, r14
    3644:	60 e2       	ldi	r22, 0x20	; 32
    3646:	70 e0       	ldi	r23, 0x00	; 0
    3648:	ce 01       	movw	r24, r28
    364a:	01 96       	adiw	r24, 0x01	; 1
    364c:	0e 94 32 0f 	call	0x1e64	; 0x1e64 <HexStringToBuffer>
    3650:	80 17       	cp	r24, r16
    3652:	91 07       	cpc	r25, r17
    3654:	11 f3       	breq	.-60     	; 0x361a <CommandSetUid+0x50>
      /* Malformed input. Abort */
      return COMMAND_ERR_INVALID_PARAM_ID;
    3656:	8a ec       	ldi	r24, 0xCA	; 202
  }

  ApplicationSetUid(UidBuffer);

  return COMMAND_INFO_OK_ID;
}
    3658:	a0 96       	adiw	r28, 0x20	; 32
    365a:	cd bf       	out	0x3d, r28	; 61
    365c:	de bf       	out	0x3e, r29	; 62
    365e:	df 91       	pop	r29
    3660:	cf 91       	pop	r28
    3662:	1f 91       	pop	r17
    3664:	0f 91       	pop	r16
    3666:	ff 90       	pop	r15
    3668:	ef 90       	pop	r14
    366a:	df 90       	pop	r13
    366c:	08 95       	ret

0000366e <CommandGetReadOnly>:

CommandStatusIdType CommandGetReadOnly(char* OutParam)
{
    366e:	fc 01       	movw	r30, r24
  if (ActiveConfiguration.ReadOnly) {
    3670:	80 91 6d 2f 	lds	r24, 0x2F6D
    3674:	88 23       	and	r24, r24
    3676:	11 f0       	breq	.+4      	; 0x367c <CommandGetReadOnly+0xe>
    OutParam[0] = COMMAND_CHAR_TRUE;
    3678:	81 e3       	ldi	r24, 0x31	; 49
    367a:	01 c0       	rjmp	.+2      	; 0x367e <CommandGetReadOnly+0x10>
  } else {
    OutParam[0] = COMMAND_CHAR_FALSE;
    367c:	80 e3       	ldi	r24, 0x30	; 48
    367e:	80 83       	st	Z, r24
  }

  OutParam[1] = '\0';
    3680:	11 82       	std	Z+1, r1	; 0x01

  return COMMAND_INFO_OK_WITH_TEXT_ID;
}
    3682:	85 e6       	ldi	r24, 0x65	; 101
    3684:	08 95       	ret

00003686 <CommandSetReadOnly>:

CommandStatusIdType CommandSetReadOnly(char* OutMessage, const char* InParam)
{
  if (InParam[1] == '\0') {
    3686:	fb 01       	movw	r30, r22
    3688:	21 81       	ldd	r18, Z+1	; 0x01
    368a:	21 11       	cpse	r18, r1
    368c:	27 c0       	rjmp	.+78     	; 0x36dc <CommandSetReadOnly+0x56>
    if (InParam[0] == COMMAND_CHAR_TRUE) {
    368e:	20 81       	ld	r18, Z
    3690:	21 33       	cpi	r18, 0x31	; 49
    3692:	21 f4       	brne	.+8      	; 0x369c <CommandSetReadOnly+0x16>
      ActiveConfiguration.ReadOnly = true;
    3694:	81 e0       	ldi	r24, 0x01	; 1
    3696:	80 93 6d 2f 	sts	0x2F6D, r24
    369a:	04 c0       	rjmp	.+8      	; 0x36a4 <CommandSetReadOnly+0x1e>
      return COMMAND_INFO_OK_ID;
    } else if (InParam[0] == COMMAND_CHAR_FALSE) {
    369c:	20 33       	cpi	r18, 0x30	; 48
    369e:	21 f4       	brne	.+8      	; 0x36a8 <CommandSetReadOnly+0x22>
      ActiveConfiguration.ReadOnly = false;
    36a0:	10 92 6d 2f 	sts	0x2F6D, r1
      return COMMAND_INFO_OK_ID;
    36a4:	84 e6       	ldi	r24, 0x64	; 100
    36a6:	08 95       	ret
    } else if (InParam[0] == COMMAND_CHAR_SUGGEST) {
    36a8:	2f 33       	cpi	r18, 0x3F	; 63
    36aa:	c1 f4       	brne	.+48     	; 0x36dc <CommandSetReadOnly+0x56>
        snprintf_P(OutMessage, TERMINAL_BUFFER_SIZE, PSTR("%c,%c"), COMMAND_CHAR_TRUE, COMMAND_CHAR_FALSE);
    36ac:	1f 92       	push	r1
    36ae:	20 e3       	ldi	r18, 0x30	; 48
    36b0:	2f 93       	push	r18
    36b2:	1f 92       	push	r1
    36b4:	21 e3       	ldi	r18, 0x31	; 49
    36b6:	2f 93       	push	r18
    36b8:	20 ec       	ldi	r18, 0xC0	; 192
    36ba:	3b e0       	ldi	r19, 0x0B	; 11
    36bc:	3f 93       	push	r19
    36be:	2f 93       	push	r18
    36c0:	22 e0       	ldi	r18, 0x02	; 2
    36c2:	2f 93       	push	r18
    36c4:	1f 92       	push	r1
    36c6:	9f 93       	push	r25
    36c8:	8f 93       	push	r24
    36ca:	0e 94 50 66 	call	0xcca0	; 0xcca0 <snprintf_P>
        return COMMAND_INFO_OK_WITH_TEXT_ID;
    36ce:	8d b7       	in	r24, 0x3d	; 61
    36d0:	9e b7       	in	r25, 0x3e	; 62
    36d2:	0a 96       	adiw	r24, 0x0a	; 10
    36d4:	8d bf       	out	0x3d, r24	; 61
    36d6:	9e bf       	out	0x3e, r25	; 62
    36d8:	85 e6       	ldi	r24, 0x65	; 101
    36da:	08 95       	ret
    }
  }

  return COMMAND_ERR_INVALID_PARAM_ID;
    36dc:	8a ec       	ldi	r24, 0xCA	; 202
}
    36de:	08 95       	ret

000036e0 <CommandExecUpload>:

CommandStatusIdType CommandExecUpload(char* OutMessage)
{
    XModemReceive(MemoryUploadBlock);
    36e0:	89 e9       	ldi	r24, 0x99	; 153
    36e2:	91 e1       	ldi	r25, 0x11	; 17
    36e4:	b1 d4       	rcall	.+2402   	; 0x4048 <XModemReceive>
    return COMMAND_INFO_XMODEM_WAIT_ID;
}
    36e6:	8e e6       	ldi	r24, 0x6E	; 110
    36e8:	08 95       	ret

000036ea <CommandExecDownload>:

CommandStatusIdType CommandExecDownload(char* OutMessage)
{
    XModemSend(MemoryDownloadBlock);
    36ea:	89 e1       	ldi	r24, 0x19	; 25
    36ec:	92 e1       	ldi	r25, 0x12	; 18
    36ee:	c7 d4       	rcall	.+2446   	; 0x407e <XModemSend>
    return COMMAND_INFO_XMODEM_WAIT_ID;
}
    36f0:	8e e6       	ldi	r24, 0x6E	; 110
    36f2:	08 95       	ret

000036f4 <CommandExecReset>:
			 *  enumerating the device once attached until \ref USB_Attach() is called.
			 */
			static inline void USB_Detach(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Detach(void)
			{
				USB.CTRLB &= ~USB_ATTACH_bm;
    36f4:	e0 ec       	ldi	r30, 0xC0	; 192
    36f6:	f4 e0       	ldi	r31, 0x04	; 4
    36f8:	81 81       	ldd	r24, Z+1	; 0x01
    36fa:	8e 7f       	andi	r24, 0xFE	; 254
    36fc:	81 83       	std	Z+1, r24	; 0x01

CommandStatusIdType CommandExecReset(char* OutMessage)
{
  USB_Detach();
  USB_Disable();
    36fe:	0e 94 63 62 	call	0xc4c6	; 0xc4c6 <USB_Disable>

  SystemReset();
    3702:	0e 94 fa 0d 	call	0x1bf4	; 0x1bf4 <SystemReset>

  return COMMAND_INFO_OK_ID;
}
    3706:	84 e6       	ldi	r24, 0x64	; 100
    3708:	08 95       	ret

0000370a <CommandExecUpgrade>:
    370a:	e0 ec       	ldi	r30, 0xC0	; 192
    370c:	f4 e0       	ldi	r31, 0x04	; 4
    370e:	81 81       	ldd	r24, Z+1	; 0x01
    3710:	8e 7f       	andi	r24, 0xFE	; 254
    3712:	81 83       	std	Z+1, r24	; 0x01

#ifdef SUPPORT_FIRMWARE_UPGRADE
CommandStatusIdType CommandExecUpgrade(char* OutMessage)
{
  USB_Detach();
  USB_Disable();
    3714:	0e 94 63 62 	call	0xc4c6	; 0xc4c6 <USB_Disable>

  SystemEnterBootloader();
    3718:	0e 94 00 0e 	call	0x1c00	; 0x1c00 <SystemEnterBootloader>

  return COMMAND_INFO_OK_ID;
}
    371c:	84 e6       	ldi	r24, 0x64	; 100
    371e:	08 95       	ret

00003720 <CommandGetMemSize>:
#endif

CommandStatusIdType CommandGetMemSize(char* OutParam)
{
  snprintf_P(OutParam, TERMINAL_BUFFER_SIZE, PSTR("%u"), ActiveConfiguration.MemorySize);
    3720:	e6 e5       	ldi	r30, 0x56	; 86
    3722:	ff e2       	ldi	r31, 0x2F	; 47
    3724:	25 89       	ldd	r18, Z+21	; 0x15
    3726:	2f 93       	push	r18
    3728:	24 89       	ldd	r18, Z+20	; 0x14
    372a:	2f 93       	push	r18
    372c:	2d eb       	ldi	r18, 0xBD	; 189
    372e:	3b e0       	ldi	r19, 0x0B	; 11
    3730:	3f 93       	push	r19
    3732:	2f 93       	push	r18
    3734:	22 e0       	ldi	r18, 0x02	; 2
    3736:	2f 93       	push	r18
    3738:	1f 92       	push	r1
    373a:	9f 93       	push	r25
    373c:	8f 93       	push	r24
    373e:	0e 94 50 66 	call	0xcca0	; 0xcca0 <snprintf_P>

  return COMMAND_INFO_OK_WITH_TEXT_ID;
    3742:	8d b7       	in	r24, 0x3d	; 61
    3744:	9e b7       	in	r25, 0x3e	; 62
    3746:	08 96       	adiw	r24, 0x08	; 8
    3748:	8d bf       	out	0x3d, r24	; 61
    374a:	9e bf       	out	0x3e, r25	; 62
}
    374c:	85 e6       	ldi	r24, 0x65	; 101
    374e:	08 95       	ret

00003750 <CommandGetUidSize>:

CommandStatusIdType CommandGetUidSize(char* OutParam)
{
    snprintf_P(OutParam, TERMINAL_BUFFER_SIZE, PSTR("%u"), ActiveConfiguration.UidSize);
    3750:	20 91 6c 2f 	lds	r18, 0x2F6C
    3754:	1f 92       	push	r1
    3756:	2f 93       	push	r18
    3758:	2a eb       	ldi	r18, 0xBA	; 186
    375a:	3b e0       	ldi	r19, 0x0B	; 11
    375c:	3f 93       	push	r19
    375e:	2f 93       	push	r18
    3760:	22 e0       	ldi	r18, 0x02	; 2
    3762:	2f 93       	push	r18
    3764:	1f 92       	push	r1
    3766:	9f 93       	push	r25
    3768:	8f 93       	push	r24
    376a:	0e 94 50 66 	call	0xcca0	; 0xcca0 <snprintf_P>

    return COMMAND_INFO_OK_WITH_TEXT_ID;
    376e:	8d b7       	in	r24, 0x3d	; 61
    3770:	9e b7       	in	r25, 0x3e	; 62
    3772:	08 96       	adiw	r24, 0x08	; 8
    3774:	8d bf       	out	0x3d, r24	; 61
    3776:	9e bf       	out	0x3e, r25	; 62
}
    3778:	85 e6       	ldi	r24, 0x65	; 101
    377a:	08 95       	ret

0000377c <CommandGetRButton>:

CommandStatusIdType CommandGetRButton(char* OutParam)
{
    ButtonGetActionByName(BUTTON_R_PRESS_SHORT, OutParam, TERMINAL_BUFFER_SIZE);
    377c:	40 e0       	ldi	r20, 0x00	; 0
    377e:	52 e0       	ldi	r21, 0x02	; 2
    3780:	bc 01       	movw	r22, r24
    3782:	80 e0       	ldi	r24, 0x00	; 0
    3784:	02 d9       	rcall	.-3580   	; 0x298a <ButtonGetActionByName>

    return COMMAND_INFO_OK_WITH_TEXT_ID;
}
    3786:	85 e6       	ldi	r24, 0x65	; 101
    3788:	08 95       	ret

0000378a <CommandSetRButton>:

CommandStatusIdType CommandSetRButton(char* OutMessage, const char* InParam)
{
    if (COMMAND_IS_SUGGEST_STRING(InParam)) {
    378a:	fb 01       	movw	r30, r22
    378c:	20 81       	ld	r18, Z
    378e:	2f 33       	cpi	r18, 0x3F	; 63
    3790:	41 f4       	brne	.+16     	; 0x37a2 <CommandSetRButton+0x18>
    3792:	21 81       	ldd	r18, Z+1	; 0x01
    3794:	21 11       	cpse	r18, r1
    3796:	05 c0       	rjmp	.+10     	; 0x37a2 <CommandSetRButton+0x18>
        /* Get suggestion list */
        ButtonGetActionList(OutMessage, TERMINAL_BUFFER_SIZE);
    3798:	60 e0       	ldi	r22, 0x00	; 0
    379a:	72 e0       	ldi	r23, 0x02	; 2
    379c:	e1 d8       	rcall	.-3646   	; 0x2960 <ButtonGetActionList>
        return COMMAND_INFO_OK_WITH_TEXT_ID;
    379e:	85 e6       	ldi	r24, 0x65	; 101
    37a0:	08 95       	ret
    } else if (ButtonSetActionByName(BUTTON_R_PRESS_SHORT, InParam)) {
    37a2:	80 e0       	ldi	r24, 0x00	; 0
    37a4:	04 d9       	rcall	.-3576   	; 0x29ae <ButtonSetActionByName>
    37a6:	88 23       	and	r24, r24
    37a8:	19 f0       	breq	.+6      	; 0x37b0 <CommandSetRButton+0x26>
        /* Try to set action name */
        SettingsSave();
    37aa:	c6 db       	rcall	.-2164   	; 0x2f38 <SettingsSave>
        return COMMAND_INFO_OK_ID;
    37ac:	84 e6       	ldi	r24, 0x64	; 100
    37ae:	08 95       	ret
    } else {
        return COMMAND_ERR_INVALID_PARAM_ID;
    37b0:	8a ec       	ldi	r24, 0xCA	; 202
    }
}
    37b2:	08 95       	ret

000037b4 <CommandGetRButtonLong>:

CommandStatusIdType CommandGetRButtonLong(char* OutParam)
{
    ButtonGetActionByName(BUTTON_R_PRESS_LONG, OutParam, TERMINAL_BUFFER_SIZE);
    37b4:	40 e0       	ldi	r20, 0x00	; 0
    37b6:	52 e0       	ldi	r21, 0x02	; 2
    37b8:	bc 01       	movw	r22, r24
    37ba:	81 e0       	ldi	r24, 0x01	; 1
    37bc:	e6 d8       	rcall	.-3636   	; 0x298a <ButtonGetActionByName>

    return COMMAND_INFO_OK_WITH_TEXT_ID;
}
    37be:	85 e6       	ldi	r24, 0x65	; 101
    37c0:	08 95       	ret

000037c2 <CommandSetRButtonLong>:

CommandStatusIdType CommandSetRButtonLong(char* OutMessage, const char* InParam)
{
    if (COMMAND_IS_SUGGEST_STRING(InParam)) {
    37c2:	fb 01       	movw	r30, r22
    37c4:	20 81       	ld	r18, Z
    37c6:	2f 33       	cpi	r18, 0x3F	; 63
    37c8:	41 f4       	brne	.+16     	; 0x37da <CommandSetRButtonLong+0x18>
    37ca:	21 81       	ldd	r18, Z+1	; 0x01
    37cc:	21 11       	cpse	r18, r1
    37ce:	05 c0       	rjmp	.+10     	; 0x37da <CommandSetRButtonLong+0x18>
        /* Get suggestion list */
        ButtonGetActionList(OutMessage, TERMINAL_BUFFER_SIZE);
    37d0:	60 e0       	ldi	r22, 0x00	; 0
    37d2:	72 e0       	ldi	r23, 0x02	; 2
    37d4:	c5 d8       	rcall	.-3702   	; 0x2960 <ButtonGetActionList>
        return COMMAND_INFO_OK_WITH_TEXT_ID;
    37d6:	85 e6       	ldi	r24, 0x65	; 101
    37d8:	08 95       	ret
    } else if (ButtonSetActionByName(BUTTON_R_PRESS_LONG, InParam)) {
    37da:	81 e0       	ldi	r24, 0x01	; 1
    37dc:	e8 d8       	rcall	.-3632   	; 0x29ae <ButtonSetActionByName>
    37de:	88 23       	and	r24, r24
    37e0:	19 f0       	breq	.+6      	; 0x37e8 <CommandSetRButtonLong+0x26>
        /* Try to set action name */
        SettingsSave();
    37e2:	aa db       	rcall	.-2220   	; 0x2f38 <SettingsSave>
        return COMMAND_INFO_OK_ID;
    37e4:	84 e6       	ldi	r24, 0x64	; 100
    37e6:	08 95       	ret
    } else {
        return COMMAND_ERR_INVALID_PARAM_ID;
    37e8:	8a ec       	ldi	r24, 0xCA	; 202
    }
}
    37ea:	08 95       	ret

000037ec <CommandGetLButton>:

CommandStatusIdType CommandGetLButton(char* OutParam)
{
    ButtonGetActionByName(BUTTON_L_PRESS_SHORT, OutParam, TERMINAL_BUFFER_SIZE);
    37ec:	40 e0       	ldi	r20, 0x00	; 0
    37ee:	52 e0       	ldi	r21, 0x02	; 2
    37f0:	bc 01       	movw	r22, r24
    37f2:	82 e0       	ldi	r24, 0x02	; 2
    37f4:	ca d8       	rcall	.-3692   	; 0x298a <ButtonGetActionByName>

    return COMMAND_INFO_OK_WITH_TEXT_ID;
}
    37f6:	85 e6       	ldi	r24, 0x65	; 101
    37f8:	08 95       	ret

000037fa <CommandSetLButton>:

CommandStatusIdType CommandSetLButton(char* OutMessage, const char* InParam)
{
    if (COMMAND_IS_SUGGEST_STRING(InParam)) {
    37fa:	fb 01       	movw	r30, r22
    37fc:	20 81       	ld	r18, Z
    37fe:	2f 33       	cpi	r18, 0x3F	; 63
    3800:	41 f4       	brne	.+16     	; 0x3812 <CommandSetLButton+0x18>
    3802:	21 81       	ldd	r18, Z+1	; 0x01
    3804:	21 11       	cpse	r18, r1
    3806:	05 c0       	rjmp	.+10     	; 0x3812 <CommandSetLButton+0x18>
        /* Get suggestion list */
        ButtonGetActionList(OutMessage, TERMINAL_BUFFER_SIZE);
    3808:	60 e0       	ldi	r22, 0x00	; 0
    380a:	72 e0       	ldi	r23, 0x02	; 2
    380c:	a9 d8       	rcall	.-3758   	; 0x2960 <ButtonGetActionList>
        return COMMAND_INFO_OK_WITH_TEXT_ID;
    380e:	85 e6       	ldi	r24, 0x65	; 101
    3810:	08 95       	ret
    } else if (ButtonSetActionByName(BUTTON_L_PRESS_SHORT, InParam)) {
    3812:	82 e0       	ldi	r24, 0x02	; 2
    3814:	cc d8       	rcall	.-3688   	; 0x29ae <ButtonSetActionByName>
    3816:	88 23       	and	r24, r24
    3818:	19 f0       	breq	.+6      	; 0x3820 <CommandSetLButton+0x26>
        /* Try to set action name */
        SettingsSave();
    381a:	8e db       	rcall	.-2276   	; 0x2f38 <SettingsSave>
        return COMMAND_INFO_OK_ID;
    381c:	84 e6       	ldi	r24, 0x64	; 100
    381e:	08 95       	ret
    } else {
        return COMMAND_ERR_INVALID_PARAM_ID;
    3820:	8a ec       	ldi	r24, 0xCA	; 202
    }
}
    3822:	08 95       	ret

00003824 <CommandGetLButtonLong>:

CommandStatusIdType CommandGetLButtonLong(char* OutParam)
{
    ButtonGetActionByName(BUTTON_L_PRESS_LONG, OutParam, TERMINAL_BUFFER_SIZE);
    3824:	40 e0       	ldi	r20, 0x00	; 0
    3826:	52 e0       	ldi	r21, 0x02	; 2
    3828:	bc 01       	movw	r22, r24
    382a:	83 e0       	ldi	r24, 0x03	; 3
    382c:	ae d8       	rcall	.-3748   	; 0x298a <ButtonGetActionByName>

    return COMMAND_INFO_OK_WITH_TEXT_ID;
}
    382e:	85 e6       	ldi	r24, 0x65	; 101
    3830:	08 95       	ret

00003832 <CommandSetLButtonLong>:

CommandStatusIdType CommandSetLButtonLong(char* OutMessage, const char* InParam)
{
    if (COMMAND_IS_SUGGEST_STRING(InParam)) {
    3832:	fb 01       	movw	r30, r22
    3834:	20 81       	ld	r18, Z
    3836:	2f 33       	cpi	r18, 0x3F	; 63
    3838:	41 f4       	brne	.+16     	; 0x384a <CommandSetLButtonLong+0x18>
    383a:	21 81       	ldd	r18, Z+1	; 0x01
    383c:	21 11       	cpse	r18, r1
    383e:	05 c0       	rjmp	.+10     	; 0x384a <CommandSetLButtonLong+0x18>
        /* Get suggestion list */
        ButtonGetActionList(OutMessage, TERMINAL_BUFFER_SIZE);
    3840:	60 e0       	ldi	r22, 0x00	; 0
    3842:	72 e0       	ldi	r23, 0x02	; 2
    3844:	8d d8       	rcall	.-3814   	; 0x2960 <ButtonGetActionList>
        return COMMAND_INFO_OK_WITH_TEXT_ID;
    3846:	85 e6       	ldi	r24, 0x65	; 101
    3848:	08 95       	ret
    } else if (ButtonSetActionByName(BUTTON_L_PRESS_LONG, InParam)) {
    384a:	83 e0       	ldi	r24, 0x03	; 3
    384c:	b0 d8       	rcall	.-3744   	; 0x29ae <ButtonSetActionByName>
    384e:	88 23       	and	r24, r24
    3850:	19 f0       	breq	.+6      	; 0x3858 <CommandSetLButtonLong+0x26>
        /* Try to set action name */
        SettingsSave();
    3852:	72 db       	rcall	.-2332   	; 0x2f38 <SettingsSave>
        return COMMAND_INFO_OK_ID;
    3854:	84 e6       	ldi	r24, 0x64	; 100
    3856:	08 95       	ret
    } else {
        return COMMAND_ERR_INVALID_PARAM_ID;
    3858:	8a ec       	ldi	r24, 0xCA	; 202
    }
}
    385a:	08 95       	ret

0000385c <CommandGetLedGreen>:

CommandStatusIdType CommandGetLedGreen(char* OutParam)
{
    LEDGetFuncByName(LED_GREEN, OutParam, TERMINAL_BUFFER_SIZE);
    385c:	40 e0       	ldi	r20, 0x00	; 0
    385e:	52 e0       	ldi	r21, 0x02	; 2
    3860:	bc 01       	movw	r22, r24
    3862:	80 e1       	ldi	r24, 0x10	; 16
    3864:	8f dc       	rcall	.-1762   	; 0x3184 <LEDGetFuncByName>

    return COMMAND_INFO_OK_WITH_TEXT_ID;
}
    3866:	85 e6       	ldi	r24, 0x65	; 101
    3868:	08 95       	ret

0000386a <CommandSetLedGreen>:

CommandStatusIdType CommandSetLedGreen(char* OutMessage, const char* InParam)
{
    if (COMMAND_IS_SUGGEST_STRING(InParam)) {
    386a:	fb 01       	movw	r30, r22
    386c:	20 81       	ld	r18, Z
    386e:	2f 33       	cpi	r18, 0x3F	; 63
    3870:	41 f4       	brne	.+16     	; 0x3882 <CommandSetLedGreen+0x18>
    3872:	21 81       	ldd	r18, Z+1	; 0x01
    3874:	21 11       	cpse	r18, r1
    3876:	05 c0       	rjmp	.+10     	; 0x3882 <CommandSetLedGreen+0x18>
        LEDGetFuncList(OutMessage, TERMINAL_BUFFER_SIZE);
    3878:	60 e0       	ldi	r22, 0x00	; 0
    387a:	72 e0       	ldi	r23, 0x02	; 2
    387c:	58 dc       	rcall	.-1872   	; 0x312e <LEDGetFuncList>
        return COMMAND_INFO_OK_WITH_TEXT_ID;
    387e:	85 e6       	ldi	r24, 0x65	; 101
    3880:	08 95       	ret
    } else if (LEDSetFuncByName(LED_GREEN, InParam)) {
    3882:	80 e1       	ldi	r24, 0x10	; 16
    3884:	99 dc       	rcall	.-1742   	; 0x31b8 <LEDSetFuncByName>
    3886:	88 23       	and	r24, r24
    3888:	19 f0       	breq	.+6      	; 0x3890 <CommandSetLedGreen+0x26>
        SettingsSave();
    388a:	56 db       	rcall	.-2388   	; 0x2f38 <SettingsSave>
        return COMMAND_INFO_OK_ID;
    388c:	84 e6       	ldi	r24, 0x64	; 100
    388e:	08 95       	ret
    } else {
        return COMMAND_ERR_INVALID_PARAM_ID;
    3890:	8a ec       	ldi	r24, 0xCA	; 202
    }
}
    3892:	08 95       	ret

00003894 <CommandGetLedRed>:

CommandStatusIdType CommandGetLedRed(char* OutParam)
{
    LEDGetFuncByName(LED_RED, OutParam, TERMINAL_BUFFER_SIZE);
    3894:	40 e0       	ldi	r20, 0x00	; 0
    3896:	52 e0       	ldi	r21, 0x02	; 2
    3898:	bc 01       	movw	r22, r24
    389a:	88 e0       	ldi	r24, 0x08	; 8
    389c:	73 dc       	rcall	.-1818   	; 0x3184 <LEDGetFuncByName>

    return COMMAND_INFO_OK_WITH_TEXT_ID;
}
    389e:	85 e6       	ldi	r24, 0x65	; 101
    38a0:	08 95       	ret

000038a2 <CommandSetLedRed>:

CommandStatusIdType CommandSetLedRed(char* OutMessage, const char* InParam)
{
    if (COMMAND_IS_SUGGEST_STRING(InParam)) {
    38a2:	fb 01       	movw	r30, r22
    38a4:	20 81       	ld	r18, Z
    38a6:	2f 33       	cpi	r18, 0x3F	; 63
    38a8:	41 f4       	brne	.+16     	; 0x38ba <CommandSetLedRed+0x18>
    38aa:	21 81       	ldd	r18, Z+1	; 0x01
    38ac:	21 11       	cpse	r18, r1
    38ae:	05 c0       	rjmp	.+10     	; 0x38ba <CommandSetLedRed+0x18>
        LEDGetFuncList(OutMessage, TERMINAL_BUFFER_SIZE);
    38b0:	60 e0       	ldi	r22, 0x00	; 0
    38b2:	72 e0       	ldi	r23, 0x02	; 2
    38b4:	3c dc       	rcall	.-1928   	; 0x312e <LEDGetFuncList>
        return COMMAND_INFO_OK_WITH_TEXT_ID;
    38b6:	85 e6       	ldi	r24, 0x65	; 101
    38b8:	08 95       	ret
    } else if (LEDSetFuncByName(LED_RED, InParam)) {
    38ba:	88 e0       	ldi	r24, 0x08	; 8
    38bc:	7d dc       	rcall	.-1798   	; 0x31b8 <LEDSetFuncByName>
    38be:	88 23       	and	r24, r24
    38c0:	19 f0       	breq	.+6      	; 0x38c8 <CommandSetLedRed+0x26>
        SettingsSave();
    38c2:	3a db       	rcall	.-2444   	; 0x2f38 <SettingsSave>
        return COMMAND_INFO_OK_ID;
    38c4:	84 e6       	ldi	r24, 0x64	; 100
    38c6:	08 95       	ret
    } else {
        return COMMAND_ERR_INVALID_PARAM_ID;
    38c8:	8a ec       	ldi	r24, 0xCA	; 202
    }
}
    38ca:	08 95       	ret

000038cc <CommandGetLogMode>:

CommandStatusIdType CommandGetLogMode(char* OutParam)
{
    /* Get Logmode */
    LogGetModeByName(OutParam, TERMINAL_BUFFER_SIZE);
    38cc:	60 e0       	ldi	r22, 0x00	; 0
    38ce:	72 e0       	ldi	r23, 0x02	; 2
    38d0:	83 da       	rcall	.-2810   	; 0x2dd8 <LogGetModeByName>

    return COMMAND_INFO_OK_WITH_TEXT_ID;
}
    38d2:	85 e6       	ldi	r24, 0x65	; 101
    38d4:	08 95       	ret

000038d6 <CommandSetLogMode>:

CommandStatusIdType CommandSetLogMode(char* OutMessage, const char* InParam)
{
    if (COMMAND_IS_SUGGEST_STRING(InParam)) {
    38d6:	fb 01       	movw	r30, r22
    38d8:	20 81       	ld	r18, Z
    38da:	2f 33       	cpi	r18, 0x3F	; 63
    38dc:	41 f4       	brne	.+16     	; 0x38ee <CommandSetLogMode+0x18>
    38de:	21 81       	ldd	r18, Z+1	; 0x01
    38e0:	21 11       	cpse	r18, r1
    38e2:	05 c0       	rjmp	.+10     	; 0x38ee <CommandSetLogMode+0x18>
        LogGetModeList(OutMessage, TERMINAL_BUFFER_SIZE);
    38e4:	60 e0       	ldi	r22, 0x00	; 0
    38e6:	72 e0       	ldi	r23, 0x02	; 2
    38e8:	87 da       	rcall	.-2802   	; 0x2df8 <LogGetModeList>
        return COMMAND_INFO_OK_WITH_TEXT_ID;
    38ea:	85 e6       	ldi	r24, 0x65	; 101
    38ec:	08 95       	ret
    } else if (LogSetModeByName(InParam)) {
    38ee:	cb 01       	movw	r24, r22
    38f0:	5a da       	rcall	.-2892   	; 0x2da6 <LogSetModeByName>
    38f2:	88 23       	and	r24, r24
    38f4:	19 f0       	breq	.+6      	; 0x38fc <CommandSetLogMode+0x26>
        SettingsSave();
    38f6:	20 db       	rcall	.-2496   	; 0x2f38 <SettingsSave>
        return COMMAND_INFO_OK_ID;
    38f8:	84 e6       	ldi	r24, 0x64	; 100
    38fa:	08 95       	ret
    } else {
        return COMMAND_ERR_INVALID_PARAM_ID;
    38fc:	8a ec       	ldi	r24, 0xCA	; 202
    }
}
    38fe:	08 95       	ret

00003900 <CommandGetLogMem>:

CommandStatusIdType CommandGetLogMem(char* OutParam)
{
    3900:	cf 93       	push	r28
    3902:	df 93       	push	r29
    3904:	ec 01       	movw	r28, r24
    uint16_t free = LogMemFree();
    3906:	6c d9       	rcall	.-3368   	; 0x2be0 <LogMemFree>
    snprintf_P(OutParam, TERMINAL_BUFFER_SIZE,
    3908:	81 30       	cpi	r24, 0x01	; 1
    390a:	28 e0       	ldi	r18, 0x08	; 8
    390c:	92 07       	cpc	r25, r18
    390e:	18 f0       	brcs	.+6      	; 0x3916 <CommandGetLogMem+0x16>
    3910:	9c 01       	movw	r18, r24
    3912:	38 50       	subi	r19, 0x08	; 8
    3914:	02 c0       	rjmp	.+4      	; 0x391a <CommandGetLogMem+0x1a>
    3916:	20 e0       	ldi	r18, 0x00	; 0
    3918:	30 e0       	ldi	r19, 0x00	; 0
    391a:	3f 93       	push	r19
    391c:	2f 93       	push	r18
    391e:	9f 93       	push	r25
    3920:	8f 93       	push	r24
    3922:	2a e9       	ldi	r18, 0x9A	; 154
    3924:	3b e0       	ldi	r19, 0x0B	; 11
    3926:	3f 93       	push	r19
    3928:	2f 93       	push	r18
    392a:	82 e0       	ldi	r24, 0x02	; 2
    392c:	8f 93       	push	r24
    392e:	1f 92       	push	r1
    3930:	df 93       	push	r29
    3932:	cf 93       	push	r28
    3934:	0e 94 50 66 	call	0xcca0	; 0xcca0 <snprintf_P>
        PSTR("%u (from which %u non-volatile)"), free, (free <= LOG_SIZE) ? 0 : (free - LOG_SIZE));


    return COMMAND_INFO_OK_WITH_TEXT_ID;
    3938:	8d b7       	in	r24, 0x3d	; 61
    393a:	9e b7       	in	r25, 0x3e	; 62
    393c:	0a 96       	adiw	r24, 0x0a	; 10
    393e:	8d bf       	out	0x3d, r24	; 61
    3940:	9e bf       	out	0x3e, r25	; 62
}
    3942:	85 e6       	ldi	r24, 0x65	; 101
    3944:	df 91       	pop	r29
    3946:	cf 91       	pop	r28
    3948:	08 95       	ret

0000394a <CommandExecLogDownload>:


CommandStatusIdType CommandExecLogDownload(char* OutMessage)
{
    XModemSend(LogMemLoadBlock);
    394a:	82 e2       	ldi	r24, 0x22	; 34
    394c:	95 e1       	ldi	r25, 0x15	; 21
    394e:	97 d3       	rcall	.+1838   	; 0x407e <XModemSend>
    return COMMAND_INFO_XMODEM_WAIT_ID;
}
    3950:	8e e6       	ldi	r24, 0x6E	; 110
    3952:	08 95       	ret

00003954 <CommandExecStoreLog>:

CommandStatusIdType CommandExecStoreLog(char* OutMessage)
{
    LogSRAMToFRAM();
    3954:	57 da       	rcall	.-2898   	; 0x2e04 <LogSRAMToFRAM>
    return COMMAND_INFO_OK_ID;
}
    3956:	84 e6       	ldi	r24, 0x64	; 100
    3958:	08 95       	ret

0000395a <CommandExecLogClear>:

CommandStatusIdType CommandExecLogClear(char* OutMessage)
{
    LogMemClear();
    395a:	06 d9       	rcall	.-3572   	; 0x2b68 <LogMemClear>
    return COMMAND_INFO_OK_ID;
}
    395c:	84 e6       	ldi	r24, 0x64	; 100
    395e:	08 95       	ret

00003960 <CommandGetSetting>:

CommandStatusIdType CommandGetSetting(char* OutParam)
{
    SettingsGetActiveByName(OutParam, TERMINAL_BUFFER_SIZE);
    3960:	60 e0       	ldi	r22, 0x00	; 0
    3962:	72 e0       	ldi	r23, 0x02	; 2
    3964:	45 db       	rcall	.-2422   	; 0x2ff0 <SettingsGetActiveByName>
    return COMMAND_INFO_OK_WITH_TEXT_ID;
}
    3966:	85 e6       	ldi	r24, 0x65	; 101
    3968:	08 95       	ret

0000396a <CommandSetSetting>:

CommandStatusIdType CommandSetSetting(char* OutMessage, const char* InParam)
{
    396a:	cb 01       	movw	r24, r22
    if (SettingsSetActiveByName(InParam)) {
    396c:	48 db       	rcall	.-2416   	; 0x2ffe <SettingsSetActiveByName>
    396e:	81 11       	cpse	r24, r1
    3970:	02 c0       	rjmp	.+4      	; 0x3976 <CommandSetSetting+0xc>
        return COMMAND_INFO_OK_ID;
    } else {
        return COMMAND_ERR_INVALID_PARAM_ID;
    3972:	8a ec       	ldi	r24, 0xCA	; 202
    3974:	08 95       	ret
}

CommandStatusIdType CommandSetSetting(char* OutMessage, const char* InParam)
{
    if (SettingsSetActiveByName(InParam)) {
        return COMMAND_INFO_OK_ID;
    3976:	84 e6       	ldi	r24, 0x64	; 100
    } else {
        return COMMAND_ERR_INVALID_PARAM_ID;
    }
}
    3978:	08 95       	ret

0000397a <CommandExecClear>:

CommandStatusIdType CommandExecClear(char* OutMessage)
{
    MemoryClear();
    397a:	0e 94 d2 10 	call	0x21a4	; 0x21a4 <MemoryClear>
    return COMMAND_INFO_OK_ID;
}
    397e:	84 e6       	ldi	r24, 0x64	; 100
    3980:	08 95       	ret

00003982 <CommandExecStore>:

CommandStatusIdType CommandExecStore(char* OutMessage)
{
    MemoryStore();
    3982:	0e 94 02 11 	call	0x2204	; 0x2204 <MemoryStore>
    return COMMAND_INFO_OK_ID;
}
    3986:	84 e6       	ldi	r24, 0x64	; 100
    3988:	08 95       	ret

0000398a <CommandExecRecall>:

CommandStatusIdType CommandExecRecall(char* OutMessage)
{
    MemoryRecall();
    398a:	0e 94 5d 10 	call	0x20ba	; 0x20ba <MemoryRecall>
    return COMMAND_INFO_OK_ID;
}
    398e:	84 e6       	ldi	r24, 0x64	; 100
    3990:	08 95       	ret

00003992 <CommandGetCharging>:
    BATTERY_PORT.DIRCLR = BATTERY_PORT_MASK;
    BATTERY_PORT.BATTERY_STAT_PINCTRL = PORT_OPC_PULLUP_gc;
}

INLINE bool BatteryIsCharging(void) {
    if (!(BATTERY_PORT.IN & BATTERY_STAT_PIN)) {
    3992:	80 91 68 06 	lds	r24, 0x0668
    3996:	80 fd       	sbrc	r24, 0
    3998:	02 c0       	rjmp	.+4      	; 0x399e <CommandGetCharging+0xc>

CommandStatusIdType CommandGetCharging(char* OutMessage)
{
    if (BatteryIsCharging()) {
        return COMMAND_INFO_TRUE_ID;
    399a:	89 e7       	ldi	r24, 0x79	; 121
    399c:	08 95       	ret
    } else {
        return COMMAND_INFO_FALSE_ID;
    399e:	88 e7       	ldi	r24, 0x78	; 120
    }
}
    39a0:	08 95       	ret

000039a2 <CommandExecHelp>:

CommandStatusIdType CommandExecHelp(char* OutMessage)
{
    39a2:	df 92       	push	r13
    39a4:	ef 92       	push	r14
    39a6:	ff 92       	push	r15
    39a8:	0f 93       	push	r16
    39aa:	1f 93       	push	r17
    39ac:	cf 93       	push	r28
    39ae:	df 93       	push	r29
    39b0:	ec 01       	movw	r28, r24
    const CommandEntryType* EntryPtr = CommandTable;
    uint16_t ByteCount = TERMINAL_BUFFER_SIZE - 1; /* Account for '\0' */
    39b2:	0f ef       	ldi	r16, 0xFF	; 255
    39b4:	11 e0       	ldi	r17, 0x01	; 1
    }
}

CommandStatusIdType CommandExecHelp(char* OutMessage)
{
    const CommandEntryType* EntryPtr = CommandTable;
    39b6:	8c ec       	ldi	r24, 0xCC	; 204
    39b8:	e8 2e       	mov	r14, r24
    39ba:	8d e0       	ldi	r24, 0x0D	; 13
    39bc:	f8 2e       	mov	r15, r24
            *OutMessage++ = c;
            CommandName++;
            ByteCount--;
        }

        *OutMessage++ = ',';
    39be:	9c e2       	ldi	r25, 0x2C	; 44
    39c0:	d9 2e       	mov	r13, r25
CommandStatusIdType CommandExecHelp(char* OutMessage)
{
    const CommandEntryType* EntryPtr = CommandTable;
    uint16_t ByteCount = TERMINAL_BUFFER_SIZE - 1; /* Account for '\0' */

    while(strcmp_P(COMMAND_LIST_END, EntryPtr->Command) != 0 && ByteCount > 0) {
    39c2:	b7 01       	movw	r22, r14
    39c4:	81 ee       	ldi	r24, 0xE1	; 225
    39c6:	93 e2       	ldi	r25, 0x23	; 35
    39c8:	0e 94 c2 65 	call	0xcb84	; 0xcb84 <strcmp_P>
    39cc:	89 2b       	or	r24, r25
    39ce:	d1 f0       	breq	.+52     	; 0x3a04 <CommandExecHelp+0x62>
    39d0:	01 15       	cp	r16, r1
    39d2:	11 05       	cpc	r17, r1
    39d4:	b9 f0       	breq	.+46     	; 0x3a04 <CommandExecHelp+0x62>
    39d6:	de 01       	movw	r26, r28
    39d8:	f7 01       	movw	r30, r14
        const char* CommandName = EntryPtr->Command;
        char c;

        while( (c = pgm_read_byte(CommandName)) != '\0' && ByteCount > 1) {
    39da:	24 91       	lpm	r18, Z
    39dc:	ed 01       	movw	r28, r26
    39de:	21 96       	adiw	r28, 0x01	; 1
    39e0:	c8 01       	movw	r24, r16
    39e2:	01 97       	sbiw	r24, 0x01	; 1
    39e4:	22 23       	and	r18, r18
    39e6:	41 f0       	breq	.+16     	; 0x39f8 <CommandExecHelp+0x56>
    39e8:	01 30       	cpi	r16, 0x01	; 1
    39ea:	11 05       	cpc	r17, r1
    39ec:	29 f0       	breq	.+10     	; 0x39f8 <CommandExecHelp+0x56>
            *OutMessage++ = c;
    39ee:	2c 93       	st	X, r18
    39f0:	de 01       	movw	r26, r28
            CommandName++;
    39f2:	31 96       	adiw	r30, 0x01	; 1
            ByteCount--;
    39f4:	8c 01       	movw	r16, r24
    39f6:	f1 cf       	rjmp	.-30     	; 0x39da <CommandExecHelp+0x38>
        }

        *OutMessage++ = ',';
    39f8:	dc 92       	st	X, r13
        ByteCount--;
    39fa:	8c 01       	movw	r16, r24

        EntryPtr++;
    39fc:	88 e1       	ldi	r24, 0x18	; 24
    39fe:	e8 0e       	add	r14, r24
    3a00:	f1 1c       	adc	r15, r1
    3a02:	df cf       	rjmp	.-66     	; 0x39c2 <CommandExecHelp+0x20>
    }

    *--OutMessage = '\0';
    3a04:	21 97       	sbiw	r28, 0x01	; 1
    3a06:	18 82       	st	Y, r1

    return COMMAND_INFO_OK_WITH_TEXT_ID;
}
    3a08:	85 e6       	ldi	r24, 0x65	; 101
    3a0a:	df 91       	pop	r29
    3a0c:	cf 91       	pop	r28
    3a0e:	1f 91       	pop	r17
    3a10:	0f 91       	pop	r16
    3a12:	ff 90       	pop	r15
    3a14:	ef 90       	pop	r14
    3a16:	df 90       	pop	r13
    3a18:	08 95       	ret

00003a1a <CommandGetRssi>:

CommandStatusIdType CommandGetRssi(char* OutParam)
{
    3a1a:	fc 01       	movw	r30, r24
}

static inline
uint16_t AntennaLevelGet(void)
{
    ADCA.CH0.CTRL |= ADC_CH_START_bm;
    3a1c:	20 91 20 02 	lds	r18, 0x0220
    3a20:	20 68       	ori	r18, 0x80	; 128
    3a22:	20 93 20 02 	sts	0x0220, r18
    while( !(ADCA.CH0.INTFLAGS & ADC_CH_CHIF_bm) );
    3a26:	80 91 23 02 	lds	r24, 0x0223
    3a2a:	80 ff       	sbrs	r24, 0
    3a2c:	fc cf       	rjmp	.-8      	; 0x3a26 <CommandGetRssi+0xc>

    ADCA.CH0.INTFLAGS = ADC_CH_CHIF_bm;
    3a2e:	81 e0       	ldi	r24, 0x01	; 1
    3a30:	80 93 23 02 	sts	0x0223, r24

    int16_t Result = ADCA.CH0RES - ANTENNA_LEVEL_OFFSET;
    3a34:	a0 91 10 02 	lds	r26, 0x0210
    3a38:	b0 91 11 02 	lds	r27, 0x0211
    3a3c:	ae 5b       	subi	r26, 0xBE	; 190
    3a3e:	b1 09       	sbc	r27, r1
    3a40:	b7 ff       	sbrs	r27, 7
    3a42:	02 c0       	rjmp	.+4      	; 0x3a48 <CommandGetRssi+0x2e>
    3a44:	a0 e0       	ldi	r26, 0x00	; 0
    3a46:	b0 e0       	ldi	r27, 0x00	; 0
    if (Result < 0) Result = 0;

    return (uint16_t) (((uint32_t) Result * ANTENNA_LEVEL_NUMERATOR) / ANTENNA_LEVEL_DENOMINATOR);
    3a48:	20 e0       	ldi	r18, 0x00	; 0
    3a4a:	38 eb       	ldi	r19, 0xB8	; 184
    3a4c:	4b e0       	ldi	r20, 0x0B	; 11
    3a4e:	50 e0       	ldi	r21, 0x00	; 0
    3a50:	0e 94 45 65 	call	0xca8a	; 0xca8a <__mulshisi3>
    3a54:	aa 27       	eor	r26, r26
    3a56:	bb 27       	eor	r27, r27
    snprintf_P(OutParam, TERMINAL_BUFFER_SIZE,
    3a58:	9f 93       	push	r25
    3a5a:	8f 93       	push	r24
    3a5c:	23 e9       	ldi	r18, 0x93	; 147
    3a5e:	3b e0       	ldi	r19, 0x0B	; 11
    3a60:	3f 93       	push	r19
    3a62:	2f 93       	push	r18
    3a64:	82 e0       	ldi	r24, 0x02	; 2
    3a66:	8f 93       	push	r24
    3a68:	1f 92       	push	r1
    3a6a:	ff 93       	push	r31
    3a6c:	ef 93       	push	r30
    3a6e:	0e 94 50 66 	call	0xcca0	; 0xcca0 <snprintf_P>
        PSTR("%5u mV"), AntennaLevelGet());

    return COMMAND_INFO_OK_WITH_TEXT_ID;
    3a72:	8d b7       	in	r24, 0x3d	; 61
    3a74:	9e b7       	in	r25, 0x3e	; 62
    3a76:	08 96       	adiw	r24, 0x08	; 8
    3a78:	8d bf       	out	0x3d, r24	; 61
    3a7a:	9e bf       	out	0x3e, r25	; 62
}
    3a7c:	85 e6       	ldi	r24, 0x65	; 101
    3a7e:	08 95       	ret

00003a80 <CommandGetSysTick>:

    RTC.INTFLAGS = RTC_COMPIF_bm;
}

INLINE uint16_t SystemGetSysTick(void) {
    return SYSTEM_TICK_REGISTER | RTC.CNT;
    3a80:	2e b1       	in	r18, 0x0e	; 14
    3a82:	3f b1       	in	r19, 0x0f	; 15
    3a84:	40 91 08 04 	lds	r20, 0x0408
    3a88:	50 91 09 04 	lds	r21, 0x0409
    3a8c:	24 2b       	or	r18, r20
    3a8e:	35 2b       	or	r19, r21

CommandStatusIdType CommandGetSysTick(char* OutParam)
{
    snprintf_P(OutParam, TERMINAL_BUFFER_SIZE, PSTR("%4.4X"), SystemGetSysTick());
    3a90:	3f 93       	push	r19
    3a92:	2f 93       	push	r18
    3a94:	2d e8       	ldi	r18, 0x8D	; 141
    3a96:	3b e0       	ldi	r19, 0x0B	; 11
    3a98:	3f 93       	push	r19
    3a9a:	2f 93       	push	r18
    3a9c:	22 e0       	ldi	r18, 0x02	; 2
    3a9e:	2f 93       	push	r18
    3aa0:	1f 92       	push	r1
    3aa2:	9f 93       	push	r25
    3aa4:	8f 93       	push	r24
    3aa6:	0e 94 50 66 	call	0xcca0	; 0xcca0 <snprintf_P>

    return COMMAND_INFO_OK_WITH_TEXT_ID;
    3aaa:	8d b7       	in	r24, 0x3d	; 61
    3aac:	9e b7       	in	r25, 0x3e	; 62
    3aae:	08 96       	adiw	r24, 0x08	; 8
    3ab0:	8d bf       	out	0x3d, r24	; 61
    3ab2:	9e bf       	out	0x3e, r25	; 62
}
    3ab4:	85 e6       	ldi	r24, 0x65	; 101
    3ab6:	08 95       	ret

00003ab8 <CommandExecParamSend>:

CommandStatusIdType CommandExecParamSend(char* OutMessage, const char* InParams)
{
    3ab8:	0f 93       	push	r16
    3aba:	1f 93       	push	r17
    3abc:	cf 93       	push	r28
    3abe:	df 93       	push	r29
    3ac0:	1f 92       	push	r1
    3ac2:	1f 92       	push	r1
    3ac4:	cd b7       	in	r28, 0x3d	; 61
    3ac6:	de b7       	in	r29, 0x3e	; 62
    3ac8:	8b 01       	movw	r16, r22
    if (GlobalSettings.ActiveSettingPtr->Configuration != CONFIG_ISO14443A_READER)
    3aca:	e0 91 71 2f 	lds	r30, 0x2F71
    3ace:	f0 91 72 2f 	lds	r31, 0x2F72
    3ad2:	85 81       	ldd	r24, Z+5	; 0x05
    3ad4:	89 30       	cpi	r24, 0x09	; 9
    3ad6:	09 f0       	breq	.+2      	; 0x3ada <CommandExecParamSend+0x22>
    3ad8:	6f c0       	rjmp	.+222    	; 0x3bb8 <CommandExecParamSend+0x100>
INLINE uint16_t ApplicationProcess(uint8_t* ByteBuffer, uint16_t ByteCount) {
    return ActiveConfiguration.ApplicationProcessFunc(ByteBuffer, ByteCount);
}

INLINE void ApplicationReset(void) {
    ActiveConfiguration.ApplicationResetFunc();
    3ada:	e0 91 5e 2f 	lds	r30, 0x2F5E
    3ade:	f0 91 5f 2f 	lds	r31, 0x2F5F
    3ae2:	19 95       	eicall
        return COMMAND_ERR_INVALID_USAGE_ID;

    ApplicationReset();
    Reader14443CurrentCommand = Reader14443_Send;
    3ae4:	81 e0       	ldi	r24, 0x01	; 1
    3ae6:	80 93 e5 2c 	sts	0x2CE5, r24

    char const * paramTwo = strchr(InParams, ' ');
    3aea:	60 e2       	ldi	r22, 0x20	; 32
    3aec:	70 e0       	ldi	r23, 0x00	; 0
    3aee:	c8 01       	movw	r24, r16
    3af0:	0e 94 08 66 	call	0xcc10	; 0xcc10 <strchr>
    uint16_t length;
    if (paramTwo == NULL) // this means, we have to calculate the length
    3af4:	00 97       	sbiw	r24, 0x00	; 0
    3af6:	f9 f4       	brne	.+62     	; 0x3b36 <CommandExecParamSend+0x7e>
    {
        length = strlen(InParams);
    3af8:	f8 01       	movw	r30, r16
    3afa:	01 90       	ld	r0, Z+
    3afc:	00 20       	and	r0, r0
    3afe:	e9 f7       	brne	.-6      	; 0x3afa <CommandExecParamSend+0x42>
    3b00:	31 97       	sbiw	r30, 0x01	; 1
    3b02:	e0 1b       	sub	r30, r16
    3b04:	f1 0b       	sbc	r31, r17
        if (length&1) // return error when length is odd
    3b06:	e0 fd       	sbrc	r30, 0
    3b08:	59 c0       	rjmp	.+178    	; 0x3bbc <CommandExecParamSend+0x104>
            return COMMAND_ERR_INVALID_PARAM_ID;
        length /= 2;
    3b0a:	f6 95       	lsr	r31
    3b0c:	e7 95       	ror	r30
        if (length == 1)
    3b0e:	e1 30       	cpi	r30, 0x01	; 1
    3b10:	f1 05       	cpc	r31, r1
    3b12:	39 f4       	brne	.+14     	; 0x3b22 <CommandExecParamSend+0x6a>
        {
            ReaderSendBitCount = 7; // this is a short frame
    3b14:	87 e0       	ldi	r24, 0x07	; 7
    3b16:	90 e0       	ldi	r25, 0x00	; 0
    3b18:	80 93 54 2f 	sts	0x2F54, r24
    3b1c:	90 93 55 2f 	sts	0x2F55, r25
    3b20:	37 c0       	rjmp	.+110    	; 0x3b90 <CommandExecParamSend+0xd8>
        } else {
            ReaderSendBitCount = length * 8;
    3b22:	53 e0       	ldi	r21, 0x03	; 3
    3b24:	ee 0f       	add	r30, r30
    3b26:	ff 1f       	adc	r31, r31
    3b28:	5a 95       	dec	r21
    3b2a:	e1 f7       	brne	.-8      	; 0x3b24 <CommandExecParamSend+0x6c>
    3b2c:	e0 93 54 2f 	sts	0x2F54, r30
    3b30:	f0 93 55 2f 	sts	0x2F55, r31
    3b34:	2d c0       	rjmp	.+90     	; 0x3b90 <CommandExecParamSend+0xd8>
        }
    } else if(paramTwo == (InParams+4)) { // we have a bitcount prepended
    3b36:	98 01       	movw	r18, r16
    3b38:	2c 5f       	subi	r18, 0xFC	; 252
    3b3a:	3f 4f       	sbci	r19, 0xFF	; 255
    3b3c:	82 17       	cp	r24, r18
    3b3e:	93 07       	cpc	r25, r19
    3b40:	e9 f5       	brne	.+122    	; 0x3bbc <CommandExecParamSend+0x104>
        uint8_t tmp[2];
        HexStringToBuffer(tmp, 2, InParams);
    3b42:	a8 01       	movw	r20, r16
    3b44:	62 e0       	ldi	r22, 0x02	; 2
    3b46:	70 e0       	ldi	r23, 0x00	; 0
    3b48:	ce 01       	movw	r24, r28
    3b4a:	01 96       	adiw	r24, 0x01	; 1
    3b4c:	0e 94 32 0f 	call	0x1e64	; 0x1e64 <HexStringToBuffer>
        ReaderSendBitCount = (tmp[0]<<8) + tmp[1]; // set our BitCount to the given value
    3b50:	89 81       	ldd	r24, Y+1	; 0x01
    3b52:	90 e0       	ldi	r25, 0x00	; 0
    3b54:	98 2f       	mov	r25, r24
    3b56:	88 27       	eor	r24, r24
    3b58:	2a 81       	ldd	r18, Y+2	; 0x02
    3b5a:	82 0f       	add	r24, r18
    3b5c:	91 1d       	adc	r25, r1
    3b5e:	80 93 54 2f 	sts	0x2F54, r24
    3b62:	90 93 55 2f 	sts	0x2F55, r25
        InParams = ++paramTwo; // set InParams to the beginning of the second parameter
    3b66:	0b 5f       	subi	r16, 0xFB	; 251
    3b68:	1f 4f       	sbci	r17, 0xFF	; 255
        length = strlen(InParams);
    3b6a:	f8 01       	movw	r30, r16
    3b6c:	01 90       	ld	r0, Z+
    3b6e:	00 20       	and	r0, r0
    3b70:	e9 f7       	brne	.-6      	; 0x3b6c <CommandExecParamSend+0xb4>
    3b72:	31 97       	sbiw	r30, 0x01	; 1
    3b74:	e0 1b       	sub	r30, r16
    3b76:	f1 0b       	sbc	r31, r17
        if ((length&1) || (length / 2 * 8) < ReaderSendBitCount) // this parameter is malformed, if it is odd or if there are less bits than the BitCount indicates
    3b78:	e0 fd       	sbrc	r30, 0
    3b7a:	20 c0       	rjmp	.+64     	; 0x3bbc <CommandExecParamSend+0x104>
    3b7c:	f6 95       	lsr	r31
    3b7e:	e7 95       	ror	r30
    3b80:	33 e0       	ldi	r19, 0x03	; 3
    3b82:	ee 0f       	add	r30, r30
    3b84:	ff 1f       	adc	r31, r31
    3b86:	3a 95       	dec	r19
    3b88:	e1 f7       	brne	.-8      	; 0x3b82 <CommandExecParamSend+0xca>
    3b8a:	e8 17       	cp	r30, r24
    3b8c:	f9 07       	cpc	r31, r25
    3b8e:	b0 f0       	brcs	.+44     	; 0x3bbc <CommandExecParamSend+0x104>
            return COMMAND_ERR_INVALID_PARAM_ID;
    } else { // any other case means we have malformed parameters
        return COMMAND_ERR_INVALID_PARAM_ID;
    }

    HexStringToBuffer(ReaderSendBuffer, (ReaderSendBitCount+7)/8, InParams);
    3b90:	60 91 54 2f 	lds	r22, 0x2F54
    3b94:	70 91 55 2f 	lds	r23, 0x2F55
    3b98:	69 5f       	subi	r22, 0xF9	; 249
    3b9a:	7f 4f       	sbci	r23, 0xFF	; 255
    3b9c:	83 e0       	ldi	r24, 0x03	; 3
    3b9e:	76 95       	lsr	r23
    3ba0:	67 95       	ror	r22
    3ba2:	8a 95       	dec	r24
    3ba4:	e1 f7       	brne	.-8      	; 0x3b9e <CommandExecParamSend+0xe6>
    3ba6:	a8 01       	movw	r20, r16
    3ba8:	82 e5       	ldi	r24, 0x52	; 82
    3baa:	9e e2       	ldi	r25, 0x2E	; 46
    3bac:	0e 94 32 0f 	call	0x1e64	; 0x1e64 <HexStringToBuffer>

    Reader14443ACodecStart();
    3bb0:	0e 94 cd 2c 	call	0x599a	; 0x599a <Reader14443ACodecStart>

    return TIMEOUT_COMMAND;
    3bb4:	8f ef       	ldi	r24, 0xFF	; 255
    3bb6:	03 c0       	rjmp	.+6      	; 0x3bbe <CommandExecParamSend+0x106>
}

CommandStatusIdType CommandExecParamSend(char* OutMessage, const char* InParams)
{
    if (GlobalSettings.ActiveSettingPtr->Configuration != CONFIG_ISO14443A_READER)
        return COMMAND_ERR_INVALID_USAGE_ID;
    3bb8:	89 ec       	ldi	r24, 0xC9	; 201
    3bba:	01 c0       	rjmp	.+2      	; 0x3bbe <CommandExecParamSend+0x106>
    uint16_t length;
    if (paramTwo == NULL) // this means, we have to calculate the length
    {
        length = strlen(InParams);
        if (length&1) // return error when length is odd
            return COMMAND_ERR_INVALID_PARAM_ID;
    3bbc:	8a ec       	ldi	r24, 0xCA	; 202
    HexStringToBuffer(ReaderSendBuffer, (ReaderSendBitCount+7)/8, InParams);

    Reader14443ACodecStart();

    return TIMEOUT_COMMAND;
}
    3bbe:	0f 90       	pop	r0
    3bc0:	0f 90       	pop	r0
    3bc2:	df 91       	pop	r29
    3bc4:	cf 91       	pop	r28
    3bc6:	1f 91       	pop	r17
    3bc8:	0f 91       	pop	r16
    3bca:	08 95       	ret

00003bcc <CommandExecParamSendRaw>:

CommandStatusIdType CommandExecParamSendRaw(char* OutMessage, const char* InParams)
{
    3bcc:	ef 92       	push	r14
    3bce:	ff 92       	push	r15
    3bd0:	0f 93       	push	r16
    3bd2:	1f 93       	push	r17
    3bd4:	cf 93       	push	r28
    3bd6:	df 93       	push	r29
    3bd8:	1f 92       	push	r1
    3bda:	1f 92       	push	r1
    3bdc:	cd b7       	in	r28, 0x3d	; 61
    3bde:	de b7       	in	r29, 0x3e	; 62
    3be0:	8b 01       	movw	r16, r22
    if (GlobalSettings.ActiveSettingPtr->Configuration != CONFIG_ISO14443A_READER)
    3be2:	e0 91 71 2f 	lds	r30, 0x2F71
    3be6:	f0 91 72 2f 	lds	r31, 0x2F72
    3bea:	85 81       	ldd	r24, Z+5	; 0x05
    3bec:	89 30       	cpi	r24, 0x09	; 9
    3bee:	09 f0       	breq	.+2      	; 0x3bf2 <CommandExecParamSendRaw+0x26>
    3bf0:	80 c0       	rjmp	.+256    	; 0x3cf2 <CommandExecParamSendRaw+0x126>
    3bf2:	e0 91 5e 2f 	lds	r30, 0x2F5E
    3bf6:	f0 91 5f 2f 	lds	r31, 0x2F5F
    3bfa:	19 95       	eicall
        return COMMAND_ERR_INVALID_USAGE_ID;

    ApplicationReset();
    Reader14443CurrentCommand = Reader14443_Send_Raw;
    3bfc:	82 e0       	ldi	r24, 0x02	; 2
    3bfe:	80 93 e5 2c 	sts	0x2CE5, r24

    char const * paramTwo = strchr(InParams, ' ');
    3c02:	60 e2       	ldi	r22, 0x20	; 32
    3c04:	70 e0       	ldi	r23, 0x00	; 0
    3c06:	c8 01       	movw	r24, r16
    3c08:	0e 94 08 66 	call	0xcc10	; 0xcc10 <strchr>
    3c0c:	7c 01       	movw	r14, r24
    uint16_t length;
    if (paramTwo == NULL) // this means, we have to calculate the length
    3c0e:	89 2b       	or	r24, r25
    3c10:	31 f5       	brne	.+76     	; 0x3c5e <CommandExecParamSendRaw+0x92>
    {
        length = strlen(InParams);
    3c12:	f8 01       	movw	r30, r16
    3c14:	01 90       	ld	r0, Z+
    3c16:	00 20       	and	r0, r0
    3c18:	e9 f7       	brne	.-6      	; 0x3c14 <CommandExecParamSendRaw+0x48>
    3c1a:	31 97       	sbiw	r30, 0x01	; 1
    3c1c:	e0 1b       	sub	r30, r16
    3c1e:	f1 0b       	sbc	r31, r17
        if (length&1) // return error when length is odd
    3c20:	e0 fd       	sbrc	r30, 0
    3c22:	69 c0       	rjmp	.+210    	; 0x3cf6 <CommandExecParamSendRaw+0x12a>
            return COMMAND_ERR_INVALID_PARAM_ID;
        length /= 2;
    3c24:	f6 95       	lsr	r31
    3c26:	e7 95       	ror	r30
        if (length == 1)
    3c28:	e1 30       	cpi	r30, 0x01	; 1
    3c2a:	f1 05       	cpc	r31, r1
    3c2c:	39 f4       	brne	.+14     	; 0x3c3c <CommandExecParamSendRaw+0x70>
        {
            ReaderSendBitCount = 7; // this is a short frame
    3c2e:	87 e0       	ldi	r24, 0x07	; 7
    3c30:	90 e0       	ldi	r25, 0x00	; 0
    3c32:	80 93 54 2f 	sts	0x2F54, r24
    3c36:	90 93 55 2f 	sts	0x2F55, r25
    3c3a:	47 c0       	rjmp	.+142    	; 0x3cca <CommandExecParamSendRaw+0xfe>
        } else {
            length *= 8;
    3c3c:	63 e0       	ldi	r22, 0x03	; 3
    3c3e:	ee 0f       	add	r30, r30
    3c40:	ff 1f       	adc	r31, r31
    3c42:	6a 95       	dec	r22
    3c44:	e1 f7       	brne	.-8      	; 0x3c3e <CommandExecParamSendRaw+0x72>
            ReaderSendBitCount = length - (length % 9); // how many bytes+paritybit match into our input?
    3c46:	cf 01       	movw	r24, r30
    3c48:	69 e0       	ldi	r22, 0x09	; 9
    3c4a:	70 e0       	ldi	r23, 0x00	; 0
    3c4c:	0e 94 31 65 	call	0xca62	; 0xca62 <__udivmodhi4>
    3c50:	e8 1b       	sub	r30, r24
    3c52:	f9 0b       	sbc	r31, r25
    3c54:	e0 93 54 2f 	sts	0x2F54, r30
    3c58:	f0 93 55 2f 	sts	0x2F55, r31
    3c5c:	36 c0       	rjmp	.+108    	; 0x3cca <CommandExecParamSendRaw+0xfe>
        }
    } else if(paramTwo == (InParams+4)) { // we have a bitcount prepended
    3c5e:	c8 01       	movw	r24, r16
    3c60:	04 96       	adiw	r24, 0x04	; 4
    3c62:	e8 16       	cp	r14, r24
    3c64:	f9 06       	cpc	r15, r25
    3c66:	09 f0       	breq	.+2      	; 0x3c6a <CommandExecParamSendRaw+0x9e>
    3c68:	46 c0       	rjmp	.+140    	; 0x3cf6 <CommandExecParamSendRaw+0x12a>
        uint8_t tmp[2];
        HexStringToBuffer(tmp, 2, InParams);
    3c6a:	a8 01       	movw	r20, r16
    3c6c:	62 e0       	ldi	r22, 0x02	; 2
    3c6e:	70 e0       	ldi	r23, 0x00	; 0
    3c70:	ce 01       	movw	r24, r28
    3c72:	01 96       	adiw	r24, 0x01	; 1
    3c74:	0e 94 32 0f 	call	0x1e64	; 0x1e64 <HexStringToBuffer>
        ReaderSendBitCount = (tmp[0]<<8) + tmp[1]; // set our BitCount to the given value
    3c78:	29 81       	ldd	r18, Y+1	; 0x01
    3c7a:	30 e0       	ldi	r19, 0x00	; 0
    3c7c:	32 2f       	mov	r19, r18
    3c7e:	22 27       	eor	r18, r18
    3c80:	8a 81       	ldd	r24, Y+2	; 0x02
    3c82:	28 0f       	add	r18, r24
    3c84:	31 1d       	adc	r19, r1
    3c86:	20 93 54 2f 	sts	0x2F54, r18
    3c8a:	30 93 55 2f 	sts	0x2F55, r19
        if (ReaderSendBitCount != 7 && (ReaderSendBitCount % 8)) // since we have to add parity bits here (in case this is not a short frame), the number of bits to be sent has to be a multiple of 8
    3c8e:	27 30       	cpi	r18, 0x07	; 7
    3c90:	31 05       	cpc	r19, r1
    3c92:	29 f0       	breq	.+10     	; 0x3c9e <CommandExecParamSendRaw+0xd2>
    3c94:	c9 01       	movw	r24, r18
    3c96:	87 70       	andi	r24, 0x07	; 7
    3c98:	99 27       	eor	r25, r25
    3c9a:	89 2b       	or	r24, r25
    3c9c:	61 f5       	brne	.+88     	; 0x3cf6 <CommandExecParamSendRaw+0x12a>
            return COMMAND_ERR_INVALID_PARAM_ID;
        InParams = ++paramTwo; // set InParams to the beginning of the second parameter
    3c9e:	87 01       	movw	r16, r14
    3ca0:	0f 5f       	subi	r16, 0xFF	; 255
    3ca2:	1f 4f       	sbci	r17, 0xFF	; 255
        length = strlen(InParams);
    3ca4:	f8 01       	movw	r30, r16
    3ca6:	01 90       	ld	r0, Z+
    3ca8:	00 20       	and	r0, r0
    3caa:	e9 f7       	brne	.-6      	; 0x3ca6 <CommandExecParamSendRaw+0xda>
    3cac:	31 97       	sbiw	r30, 0x01	; 1
    3cae:	e0 1b       	sub	r30, r16
    3cb0:	f1 0b       	sbc	r31, r17
        if ((length&1) || (length / 2 * 8) < ReaderSendBitCount) // this parameter is malformed, if it is odd or if there are less bits than the BitCount indicates
    3cb2:	e0 fd       	sbrc	r30, 0
    3cb4:	20 c0       	rjmp	.+64     	; 0x3cf6 <CommandExecParamSendRaw+0x12a>
    3cb6:	f6 95       	lsr	r31
    3cb8:	e7 95       	ror	r30
    3cba:	43 e0       	ldi	r20, 0x03	; 3
    3cbc:	ee 0f       	add	r30, r30
    3cbe:	ff 1f       	adc	r31, r31
    3cc0:	4a 95       	dec	r20
    3cc2:	e1 f7       	brne	.-8      	; 0x3cbc <CommandExecParamSendRaw+0xf0>
    3cc4:	e2 17       	cp	r30, r18
    3cc6:	f3 07       	cpc	r31, r19
    3cc8:	b0 f0       	brcs	.+44     	; 0x3cf6 <CommandExecParamSendRaw+0x12a>
            return COMMAND_ERR_INVALID_PARAM_ID;
    } else { // any other case means we have malformed parameters
        return COMMAND_ERR_INVALID_PARAM_ID;
    }

    HexStringToBuffer(ReaderSendBuffer, (ReaderSendBitCount+7)/8, InParams);
    3cca:	60 91 54 2f 	lds	r22, 0x2F54
    3cce:	70 91 55 2f 	lds	r23, 0x2F55
    3cd2:	69 5f       	subi	r22, 0xF9	; 249
    3cd4:	7f 4f       	sbci	r23, 0xFF	; 255
    3cd6:	83 e0       	ldi	r24, 0x03	; 3
    3cd8:	76 95       	lsr	r23
    3cda:	67 95       	ror	r22
    3cdc:	8a 95       	dec	r24
    3cde:	e1 f7       	brne	.-8      	; 0x3cd8 <CommandExecParamSendRaw+0x10c>
    3ce0:	a8 01       	movw	r20, r16
    3ce2:	82 e5       	ldi	r24, 0x52	; 82
    3ce4:	9e e2       	ldi	r25, 0x2E	; 46
    3ce6:	0e 94 32 0f 	call	0x1e64	; 0x1e64 <HexStringToBuffer>

    Reader14443ACodecStart();
    3cea:	0e 94 cd 2c 	call	0x599a	; 0x599a <Reader14443ACodecStart>

    return TIMEOUT_COMMAND;
    3cee:	8f ef       	ldi	r24, 0xFF	; 255
    3cf0:	03 c0       	rjmp	.+6      	; 0x3cf8 <CommandExecParamSendRaw+0x12c>
}

CommandStatusIdType CommandExecParamSendRaw(char* OutMessage, const char* InParams)
{
    if (GlobalSettings.ActiveSettingPtr->Configuration != CONFIG_ISO14443A_READER)
        return COMMAND_ERR_INVALID_USAGE_ID;
    3cf2:	89 ec       	ldi	r24, 0xC9	; 201
    3cf4:	01 c0       	rjmp	.+2      	; 0x3cf8 <CommandExecParamSendRaw+0x12c>
    uint16_t length;
    if (paramTwo == NULL) // this means, we have to calculate the length
    {
        length = strlen(InParams);
        if (length&1) // return error when length is odd
            return COMMAND_ERR_INVALID_PARAM_ID;
    3cf6:	8a ec       	ldi	r24, 0xCA	; 202
    HexStringToBuffer(ReaderSendBuffer, (ReaderSendBitCount+7)/8, InParams);

    Reader14443ACodecStart();

    return TIMEOUT_COMMAND;
}
    3cf8:	0f 90       	pop	r0
    3cfa:	0f 90       	pop	r0
    3cfc:	df 91       	pop	r29
    3cfe:	cf 91       	pop	r28
    3d00:	1f 91       	pop	r17
    3d02:	0f 91       	pop	r16
    3d04:	ff 90       	pop	r15
    3d06:	ef 90       	pop	r14
    3d08:	08 95       	ret

00003d0a <CommandExecDumpMFU>:

CommandStatusIdType CommandExecDumpMFU(char* OutMessage)
{
    if (GlobalSettings.ActiveSettingPtr->Configuration != CONFIG_ISO14443A_READER)
    3d0a:	e0 91 71 2f 	lds	r30, 0x2F71
    3d0e:	f0 91 72 2f 	lds	r31, 0x2F72
    3d12:	85 81       	ldd	r24, Z+5	; 0x05
    3d14:	89 30       	cpi	r24, 0x09	; 9
    3d16:	a1 f4       	brne	.+40     	; 0x3d40 <CommandExecDumpMFU+0x36>
    3d18:	e0 91 5e 2f 	lds	r30, 0x2F5E
    3d1c:	f0 91 5f 2f 	lds	r31, 0x2F5F
    3d20:	19 95       	eicall
        return COMMAND_ERR_INVALID_USAGE_ID;
    ApplicationReset();

    Reader14443CurrentCommand = Reader14443_Read_MF_Ultralight;
    3d22:	85 e0       	ldi	r24, 0x05	; 5
    3d24:	80 93 e5 2c 	sts	0x2CE5, r24
    Reader14443AAppInit();
    3d28:	0e 94 68 4c 	call	0x98d0	; 0x98d0 <Reader14443AAppInit>
    Reader14443ACodecStart();
    3d2c:	0e 94 cd 2c 	call	0x599a	; 0x599a <Reader14443ACodecStart>
    CommandLinePendingTaskTimeout = &Reader14443AAppTimeout;
    3d30:	82 e7       	ldi	r24, 0x72	; 114
    3d32:	9c e4       	ldi	r25, 0x4C	; 76
    3d34:	80 93 90 2c 	sts	0x2C90, r24
    3d38:	90 93 91 2c 	sts	0x2C91, r25
    return TIMEOUT_COMMAND;
    3d3c:	8f ef       	ldi	r24, 0xFF	; 255
    3d3e:	08 95       	ret
}

CommandStatusIdType CommandExecDumpMFU(char* OutMessage)
{
    if (GlobalSettings.ActiveSettingPtr->Configuration != CONFIG_ISO14443A_READER)
        return COMMAND_ERR_INVALID_USAGE_ID;
    3d40:	89 ec       	ldi	r24, 0xC9	; 201
    Reader14443CurrentCommand = Reader14443_Read_MF_Ultralight;
    Reader14443AAppInit();
    Reader14443ACodecStart();
    CommandLinePendingTaskTimeout = &Reader14443AAppTimeout;
    return TIMEOUT_COMMAND;
}
    3d42:	08 95       	ret

00003d44 <CommandExecGetUid>:

CommandStatusIdType CommandExecGetUid(char* OutMessage) // this function is for reading the uid in reader mode
{
    if (GlobalSettings.ActiveSettingPtr->Configuration != CONFIG_ISO14443A_READER)
    3d44:	e0 91 71 2f 	lds	r30, 0x2F71
    3d48:	f0 91 72 2f 	lds	r31, 0x2F72
    3d4c:	85 81       	ldd	r24, Z+5	; 0x05
    3d4e:	89 30       	cpi	r24, 0x09	; 9
    3d50:	a1 f4       	brne	.+40     	; 0x3d7a <CommandExecGetUid+0x36>
    3d52:	e0 91 5e 2f 	lds	r30, 0x2F5E
    3d56:	f0 91 5f 2f 	lds	r31, 0x2F5F
    3d5a:	19 95       	eicall
        return COMMAND_ERR_INVALID_USAGE_ID;
    ApplicationReset();

    Reader14443CurrentCommand = Reader14443_Get_UID;
    3d5c:	83 e0       	ldi	r24, 0x03	; 3
    3d5e:	80 93 e5 2c 	sts	0x2CE5, r24
    Reader14443AAppInit();
    3d62:	0e 94 68 4c 	call	0x98d0	; 0x98d0 <Reader14443AAppInit>
    Reader14443ACodecStart();
    3d66:	0e 94 cd 2c 	call	0x599a	; 0x599a <Reader14443ACodecStart>
    CommandLinePendingTaskTimeout = &Reader14443AAppTimeout;
    3d6a:	82 e7       	ldi	r24, 0x72	; 114
    3d6c:	9c e4       	ldi	r25, 0x4C	; 76
    3d6e:	80 93 90 2c 	sts	0x2C90, r24
    3d72:	90 93 91 2c 	sts	0x2C91, r25
    return TIMEOUT_COMMAND;
    3d76:	8f ef       	ldi	r24, 0xFF	; 255
    3d78:	08 95       	ret
}

CommandStatusIdType CommandExecGetUid(char* OutMessage) // this function is for reading the uid in reader mode
{
    if (GlobalSettings.ActiveSettingPtr->Configuration != CONFIG_ISO14443A_READER)
        return COMMAND_ERR_INVALID_USAGE_ID;
    3d7a:	89 ec       	ldi	r24, 0xC9	; 201
    Reader14443CurrentCommand = Reader14443_Get_UID;
    Reader14443AAppInit();
    Reader14443ACodecStart();
    CommandLinePendingTaskTimeout = &Reader14443AAppTimeout;
    return TIMEOUT_COMMAND;
}
    3d7c:	08 95       	ret

00003d7e <CommandExecIdentifyCard>:

CommandStatusIdType CommandExecIdentifyCard(char* OutMessage)
{
    if (GlobalSettings.ActiveSettingPtr->Configuration != CONFIG_ISO14443A_READER)
    3d7e:	e0 91 71 2f 	lds	r30, 0x2F71
    3d82:	f0 91 72 2f 	lds	r31, 0x2F72
    3d86:	85 81       	ldd	r24, Z+5	; 0x05
    3d88:	89 30       	cpi	r24, 0x09	; 9
    3d8a:	a1 f4       	brne	.+40     	; 0x3db4 <CommandExecIdentifyCard+0x36>
    3d8c:	e0 91 5e 2f 	lds	r30, 0x2F5E
    3d90:	f0 91 5f 2f 	lds	r31, 0x2F5F
    3d94:	19 95       	eicall
        return COMMAND_ERR_INVALID_USAGE_ID;
    ApplicationReset();

    Reader14443CurrentCommand = Reader14443_Identify;
    3d96:	86 e0       	ldi	r24, 0x06	; 6
    3d98:	80 93 e5 2c 	sts	0x2CE5, r24
    Reader14443AAppInit();
    3d9c:	0e 94 68 4c 	call	0x98d0	; 0x98d0 <Reader14443AAppInit>
    Reader14443ACodecStart();
    3da0:	0e 94 cd 2c 	call	0x599a	; 0x599a <Reader14443ACodecStart>
    CommandLinePendingTaskTimeout = &Reader14443AAppTimeout;
    3da4:	82 e7       	ldi	r24, 0x72	; 114
    3da6:	9c e4       	ldi	r25, 0x4C	; 76
    3da8:	80 93 90 2c 	sts	0x2C90, r24
    3dac:	90 93 91 2c 	sts	0x2C91, r25
    return TIMEOUT_COMMAND;
    3db0:	8f ef       	ldi	r24, 0xFF	; 255
    3db2:	08 95       	ret
}

CommandStatusIdType CommandExecIdentifyCard(char* OutMessage)
{
    if (GlobalSettings.ActiveSettingPtr->Configuration != CONFIG_ISO14443A_READER)
        return COMMAND_ERR_INVALID_USAGE_ID;
    3db4:	89 ec       	ldi	r24, 0xC9	; 201
    Reader14443CurrentCommand = Reader14443_Identify;
    Reader14443AAppInit();
    Reader14443ACodecStart();
    CommandLinePendingTaskTimeout = &Reader14443AAppTimeout;
    return TIMEOUT_COMMAND;
}
    3db6:	08 95       	ret

00003db8 <CommandGetTimeout>:

CommandStatusIdType CommandGetTimeout(char* OutParam)
{
    snprintf_P(OutParam, TERMINAL_BUFFER_SIZE, PSTR("%u ms"), GlobalSettings.ActiveSettingPtr->PendingTaskTimeout * 100);
    3db8:	e0 91 71 2f 	lds	r30, 0x2F71
    3dbc:	f0 91 72 2f 	lds	r31, 0x2F72
    3dc0:	40 85       	ldd	r20, Z+8	; 0x08
    3dc2:	51 85       	ldd	r21, Z+9	; 0x09
    3dc4:	64 e6       	ldi	r22, 0x64	; 100
    3dc6:	64 9f       	mul	r22, r20
    3dc8:	90 01       	movw	r18, r0
    3dca:	65 9f       	mul	r22, r21
    3dcc:	30 0d       	add	r19, r0
    3dce:	11 24       	eor	r1, r1
    3dd0:	3f 93       	push	r19
    3dd2:	2f 93       	push	r18
    3dd4:	27 e8       	ldi	r18, 0x87	; 135
    3dd6:	3b e0       	ldi	r19, 0x0B	; 11
    3dd8:	3f 93       	push	r19
    3dda:	2f 93       	push	r18
    3ddc:	22 e0       	ldi	r18, 0x02	; 2
    3dde:	2f 93       	push	r18
    3de0:	1f 92       	push	r1
    3de2:	9f 93       	push	r25
    3de4:	8f 93       	push	r24
    3de6:	0e 94 50 66 	call	0xcca0	; 0xcca0 <snprintf_P>
    return COMMAND_INFO_OK_WITH_TEXT_ID;
    3dea:	8d b7       	in	r24, 0x3d	; 61
    3dec:	9e b7       	in	r25, 0x3e	; 62
    3dee:	08 96       	adiw	r24, 0x08	; 8
    3df0:	8d bf       	out	0x3d, r24	; 61
    3df2:	9e bf       	out	0x3e, r25	; 62
}
    3df4:	85 e6       	ldi	r24, 0x65	; 101
    3df6:	08 95       	ret

00003df8 <CommandSetTimeout>:

CommandStatusIdType CommandSetTimeout(char* OutMessage, const char* InParam)
{
    3df8:	cf 93       	push	r28
    3dfa:	df 93       	push	r29
    3dfc:	1f 92       	push	r1
    3dfe:	1f 92       	push	r1
    3e00:	cd b7       	in	r28, 0x3d	; 61
    3e02:	de b7       	in	r29, 0x3e	; 62
    if (COMMAND_IS_SUGGEST_STRING(InParam))
    3e04:	fb 01       	movw	r30, r22
    3e06:	20 81       	ld	r18, Z
    3e08:	2f 33       	cpi	r18, 0x3F	; 63
    3e0a:	b1 f4       	brne	.+44     	; 0x3e38 <CommandSetTimeout+0x40>
    3e0c:	21 81       	ldd	r18, Z+1	; 0x01
    3e0e:	21 11       	cpse	r18, r1
    3e10:	13 c0       	rjmp	.+38     	; 0x3e38 <CommandSetTimeout+0x40>
    {
        snprintf_P(OutMessage, TERMINAL_BUFFER_SIZE, PSTR("0 = no timeout\r\n1-600 = 100 ms - 60000 ms timeout"));
    3e12:	25 e5       	ldi	r18, 0x55	; 85
    3e14:	3b e0       	ldi	r19, 0x0B	; 11
    3e16:	3f 93       	push	r19
    3e18:	2f 93       	push	r18
    3e1a:	22 e0       	ldi	r18, 0x02	; 2
    3e1c:	2f 93       	push	r18
    3e1e:	1f 92       	push	r1
    3e20:	9f 93       	push	r25
    3e22:	8f 93       	push	r24
    3e24:	0e 94 50 66 	call	0xcca0	; 0xcca0 <snprintf_P>
        return COMMAND_INFO_OK_WITH_TEXT_ID;
    3e28:	0f 90       	pop	r0
    3e2a:	0f 90       	pop	r0
    3e2c:	0f 90       	pop	r0
    3e2e:	0f 90       	pop	r0
    3e30:	0f 90       	pop	r0
    3e32:	0f 90       	pop	r0
    3e34:	85 e6       	ldi	r24, 0x65	; 101
    3e36:	2e c0       	rjmp	.+92     	; 0x3e94 <CommandSetTimeout+0x9c>
    }
    uint16_t tmp = 601;
    3e38:	89 e5       	ldi	r24, 0x59	; 89
    3e3a:	92 e0       	ldi	r25, 0x02	; 2
    3e3c:	89 83       	std	Y+1, r24	; 0x01
    3e3e:	9a 83       	std	Y+2, r25	; 0x02
    if (!sscanf_P(InParam, PSTR("%5d"), &tmp) || tmp > 600)
    3e40:	ce 01       	movw	r24, r28
    3e42:	01 96       	adiw	r24, 0x01	; 1
    3e44:	9f 93       	push	r25
    3e46:	8f 93       	push	r24
    3e48:	81 e5       	ldi	r24, 0x51	; 81
    3e4a:	9b e0       	ldi	r25, 0x0B	; 11
    3e4c:	9f 93       	push	r25
    3e4e:	8f 93       	push	r24
    3e50:	7f 93       	push	r23
    3e52:	6f 93       	push	r22
    3e54:	0e 94 86 66 	call	0xcd0c	; 0xcd0c <sscanf_P>
    3e58:	0f 90       	pop	r0
    3e5a:	0f 90       	pop	r0
    3e5c:	0f 90       	pop	r0
    3e5e:	0f 90       	pop	r0
    3e60:	0f 90       	pop	r0
    3e62:	0f 90       	pop	r0
    3e64:	89 2b       	or	r24, r25
    3e66:	a9 f0       	breq	.+42     	; 0x3e92 <CommandSetTimeout+0x9a>
    3e68:	69 81       	ldd	r22, Y+1	; 0x01
    3e6a:	7a 81       	ldd	r23, Y+2	; 0x02
    3e6c:	69 35       	cpi	r22, 0x59	; 89
    3e6e:	f2 e0       	ldi	r31, 0x02	; 2
    3e70:	7f 07       	cpc	r23, r31
    3e72:	78 f4       	brcc	.+30     	; 0x3e92 <CommandSetTimeout+0x9a>
        return COMMAND_ERR_INVALID_PARAM_ID;
    GlobalSettings.ActiveSettingPtr->PendingTaskTimeout = tmp;
    3e74:	e0 91 71 2f 	lds	r30, 0x2F71
    3e78:	f0 91 72 2f 	lds	r31, 0x2F72
    3e7c:	60 87       	std	Z+8, r22	; 0x08
    3e7e:	71 87       	std	Z+9, r23	; 0x09
    3e80:	cf 01       	movw	r24, r30
    3e82:	88 56       	subi	r24, 0x68	; 104
    3e84:	9f 42       	sbci	r25, 0x2F	; 47
        break;

    case 2:
        eeprom_update_word((uint16_t *)EEAddr, *(uint16_t*)addr);
    3e86:	8f 5f       	subi	r24, 0xFF	; 255
    3e88:	9f 4f       	sbci	r25, 0xFF	; 255
    3e8a:	0e 94 7c 6c 	call	0xd8f8	; 0xd8f8 <eeprom_update_word>
    SETTING_UPDATE(GlobalSettings.ActiveSettingPtr->PendingTaskTimeout);
    return COMMAND_INFO_OK_ID;
    3e8e:	84 e6       	ldi	r24, 0x64	; 100
    3e90:	01 c0       	rjmp	.+2      	; 0x3e94 <CommandSetTimeout+0x9c>
        snprintf_P(OutMessage, TERMINAL_BUFFER_SIZE, PSTR("0 = no timeout\r\n1-600 = 100 ms - 60000 ms timeout"));
        return COMMAND_INFO_OK_WITH_TEXT_ID;
    }
    uint16_t tmp = 601;
    if (!sscanf_P(InParam, PSTR("%5d"), &tmp) || tmp > 600)
        return COMMAND_ERR_INVALID_PARAM_ID;
    3e92:	8a ec       	ldi	r24, 0xCA	; 202
    GlobalSettings.ActiveSettingPtr->PendingTaskTimeout = tmp;
    SETTING_UPDATE(GlobalSettings.ActiveSettingPtr->PendingTaskTimeout);
    return COMMAND_INFO_OK_ID;
}
    3e94:	0f 90       	pop	r0
    3e96:	0f 90       	pop	r0
    3e98:	df 91       	pop	r29
    3e9a:	cf 91       	pop	r28
    3e9c:	08 95       	ret

00003e9e <CommandGetThreshold>:

CommandStatusIdType CommandGetThreshold(char* OutParam)
{
    snprintf_P(OutParam, TERMINAL_BUFFER_SIZE, PSTR("%u"), GlobalSettings.ActiveSettingPtr->ReaderThreshold);
    3e9e:	e0 91 71 2f 	lds	r30, 0x2F71
    3ea2:	f0 91 72 2f 	lds	r31, 0x2F72
    3ea6:	23 85       	ldd	r18, Z+11	; 0x0b
    3ea8:	2f 93       	push	r18
    3eaa:	22 85       	ldd	r18, Z+10	; 0x0a
    3eac:	2f 93       	push	r18
    3eae:	2e e4       	ldi	r18, 0x4E	; 78
    3eb0:	3b e0       	ldi	r19, 0x0B	; 11
    3eb2:	3f 93       	push	r19
    3eb4:	2f 93       	push	r18
    3eb6:	22 e0       	ldi	r18, 0x02	; 2
    3eb8:	2f 93       	push	r18
    3eba:	1f 92       	push	r1
    3ebc:	9f 93       	push	r25
    3ebe:	8f 93       	push	r24
    3ec0:	0e 94 50 66 	call	0xcca0	; 0xcca0 <snprintf_P>
    return COMMAND_INFO_OK_WITH_TEXT_ID;
    3ec4:	8d b7       	in	r24, 0x3d	; 61
    3ec6:	9e b7       	in	r25, 0x3e	; 62
    3ec8:	08 96       	adiw	r24, 0x08	; 8
    3eca:	8d bf       	out	0x3d, r24	; 61
    3ecc:	9e bf       	out	0x3e, r25	; 62
}
    3ece:	85 e6       	ldi	r24, 0x65	; 101
    3ed0:	08 95       	ret

00003ed2 <CommandSetThreshold>:

CommandStatusIdType CommandSetThreshold(char* OutMessage, const char* InParam)
{
    3ed2:	cf 93       	push	r28
    3ed4:	df 93       	push	r29
    3ed6:	1f 92       	push	r1
    3ed8:	1f 92       	push	r1
    3eda:	cd b7       	in	r28, 0x3d	; 61
    3edc:	de b7       	in	r29, 0x3e	; 62
    if (COMMAND_IS_SUGGEST_STRING(InParam))
    3ede:	fb 01       	movw	r30, r22
    3ee0:	20 81       	ld	r18, Z
    3ee2:	2f 33       	cpi	r18, 0x3F	; 63
    3ee4:	b1 f4       	brne	.+44     	; 0x3f12 <CommandSetThreshold+0x40>
    3ee6:	21 81       	ldd	r18, Z+1	; 0x01
    3ee8:	21 11       	cpse	r18, r1
    3eea:	13 c0       	rjmp	.+38     	; 0x3f12 <CommandSetThreshold+0x40>
    {
        snprintf_P(OutMessage, TERMINAL_BUFFER_SIZE, PSTR("Any integer from 0 to %u. Reference voltage will be (VCC * THRESHOLD / 4095) mV."), CODEC_MAXIMUM_THRESHOLD);
    3eec:	2f e0       	ldi	r18, 0x0F	; 15
    3eee:	2f 93       	push	r18
    3ef0:	2f ef       	ldi	r18, 0xFF	; 255
    3ef2:	2f 93       	push	r18
    3ef4:	2d ef       	ldi	r18, 0xFD	; 253
    3ef6:	3a e0       	ldi	r19, 0x0A	; 10
    3ef8:	3f 93       	push	r19
    3efa:	2f 93       	push	r18
    3efc:	22 e0       	ldi	r18, 0x02	; 2
    3efe:	2f 93       	push	r18
    3f00:	1f 92       	push	r1
    3f02:	9f 93       	push	r25
    3f04:	8f 93       	push	r24
    3f06:	0e 94 50 66 	call	0xcca0	; 0xcca0 <snprintf_P>
        return COMMAND_INFO_OK_WITH_TEXT_ID;
    3f0a:	cd bf       	out	0x3d, r28	; 61
    3f0c:	de bf       	out	0x3e, r29	; 62
    3f0e:	85 e6       	ldi	r24, 0x65	; 101
    3f10:	30 c0       	rjmp	.+96     	; 0x3f72 <CommandSetThreshold+0xa0>
    }
    uint16_t tmp = 0;
    3f12:	19 82       	std	Y+1, r1	; 0x01
    3f14:	1a 82       	std	Y+2, r1	; 0x02
    if (!sscanf_P(InParam, PSTR("%5d"), &tmp) || tmp > CODEC_MAXIMUM_THRESHOLD)
    3f16:	ce 01       	movw	r24, r28
    3f18:	01 96       	adiw	r24, 0x01	; 1
    3f1a:	9f 93       	push	r25
    3f1c:	8f 93       	push	r24
    3f1e:	89 ef       	ldi	r24, 0xF9	; 249
    3f20:	9a e0       	ldi	r25, 0x0A	; 10
    3f22:	9f 93       	push	r25
    3f24:	8f 93       	push	r24
    3f26:	7f 93       	push	r23
    3f28:	6f 93       	push	r22
    3f2a:	0e 94 86 66 	call	0xcd0c	; 0xcd0c <sscanf_P>
    3f2e:	0f 90       	pop	r0
    3f30:	0f 90       	pop	r0
    3f32:	0f 90       	pop	r0
    3f34:	0f 90       	pop	r0
    3f36:	0f 90       	pop	r0
    3f38:	0f 90       	pop	r0
    3f3a:	89 2b       	or	r24, r25
    3f3c:	c9 f0       	breq	.+50     	; 0x3f70 <CommandSetThreshold+0x9e>
    3f3e:	69 81       	ldd	r22, Y+1	; 0x01
    3f40:	7a 81       	ldd	r23, Y+2	; 0x02
    3f42:	61 15       	cp	r22, r1
    3f44:	90 e1       	ldi	r25, 0x10	; 16
    3f46:	79 07       	cpc	r23, r25
    3f48:	98 f4       	brcc	.+38     	; 0x3f70 <CommandSetThreshold+0x9e>
        return COMMAND_ERR_INVALID_PARAM_ID;
    DACB.CH0DATA = tmp;
    3f4a:	60 93 38 03 	sts	0x0338, r22
    3f4e:	70 93 39 03 	sts	0x0339, r23
    GlobalSettings.ActiveSettingPtr->ReaderThreshold = tmp;
    3f52:	e0 91 71 2f 	lds	r30, 0x2F71
    3f56:	f0 91 72 2f 	lds	r31, 0x2F72
    3f5a:	62 87       	std	Z+10, r22	; 0x0a
    3f5c:	73 87       	std	Z+11, r23	; 0x0b
    3f5e:	cf 01       	movw	r24, r30
    3f60:	86 56       	subi	r24, 0x66	; 102
    3f62:	9f 42       	sbci	r25, 0x2F	; 47
    3f64:	8f 5f       	subi	r24, 0xFF	; 255
    3f66:	9f 4f       	sbci	r25, 0xFF	; 255
    3f68:	0e 94 7c 6c 	call	0xd8f8	; 0xd8f8 <eeprom_update_word>
    SETTING_UPDATE(GlobalSettings.ActiveSettingPtr->ReaderThreshold);
    return COMMAND_INFO_OK_ID;
    3f6c:	84 e6       	ldi	r24, 0x64	; 100
    3f6e:	01 c0       	rjmp	.+2      	; 0x3f72 <CommandSetThreshold+0xa0>
        snprintf_P(OutMessage, TERMINAL_BUFFER_SIZE, PSTR("Any integer from 0 to %u. Reference voltage will be (VCC * THRESHOLD / 4095) mV."), CODEC_MAXIMUM_THRESHOLD);
        return COMMAND_INFO_OK_WITH_TEXT_ID;
    }
    uint16_t tmp = 0;
    if (!sscanf_P(InParam, PSTR("%5d"), &tmp) || tmp > CODEC_MAXIMUM_THRESHOLD)
        return COMMAND_ERR_INVALID_PARAM_ID;
    3f70:	8a ec       	ldi	r24, 0xCA	; 202
    DACB.CH0DATA = tmp;
    GlobalSettings.ActiveSettingPtr->ReaderThreshold = tmp;
    SETTING_UPDATE(GlobalSettings.ActiveSettingPtr->ReaderThreshold);
    return COMMAND_INFO_OK_ID;
}
    3f72:	0f 90       	pop	r0
    3f74:	0f 90       	pop	r0
    3f76:	df 91       	pop	r29
    3f78:	cf 91       	pop	r28
    3f7a:	08 95       	ret

00003f7c <CommandSetField>:

CommandStatusIdType CommandSetField(char* OutMessage, const char* InParam)
{
    if (COMMAND_IS_SUGGEST_STRING(InParam))
    3f7c:	fb 01       	movw	r30, r22
    3f7e:	20 81       	ld	r18, Z
    3f80:	2f 33       	cpi	r18, 0x3F	; 63
    3f82:	d9 f4       	brne	.+54     	; 0x3fba <CommandSetField+0x3e>
    3f84:	21 81       	ldd	r18, Z+1	; 0x01
    3f86:	21 11       	cpse	r18, r1
    3f88:	21 c0       	rjmp	.+66     	; 0x3fcc <CommandSetField+0x50>
    {
        snprintf_P(OutMessage, TERMINAL_BUFFER_SIZE, PSTR("%c,%c"), COMMAND_CHAR_TRUE, COMMAND_CHAR_FALSE);
    3f8a:	1f 92       	push	r1
    3f8c:	20 e3       	ldi	r18, 0x30	; 48
    3f8e:	2f 93       	push	r18
    3f90:	1f 92       	push	r1
    3f92:	21 e3       	ldi	r18, 0x31	; 49
    3f94:	2f 93       	push	r18
    3f96:	23 ef       	ldi	r18, 0xF3	; 243
    3f98:	3a e0       	ldi	r19, 0x0A	; 10
    3f9a:	3f 93       	push	r19
    3f9c:	2f 93       	push	r18
    3f9e:	22 e0       	ldi	r18, 0x02	; 2
    3fa0:	2f 93       	push	r18
    3fa2:	1f 92       	push	r1
    3fa4:	9f 93       	push	r25
    3fa6:	8f 93       	push	r24
    3fa8:	0e 94 50 66 	call	0xcca0	; 0xcca0 <snprintf_P>
        return COMMAND_INFO_OK_WITH_TEXT_ID;
    3fac:	8d b7       	in	r24, 0x3d	; 61
    3fae:	9e b7       	in	r25, 0x3e	; 62
    3fb0:	0a 96       	adiw	r24, 0x0a	; 10
    3fb2:	8d bf       	out	0x3d, r24	; 61
    3fb4:	9e bf       	out	0x3e, r25	; 62
    3fb6:	85 e6       	ldi	r24, 0x65	; 101
    3fb8:	08 95       	ret
    }
    if (InParam[0] == COMMAND_CHAR_TRUE)
    3fba:	21 33       	cpi	r18, 0x31	; 49
    3fbc:	11 f4       	brne	.+4      	; 0x3fc2 <CommandSetField+0x46>
    {
        CodecReaderFieldStart();
    3fbe:	df d3       	rcall	.+1982   	; 0x477e <CodecReaderFieldStart>
    3fc0:	03 c0       	rjmp	.+6      	; 0x3fc8 <CommandSetField+0x4c>
    } else if(InParam[0] == COMMAND_CHAR_FALSE) {
    3fc2:	20 33       	cpi	r18, 0x30	; 48
    3fc4:	19 f4       	brne	.+6      	; 0x3fcc <CommandSetField+0x50>
        CodecReaderFieldStop();
    3fc6:	00 d4       	rcall	.+2048   	; 0x47c8 <CodecReaderFieldStop>
    } else {
        return COMMAND_ERR_INVALID_PARAM_ID;
    }
    return COMMAND_INFO_OK_ID;
    3fc8:	84 e6       	ldi	r24, 0x64	; 100
    3fca:	08 95       	ret
    {
        CodecReaderFieldStart();
    } else if(InParam[0] == COMMAND_CHAR_FALSE) {
        CodecReaderFieldStop();
    } else {
        return COMMAND_ERR_INVALID_PARAM_ID;
    3fcc:	8a ec       	ldi	r24, 0xCA	; 202
    }
    return COMMAND_INFO_OK_ID;
}
    3fce:	08 95       	ret

00003fd0 <CommandGetField>:

CommandStatusIdType CommandGetField(char* OutMessage)
{
    3fd0:	fc 01       	movw	r30, r24
    }
}

// Get the status of the reader field
INLINE bool CodecGetReaderField(void) {
    return (CODEC_READER_TIMER.CTRLA == TC_CLKSEL_DIV1_gc) && (AWEXC.OUTOVEN == CODEC_READER_MASK);
    3fd2:	80 91 00 08 	lds	r24, 0x0800
    3fd6:	81 30       	cpi	r24, 0x01	; 1
    3fd8:	21 f4       	brne	.+8      	; 0x3fe2 <CommandGetField+0x12>
    3fda:	80 91 8c 08 	lds	r24, 0x088C
    3fde:	83 30       	cpi	r24, 0x03	; 3
    3fe0:	11 f0       	breq	.+4      	; 0x3fe6 <CommandGetField+0x16>
    if (CodecGetReaderField())
        OutMessage[0] = COMMAND_CHAR_TRUE;
    else
        OutMessage[0] = COMMAND_CHAR_FALSE;
    3fe2:	80 e3       	ldi	r24, 0x30	; 48
    3fe4:	01 c0       	rjmp	.+2      	; 0x3fe8 <CommandGetField+0x18>
}

CommandStatusIdType CommandGetField(char* OutMessage)
{
    if (CodecGetReaderField())
        OutMessage[0] = COMMAND_CHAR_TRUE;
    3fe6:	81 e3       	ldi	r24, 0x31	; 49
    3fe8:	80 83       	st	Z, r24
    else
        OutMessage[0] = COMMAND_CHAR_FALSE;
    OutMessage[1] = '\0';
    3fea:	11 82       	std	Z+1, r1	; 0x01
    return COMMAND_INFO_OK_WITH_TEXT_ID;
}
    3fec:	85 e6       	ldi	r24, 0x65	; 101
    3fee:	08 95       	ret

00003ff0 <CommandExecAutocalibrate>:


CommandStatusIdType CommandExecAutocalibrate(char* OutMessage)
{
    if (GlobalSettings.ActiveSettingPtr->Configuration == CONFIG_ISO14443A_READER){
    3ff0:	e0 91 71 2f 	lds	r30, 0x2F71
    3ff4:	f0 91 72 2f 	lds	r31, 0x2F72
    3ff8:	85 81       	ldd	r24, Z+5	; 0x05
    3ffa:	89 30       	cpi	r24, 0x09	; 9
    3ffc:	79 f4       	brne	.+30     	; 0x401c <__stack+0x1d>
    3ffe:	e0 91 5e 2f 	lds	r30, 0x2F5E
    4002:	f0 91 5f 2f 	lds	r31, 0x2F5F
    4006:	19 95       	eicall
        ApplicationReset();

        Reader14443CurrentCommand = Reader14443_Autocalibrate;
    4008:	84 e0       	ldi	r24, 0x04	; 4
    400a:	80 93 e5 2c 	sts	0x2CE5, r24
        Reader14443AAppInit();
    400e:	0e 94 68 4c 	call	0x98d0	; 0x98d0 <Reader14443AAppInit>
        Reader14443ACodecStart();
    4012:	0e 94 cd 2c 	call	0x599a	; 0x599a <Reader14443ACodecStart>
        CommandLinePendingTaskTimeout = &Reader14443AAppTimeout;
    4016:	82 e7       	ldi	r24, 0x72	; 114
    4018:	9c e4       	ldi	r25, 0x4C	; 76
    401a:	0e c0       	rjmp	.+28     	; 0x4038 <__stack+0x39>
        return TIMEOUT_COMMAND;
    }
    else if (GlobalSettings.ActiveSettingPtr->Configuration == CONFIG_ISO14443A_SNIFF){
    401c:	88 30       	cpi	r24, 0x08	; 8
    401e:	91 f4       	brne	.+36     	; 0x4044 <__stack+0x45>
    4020:	e0 91 5e 2f 	lds	r30, 0x2F5E
    4024:	f0 91 5f 2f 	lds	r31, 0x2F5F
    4028:	19 95       	eicall
        ApplicationReset();

        Sniff14443CurrentCommand = Sniff14443_Autocalibrate;
    402a:	81 e0       	ldi	r24, 0x01	; 1
    402c:	80 93 c1 2d 	sts	0x2DC1, r24
        Sniff14443AAppInit();
    4030:	0e 94 38 54 	call	0xa870	; 0xa870 <Sniff14443AAppInit>
        CommandLinePendingTaskTimeout = &Sniff14443AAppTimeout;
    4034:	8d e4       	ldi	r24, 0x4D	; 77
    4036:	94 e5       	ldi	r25, 0x54	; 84
    4038:	80 93 90 2c 	sts	0x2C90, r24
    403c:	90 93 91 2c 	sts	0x2C91, r25
        return TIMEOUT_COMMAND;
    4040:	8f ef       	ldi	r24, 0xFF	; 255
    4042:	08 95       	ret
    }
    else {
        return COMMAND_ERR_INVALID_USAGE_ID;
    4044:	89 ec       	ldi	r24, 0xC9	; 201
    }

}
    4046:	08 95       	ret

00004048 <XModemReceive>:
    return Checksum;
}

void XModemReceive(XModemCallbackType TheCallbackFunc)
{
    State = STATE_RECEIVE_INIT;
    4048:	21 e0       	ldi	r18, 0x01	; 1
    404a:	20 93 8f 2c 	sts	0x2C8F, r18
    CurrentFrameNumber = FIRST_FRAME_NUMBER;
    404e:	20 93 8e 2c 	sts	0x2C8E, r18
    RetryCount = RECV_INIT_COUNT;
    4052:	2c e3       	ldi	r18, 0x3C	; 60
    4054:	20 93 8b 2c 	sts	0x2C8B, r18
    RetryTimeout = RECV_INIT_TIMEOUT;
    4058:	25 e0       	ldi	r18, 0x05	; 5
    405a:	30 e0       	ldi	r19, 0x00	; 0
    405c:	20 93 89 2c 	sts	0x2C89, r18
    4060:	30 93 8a 2c 	sts	0x2C8A, r19
    BlockAddress = 0;
    4064:	10 92 83 2c 	sts	0x2C83, r1
    4068:	10 92 84 2c 	sts	0x2C84, r1
    406c:	10 92 85 2c 	sts	0x2C85, r1
    4070:	10 92 86 2c 	sts	0x2C86, r1

    CallbackFunc = TheCallbackFunc;
    4074:	80 93 81 2c 	sts	0x2C81, r24
    4078:	90 93 82 2c 	sts	0x2C82, r25
    407c:	08 95       	ret

0000407e <XModemSend>:
}

void XModemSend(XModemCallbackType TheCallbackFunc)
{
    State = STATE_SEND_INIT;
    407e:	27 e0       	ldi	r18, 0x07	; 7
    4080:	20 93 8f 2c 	sts	0x2C8F, r18
    RetryTimeout = SEND_INIT_TIMEOUT;
    4084:	2c e2       	ldi	r18, 0x2C	; 44
    4086:	31 e0       	ldi	r19, 0x01	; 1
    4088:	20 93 89 2c 	sts	0x2C89, r18
    408c:	30 93 8a 2c 	sts	0x2C8A, r19
    BlockAddress = 0;
    4090:	10 92 83 2c 	sts	0x2C83, r1
    4094:	10 92 84 2c 	sts	0x2C84, r1
    4098:	10 92 85 2c 	sts	0x2C85, r1
    409c:	10 92 86 2c 	sts	0x2C86, r1

    CallbackFunc = TheCallbackFunc;
    40a0:	80 93 81 2c 	sts	0x2C81, r24
    40a4:	90 93 82 2c 	sts	0x2C82, r25
    40a8:	08 95       	ret

000040aa <XModemProcessByte>:
}

bool XModemProcessByte(uint8_t Byte)
{
    40aa:	cf 93       	push	r28
    switch(State) {
    40ac:	90 91 8f 2c 	lds	r25, 0x2C8F
    40b0:	95 30       	cpi	r25, 0x05	; 5
    40b2:	e1 f1       	breq	.+120    	; 0x412c <XModemProcessByte+0x82>
    40b4:	30 f4       	brcc	.+12     	; 0x40c2 <XModemProcessByte+0x18>
    40b6:	93 30       	cpi	r25, 0x03	; 3
    40b8:	29 f1       	breq	.+74     	; 0x4104 <XModemProcessByte+0x5a>
    40ba:	40 f5       	brcc	.+80     	; 0x410c <XModemProcessByte+0x62>
    40bc:	91 30       	cpi	r25, 0x01	; 1
    40be:	68 f4       	brcc	.+26     	; 0x40da <XModemProcessByte+0x30>
    40c0:	40 c1       	rjmp	.+640    	; 0x4342 <XModemProcessByte+0x298>
    40c2:	97 30       	cpi	r25, 0x07	; 7
    40c4:	09 f4       	brne	.+2      	; 0x40c8 <XModemProcessByte+0x1e>
    40c6:	a7 c0       	rjmp	.+334    	; 0x4216 <XModemProcessByte+0x16c>
    40c8:	08 f4       	brcc	.+2      	; 0x40cc <XModemProcessByte+0x22>
    40ca:	45 c0       	rjmp	.+138    	; 0x4156 <XModemProcessByte+0xac>
    40cc:	98 30       	cpi	r25, 0x08	; 8
    40ce:	09 f4       	brne	.+2      	; 0x40d2 <XModemProcessByte+0x28>
    40d0:	aa c0       	rjmp	.+340    	; 0x4226 <XModemProcessByte+0x17c>
    40d2:	99 30       	cpi	r25, 0x09	; 9
    40d4:	09 f4       	brne	.+2      	; 0x40d8 <XModemProcessByte+0x2e>
    40d6:	32 c1       	rjmp	.+612    	; 0x433c <XModemProcessByte+0x292>
    40d8:	34 c1       	rjmp	.+616    	; 0x4342 <XModemProcessByte+0x298>
    case STATE_RECEIVE_INIT:
    case STATE_RECEIVE_WAIT:
        if (Byte == BYTE_SOH) {
    40da:	81 30       	cpi	r24, 0x01	; 1
    40dc:	41 f4       	brne	.+16     	; 0x40ee <XModemProcessByte+0x44>
            /* Next frame incoming */
            BufferIdx = 0;
    40de:	10 92 87 2c 	sts	0x2C87, r1
    40e2:	10 92 88 2c 	sts	0x2C88, r1
            Checksum = CHECKSUM_INIT_VALUE;
    40e6:	10 92 8c 2c 	sts	0x2C8C, r1
            State = STATE_RECEIVE_FRAMENUM1;
    40ea:	83 e0       	ldi	r24, 0x03	; 3
    40ec:	fb c0       	rjmp	.+502    	; 0x42e4 <XModemProcessByte+0x23a>
        } else if (Byte == BYTE_EOT) {
    40ee:	84 30       	cpi	r24, 0x04	; 4
    40f0:	11 f4       	brne	.+4      	; 0x40f6 <XModemProcessByte+0x4c>
INLINE void TerminalSendByte(uint8_t Byte) { CDC_Device_SendByte(&TerminalHandle, Byte); }
    40f2:	66 e0       	ldi	r22, 0x06	; 6
    40f4:	8b c0       	rjmp	.+278    	; 0x420c <XModemProcessByte+0x162>
            /* Transmission finished */
            TerminalSendByte(BYTE_ACK);
            State = STATE_OFF;
        } else if ( (Byte == BYTE_CAN) || (Byte == BYTE_ESC) ) {
    40f6:	88 31       	cpi	r24, 0x18	; 24
    40f8:	09 f4       	brne	.+2      	; 0x40fc <XModemProcessByte+0x52>
    40fa:	20 c1       	rjmp	.+576    	; 0x433c <XModemProcessByte+0x292>
    40fc:	8b 31       	cpi	r24, 0x1B	; 27
    40fe:	09 f0       	breq	.+2      	; 0x4102 <XModemProcessByte+0x58>
    4100:	f3 c0       	rjmp	.+486    	; 0x42e8 <XModemProcessByte+0x23e>
    4102:	1c c1       	rjmp	.+568    	; 0x433c <XModemProcessByte+0x292>

        break;

    case STATE_RECEIVE_FRAMENUM1:
        /* Store frame number */
        ReceivedFrameNumber = Byte;
    4104:	80 93 8d 2c 	sts	0x2C8D, r24
        State = STATE_RECEIVE_FRAMENUM2;
    4108:	84 e0       	ldi	r24, 0x04	; 4
    410a:	ec c0       	rjmp	.+472    	; 0x42e4 <XModemProcessByte+0x23a>
        break;

    case STATE_RECEIVE_FRAMENUM2:
        if (Byte == (255 - ReceivedFrameNumber)) {
    410c:	90 e0       	ldi	r25, 0x00	; 0
    410e:	40 91 8d 2c 	lds	r20, 0x2C8D
    4112:	2f ef       	ldi	r18, 0xFF	; 255
    4114:	30 e0       	ldi	r19, 0x00	; 0
    4116:	24 1b       	sub	r18, r20
    4118:	31 09       	sbc	r19, r1
    411a:	82 17       	cp	r24, r18
    411c:	93 07       	cpc	r25, r19
    411e:	21 f4       	brne	.+8      	; 0x4128 <XModemProcessByte+0x7e>
            /* frame-number check passed. */
            State = STATE_RECEIVE_DATA;
    4120:	85 e0       	ldi	r24, 0x05	; 5
    4122:	e0 c0       	rjmp	.+448    	; 0x42e4 <XModemProcessByte+0x23a>

    case STATE_RECEIVE_PROCESS:
        if (ReceivedFrameNumber == CurrentFrameNumber) {
            /* This is the expected frame. Calculate and verify checksum */

            if (CalcChecksum(TerminalBuffer, XMODEM_BLOCK_SIZE) == Byte) {
    4124:	98 17       	cp	r25, r24
    4126:	39 f1       	breq	.+78     	; 0x4176 <XModemProcessByte+0xcc>
    4128:	65 e1       	ldi	r22, 0x15	; 21
    412a:	69 c0       	rjmp	.+210    	; 0x41fe <XModemProcessByte+0x154>

        break;

    case STATE_RECEIVE_DATA:
        /* Process byte and update checksum */
        TerminalBuffer[BufferIdx++] = Byte;
    412c:	20 91 87 2c 	lds	r18, 0x2C87
    4130:	30 91 88 2c 	lds	r19, 0x2C88
    4134:	a9 01       	movw	r20, r18
    4136:	4f 5f       	subi	r20, 0xFF	; 255
    4138:	5f 4f       	sbci	r21, 0xFF	; 255
    413a:	40 93 87 2c 	sts	0x2C87, r20
    413e:	50 93 88 2c 	sts	0x2C88, r21
    4142:	f9 01       	movw	r30, r18
    4144:	ed 52       	subi	r30, 0x2D	; 45
    4146:	f0 4d       	sbci	r31, 0xD0	; 208
    4148:	80 83       	st	Z, r24

        if (BufferIdx == XMODEM_BLOCK_SIZE) {
    414a:	40 38       	cpi	r20, 0x80	; 128
    414c:	51 05       	cpc	r21, r1
    414e:	09 f0       	breq	.+2      	; 0x4152 <XModemProcessByte+0xa8>
    4150:	cb c0       	rjmp	.+406    	; 0x42e8 <XModemProcessByte+0x23e>
            /* Block full */
            State = STATE_RECEIVE_PROCESS;
    4152:	86 e0       	ldi	r24, 0x06	; 6
    4154:	c7 c0       	rjmp	.+398    	; 0x42e4 <XModemProcessByte+0x23a>
        }

        break;

    case STATE_RECEIVE_PROCESS:
        if (ReceivedFrameNumber == CurrentFrameNumber) {
    4156:	20 91 8d 2c 	lds	r18, 0x2C8D
    415a:	90 91 8e 2c 	lds	r25, 0x2C8E
    415e:	29 13       	cpse	r18, r25
    4160:	46 c0       	rjmp	.+140    	; 0x41ee <XModemProcessByte+0x144>
    4162:	e3 ed       	ldi	r30, 0xD3	; 211
    4164:	ff e2       	ldi	r31, 0x2F	; 47
    4166:	90 e0       	ldi	r25, 0x00	; 0

static uint8_t CalcChecksum(const void* Buffer, uint16_t ByteCount) {
    uint8_t Checksum = CHECKSUM_INIT_VALUE;
    uint8_t* DataPtr = (uint8_t*) Buffer;

    while(ByteCount--) {
    4168:	20 e3       	ldi	r18, 0x30	; 48
    416a:	e3 35       	cpi	r30, 0x53	; 83
    416c:	f2 07       	cpc	r31, r18
    416e:	d1 f2       	breq	.-76     	; 0x4124 <XModemProcessByte+0x7a>
        Checksum += *DataPtr++;
    4170:	21 91       	ld	r18, Z+
    4172:	92 0f       	add	r25, r18
    4174:	f9 cf       	rjmp	.-14     	; 0x4168 <XModemProcessByte+0xbe>
        if (ReceivedFrameNumber == CurrentFrameNumber) {
            /* This is the expected frame. Calculate and verify checksum */

            if (CalcChecksum(TerminalBuffer, XMODEM_BLOCK_SIZE) == Byte) {
                /* Checksum is valid. Pass received data to callback function */
                if (CallbackFunc(TerminalBuffer, BlockAddress, XMODEM_BLOCK_SIZE)) {
    4176:	40 91 83 2c 	lds	r20, 0x2C83
    417a:	50 91 84 2c 	lds	r21, 0x2C84
    417e:	60 91 85 2c 	lds	r22, 0x2C85
    4182:	70 91 86 2c 	lds	r23, 0x2C86
    4186:	e0 91 81 2c 	lds	r30, 0x2C81
    418a:	f0 91 82 2c 	lds	r31, 0x2C82
    418e:	20 e8       	ldi	r18, 0x80	; 128
    4190:	30 e0       	ldi	r19, 0x00	; 0
    4192:	83 ed       	ldi	r24, 0xD3	; 211
    4194:	9f e2       	ldi	r25, 0x2F	; 47
    4196:	19 95       	eicall
    4198:	c8 2f       	mov	r28, r24
    419a:	88 23       	and	r24, r24
    419c:	11 f1       	breq	.+68     	; 0x41e2 <XModemProcessByte+0x138>
                    /* Proceed to next frame and send ACK */
                    CurrentFrameNumber++;
    419e:	80 91 8e 2c 	lds	r24, 0x2C8E
    41a2:	8f 5f       	subi	r24, 0xFF	; 255
    41a4:	80 93 8e 2c 	sts	0x2C8E, r24
                    BlockAddress += XMODEM_BLOCK_SIZE;
    41a8:	80 91 83 2c 	lds	r24, 0x2C83
    41ac:	90 91 84 2c 	lds	r25, 0x2C84
    41b0:	a0 91 85 2c 	lds	r26, 0x2C85
    41b4:	b0 91 86 2c 	lds	r27, 0x2C86
    41b8:	80 58       	subi	r24, 0x80	; 128
    41ba:	9f 4f       	sbci	r25, 0xFF	; 255
    41bc:	af 4f       	sbci	r26, 0xFF	; 255
    41be:	bf 4f       	sbci	r27, 0xFF	; 255
    41c0:	80 93 83 2c 	sts	0x2C83, r24
    41c4:	90 93 84 2c 	sts	0x2C84, r25
    41c8:	a0 93 85 2c 	sts	0x2C85, r26
    41cc:	b0 93 86 2c 	sts	0x2C86, r27
void EVENT_USB_Device_Connect(void);
void EVENT_USB_Device_Disconnect(void);
void EVENT_USB_Device_ConfigurationChanged(void);
void EVENT_USB_Device_ControlRequest(void);

INLINE void TerminalSendChar(char c) { CDC_Device_SendByte(&TerminalHandle, c); }
    41d0:	66 e0       	ldi	r22, 0x06	; 6
    41d2:	83 e0       	ldi	r24, 0x03	; 3
    41d4:	90 e2       	ldi	r25, 0x20	; 32
    41d6:	0e 94 bf 63 	call	0xc77e	; 0xc77e <CDC_Device_SendByte>
                    TerminalSendChar(BYTE_ACK);
                    State = STATE_RECEIVE_WAIT;
    41da:	82 e0       	ldi	r24, 0x02	; 2
    41dc:	80 93 8f 2c 	sts	0x2C8F, r24
    41e0:	b1 c0       	rjmp	.+354    	; 0x4344 <XModemProcessByte+0x29a>
INLINE void TerminalSendByte(uint8_t Byte) { CDC_Device_SendByte(&TerminalHandle, Byte); }
    41e2:	68 e1       	ldi	r22, 0x18	; 24
    41e4:	83 e0       	ldi	r24, 0x03	; 3
    41e6:	90 e2       	ldi	r25, 0x20	; 32
    41e8:	0e 94 bf 63 	call	0xc77e	; 0xc77e <CDC_Device_SendByte>
    41ec:	0e c0       	rjmp	.+28     	; 0x420a <XModemProcessByte+0x160>
            } else {
                /* Data seems to be damaged */
                TerminalSendByte(BYTE_NAK);
                State = STATE_RECEIVE_WAIT;
            }
        } else if (ReceivedFrameNumber == (CurrentFrameNumber - 1)) {
    41ee:	30 e0       	ldi	r19, 0x00	; 0
    41f0:	89 2f       	mov	r24, r25
    41f2:	90 e0       	ldi	r25, 0x00	; 0
    41f4:	01 97       	sbiw	r24, 0x01	; 1
    41f6:	28 17       	cp	r18, r24
    41f8:	39 07       	cpc	r19, r25
    41fa:	39 f4       	brne	.+14     	; 0x420a <XModemProcessByte+0x160>
    41fc:	66 e0       	ldi	r22, 0x06	; 6
    41fe:	83 e0       	ldi	r24, 0x03	; 3
    4200:	90 e2       	ldi	r25, 0x20	; 32
    4202:	0e 94 bf 63 	call	0xc77e	; 0xc77e <CDC_Device_SendByte>
            /* This is a retransmission */
            TerminalSendByte(BYTE_ACK);
            State = STATE_RECEIVE_WAIT;
    4206:	82 e0       	ldi	r24, 0x02	; 2
    4208:	6d c0       	rjmp	.+218    	; 0x42e4 <XModemProcessByte+0x23a>
    420a:	68 e1       	ldi	r22, 0x18	; 24
    420c:	83 e0       	ldi	r24, 0x03	; 3
    420e:	90 e2       	ldi	r25, 0x20	; 32
    4210:	0e 94 bf 63 	call	0xc77e	; 0xc77e <CDC_Device_SendByte>
    4214:	93 c0       	rjmp	.+294    	; 0x433c <XModemProcessByte+0x292>

        break;

    case STATE_SEND_INIT:
        /* Start sending on NAK */
        if (Byte == BYTE_NAK) {
    4216:	85 31       	cpi	r24, 0x15	; 21
    4218:	19 f4       	brne	.+6      	; 0x4220 <XModemProcessByte+0x176>
            CurrentFrameNumber = FIRST_FRAME_NUMBER - 1;
    421a:	10 92 8e 2c 	sts	0x2C8E, r1
    421e:	09 c0       	rjmp	.+18     	; 0x4232 <XModemProcessByte+0x188>
            Byte = BYTE_ACK;
        } else if (Byte == BYTE_ESC) {
    4220:	8b 31       	cpi	r24, 0x1B	; 27
    4222:	09 f4       	brne	.+2      	; 0x4226 <XModemProcessByte+0x17c>
    4224:	8b c0       	rjmp	.+278    	; 0x433c <XModemProcessByte+0x292>
        }

        /* Fallthrough */

    case STATE_SEND_WAIT:
        if (Byte == BYTE_CAN) {
    4226:	88 31       	cpi	r24, 0x18	; 24
    4228:	09 f4       	brne	.+2      	; 0x422c <XModemProcessByte+0x182>
    422a:	63 cf       	rjmp	.-314    	; 0x40f2 <XModemProcessByte+0x48>
            /* Cancel */
            TerminalSendByte(BYTE_ACK);
            State = STATE_OFF;
        } else if (Byte == BYTE_ACK) {
    422c:	86 30       	cpi	r24, 0x06	; 6
    422e:	09 f0       	breq	.+2      	; 0x4232 <XModemProcessByte+0x188>
    4230:	5d c0       	rjmp	.+186    	; 0x42ec <XModemProcessByte+0x242>
            /* Acknowledge. Proceed to next frame, get data and calc checksum */
            CurrentFrameNumber++;
    4232:	80 91 8e 2c 	lds	r24, 0x2C8E
    4236:	8f 5f       	subi	r24, 0xFF	; 255
    4238:	80 93 8e 2c 	sts	0x2C8E, r24

            if (CallbackFunc(TerminalBuffer, BlockAddress, XMODEM_BLOCK_SIZE)) {
    423c:	40 91 83 2c 	lds	r20, 0x2C83
    4240:	50 91 84 2c 	lds	r21, 0x2C84
    4244:	60 91 85 2c 	lds	r22, 0x2C85
    4248:	70 91 86 2c 	lds	r23, 0x2C86
    424c:	e0 91 81 2c 	lds	r30, 0x2C81
    4250:	f0 91 82 2c 	lds	r31, 0x2C82
    4254:	20 e8       	ldi	r18, 0x80	; 128
    4256:	30 e0       	ldi	r19, 0x00	; 0
    4258:	83 ed       	ldi	r24, 0xD3	; 211
    425a:	9f e2       	ldi	r25, 0x2F	; 47
    425c:	19 95       	eicall
    425e:	c8 2f       	mov	r28, r24
    4260:	88 23       	and	r24, r24
    4262:	d1 f1       	breq	.+116    	; 0x42d8 <XModemProcessByte+0x22e>
    4264:	61 e0       	ldi	r22, 0x01	; 1
    4266:	83 e0       	ldi	r24, 0x03	; 3
    4268:	90 e2       	ldi	r25, 0x20	; 32
    426a:	0e 94 bf 63 	call	0xc77e	; 0xc77e <CDC_Device_SendByte>
    426e:	60 91 8e 2c 	lds	r22, 0x2C8E
    4272:	83 e0       	ldi	r24, 0x03	; 3
    4274:	90 e2       	ldi	r25, 0x20	; 32
    4276:	0e 94 bf 63 	call	0xc77e	; 0xc77e <CDC_Device_SendByte>
                TerminalSendByte(BYTE_SOH);
                TerminalSendByte(CurrentFrameNumber);
                TerminalSendByte(255 - CurrentFrameNumber);
    427a:	60 91 8e 2c 	lds	r22, 0x2C8E
    427e:	60 95       	com	r22
    4280:	83 e0       	ldi	r24, 0x03	; 3
    4282:	90 e2       	ldi	r25, 0x20	; 32
    4284:	0e 94 bf 63 	call	0xc77e	; 0xc77e <CDC_Device_SendByte>
                TerminalSendBlock(TerminalBuffer, XMODEM_BLOCK_SIZE);
    4288:	60 e8       	ldi	r22, 0x80	; 128
    428a:	70 e0       	ldi	r23, 0x00	; 0
    428c:	83 ed       	ldi	r24, 0xD3	; 211
    428e:	9f e2       	ldi	r25, 0x2F	; 47
    4290:	70 d8       	rcall	.-3872   	; 0x3372 <TerminalSendBlock>
    4292:	e3 ed       	ldi	r30, 0xD3	; 211
    4294:	ff e2       	ldi	r31, 0x2F	; 47
static uint32_t BlockAddress;

static XModemCallbackType CallbackFunc;

static uint8_t CalcChecksum(const void* Buffer, uint16_t ByteCount) {
    uint8_t Checksum = CHECKSUM_INIT_VALUE;
    4296:	60 e0       	ldi	r22, 0x00	; 0
    uint8_t* DataPtr = (uint8_t*) Buffer;

    while(ByteCount--) {
    4298:	80 e3       	ldi	r24, 0x30	; 48
    429a:	e3 35       	cpi	r30, 0x53	; 83
    429c:	f8 07       	cpc	r31, r24
    429e:	19 f0       	breq	.+6      	; 0x42a6 <XModemProcessByte+0x1fc>
        Checksum += *DataPtr++;
    42a0:	81 91       	ld	r24, Z+
    42a2:	68 0f       	add	r22, r24
    42a4:	f9 cf       	rjmp	.-14     	; 0x4298 <XModemProcessByte+0x1ee>
    42a6:	83 e0       	ldi	r24, 0x03	; 3
    42a8:	90 e2       	ldi	r25, 0x20	; 32
    42aa:	0e 94 bf 63 	call	0xc77e	; 0xc77e <CDC_Device_SendByte>
                TerminalSendByte(CurrentFrameNumber);
                TerminalSendByte(255 - CurrentFrameNumber);
                TerminalSendBlock(TerminalBuffer, XMODEM_BLOCK_SIZE);
                TerminalSendByte(CalcChecksum(TerminalBuffer, XMODEM_BLOCK_SIZE));

                BlockAddress += XMODEM_BLOCK_SIZE;
    42ae:	80 91 83 2c 	lds	r24, 0x2C83
    42b2:	90 91 84 2c 	lds	r25, 0x2C84
    42b6:	a0 91 85 2c 	lds	r26, 0x2C85
    42ba:	b0 91 86 2c 	lds	r27, 0x2C86
    42be:	80 58       	subi	r24, 0x80	; 128
    42c0:	9f 4f       	sbci	r25, 0xFF	; 255
    42c2:	af 4f       	sbci	r26, 0xFF	; 255
    42c4:	bf 4f       	sbci	r27, 0xFF	; 255
    42c6:	80 93 83 2c 	sts	0x2C83, r24
    42ca:	90 93 84 2c 	sts	0x2C84, r25
    42ce:	a0 93 85 2c 	sts	0x2C85, r26
    42d2:	b0 93 86 2c 	sts	0x2C86, r27
    42d6:	36 c0       	rjmp	.+108    	; 0x4344 <XModemProcessByte+0x29a>
    42d8:	64 e0       	ldi	r22, 0x04	; 4
    42da:	83 e0       	ldi	r24, 0x03	; 3
    42dc:	90 e2       	ldi	r25, 0x20	; 32
    42de:	0e 94 bf 63 	call	0xc77e	; 0xc77e <CDC_Device_SendByte>
            } else {
                TerminalSendByte(BYTE_EOT);
                State = STATE_SEND_EOT;
    42e2:	89 e0       	ldi	r24, 0x09	; 9
    42e4:	80 93 8f 2c 	sts	0x2C8F, r24
    default:
        return false;
        break;
    }

    return true;
    42e8:	c1 e0       	ldi	r28, 0x01	; 1
    42ea:	2c c0       	rjmp	.+88     	; 0x4344 <XModemProcessByte+0x29a>
                BlockAddress += XMODEM_BLOCK_SIZE;
            } else {
                TerminalSendByte(BYTE_EOT);
                State = STATE_SEND_EOT;
            }
        } else if (Byte == BYTE_NAK){
    42ec:	85 31       	cpi	r24, 0x15	; 21
    42ee:	e1 f7       	brne	.-8      	; 0x42e8 <XModemProcessByte+0x23e>
    42f0:	61 e0       	ldi	r22, 0x01	; 1
    42f2:	83 e0       	ldi	r24, 0x03	; 3
    42f4:	90 e2       	ldi	r25, 0x20	; 32
    42f6:	0e 94 bf 63 	call	0xc77e	; 0xc77e <CDC_Device_SendByte>
    42fa:	60 91 8e 2c 	lds	r22, 0x2C8E
    42fe:	83 e0       	ldi	r24, 0x03	; 3
    4300:	90 e2       	ldi	r25, 0x20	; 32
    4302:	0e 94 bf 63 	call	0xc77e	; 0xc77e <CDC_Device_SendByte>
            /* Resend frame */
            TerminalSendByte(BYTE_SOH);
            TerminalSendByte(CurrentFrameNumber);
            TerminalSendByte(255 - CurrentFrameNumber);
    4306:	60 91 8e 2c 	lds	r22, 0x2C8E
    430a:	60 95       	com	r22
    430c:	83 e0       	ldi	r24, 0x03	; 3
    430e:	90 e2       	ldi	r25, 0x20	; 32
    4310:	0e 94 bf 63 	call	0xc77e	; 0xc77e <CDC_Device_SendByte>
            TerminalSendBlock(TerminalBuffer, XMODEM_BLOCK_SIZE);
    4314:	60 e8       	ldi	r22, 0x80	; 128
    4316:	70 e0       	ldi	r23, 0x00	; 0
    4318:	83 ed       	ldi	r24, 0xD3	; 211
    431a:	9f e2       	ldi	r25, 0x2F	; 47
    431c:	2a d8       	rcall	.-4012   	; 0x3372 <TerminalSendBlock>
    431e:	e3 ed       	ldi	r30, 0xD3	; 211
    4320:	ff e2       	ldi	r31, 0x2F	; 47
static uint32_t BlockAddress;

static XModemCallbackType CallbackFunc;

static uint8_t CalcChecksum(const void* Buffer, uint16_t ByteCount) {
    uint8_t Checksum = CHECKSUM_INIT_VALUE;
    4322:	60 e0       	ldi	r22, 0x00	; 0
    uint8_t* DataPtr = (uint8_t*) Buffer;

    while(ByteCount--) {
    4324:	20 e3       	ldi	r18, 0x30	; 48
    4326:	e3 35       	cpi	r30, 0x53	; 83
    4328:	f2 07       	cpc	r31, r18
    432a:	19 f0       	breq	.+6      	; 0x4332 <XModemProcessByte+0x288>
        Checksum += *DataPtr++;
    432c:	81 91       	ld	r24, Z+
    432e:	68 0f       	add	r22, r24
    4330:	f9 cf       	rjmp	.-14     	; 0x4324 <XModemProcessByte+0x27a>
    4332:	83 e0       	ldi	r24, 0x03	; 3
    4334:	90 e2       	ldi	r25, 0x20	; 32
    4336:	0e 94 bf 63 	call	0xc77e	; 0xc77e <CDC_Device_SendByte>
    433a:	d6 cf       	rjmp	.-84     	; 0x42e8 <XModemProcessByte+0x23e>

        break;

    case STATE_SEND_EOT:
        /* Receive Ack */
        State = STATE_OFF;
    433c:	10 92 8f 2c 	sts	0x2C8F, r1
    4340:	d3 cf       	rjmp	.-90     	; 0x42e8 <XModemProcessByte+0x23e>
        break;

    default:
        return false;
    4342:	c0 e0       	ldi	r28, 0x00	; 0
        break;
    }

    return true;
}
    4344:	8c 2f       	mov	r24, r28
    4346:	cf 91       	pop	r28
    4348:	08 95       	ret

0000434a <XModemTick>:

void XModemTick(void)
{
    /* Timeouts go here */
    switch(State) {
    434a:	80 91 8f 2c 	lds	r24, 0x2C8F
    434e:	81 30       	cpi	r24, 0x01	; 1
    4350:	19 f0       	breq	.+6      	; 0x4358 <XModemTick+0xe>
    4352:	87 30       	cpi	r24, 0x07	; 7
    4354:	29 f1       	breq	.+74     	; 0x43a0 <XModemTick+0x56>
    4356:	08 95       	ret
    case STATE_RECEIVE_INIT:
        if (RetryTimeout-- == 0) {
    4358:	80 91 89 2c 	lds	r24, 0x2C89
    435c:	90 91 8a 2c 	lds	r25, 0x2C8A
    4360:	9c 01       	movw	r18, r24
    4362:	21 50       	subi	r18, 0x01	; 1
    4364:	31 09       	sbc	r19, r1
    4366:	20 93 89 2c 	sts	0x2C89, r18
    436a:	30 93 8a 2c 	sts	0x2C8A, r19
    436e:	89 2b       	or	r24, r25
    4370:	31 f5       	brne	.+76     	; 0x43be <XModemTick+0x74>
            if (RetryCount-- > 0) {
    4372:	80 91 8b 2c 	lds	r24, 0x2C8B
    4376:	9f ef       	ldi	r25, 0xFF	; 255
    4378:	98 0f       	add	r25, r24
    437a:	90 93 8b 2c 	sts	0x2C8B, r25
    437e:	88 23       	and	r24, r24
    4380:	31 f0       	breq	.+12     	; 0x438e <XModemTick+0x44>
void EVENT_USB_Device_Connect(void);
void EVENT_USB_Device_Disconnect(void);
void EVENT_USB_Device_ConfigurationChanged(void);
void EVENT_USB_Device_ControlRequest(void);

INLINE void TerminalSendChar(char c) { CDC_Device_SendByte(&TerminalHandle, c); }
    4382:	65 e1       	ldi	r22, 0x15	; 21
    4384:	83 e0       	ldi	r24, 0x03	; 3
    4386:	90 e2       	ldi	r25, 0x20	; 32
    4388:	0e 94 bf 63 	call	0xc77e	; 0xc77e <CDC_Device_SendByte>
    438c:	02 c0       	rjmp	.+4      	; 0x4392 <XModemTick+0x48>
                /* Put out communication request */
                TerminalSendChar(BYTE_NAK);
            } else {
                /* Just shut off after some time. */
                State = STATE_OFF;
    438e:	10 92 8f 2c 	sts	0x2C8F, r1
            }

            RetryTimeout = RECV_INIT_TIMEOUT;
    4392:	85 e0       	ldi	r24, 0x05	; 5
    4394:	90 e0       	ldi	r25, 0x00	; 0
    4396:	80 93 89 2c 	sts	0x2C89, r24
    439a:	90 93 8a 2c 	sts	0x2C8A, r25
    439e:	08 95       	ret
        }
        break;

    case STATE_SEND_INIT:
        if (RetryTimeout-- == 0) {
    43a0:	80 91 89 2c 	lds	r24, 0x2C89
    43a4:	90 91 8a 2c 	lds	r25, 0x2C8A
    43a8:	9c 01       	movw	r18, r24
    43aa:	21 50       	subi	r18, 0x01	; 1
    43ac:	31 09       	sbc	r19, r1
    43ae:	20 93 89 2c 	sts	0x2C89, r18
    43b2:	30 93 8a 2c 	sts	0x2C8A, r19
    43b6:	89 2b       	or	r24, r25
    43b8:	11 f4       	brne	.+4      	; 0x43be <XModemTick+0x74>
            /* Abort */
            State = STATE_OFF;
    43ba:	10 92 8f 2c 	sts	0x2C8F, r1
    43be:	08 95       	ret

000043c0 <GetStatusMessageP>:
  }
}

void CommandLineInit(void)
{
  BufferIdx = 0;
    43c0:	e3 ea       	ldi	r30, 0xA3	; 163
    43c2:	fc e0       	ldi	r31, 0x0C	; 12
    43c4:	20 e0       	ldi	r18, 0x00	; 0
    43c6:	30 e0       	ldi	r19, 0x00	; 0
    43c8:	94 91       	lpm	r25, Z
    43ca:	98 13       	cpse	r25, r24
    43cc:	09 c0       	rjmp	.+18     	; 0x43e0 <GetStatusMessageP+0x20>
    43ce:	41 e2       	ldi	r20, 0x21	; 33
    43d0:	42 9f       	mul	r20, r18
    43d2:	c0 01       	movw	r24, r0
    43d4:	43 9f       	mul	r20, r19
    43d6:	90 0d       	add	r25, r0
    43d8:	11 24       	eor	r1, r1
    43da:	8c 55       	subi	r24, 0x5C	; 92
    43dc:	93 4f       	sbci	r25, 0xF3	; 243
    43de:	08 95       	ret
    43e0:	2f 5f       	subi	r18, 0xFF	; 255
    43e2:	3f 4f       	sbci	r19, 0xFF	; 255
    43e4:	b1 96       	adiw	r30, 0x21	; 33
    43e6:	29 30       	cpi	r18, 0x09	; 9
    43e8:	31 05       	cpc	r19, r1
    43ea:	71 f7       	brne	.-36     	; 0x43c8 <GetStatusMessageP+0x8>
    43ec:	80 e0       	ldi	r24, 0x00	; 0
    43ee:	90 e0       	ldi	r25, 0x00	; 0
    43f0:	08 95       	ret

000043f2 <CommandLineProcessByte>:
}

bool CommandLineProcessByte(uint8_t Byte) {
    43f2:	cf 92       	push	r12
    43f4:	df 92       	push	r13
    43f6:	ef 92       	push	r14
    43f8:	ff 92       	push	r15
    43fa:	0f 93       	push	r16
    43fc:	1f 93       	push	r17
    43fe:	cf 93       	push	r28
	if (IS_CHARACTER(Byte)) {
    4400:	98 2f       	mov	r25, r24
    4402:	9f 7d       	andi	r25, 0xDF	; 223
    4404:	91 54       	subi	r25, 0x41	; 65
    4406:	9a 31       	cpi	r25, 0x1A	; 26
    4408:	60 f0       	brcs	.+24     	; 0x4422 <CommandLineProcessByte+0x30>
    440a:	90 ed       	ldi	r25, 0xD0	; 208
    440c:	98 0f       	add	r25, r24
    440e:	9a 30       	cpi	r25, 0x0A	; 10
    4410:	40 f0       	brcs	.+16     	; 0x4422 <CommandLineProcessByte+0x30>
    4412:	8f 35       	cpi	r24, 0x5F	; 95
    4414:	31 f0       	breq	.+12     	; 0x4422 <CommandLineProcessByte+0x30>
    4416:	98 2f       	mov	r25, r24
    4418:	9d 7f       	andi	r25, 0xFD	; 253
    441a:	9d 33       	cpi	r25, 0x3D	; 61
    441c:	11 f0       	breq	.+4      	; 0x4422 <CommandLineProcessByte+0x30>
    441e:	80 32       	cpi	r24, 0x20	; 32
    4420:	d1 f4       	brne	.+52     	; 0x4456 <CommandLineProcessByte+0x64>
		/* Store uppercase character */
		if (IS_LOWERCASE(Byte)) {
    4422:	9f e9       	ldi	r25, 0x9F	; 159
    4424:	98 0f       	add	r25, r24
    4426:	9a 31       	cpi	r25, 0x1A	; 26
    4428:	08 f4       	brcc	.+2      	; 0x442c <CommandLineProcessByte+0x3a>
			Byte = TO_UPPERCASE(Byte);
    442a:	80 52       	subi	r24, 0x20	; 32
		}

		/* Prevent buffer overflow and account for '\0' */
		if (BufferIdx < TERMINAL_BUFFER_SIZE - 1) {
    442c:	20 91 95 2c 	lds	r18, 0x2C95
    4430:	30 91 96 2c 	lds	r19, 0x2C96
    4434:	2f 3f       	cpi	r18, 0xFF	; 255
    4436:	91 e0       	ldi	r25, 0x01	; 1
    4438:	39 07       	cpc	r19, r25
    443a:	08 f0       	brcs	.+2      	; 0x443e <CommandLineProcessByte+0x4c>
    443c:	d3 c0       	rjmp	.+422    	; 0x45e4 <CommandLineProcessByte+0x1f2>
			TerminalBuffer[BufferIdx++] = Byte;
    443e:	a9 01       	movw	r20, r18
    4440:	4f 5f       	subi	r20, 0xFF	; 255
    4442:	5f 4f       	sbci	r21, 0xFF	; 255
    4444:	40 93 95 2c 	sts	0x2C95, r20
    4448:	50 93 96 2c 	sts	0x2C96, r21
    444c:	f9 01       	movw	r30, r18
    444e:	ed 52       	subi	r30, 0x2D	; 45
    4450:	f0 4d       	sbci	r31, 0xD0	; 208
    4452:	80 83       	st	Z, r24
    4454:	c7 c0       	rjmp	.+398    	; 0x45e4 <CommandLineProcessByte+0x1f2>
		}
	} else if (Byte == '\r') {
    4456:	8d 30       	cpi	r24, 0x0D	; 13
    4458:	09 f0       	breq	.+2      	; 0x445c <CommandLineProcessByte+0x6a>
    445a:	95 c0       	rjmp	.+298    	; 0x4586 <CommandLineProcessByte+0x194>
		/* Process on \r. Terminate string and decode. */
		TerminalBuffer[BufferIdx] = '\0';
    445c:	e0 91 95 2c 	lds	r30, 0x2C95
    4460:	f0 91 96 2c 	lds	r31, 0x2C96
    4464:	ed 52       	subi	r30, 0x2D	; 45
    4466:	f0 4d       	sbci	r31, 0xD0	; 208
    4468:	10 82       	st	Z, r1
		BufferIdx = 0;
    446a:	10 92 95 2c 	sts	0x2C95, r1
    446e:	10 92 96 2c 	sts	0x2C96, r1

		if (!TaskPending)
    4472:	80 91 94 2c 	lds	r24, 0x2C94
    4476:	81 11       	cpse	r24, r1
    4478:	b5 c0       	rjmp	.+362    	; 0x45e4 <CommandLineProcessByte+0x1f2>
  bool CommandFound = false;
  CommandStatusIdType StatusId = COMMAND_ERR_UNKNOWN_CMD_ID;
  char* pTerminalBuffer = (char*) TerminalBuffer;

  /* Do some sanity check first */
  if (!IS_COMMAND_DELIMITER(pTerminalBuffer[0])) {
    447a:	80 91 d3 2f 	lds	r24, 0x2FD3
    447e:	98 2f       	mov	r25, r24
    4480:	9f 7d       	andi	r25, 0xDF	; 223
    4482:	09 f4       	brne	.+2      	; 0x4486 <CommandLineProcessByte+0x94>
    4484:	95 c0       	rjmp	.+298    	; 0x45b0 <CommandLineProcessByte+0x1be>
    4486:	8d 7f       	andi	r24, 0xFD	; 253
    4488:	8d 33       	cpi	r24, 0x3D	; 61
    448a:	09 f4       	brne	.+2      	; 0x448e <CommandLineProcessByte+0x9c>
    448c:	91 c0       	rjmp	.+290    	; 0x45b0 <CommandLineProcessByte+0x1be>
    448e:	e3 ed       	ldi	r30, 0xD3	; 211
    4490:	ff e2       	ldi	r31, 0x2F	; 47
    4492:	7f 01       	movw	r14, r30
    char* pCommandDelimiter = pTerminalBuffer;
    char CommandDelimiter = '\0';

    /* Search for command delimiter, store it and replace with '\0' */
    while(!(IS_COMMAND_DELIMITER(*pCommandDelimiter)))
    4494:	c1 91       	ld	r28, Z+
    4496:	cc 23       	and	r28, r28
    4498:	31 f0       	breq	.+12     	; 0x44a6 <CommandLineProcessByte+0xb4>
    449a:	cf 33       	cpi	r28, 0x3F	; 63
    449c:	21 f0       	breq	.+8      	; 0x44a6 <CommandLineProcessByte+0xb4>
    449e:	cd 33       	cpi	r28, 0x3D	; 61
    44a0:	11 f0       	breq	.+4      	; 0x44a6 <CommandLineProcessByte+0xb4>
    44a2:	c0 32       	cpi	r28, 0x20	; 32
    44a4:	b1 f7       	brne	.-20     	; 0x4492 <CommandLineProcessByte+0xa0>
      pCommandDelimiter++;

    CommandDelimiter = *pCommandDelimiter;
    *pCommandDelimiter = '\0';
    44a6:	f7 01       	movw	r30, r14
    44a8:	10 82       	st	Z, r1
    44aa:	8c ec       	ldi	r24, 0xCC	; 204
    44ac:	c8 2e       	mov	r12, r24
    44ae:	8d e0       	ldi	r24, 0x0D	; 13
    44b0:	d8 2e       	mov	r13, r24
    44b2:	00 e0       	ldi	r16, 0x00	; 0
    44b4:	10 e0       	ldi	r17, 0x00	; 0

    /* Search in command table */
    for (i = 0; i < ARRAY_COUNT(CommandTable); i++) {
      if (strcmp_P(pTerminalBuffer, CommandTable[i].Command) == 0) {
    44b6:	b6 01       	movw	r22, r12
    44b8:	83 ed       	ldi	r24, 0xD3	; 211
    44ba:	9f e2       	ldi	r25, 0x2F	; 47
    44bc:	0e 94 c2 65 	call	0xcb84	; 0xcb84 <strcmp_P>
    44c0:	89 2b       	or	r24, r25
    44c2:	09 f0       	breq	.+2      	; 0x44c6 <CommandLineProcessByte+0xd4>
    44c4:	56 c0       	rjmp	.+172    	; 0x4572 <CommandLineProcessByte+0x180>
        /* Command found. Clear buffer, and call appropriate function */
        char* pParam = ++pCommandDelimiter;

        pTerminalBuffer[0] = '\0';
    44c6:	10 92 d3 2f 	sts	0x2FD3, r1
    const CommandEntryType* CommandEntry, char CommandDelimiter, char* pParam) {
  char* pTerminalBuffer = (char*) TerminalBuffer;
  CommandStatusIdType Status = COMMAND_ERR_INVALID_USAGE_ID;

	/* Call appropriate function depending on CommandDelimiter */
	if (CommandDelimiter == CHAR_GET_MODE) {
    44ca:	cf 33       	cpi	r28, 0x3F	; 63
    44cc:	49 f4       	brne	.+18     	; 0x44e0 <CommandLineProcessByte+0xee>
		CommandGetFuncType GetFunc = pgm_read_ptr(&CommandEntry->GetFunc);
    44ce:	88 e1       	ldi	r24, 0x18	; 24
    44d0:	80 9f       	mul	r24, r16
    44d2:	f0 01       	movw	r30, r0
    44d4:	81 9f       	mul	r24, r17
    44d6:	f0 0d       	add	r31, r0
    44d8:	11 24       	eor	r1, r1
    44da:	ee 51       	subi	r30, 0x1E	; 30
    44dc:	f2 4f       	sbci	r31, 0xF2	; 242
    44de:	18 c0       	rjmp	.+48     	; 0x4510 <CommandLineProcessByte+0x11e>

    /* Search in command table */
    for (i = 0; i < ARRAY_COUNT(CommandTable); i++) {
      if (strcmp_P(pTerminalBuffer, CommandTable[i].Command) == 0) {
        /* Command found. Clear buffer, and call appropriate function */
        char* pParam = ++pCommandDelimiter;
    44e0:	b7 01       	movw	r22, r14
    44e2:	6f 5f       	subi	r22, 0xFF	; 255
    44e4:	7f 4f       	sbci	r23, 0xFF	; 255
	if (CommandDelimiter == CHAR_GET_MODE) {
		CommandGetFuncType GetFunc = pgm_read_ptr(&CommandEntry->GetFunc);
		if (GetFunc != NO_FUNCTION) {
			Status = GetFunc(pTerminalBuffer);
		}
	} else if (CommandDelimiter == CHAR_SET_MODE) {
    44e6:	cd 33       	cpi	r28, 0x3D	; 61
    44e8:	49 f4       	brne	.+18     	; 0x44fc <CommandLineProcessByte+0x10a>
		CommandSetFuncType SetFunc = pgm_read_ptr(&CommandEntry->SetFunc);
    44ea:	88 e1       	ldi	r24, 0x18	; 24
    44ec:	80 9f       	mul	r24, r16
    44ee:	f0 01       	movw	r30, r0
    44f0:	81 9f       	mul	r24, r17
    44f2:	f0 0d       	add	r31, r0
    44f4:	11 24       	eor	r1, r1
    44f6:	e0 52       	subi	r30, 0x20	; 32
    44f8:	f2 4f       	sbci	r31, 0xF2	; 242
    44fa:	20 c0       	rjmp	.+64     	; 0x453c <CommandLineProcessByte+0x14a>
		if (SetFunc != NO_FUNCTION) {
			Status = SetFunc(pTerminalBuffer, pParam);
		}
	} else if (CommandDelimiter == CHAR_EXEC_MODE) {
    44fc:	c1 11       	cpse	r28, r1
    44fe:	13 c0       	rjmp	.+38     	; 0x4526 <CommandLineProcessByte+0x134>
		CommandExecFuncType ExecFunc = pgm_read_ptr(&CommandEntry->ExecFunc);
    4500:	88 e1       	ldi	r24, 0x18	; 24
    4502:	80 9f       	mul	r24, r16
    4504:	f0 01       	movw	r30, r0
    4506:	81 9f       	mul	r24, r17
    4508:	f0 0d       	add	r31, r0
    450a:	11 24       	eor	r1, r1
    450c:	e4 52       	subi	r30, 0x24	; 36
    450e:	f2 4f       	sbci	r31, 0xF2	; 242
    4510:	25 91       	lpm	r18, Z+
    4512:	34 91       	lpm	r19, Z
		if (ExecFunc != NO_FUNCTION) {
    4514:	21 15       	cp	r18, r1
    4516:	31 05       	cpc	r19, r1
    4518:	09 f4       	brne	.+2      	; 0x451c <CommandLineProcessByte+0x12a>
    451a:	4d c0       	rjmp	.+154    	; 0x45b6 <CommandLineProcessByte+0x1c4>
			Status = ExecFunc(pTerminalBuffer);
    451c:	83 ed       	ldi	r24, 0xD3	; 211
    451e:	9f e2       	ldi	r25, 0x2F	; 47
    4520:	f9 01       	movw	r30, r18
    4522:	19 95       	eicall
    4524:	14 c0       	rjmp	.+40     	; 0x454e <CommandLineProcessByte+0x15c>
		}
	} else if (CommandDelimiter == CHAR_EXEC_MODE_PARAM) {
    4526:	c0 32       	cpi	r28, 0x20	; 32
    4528:	09 f0       	breq	.+2      	; 0x452c <CommandLineProcessByte+0x13a>
    452a:	45 c0       	rjmp	.+138    	; 0x45b6 <CommandLineProcessByte+0x1c4>
		CommandExecParamFuncType ExecParamFunc = pgm_read_ptr(&CommandEntry->ExecParamFunc);
    452c:	88 e1       	ldi	r24, 0x18	; 24
    452e:	80 9f       	mul	r24, r16
    4530:	f0 01       	movw	r30, r0
    4532:	81 9f       	mul	r24, r17
    4534:	f0 0d       	add	r31, r0
    4536:	11 24       	eor	r1, r1
    4538:	e2 52       	subi	r30, 0x22	; 34
    453a:	f2 4f       	sbci	r31, 0xF2	; 242
    453c:	25 91       	lpm	r18, Z+
    453e:	34 91       	lpm	r19, Z
		if (ExecParamFunc != NO_FUNCTION) {
    4540:	21 15       	cp	r18, r1
    4542:	31 05       	cpc	r19, r1
    4544:	c1 f1       	breq	.+112    	; 0x45b6 <CommandLineProcessByte+0x1c4>
			Status = ExecParamFunc(pTerminalBuffer, pParam);
    4546:	83 ed       	ldi	r24, 0xD3	; 211
    4548:	9f e2       	ldi	r25, 0x2F	; 47
    454a:	f9 01       	movw	r30, r18
    454c:	19 95       	eicall
		}
	} else {
		/* This should not happen (TM) */
	}

	if (Status == TIMEOUT_COMMAND)
    454e:	8f 3f       	cpi	r24, 0xFF	; 255
    4550:	99 f5       	brne	.+102    	; 0x45b8 <CommandLineProcessByte+0x1c6>
	{
		TaskPending = true;
    4552:	81 e0       	ldi	r24, 0x01	; 1
    4554:	80 93 94 2c 	sts	0x2C94, r24

    RTC.INTFLAGS = RTC_COMPIF_bm;
}

INLINE uint16_t SystemGetSysTick(void) {
    return SYSTEM_TICK_REGISTER | RTC.CNT;
    4558:	8e b1       	in	r24, 0x0e	; 14
    455a:	9f b1       	in	r25, 0x0f	; 15
    455c:	20 91 08 04 	lds	r18, 0x0408
    4560:	30 91 09 04 	lds	r19, 0x0409
    4564:	82 2b       	or	r24, r18
    4566:	93 2b       	or	r25, r19
		TaskPendingSince = SystemGetSysTick();
    4568:	80 93 92 2c 	sts	0x2C92, r24
    456c:	90 93 93 2c 	sts	0x2C93, r25
    4570:	39 c0       	rjmp	.+114    	; 0x45e4 <CommandLineProcessByte+0x1f2>
    4572:	0f 5f       	subi	r16, 0xFF	; 255
    4574:	1f 4f       	sbci	r17, 0xFF	; 255
    4576:	f8 e1       	ldi	r31, 0x18	; 24
    4578:	cf 0e       	add	r12, r31
    457a:	d1 1c       	adc	r13, r1

    CommandDelimiter = *pCommandDelimiter;
    *pCommandDelimiter = '\0';

    /* Search in command table */
    for (i = 0; i < ARRAY_COUNT(CommandTable); i++) {
    457c:	07 32       	cpi	r16, 0x27	; 39
    457e:	11 05       	cpc	r17, r1
    4580:	09 f0       	breq	.+2      	; 0x4584 <CommandLineProcessByte+0x192>
    4582:	99 cf       	rjmp	.-206    	; 0x44b6 <CommandLineProcessByte+0xc4>
    4584:	15 c0       	rjmp	.+42     	; 0x45b0 <CommandLineProcessByte+0x1be>
		TerminalBuffer[BufferIdx] = '\0';
		BufferIdx = 0;

		if (!TaskPending)
			DecodeCommand();
	} else if (Byte == '\b') {
    4586:	88 30       	cpi	r24, 0x08	; 8
    4588:	61 f4       	brne	.+24     	; 0x45a2 <CommandLineProcessByte+0x1b0>
		/* Backspace. Delete last character in buffer. */
		if (BufferIdx > 0) {
    458a:	80 91 95 2c 	lds	r24, 0x2C95
    458e:	90 91 96 2c 	lds	r25, 0x2C96
    4592:	00 97       	sbiw	r24, 0x00	; 0
    4594:	39 f1       	breq	.+78     	; 0x45e4 <CommandLineProcessByte+0x1f2>
			BufferIdx--;
    4596:	01 97       	sbiw	r24, 0x01	; 1
    4598:	80 93 95 2c 	sts	0x2C95, r24
    459c:	90 93 96 2c 	sts	0x2C96, r25
    45a0:	21 c0       	rjmp	.+66     	; 0x45e4 <CommandLineProcessByte+0x1f2>
		}
	} else if (Byte == 0x1B) {
    45a2:	8b 31       	cpi	r24, 0x1B	; 27
    45a4:	f9 f4       	brne	.+62     	; 0x45e4 <CommandLineProcessByte+0x1f2>
		/* Drop buffer on escape */
		BufferIdx = 0;
    45a6:	10 92 95 2c 	sts	0x2C95, r1
    45aa:	10 92 96 2c 	sts	0x2C96, r1
    45ae:	1a c0       	rjmp	.+52     	; 0x45e4 <CommandLineProcessByte+0x1f2>

static void DecodeCommand(void)
{
  uint8_t i;
  bool CommandFound = false;
  CommandStatusIdType StatusId = COMMAND_ERR_UNKNOWN_CMD_ID;
    45b0:	88 ec       	ldi	r24, 0xC8	; 200
}

static void DecodeCommand(void)
{
  uint8_t i;
  bool CommandFound = false;
    45b2:	c0 e0       	ldi	r28, 0x00	; 0
    45b4:	02 c0       	rjmp	.+4      	; 0x45ba <CommandLineProcessByte+0x1c8>
		if (ExecFunc != NO_FUNCTION) {
			Status = ExecFunc(pTerminalBuffer);
		}
	} else if (CommandDelimiter == CHAR_EXEC_MODE_PARAM) {
		CommandExecParamFuncType ExecParamFunc = pgm_read_ptr(&CommandEntry->ExecParamFunc);
		if (ExecParamFunc != NO_FUNCTION) {
    45b6:	89 ec       	ldi	r24, 0xC9	; 201
      if (strcmp_P(pTerminalBuffer, CommandTable[i].Command) == 0) {
        /* Command found. Clear buffer, and call appropriate function */
        char* pParam = ++pCommandDelimiter;

        pTerminalBuffer[0] = '\0';
        CommandFound = true;
    45b8:	c1 e0       	ldi	r28, 0x01	; 1

  if (StatusId == TIMEOUT_COMMAND) // it is a timeout command, so we return
	  return;

  /* Send command status message */
  TerminalSendStringP(GetStatusMessageP(StatusId));
    45ba:	02 df       	rcall	.-508    	; 0x43c0 <GetStatusMessageP>
    45bc:	0e 94 a8 19 	call	0x3350	; 0x3350 <TerminalSendStringP>
  TerminalSendStringP(PSTR(STATUS_MESSAGE_TRAILER));
    45c0:	80 ea       	ldi	r24, 0xA0	; 160
    45c2:	9c e0       	ldi	r25, 0x0C	; 12
    45c4:	0e 94 a8 19 	call	0x3350	; 0x3350 <TerminalSendStringP>

  if (CommandFound && (pTerminalBuffer[0] != '\0') ) {
    45c8:	cc 23       	and	r28, r28
    45ca:	61 f0       	breq	.+24     	; 0x45e4 <CommandLineProcessByte+0x1f2>
    45cc:	80 91 d3 2f 	lds	r24, 0x2FD3
    45d0:	88 23       	and	r24, r24
    45d2:	41 f0       	breq	.+16     	; 0x45e4 <CommandLineProcessByte+0x1f2>
    /* Send optional answer */
    TerminalSendString(pTerminalBuffer);
    45d4:	83 ed       	ldi	r24, 0xD3	; 211
    45d6:	9f e2       	ldi	r25, 0x2F	; 47
    45d8:	0e 94 a3 19 	call	0x3346	; 0x3346 <TerminalSendString>
    TerminalSendStringP(PSTR(OPTIONAL_ANSWER_TRAILER));
    45dc:	8d e9       	ldi	r24, 0x9D	; 157
    45de:	9c e0       	ldi	r25, 0x0C	; 12
    45e0:	0e 94 a8 19 	call	0x3350	; 0x3350 <TerminalSendStringP>
	} else {
		/* Ignore other chars */
	}

	return true;
}
    45e4:	81 e0       	ldi	r24, 0x01	; 1
    45e6:	cf 91       	pop	r28
    45e8:	1f 91       	pop	r17
    45ea:	0f 91       	pop	r16
    45ec:	ff 90       	pop	r15
    45ee:	ef 90       	pop	r14
    45f0:	df 90       	pop	r13
    45f2:	cf 90       	pop	r12
    45f4:	08 95       	ret

000045f6 <CommandLineTick>:
	}
}

void CommandLineTick(void)
{
	if (TaskPending &&
    45f6:	80 91 94 2c 	lds	r24, 0x2C94
    45fa:	88 23       	and	r24, r24
    45fc:	99 f1       	breq	.+102    	; 0x4664 <CommandLineTick+0x6e>
			GlobalSettings.ActiveSettingPtr->PendingTaskTimeout != 0 && // 0 means no timeout
    45fe:	e0 91 71 2f 	lds	r30, 0x2F71
    4602:	f0 91 72 2f 	lds	r31, 0x2F72
    4606:	20 85       	ldd	r18, Z+8	; 0x08
    4608:	31 85       	ldd	r19, Z+9	; 0x09
	}
}

void CommandLineTick(void)
{
	if (TaskPending &&
    460a:	21 15       	cp	r18, r1
    460c:	31 05       	cpc	r19, r1
    460e:	51 f1       	breq	.+84     	; 0x4664 <CommandLineTick+0x6e>
    4610:	8e b1       	in	r24, 0x0e	; 14
    4612:	9f b1       	in	r25, 0x0f	; 15
    4614:	40 91 08 04 	lds	r20, 0x0408
    4618:	50 91 09 04 	lds	r21, 0x0409
    461c:	84 2b       	or	r24, r20
    461e:	95 2b       	or	r25, r21
			GlobalSettings.ActiveSettingPtr->PendingTaskTimeout != 0 && // 0 means no timeout
			SYSTICK_DIFF_100MS(TaskPendingSince) >= GlobalSettings.ActiveSettingPtr->PendingTaskTimeout) // timeout expired
    4620:	40 91 92 2c 	lds	r20, 0x2C92
    4624:	50 91 93 2c 	lds	r21, 0x2C93
    4628:	84 1b       	sub	r24, r20
    462a:	95 0b       	sbc	r25, r21
    462c:	64 e6       	ldi	r22, 0x64	; 100
    462e:	70 e0       	ldi	r23, 0x00	; 0
    4630:	0e 94 31 65 	call	0xca62	; 0xca62 <__udivmodhi4>
}

void CommandLineTick(void)
{
	if (TaskPending &&
			GlobalSettings.ActiveSettingPtr->PendingTaskTimeout != 0 && // 0 means no timeout
    4634:	62 17       	cp	r22, r18
    4636:	73 07       	cpc	r23, r19
    4638:	a8 f0       	brcs	.+42     	; 0x4664 <CommandLineTick+0x6e>
	return true;
}

INLINE void Timeout(void)
{
	TaskPending = false;
    463a:	10 92 94 2c 	sts	0x2C94, r1
	TerminalSendStringP(GetStatusMessageP(COMMAND_ERR_TIMEOUT_ID));
    463e:	8b ec       	ldi	r24, 0xCB	; 203
    4640:	bf de       	rcall	.-642    	; 0x43c0 <GetStatusMessageP>
    4642:	0e 94 a8 19 	call	0x3350	; 0x3350 <TerminalSendStringP>
	TerminalSendStringP(PSTR(STATUS_MESSAGE_TRAILER));
    4646:	8a e9       	ldi	r24, 0x9A	; 154
    4648:	9c e0       	ldi	r25, 0x0C	; 12
    464a:	0e 94 a8 19 	call	0x3350	; 0x3350 <TerminalSendStringP>

	if (CommandLinePendingTaskTimeout != NO_FUNCTION)
    464e:	e0 91 90 2c 	lds	r30, 0x2C90
    4652:	f0 91 91 2c 	lds	r31, 0x2C91
    4656:	30 97       	sbiw	r30, 0x00	; 0
    4658:	29 f0       	breq	.+10     	; 0x4664 <CommandLineTick+0x6e>
	{
		CommandLinePendingTaskTimeout(); // call the function that ends the task
    465a:	19 95       	eicall
		CommandLinePendingTaskTimeout = NO_FUNCTION;
    465c:	10 92 90 2c 	sts	0x2C90, r1
    4660:	10 92 91 2c 	sts	0x2C91, r1
    4664:	08 95       	ret

00004666 <CommandLinePendingTaskBreak>:
	}
}

void CommandLinePendingTaskBreak(void)
{
	if (!TaskPending)
    4666:	80 91 94 2c 	lds	r24, 0x2C94
    466a:	88 23       	and	r24, r24
    466c:	a9 f0       	breq	.+42     	; 0x4698 <CommandLinePendingTaskBreak+0x32>
	return true;
}

INLINE void Timeout(void)
{
	TaskPending = false;
    466e:	10 92 94 2c 	sts	0x2C94, r1
	TerminalSendStringP(GetStatusMessageP(COMMAND_ERR_TIMEOUT_ID));
    4672:	8b ec       	ldi	r24, 0xCB	; 203
    4674:	a5 de       	rcall	.-694    	; 0x43c0 <GetStatusMessageP>
    4676:	0e 94 a8 19 	call	0x3350	; 0x3350 <TerminalSendStringP>
	TerminalSendStringP(PSTR(STATUS_MESSAGE_TRAILER));
    467a:	8a e9       	ldi	r24, 0x9A	; 154
    467c:	9c e0       	ldi	r25, 0x0C	; 12
    467e:	0e 94 a8 19 	call	0x3350	; 0x3350 <TerminalSendStringP>

	if (CommandLinePendingTaskTimeout != NO_FUNCTION)
    4682:	e0 91 90 2c 	lds	r30, 0x2C90
    4686:	f0 91 91 2c 	lds	r31, 0x2C91
    468a:	30 97       	sbiw	r30, 0x00	; 0
    468c:	29 f0       	breq	.+10     	; 0x4698 <CommandLinePendingTaskBreak+0x32>
	{
		CommandLinePendingTaskTimeout(); // call the function that ends the task
    468e:	19 95       	eicall
		CommandLinePendingTaskTimeout = NO_FUNCTION;
    4690:	10 92 90 2c 	sts	0x2C90, r1
    4694:	10 92 91 2c 	sts	0x2C91, r1
    4698:	08 95       	ret

0000469a <CommandLinePendingTaskFinished>:

	Timeout();
}

void CommandLinePendingTaskFinished(CommandStatusIdType ReturnStatusID, char const * const OutMessage)
{
    469a:	cf 93       	push	r28
    469c:	df 93       	push	r29
	if (!TaskPending) // if no task is pending, no task can be finished
    469e:	90 91 94 2c 	lds	r25, 0x2C94
    46a2:	99 23       	and	r25, r25
    46a4:	a9 f0       	breq	.+42     	; 0x46d0 <CommandLinePendingTaskFinished+0x36>
    46a6:	eb 01       	movw	r28, r22
		return;
	TaskPending = false;
    46a8:	10 92 94 2c 	sts	0x2C94, r1

	TerminalSendStringP(GetStatusMessageP(ReturnStatusID));
    46ac:	89 de       	rcall	.-750    	; 0x43c0 <GetStatusMessageP>
    46ae:	0e 94 a8 19 	call	0x3350	; 0x3350 <TerminalSendStringP>
	TerminalSendStringP(PSTR(STATUS_MESSAGE_TRAILER));
    46b2:	87 e9       	ldi	r24, 0x97	; 151
    46b4:	9c e0       	ldi	r25, 0x0C	; 12
    46b6:	0e 94 a8 19 	call	0x3350	; 0x3350 <TerminalSendStringP>

	if (OutMessage != NULL)
    46ba:	20 97       	sbiw	r28, 0x00	; 0
    46bc:	49 f0       	breq	.+18     	; 0x46d0 <CommandLinePendingTaskFinished+0x36>
	{
		TerminalSendString(OutMessage);
    46be:	ce 01       	movw	r24, r28
    46c0:	0e 94 a3 19 	call	0x3346	; 0x3346 <TerminalSendString>
	    TerminalSendStringP(PSTR(OPTIONAL_ANSWER_TRAILER));
    46c4:	84 e9       	ldi	r24, 0x94	; 148
    46c6:	9c e0       	ldi	r25, 0x0C	; 12
	}
}
    46c8:	df 91       	pop	r29
    46ca:	cf 91       	pop	r28
	TerminalSendStringP(PSTR(STATUS_MESSAGE_TRAILER));

	if (OutMessage != NULL)
	{
		TerminalSendString(OutMessage);
	    TerminalSendStringP(PSTR(OPTIONAL_ANSWER_TRAILER));
    46cc:	0c 94 a8 19 	jmp	0x3350	; 0x3350 <TerminalSendStringP>
	}
}
    46d0:	df 91       	pop	r29
    46d2:	cf 91       	pop	r28
    46d4:	08 95       	ret

000046d6 <CommandLineAppendData>:

void CommandLineAppendData(void const * const Buffer, uint16_t Bytes)
{
    46d6:	ef 92       	push	r14
    46d8:	ff 92       	push	r15
    46da:	0f 93       	push	r16
    46dc:	1f 93       	push	r17
    46de:	cf 93       	push	r28
    46e0:	7c 01       	movw	r14, r24
    46e2:	9b 01       	movw	r18, r22
    46e4:	61 30       	cpi	r22, 0x01	; 1
    46e6:	81 e0       	ldi	r24, 0x01	; 1
    46e8:	78 07       	cpc	r23, r24
    46ea:	10 f0       	brcs	.+4      	; 0x46f0 <CommandLineAppendData+0x1a>
    46ec:	20 e0       	ldi	r18, 0x00	; 0
    46ee:	31 e0       	ldi	r19, 0x01	; 1
    char* pTerminalBuffer = (char*) TerminalBuffer;

    uint16_t tmpBytes = Bytes;
    if (Bytes > (TERMINAL_BUFFER_SIZE / 2))
    	tmpBytes = TERMINAL_BUFFER_SIZE / 2;
    Bytes -= tmpBytes;
    46f0:	8b 01       	movw	r16, r22
    46f2:	02 1b       	sub	r16, r18
    46f4:	13 0b       	sbc	r17, r19

    BufferToHexString(pTerminalBuffer, TERMINAL_BUFFER_SIZE, Buffer, tmpBytes);
    46f6:	a7 01       	movw	r20, r14
    46f8:	60 e0       	ldi	r22, 0x00	; 0
    46fa:	72 e0       	ldi	r23, 0x02	; 2
    46fc:	83 ed       	ldi	r24, 0xD3	; 211
    46fe:	9f e2       	ldi	r25, 0x2F	; 47
    4700:	0e 94 f8 0e 	call	0x1df0	; 0x1df0 <BufferToHexString>
    TerminalSendString(pTerminalBuffer);
    4704:	83 ed       	ldi	r24, 0xD3	; 211
    4706:	9f e2       	ldi	r25, 0x2F	; 47
    4708:	0e 94 a3 19 	call	0x3346	; 0x3346 <TerminalSendString>

    uint8_t i = 1;
    470c:	c1 e0       	ldi	r28, 0x01	; 1
    while (Bytes > (TERMINAL_BUFFER_SIZE / 2))
    470e:	01 30       	cpi	r16, 0x01	; 1
    4710:	81 e0       	ldi	r24, 0x01	; 1
    4712:	18 07       	cpc	r17, r24
    4714:	b0 f0       	brcs	.+44     	; 0x4742 <CommandLineAppendData+0x6c>
    {
    	Bytes -= TERMINAL_BUFFER_SIZE / 2;
    4716:	1a 95       	dec	r17
        BufferToHexString(pTerminalBuffer, TERMINAL_BUFFER_SIZE, Buffer + i * TERMINAL_BUFFER_SIZE / 2, TERMINAL_BUFFER_SIZE);
    4718:	6c 2f       	mov	r22, r28
    471a:	70 e0       	ldi	r23, 0x00	; 0
    471c:	76 2f       	mov	r23, r22
    471e:	66 27       	eor	r22, r22
    4720:	a7 01       	movw	r20, r14
    4722:	46 0f       	add	r20, r22
    4724:	57 1f       	adc	r21, r23
    4726:	20 e0       	ldi	r18, 0x00	; 0
    4728:	32 e0       	ldi	r19, 0x02	; 2
    472a:	60 e0       	ldi	r22, 0x00	; 0
    472c:	72 e0       	ldi	r23, 0x02	; 2
    472e:	83 ed       	ldi	r24, 0xD3	; 211
    4730:	9f e2       	ldi	r25, 0x2F	; 47
    4732:	0e 94 f8 0e 	call	0x1df0	; 0x1df0 <BufferToHexString>
        TerminalSendString(pTerminalBuffer);
    4736:	83 ed       	ldi	r24, 0xD3	; 211
    4738:	9f e2       	ldi	r25, 0x2F	; 47
    473a:	0e 94 a3 19 	call	0x3346	; 0x3346 <TerminalSendString>
    	i++;
    473e:	cf 5f       	subi	r28, 0xFF	; 255
    4740:	e6 cf       	rjmp	.-52     	; 0x470e <CommandLineAppendData+0x38>
    }

    if (Bytes > 0)
    4742:	01 15       	cp	r16, r1
    4744:	11 05       	cpc	r17, r1
    4746:	91 f0       	breq	.+36     	; 0x476c <CommandLineAppendData+0x96>
    {
        BufferToHexString(pTerminalBuffer, TERMINAL_BUFFER_SIZE, Buffer + i * TERMINAL_BUFFER_SIZE / 2, Bytes);
    4748:	ec 2f       	mov	r30, r28
    474a:	f0 e0       	ldi	r31, 0x00	; 0
    474c:	fe 2f       	mov	r31, r30
    474e:	ee 27       	eor	r30, r30
    4750:	a7 01       	movw	r20, r14
    4752:	4e 0f       	add	r20, r30
    4754:	5f 1f       	adc	r21, r31
    4756:	98 01       	movw	r18, r16
    4758:	60 e0       	ldi	r22, 0x00	; 0
    475a:	72 e0       	ldi	r23, 0x02	; 2
    475c:	83 ed       	ldi	r24, 0xD3	; 211
    475e:	9f e2       	ldi	r25, 0x2F	; 47
    4760:	0e 94 f8 0e 	call	0x1df0	; 0x1df0 <BufferToHexString>
        TerminalSendString(pTerminalBuffer);
    4764:	83 ed       	ldi	r24, 0xD3	; 211
    4766:	9f e2       	ldi	r25, 0x2F	; 47
    4768:	0e 94 a3 19 	call	0x3346	; 0x3346 <TerminalSendString>
    }

    TerminalSendStringP(PSTR(OPTIONAL_ANSWER_TRAILER));
    476c:	81 e9       	ldi	r24, 0x91	; 145
    476e:	9c e0       	ldi	r25, 0x0C	; 12
}
    4770:	cf 91       	pop	r28
    4772:	1f 91       	pop	r17
    4774:	0f 91       	pop	r16
    4776:	ff 90       	pop	r15
    4778:	ef 90       	pop	r14
    {
        BufferToHexString(pTerminalBuffer, TERMINAL_BUFFER_SIZE, Buffer + i * TERMINAL_BUFFER_SIZE / 2, Bytes);
        TerminalSendString(pTerminalBuffer);
    }

    TerminalSendStringP(PSTR(OPTIONAL_ANSWER_TRAILER));
    477a:	0c 94 a8 19 	jmp	0x3350	; 0x3350 <TerminalSendStringP>

0000477e <CodecReaderFieldStart>:
void CodecReaderFieldRestart(uint16_t delay)
{
    ReaderFieldFlags.ToBeRestarted = true;
    ReaderFieldRestartTimestamp = SystemGetSysTick();
    ReaderFieldRestartDelay = delay;
    CodecReaderFieldStop();
    477e:	80 91 00 08 	lds	r24, 0x0800
    4782:	81 30       	cpi	r24, 0x01	; 1
    4784:	29 f4       	brne	.+10     	; 0x4790 <CodecReaderFieldStart+0x12>
    4786:	80 91 8c 08 	lds	r24, 0x088C
    478a:	83 30       	cpi	r24, 0x03	; 3
    478c:	09 f4       	brne	.+2      	; 0x4790 <CodecReaderFieldStart+0x12>
    478e:	08 95       	ret
    4790:	80 91 99 2c 	lds	r24, 0x2C99
    4794:	81 11       	cpse	r24, r1
    4796:	17 c0       	rjmp	.+46     	; 0x47c6 <CodecReaderFieldStart+0x48>
    4798:	81 e0       	ldi	r24, 0x01	; 1
    479a:	80 93 00 08 	sts	0x0800, r24
    479e:	93 e0       	ldi	r25, 0x03	; 3
    47a0:	90 93 8c 08 	sts	0x088C, r25
    47a4:	80 93 97 2c 	sts	0x2C97, r24
    47a8:	10 92 98 2c 	sts	0x2C98, r1
    47ac:	8e b1       	in	r24, 0x0e	; 14
    47ae:	9f b1       	in	r25, 0x0f	; 15
    47b0:	20 91 08 04 	lds	r18, 0x0408
    47b4:	30 91 09 04 	lds	r19, 0x0409
    47b8:	82 2b       	or	r24, r18
    47ba:	93 2b       	or	r25, r19
    47bc:	80 93 9e 2c 	sts	0x2C9E, r24
    47c0:	90 93 9f 2c 	sts	0x2C9F, r25
    47c4:	08 95       	ret
    47c6:	08 95       	ret

000047c8 <CodecReaderFieldStop>:
    47c8:	10 92 8c 08 	sts	0x088C, r1
    47cc:	10 92 00 08 	sts	0x0800, r1
    47d0:	e7 e9       	ldi	r30, 0x97	; 151
    47d2:	fc e2       	ldi	r31, 0x2C	; 44
    47d4:	10 82       	st	Z, r1
    47d6:	11 82       	std	Z+1, r1	; 0x01
    47d8:	08 95       	ret

000047da <CodecIsReaderFieldReady>:
 * This function returns false if and only if the reader field has been turned on in the last READER_FIELD_MIN..._TIME ms.
 * If the reader field is not active, true is returned.
 */
bool CodecIsReaderFieldReady(void)
{
    if (!ReaderFieldFlags.Started)
    47da:	90 91 97 2c 	lds	r25, 0x2C97
    47de:	99 23       	and	r25, r25
    47e0:	f1 f0       	breq	.+60     	; 0x481e <CodecIsReaderFieldReady+0x44>
        return true;
    if (ReaderFieldFlags.Ready || (ReaderFieldFlags.Started && SYSTICK_DIFF(ReaderFieldStartTimestamp) >= READER_FIELD_MINIMUM_WAITING_TIME))
    47e2:	80 91 98 2c 	lds	r24, 0x2C98
    47e6:	81 11       	cpse	r24, r1
    47e8:	15 c0       	rjmp	.+42     	; 0x4814 <CodecIsReaderFieldReady+0x3a>
    47ea:	20 91 97 2c 	lds	r18, 0x2C97
    47ee:	22 23       	and	r18, r18
    47f0:	b9 f0       	breq	.+46     	; 0x4820 <CodecIsReaderFieldReady+0x46>

    RTC.INTFLAGS = RTC_COMPIF_bm;
}

INLINE uint16_t SystemGetSysTick(void) {
    return SYSTEM_TICK_REGISTER | RTC.CNT;
    47f2:	2e b1       	in	r18, 0x0e	; 14
    47f4:	3f b1       	in	r19, 0x0f	; 15
    47f6:	40 91 08 04 	lds	r20, 0x0408
    47fa:	50 91 09 04 	lds	r21, 0x0409
    47fe:	24 2b       	or	r18, r20
    4800:	35 2b       	or	r19, r21
    4802:	40 91 9e 2c 	lds	r20, 0x2C9E
    4806:	50 91 9f 2c 	lds	r21, 0x2C9F
    480a:	24 1b       	sub	r18, r20
    480c:	35 0b       	sbc	r19, r21
    480e:	26 34       	cpi	r18, 0x46	; 70
    4810:	31 05       	cpc	r19, r1
    4812:	30 f0       	brcs	.+12     	; 0x4820 <CodecIsReaderFieldReady+0x46>
    {
        ReaderFieldFlags.Ready = true;
    4814:	81 e0       	ldi	r24, 0x01	; 1
    4816:	80 93 98 2c 	sts	0x2C98, r24
        return true;
    481a:	89 2f       	mov	r24, r25
    481c:	08 95       	ret
 * If the reader field is not active, true is returned.
 */
bool CodecIsReaderFieldReady(void)
{
    if (!ReaderFieldFlags.Started)
        return true;
    481e:	81 e0       	ldi	r24, 0x01	; 1
    {
        ReaderFieldFlags.Ready = true;
        return true;
    }
    return false;
}
    4820:	08 95       	ret

00004822 <CodecIsReaderToBeRestarted>:

bool CodecIsReaderToBeRestarted(void)
{
    4822:	cf 93       	push	r28
    4824:	df 93       	push	r29
    4826:	1f 92       	push	r1
    4828:	cd b7       	in	r28, 0x3d	; 61
    482a:	de b7       	in	r29, 0x3e	; 62
    if (ReaderFieldFlags.ToBeRestarted)
    482c:	80 91 99 2c 	lds	r24, 0x2C99
    4830:	88 23       	and	r24, r24
    4832:	d1 f0       	breq	.+52     	; 0x4868 <CodecIsReaderToBeRestarted+0x46>
    4834:	2e b1       	in	r18, 0x0e	; 14
    4836:	3f b1       	in	r19, 0x0f	; 15
    4838:	40 91 08 04 	lds	r20, 0x0408
    483c:	50 91 09 04 	lds	r21, 0x0409
    4840:	24 2b       	or	r18, r20
    4842:	35 2b       	or	r19, r21
    {
        if (SYSTICK_DIFF(ReaderFieldRestartTimestamp) >= ReaderFieldRestartDelay)
    4844:	40 91 9c 2c 	lds	r20, 0x2C9C
    4848:	50 91 9d 2c 	lds	r21, 0x2C9D
    484c:	24 1b       	sub	r18, r20
    484e:	35 0b       	sbc	r19, r21
    4850:	40 91 9a 2c 	lds	r20, 0x2C9A
    4854:	50 91 9b 2c 	lds	r21, 0x2C9B
    4858:	24 17       	cp	r18, r20
    485a:	35 07       	cpc	r19, r21
    485c:	28 f0       	brcs	.+10     	; 0x4868 <CodecIsReaderToBeRestarted+0x46>
        {
            ReaderFieldFlags.ToBeRestarted = false;
    485e:	10 92 99 2c 	sts	0x2C99, r1
            CodecReaderFieldStart();
    4862:	89 83       	std	Y+1, r24	; 0x01
    4864:	8c df       	rcall	.-232    	; 0x477e <CodecReaderFieldStart>
    4866:	89 81       	ldd	r24, Y+1	; 0x01
        }
        return true;
    }
    return false;
}
    4868:	0f 90       	pop	r0
    486a:	df 91       	pop	r29
    486c:	cf 91       	pop	r28
    486e:	08 95       	ret

00004870 <CodecThresholdSet>:

void CodecThresholdSet(uint16_t th) // threshold has to be saved back to eeprom by the caller, if wanted
{
    GlobalSettings.ActiveSettingPtr->ReaderThreshold = th;
    4870:	e0 91 71 2f 	lds	r30, 0x2F71
    4874:	f0 91 72 2f 	lds	r31, 0x2F72
    4878:	82 87       	std	Z+10, r24	; 0x0a
    487a:	93 87       	std	Z+11, r25	; 0x0b
    DACB.CH0DATA = th;
    487c:	80 93 38 03 	sts	0x0338, r24
    4880:	90 93 39 03 	sts	0x0339, r25
    4884:	08 95       	ret

00004886 <CodecThresholdIncrement>:
}

uint16_t CodecThresholdIncrement(void) // threshold has to be saved back to eeprom by the caller, if wanted
{
    GlobalSettings.ActiveSettingPtr->ReaderThreshold += CODEC_THRESHOLD_CALIBRATE_STEPS;
    4886:	e0 91 71 2f 	lds	r30, 0x2F71
    488a:	f0 91 72 2f 	lds	r31, 0x2F72
    488e:	82 85       	ldd	r24, Z+10	; 0x0a
    4890:	93 85       	ldd	r25, Z+11	; 0x0b
    4892:	40 96       	adiw	r24, 0x10	; 16
    4894:	82 87       	std	Z+10, r24	; 0x0a
    4896:	93 87       	std	Z+11, r25	; 0x0b
    DACB.CH0DATA = GlobalSettings.ActiveSettingPtr->ReaderThreshold;
    4898:	80 93 38 03 	sts	0x0338, r24
    489c:	90 93 39 03 	sts	0x0339, r25
    return GlobalSettings.ActiveSettingPtr->ReaderThreshold;
}
    48a0:	82 85       	ldd	r24, Z+10	; 0x0a
    48a2:	93 85       	ldd	r25, Z+11	; 0x0b
    48a4:	08 95       	ret

000048a6 <CodecThresholdReset>:

void CodecThresholdReset(void) // threshold has to be saved back to eeprom by the caller, if wanted
{
    GlobalSettings.ActiveSettingPtr->ReaderThreshold = DEFAULT_READER_THRESHOLD;
    48a6:	e0 91 71 2f 	lds	r30, 0x2F71
    48aa:	f0 91 72 2f 	lds	r31, 0x2F72
    48ae:	80 e9       	ldi	r24, 0x90	; 144
    48b0:	91 e0       	ldi	r25, 0x01	; 1
    48b2:	82 87       	std	Z+10, r24	; 0x0a
    48b4:	93 87       	std	Z+11, r25	; 0x0b
    DACB.CH0DATA = GlobalSettings.ActiveSettingPtr->ReaderThreshold;
    48b6:	80 93 38 03 	sts	0x0338, r24
    48ba:	90 93 39 03 	sts	0x0339, r25
    48be:	08 95       	ret

000048c0 <StartDemod>:
}

INLINE void CodecSetDemodPower(bool bOnOff)
{
    if (bOnOff) {
        CODEC_DEMOD_POWER_PORT.OUTSET = CODEC_DEMOD_POWER_MASK;
    48c0:	a0 e2       	ldi	r26, 0x20	; 32
    48c2:	b6 e0       	ldi	r27, 0x06	; 6
    48c4:	81 e0       	ldi	r24, 0x01	; 1
    48c6:	15 96       	adiw	r26, 0x05	; 5
    48c8:	8c 93       	st	X, r24
    48ca:	15 97       	sbiw	r26, 0x05	; 5

static void StartDemod(void) {
    /* Activate Power for demodulator */
    CodecSetDemodPower(true);

    CodecBufferPtr = CodecBuffer;
    48cc:	23 ed       	ldi	r18, 0xD3	; 211
    48ce:	31 e3       	ldi	r19, 0x31	; 49
    48d0:	28 b9       	out	0x08, r18	; 8
    48d2:	39 b9       	out	0x09, r19	; 9
    ParityBufferPtr = &CodecBuffer[ISO14443A_BUFFER_PARITY_OFFSET];
    48d4:	23 e5       	ldi	r18, 0x53	; 83
    48d6:	32 e3       	ldi	r19, 0x32	; 50
    48d8:	2a b9       	out	0x0a, r18	; 10
    48da:	3b b9       	out	0x0b, r19	; 11
    DataRegister = 0;
    48dc:	10 b8       	out	0x00, r1	; 0
    SampleRegister = 0;
    48de:	13 b8       	out	0x03, r1	; 3
    SampleIdxRegister = 0;
    48e0:	12 b8       	out	0x02, r1	; 2
    BitCount = 0;
    48e2:	16 b8       	out	0x06, r1	; 6
    48e4:	17 b8       	out	0x07, r1	; 7
    StateRegister = DEMOD_DATA_BIT;
    48e6:	11 b8       	out	0x01, r1	; 1

    /* Configure sampling-timer free running and sync to first modulation-pause. */
    CODEC_TIMER_SAMPLING.CNT = 0;                               // Reset the timer count
    48e8:	e0 e0       	ldi	r30, 0x00	; 0
    48ea:	f9 e0       	ldi	r31, 0x09	; 9
    48ec:	10 a2       	std	Z+32, r1	; 0x20
    48ee:	11 a2       	std	Z+33, r1	; 0x21
    CODEC_TIMER_SAMPLING.PER = SAMPLE_RATE_SYSTEM_CYCLES - 1;   // Set Period regisiter
    48f0:	2f ef       	ldi	r18, 0xFF	; 255
    48f2:	30 e0       	ldi	r19, 0x00	; 0
    48f4:	26 a3       	std	Z+38, r18	; 0x26
    48f6:	37 a3       	std	Z+39, r19	; 0x27
    CODEC_TIMER_SAMPLING.CCA = 0xFFFF; /* CCA Interrupt is not active! */
    48f8:	2f ef       	ldi	r18, 0xFF	; 255
    48fa:	3f ef       	ldi	r19, 0xFF	; 255
    48fc:	20 a7       	std	Z+40, r18	; 0x28
    48fe:	31 a7       	std	Z+41, r19	; 0x29
    CODEC_TIMER_SAMPLING.CTRLA = TC_CLKSEL_DIV1_gc;
    4900:	80 83       	st	Z, r24
    CODEC_TIMER_SAMPLING.CTRLD = TC_EVACT_RESTART_gc | CODEC_TIMER_MODSTART_EVSEL;
    4902:	98 e8       	ldi	r25, 0x88	; 136
    4904:	93 83       	std	Z+3, r25	; 0x03
    CODEC_TIMER_SAMPLING.INTFLAGS = TC0_CCAIF_bm;
    4906:	90 e1       	ldi	r25, 0x10	; 16
    4908:	94 87       	std	Z+12, r25	; 0x0c
    CODEC_TIMER_SAMPLING.INTCTRLB = TC_CCAINTLVL_HI_gc;
    490a:	93 e0       	ldi	r25, 0x03	; 3
    490c:	97 83       	std	Z+7, r25	; 0x07

    /* Start looking out for modulation pause via interrupt. */
    CODEC_DEMOD_IN_PORT.INTFLAGS = PORT_INT0IF_bm;
    490e:	1c 96       	adiw	r26, 0x0c	; 12
    4910:	8c 93       	st	X, r24
    4912:	1c 97       	sbiw	r26, 0x0c	; 12
    CODEC_DEMOD_IN_PORT.INT0MASK = CODEC_DEMOD_IN_MASK0;
    4914:	82 e0       	ldi	r24, 0x02	; 2
    4916:	1a 96       	adiw	r26, 0x0a	; 10
    4918:	8c 93       	st	X, r24
    491a:	08 95       	ret

0000491c <isr_ISO14443_2A_TCD0_CCC_vect>:
     * XYZBUF mechanism of the xmega to automatically double the sampling rate on the
     * next overflow. For this we have to temporarily deactivate the automatical alignment
     * in order to catch next overflow event for updating the BUF registers.
     * We want to sample the demodulated data stream in the first quarter of the half-bit
     * where the pulsed miller encoded is located. */
    CODEC_TIMER_SAMPLING.CTRLD = TC_EVACT_OFF_gc;
    491c:	e0 e0       	ldi	r30, 0x00	; 0
    491e:	f9 e0       	ldi	r31, 0x09	; 9
    4920:	13 82       	std	Z+3, r1	; 0x03
    CODEC_TIMER_SAMPLING.PERBUF = SAMPLE_RATE_SYSTEM_CYCLES/2 - 1; /* Half bit width */
    4922:	8f e7       	ldi	r24, 0x7F	; 127
    4924:	90 e0       	ldi	r25, 0x00	; 0
    4926:	86 ab       	std	Z+54, r24	; 0x36
    4928:	97 ab       	std	Z+55, r25	; 0x37
    CODEC_TIMER_SAMPLING.CCABUF = SAMPLE_RATE_SYSTEM_CYCLES/8 - 14 - 1; /* Compensate for DIGFILT and ISR prolog */
    492a:	81 e1       	ldi	r24, 0x11	; 17
    492c:	90 e0       	ldi	r25, 0x00	; 0
    492e:	80 af       	std	Z+56, r24	; 0x38
    4930:	91 af       	std	Z+57, r25	; 0x39
    /* Setup Frame Delay Timer and wire to EVSYS. Frame delay time is
     * measured from last change in RF field, therefore we use
     * the event channel 1 (end of modulation pause) as the restart event.
     * The preliminary frame delay time chosen here is irrelevant, because
     * the correct FDT gets set automatically after demodulation. */
    CODEC_TIMER_LOADMOD.CNT = 0;
    4932:	e0 e0       	ldi	r30, 0x00	; 0
    4934:	fa e0       	ldi	r31, 0x0A	; 10
    4936:	10 a2       	std	Z+32, r1	; 0x20
    4938:	11 a2       	std	Z+33, r1	; 0x21
    CODEC_TIMER_LOADMOD.PER = 0xFFFF;
    493a:	8f ef       	ldi	r24, 0xFF	; 255
    493c:	9f ef       	ldi	r25, 0xFF	; 255
    493e:	86 a3       	std	Z+38, r24	; 0x26
    4940:	97 a3       	std	Z+39, r25	; 0x27
    CODEC_TIMER_LOADMOD.CTRLD = TC_EVACT_RESTART_gc | CODEC_TIMER_MODEND_EVSEL;
    4942:	89 e8       	ldi	r24, 0x89	; 137
    4944:	83 83       	std	Z+3, r24	; 0x03
    CODEC_TIMER_LOADMOD.INTCTRLA = TC_OVFINTLVL_OFF_gc;
    4946:	16 82       	std	Z+6, r1	; 0x06
    CODEC_TIMER_LOADMOD.INTFLAGS = TC0_OVFIF_bm;
    4948:	81 e0       	ldi	r24, 0x01	; 1
    494a:	84 87       	std	Z+12, r24	; 0x0c
    CODEC_TIMER_LOADMOD.CTRLA = CODEC_TIMER_CARRIER_CLKSEL;
    494c:	8e e0       	ldi	r24, 0x0E	; 14
    494e:	80 83       	st	Z, r24

    /* Disable this interrupt */
    CODEC_DEMOD_IN_PORT.INT0MASK = 0;
    4950:	10 92 2a 06 	sts	0x062A, r1
    4954:	08 95       	ret

00004956 <__vector_34>:
    CODEC_DEMOD_IN_PORT.INTFLAGS = PORT_INT0IF_bm;
    CODEC_DEMOD_IN_PORT.INT0MASK = CODEC_DEMOD_IN_MASK0;
}

ISR (CODEC_DEMOD_IN_INT0_VECT)
{
    4956:	1f 92       	push	r1
    4958:	0f 92       	push	r0
    495a:	0f b6       	in	r0, 0x3f	; 63
    495c:	0f 92       	push	r0
    495e:	11 24       	eor	r1, r1
    4960:	08 b6       	in	r0, 0x38	; 56
    4962:	0f 92       	push	r0
    4964:	18 be       	out	0x38, r1	; 56
    4966:	09 b6       	in	r0, 0x39	; 57
    4968:	0f 92       	push	r0
    496a:	19 be       	out	0x39, r1	; 57
    496c:	0b b6       	in	r0, 0x3b	; 59
    496e:	0f 92       	push	r0
    4970:	1b be       	out	0x3b, r1	; 59
    4972:	2f 93       	push	r18
    4974:	3f 93       	push	r19
    4976:	4f 93       	push	r20
    4978:	5f 93       	push	r21
    497a:	6f 93       	push	r22
    497c:	7f 93       	push	r23
    497e:	8f 93       	push	r24
    4980:	9f 93       	push	r25
    4982:	af 93       	push	r26
    4984:	bf 93       	push	r27
    4986:	ef 93       	push	r30
    4988:	ff 93       	push	r31
  isr_func_CODEC_DEMOD_IN_INT0_VECT();
    498a:	e0 91 52 2f 	lds	r30, 0x2F52
    498e:	f0 91 53 2f 	lds	r31, 0x2F53
    4992:	19 95       	eicall
}
    4994:	ff 91       	pop	r31
    4996:	ef 91       	pop	r30
    4998:	bf 91       	pop	r27
    499a:	af 91       	pop	r26
    499c:	9f 91       	pop	r25
    499e:	8f 91       	pop	r24
    49a0:	7f 91       	pop	r23
    49a2:	6f 91       	pop	r22
    49a4:	5f 91       	pop	r21
    49a6:	4f 91       	pop	r20
    49a8:	3f 91       	pop	r19
    49aa:	2f 91       	pop	r18
    49ac:	0f 90       	pop	r0
    49ae:	0b be       	out	0x3b, r0	; 59
    49b0:	0f 90       	pop	r0
    49b2:	09 be       	out	0x39, r0	; 57
    49b4:	0f 90       	pop	r0
    49b6:	08 be       	out	0x38, r0	; 56
    49b8:	0f 90       	pop	r0
    49ba:	0f be       	out	0x3f, r0	; 63
    49bc:	0f 90       	pop	r0
    49be:	1f 90       	pop	r1
    49c0:	18 95       	reti

000049c2 <__vector_79>:
    /* Disable this interrupt */
    CODEC_DEMOD_IN_PORT.INT0MASK = 0;
}

// Sampling with timer and demod
ISR(CODEC_TIMER_SAMPLING_CCA_VECT) {
    49c2:	1f 92       	push	r1
    49c4:	0f 92       	push	r0
    49c6:	0f b6       	in	r0, 0x3f	; 63
    49c8:	0f 92       	push	r0
    49ca:	11 24       	eor	r1, r1
    49cc:	08 b6       	in	r0, 0x38	; 56
    49ce:	0f 92       	push	r0
    49d0:	18 be       	out	0x38, r1	; 56
    49d2:	0b b6       	in	r0, 0x3b	; 59
    49d4:	0f 92       	push	r0
    49d6:	1b be       	out	0x3b, r1	; 59
    49d8:	2f 93       	push	r18
    49da:	3f 93       	push	r19
    49dc:	8f 93       	push	r24
    49de:	9f 93       	push	r25
    49e0:	ef 93       	push	r30
    49e2:	ff 93       	push	r31
    /* This interrupt gets called twice for every bit to sample it. */
    uint8_t SamplePin = CODEC_DEMOD_IN_PORT.IN & CODEC_DEMOD_IN_MASK;
    49e4:	20 91 28 06 	lds	r18, 0x0628

    /* Shift sampled bit into sampling register */
    SampleRegister = (SampleRegister << 1) | (!SamplePin ? 0x01 : 0x00);
    49e8:	93 b1       	in	r25, 0x03	; 3
}

// Sampling with timer and demod
ISR(CODEC_TIMER_SAMPLING_CCA_VECT) {
    /* This interrupt gets called twice for every bit to sample it. */
    uint8_t SamplePin = CODEC_DEMOD_IN_PORT.IN & CODEC_DEMOD_IN_MASK;
    49ea:	26 70       	andi	r18, 0x06	; 6

    /* Shift sampled bit into sampling register */
    SampleRegister = (SampleRegister << 1) | (!SamplePin ? 0x01 : 0x00);
    49ec:	81 e0       	ldi	r24, 0x01	; 1
    49ee:	09 f0       	breq	.+2      	; 0x49f2 <__vector_79+0x30>
    49f0:	80 e0       	ldi	r24, 0x00	; 0
    49f2:	99 0f       	add	r25, r25
    49f4:	89 2b       	or	r24, r25
    49f6:	83 b9       	out	0x03, r24	; 3

    if (SampleIdxRegister) {
    49f8:	82 b1       	in	r24, 0x02	; 2
    49fa:	88 23       	and	r24, r24
    49fc:	09 f4       	brne	.+2      	; 0x4a00 <__vector_79+0x3e>
    49fe:	64 c0       	rjmp	.+200    	; 0x4ac8 <__vector_79+0x106>
        SampleIdxRegister = 0;
    4a00:	12 b8       	out	0x02, r1	; 2
        /* Analyze the sampling register after 2 samples. */
        if ((SampleRegister & 0x07) == 0x07) {
    4a02:	83 b1       	in	r24, 0x03	; 3
    4a04:	87 70       	andi	r24, 0x07	; 7
    4a06:	87 30       	cpi	r24, 0x07	; 7
    4a08:	59 f5       	brne	.+86     	; 0x4a60 <__vector_79+0x9e>
            /* No carrier modulation for 3 sample points. EOC! */
            CODEC_TIMER_SAMPLING.CTRLA = TC_CLKSEL_OFF_gc;
    4a0a:	10 92 00 09 	sts	0x0900, r1
            CODEC_TIMER_SAMPLING.INTFLAGS = TC0_CCAIF_bm;
    4a0e:	80 e1       	ldi	r24, 0x10	; 16
    4a10:	80 93 0c 09 	sts	0x090C, r24

            /* By this time, the FDT timer is aligned to the last modulation
             * edge of the reader. So we disable the auto-synchronization and
             * let it count the frame delay time in the background, and generate
             * an interrupt once it has reached the FDT. */
            CODEC_TIMER_LOADMOD.CTRLD = TC_EVACT_OFF_gc;
    4a14:	10 92 03 0a 	sts	0x0A03, r1

            if (SampleRegister & 0x08) {
    4a18:	1b 9b       	sbis	0x03, 3	; 3
    4a1a:	03 c0       	rjmp	.+6      	; 0x4a22 <__vector_79+0x60>
                CODEC_TIMER_LOADMOD.PER = ISO14443A_FRAME_DELAY_PREV1 - 40; /* compensate for ISR prolog */
    4a1c:	8c ea       	ldi	r24, 0xAC	; 172
    4a1e:	94 e0       	ldi	r25, 0x04	; 4
    4a20:	02 c0       	rjmp	.+4      	; 0x4a26 <__vector_79+0x64>
            } else {
                CODEC_TIMER_LOADMOD.PER = ISO14443A_FRAME_DELAY_PREV0 - 40; /* compensate for ISR prolog */
    4a22:	8c e6       	ldi	r24, 0x6C	; 108
    4a24:	94 e0       	ldi	r25, 0x04	; 4
    4a26:	80 93 26 0a 	sts	0x0A26, r24
    4a2a:	90 93 27 0a 	sts	0x0A27, r25
            }

            StateRegister = LOADMOD_FDT;
    4a2e:	82 e0       	ldi	r24, 0x02	; 2
    4a30:	81 b9       	out	0x01, r24	; 1

            CODEC_TIMER_LOADMOD.INTFLAGS = TC0_OVFIF_bm;
    4a32:	81 e0       	ldi	r24, 0x01	; 1
    4a34:	80 93 0c 0a 	sts	0x0A0C, r24
            CODEC_TIMER_LOADMOD.INTCTRLA = TC_OVFINTLVL_HI_gc;
    4a38:	83 e0       	ldi	r24, 0x03	; 3
    4a3a:	80 93 06 0a 	sts	0x0A06, r24

            /* Determine if we did not receive a multiple of 8 bits.
             * If this is the case, right-align the remaining data and
             * store it into the buffer. */
            uint8_t RemainingBits = BitCount % 8;
    4a3e:	86 b1       	in	r24, 0x06	; 6
    4a40:	97 b1       	in	r25, 0x07	; 7
    4a42:	87 70       	andi	r24, 0x07	; 7
            if (RemainingBits != 0) {
    4a44:	49 f0       	breq	.+18     	; 0x4a58 <__vector_79+0x96>
                uint8_t NewDataRegister = DataRegister;
    4a46:	90 b1       	in	r25, 0x00	; 0

                while (RemainingBits++ < 8) {
    4a48:	8f 5f       	subi	r24, 0xFF	; 255
    4a4a:	89 30       	cpi	r24, 0x09	; 9
    4a4c:	11 f0       	breq	.+4      	; 0x4a52 <__vector_79+0x90>
                    /* Pad with zeroes to right-align. */
                    NewDataRegister >>= 1;
    4a4e:	96 95       	lsr	r25
    4a50:	fb cf       	rjmp	.-10     	; 0x4a48 <__vector_79+0x86>
                }

                /* TODO: Prevent buffer overflow */
                *CodecBufferPtr = NewDataRegister;
    4a52:	e8 b1       	in	r30, 0x08	; 8
    4a54:	f9 b1       	in	r31, 0x09	; 9
    4a56:	90 83       	st	Z, r25
            }

            /* Signal, that we have finished sampling */
            Flags.DemodFinished = 1;
    4a58:	81 e0       	ldi	r24, 0x01	; 1
    4a5a:	80 93 a0 2c 	sts	0x2CA0, r24
    4a5e:	37 c0       	rjmp	.+110    	; 0x4ace <__vector_79+0x10c>
        } else {
            /* Otherwise, we check the two sample bits from the bit before. */
            uint8_t BitSample = SampleRegister & 0xC;
    4a60:	93 b1       	in	r25, 0x03	; 3
    4a62:	89 2f       	mov	r24, r25
    4a64:	8c 70       	andi	r24, 0x0C	; 12
            uint8_t Bit = 0;

            if (BitSample != (0x0 << 2)) {
    4a66:	99 f1       	breq	.+102    	; 0x4ace <__vector_79+0x10c>
                /* We have a valid bit. decode and process it. */
                if (BitSample & (0x1 << 2)) {
    4a68:	92 fb       	bst	r25, 2
    4a6a:	99 27       	eor	r25, r25
    4a6c:	90 f9       	bld	r25, 0
    4a6e:	81 e0       	ldi	r24, 0x01	; 1
    4a70:	98 27       	eor	r25, r24
                } else {
                    /* 10 sequence -> This is a one bit */
                    Bit = 1;
                }

                if (StateRegister == DEMOD_DATA_BIT) {
    4a72:	81 b1       	in	r24, 0x01	; 1
    4a74:	81 11       	cpse	r24, r1
    4a76:	1b c0       	rjmp	.+54     	; 0x4aae <__vector_79+0xec>
                    /* This is a data bit, so shift it into the data register and
                     * hold a local copy of it. */
                    uint8_t NewDataRegister = DataRegister >> 1;
    4a78:	80 b1       	in	r24, 0x00	; 0
    4a7a:	86 95       	lsr	r24
                    NewDataRegister |= (Bit ? 0x80 : 0x00);
    4a7c:	91 11       	cpse	r25, r1
    4a7e:	90 e8       	ldi	r25, 0x80	; 128
    4a80:	89 2b       	or	r24, r25
                    DataRegister = NewDataRegister;
    4a82:	80 b9       	out	0x00, r24	; 0

                    /* Update bitcount */
                    uint16_t NewBitCount = ++BitCount;
    4a84:	26 b1       	in	r18, 0x06	; 6
    4a86:	37 b1       	in	r19, 0x07	; 7
    4a88:	2f 5f       	subi	r18, 0xFF	; 255
    4a8a:	3f 4f       	sbci	r19, 0xFF	; 255
    4a8c:	26 b9       	out	0x06, r18	; 6
    4a8e:	37 b9       	out	0x07, r19	; 7
                    if ((NewBitCount & 0x07) == 0) {
    4a90:	27 70       	andi	r18, 0x07	; 7
    4a92:	33 27       	eor	r19, r19
    4a94:	23 2b       	or	r18, r19
    4a96:	d9 f4       	brne	.+54     	; 0x4ace <__vector_79+0x10c>
                        /* We have reached a byte boundary! Store the data register. */
                        /* TODO: Prevent buffer overflow */
                        *CodecBufferPtr++ = NewDataRegister;
    4a98:	e8 b1       	in	r30, 0x08	; 8
    4a9a:	f9 b1       	in	r31, 0x09	; 9
    4a9c:	9f 01       	movw	r18, r30
    4a9e:	2f 5f       	subi	r18, 0xFF	; 255
    4aa0:	3f 4f       	sbci	r19, 0xFF	; 255
    4aa2:	28 b9       	out	0x08, r18	; 8
    4aa4:	39 b9       	out	0x09, r19	; 9
    4aa6:	80 83       	st	Z, r24

                        /* Store bit for determining FDT at EOC and enable parity
                         * handling on next bit. */
                        StateRegister = DEMOD_PARITY_BIT;
    4aa8:	81 e0       	ldi	r24, 0x01	; 1
    4aaa:	81 b9       	out	0x01, r24	; 1
    4aac:	10 c0       	rjmp	.+32     	; 0x4ace <__vector_79+0x10c>
                    }

                } else if (StateRegister == DEMOD_PARITY_BIT) {
    4aae:	81 b1       	in	r24, 0x01	; 1
    4ab0:	81 30       	cpi	r24, 0x01	; 1
    4ab2:	69 f4       	brne	.+26     	; 0x4ace <__vector_79+0x10c>
                    /* This is a parity bit. Store it */
                    *ParityBufferPtr++ = Bit;
    4ab4:	ea b1       	in	r30, 0x0a	; 10
    4ab6:	fb b1       	in	r31, 0x0b	; 11
    4ab8:	9f 01       	movw	r18, r30
    4aba:	2f 5f       	subi	r18, 0xFF	; 255
    4abc:	3f 4f       	sbci	r19, 0xFF	; 255
    4abe:	2a b9       	out	0x0a, r18	; 10
    4ac0:	3b b9       	out	0x0b, r19	; 11
    4ac2:	90 83       	st	Z, r25
                    StateRegister = DEMOD_DATA_BIT;
    4ac4:	11 b8       	out	0x01, r1	; 1
    4ac6:	03 c0       	rjmp	.+6      	; 0x4ace <__vector_79+0x10c>
                 * sampling and have sampled less than 2 bits yet. Thus ignore. */
            }
        }
    } else {
        /* On odd sample position just sample. */
        SampleIdxRegister = ~SampleIdxRegister;
    4ac8:	82 b1       	in	r24, 0x02	; 2
    4aca:	80 95       	com	r24
    4acc:	82 b9       	out	0x02, r24	; 2

    /* Make sure the sampling timer gets automatically aligned to the
     * modulation pauses by using the RESTART event.
     * This can be understood as a "poor mans PLL" and makes sure that we are
     * never too far out the bit-grid while sampling. */
    CODEC_TIMER_SAMPLING.CTRLD = TC_EVACT_RESTART_gc | CODEC_TIMER_MODSTART_EVSEL;
    4ace:	88 e8       	ldi	r24, 0x88	; 136
    4ad0:	80 93 03 09 	sts	0x0903, r24
}
    4ad4:	ff 91       	pop	r31
    4ad6:	ef 91       	pop	r30
    4ad8:	9f 91       	pop	r25
    4ada:	8f 91       	pop	r24
    4adc:	3f 91       	pop	r19
    4ade:	2f 91       	pop	r18
    4ae0:	0f 90       	pop	r0
    4ae2:	0b be       	out	0x3b, r0	; 59
    4ae4:	0f 90       	pop	r0
    4ae6:	08 be       	out	0x38, r0	; 56
    4ae8:	0f 90       	pop	r0
    4aea:	0f be       	out	0x3f, r0	; 63
    4aec:	0f 90       	pop	r0
    4aee:	1f 90       	pop	r1
    4af0:	18 95       	reti

00004af2 <__vector_47>:

// Enumulate as a card to send card responds
ISR(CODEC_TIMER_LOADMOD_OVF_VECT) {
    4af2:	1f 92       	push	r1
    4af4:	0f 92       	push	r0
    4af6:	0f b6       	in	r0, 0x3f	; 63
    4af8:	0f 92       	push	r0
    4afa:	11 24       	eor	r1, r1
    4afc:	08 b6       	in	r0, 0x38	; 56
    4afe:	0f 92       	push	r0
    4b00:	18 be       	out	0x38, r1	; 56
    4b02:	0b b6       	in	r0, 0x3b	; 59
    4b04:	0f 92       	push	r0
    4b06:	1b be       	out	0x3b, r1	; 59
    4b08:	2f 93       	push	r18
    4b0a:	3f 93       	push	r19
    4b0c:	8f 93       	push	r24
    4b0e:	9f 93       	push	r25
    4b10:	ef 93       	push	r30
    4b12:	ff 93       	push	r31
        [LOADMOD_STOP_BIT0] = &&LOADMOD_STOP_BIT0_LABEL,
        [LOADMOD_STOP_BIT1] = &&LOADMOD_STOP_BIT1_LABEL,
        [LOADMOD_FINISHED] = &&LOADMOD_FINISHED_LABEL
    };

    if ( (StateRegister >= LOADMOD_FDT) && (StateRegister <= LOADMOD_FINISHED) ) {
    4b14:	81 b1       	in	r24, 0x01	; 1
    4b16:	82 30       	cpi	r24, 0x02	; 2
    4b18:	08 f4       	brcc	.+2      	; 0x4b1c <__vector_47+0x2a>
    4b1a:	9d c0       	rjmp	.+314    	; 0x4c56 <__vector_47+0x164>
    4b1c:	81 b1       	in	r24, 0x01	; 1
    4b1e:	8d 30       	cpi	r24, 0x0D	; 13
    4b20:	08 f0       	brcs	.+2      	; 0x4b24 <__vector_47+0x32>
    4b22:	99 c0       	rjmp	.+306    	; 0x4c56 <__vector_47+0x164>
        goto *JumpTable[StateRegister];
    4b24:	e1 b1       	in	r30, 0x01	; 1
    4b26:	f0 e0       	ldi	r31, 0x00	; 0
    4b28:	ee 0f       	add	r30, r30
    4b2a:	ff 1f       	adc	r31, r31
    4b2c:	e2 5d       	subi	r30, 0xD2	; 210
    4b2e:	ff 4d       	sbci	r31, 0xDF	; 223
    4b30:	01 90       	ld	r0, Z+
    4b32:	f0 81       	ld	r31, Z
    4b34:	e0 2d       	mov	r30, r0
    4b36:	19 94       	eijmp
        return;
    }

    LOADMOD_FDT_LABEL:
        /* No data has been produced, but FDT has ended. Switch over to bit-grid aligning. */
        CODEC_TIMER_LOADMOD.PER = ISO14443A_BIT_GRID_CYCLES - 1;
    4b38:	8f e7       	ldi	r24, 0x7F	; 127
    4b3a:	90 e0       	ldi	r25, 0x00	; 0
    4b3c:	80 93 26 0a 	sts	0x0A26, r24
    4b40:	90 93 27 0a 	sts	0x0A27, r25
        return;
    4b44:	88 c0       	rjmp	.+272    	; 0x4c56 <__vector_47+0x164>
    }
}

INLINE void CodecSetLoadmodState(bool bOnOff) {
    if (bOnOff) {
        VPORT0.OUT |= CODEC_LOADMOD_MASK;
    4b46:	8e 9a       	sbi	0x11, 6	; 17
    CODEC_SUBCARRIER_TIMER.PER = Divider - 1;
}

INLINE void CodecStartSubcarrier(void)
{
    CODEC_SUBCARRIER_TIMER.CTRLA = CODEC_TIMER_CARRIER_CLKSEL;
    4b48:	8e e0       	ldi	r24, 0x0E	; 14
    4b4a:	80 93 40 08 	sts	0x0840, r24
    LOADMOD_START_BIT0_LABEL:
        /* Start subcarrier generation, output startbit and align to bitrate. */
        CodecSetLoadmodState(true);
        CodecStartSubcarrier();

        CODEC_TIMER_LOADMOD.PER = ISO14443A_BIT_RATE_CYCLES / 2 - 1;
    4b4e:	8f e3       	ldi	r24, 0x3F	; 63
    4b50:	90 e0       	ldi	r25, 0x00	; 0
    4b52:	80 93 26 0a 	sts	0x0A26, r24
    4b56:	90 93 27 0a 	sts	0x0A27, r25
        StateRegister = LOADMOD_START_BIT1;
    4b5a:	85 e0       	ldi	r24, 0x05	; 5
    4b5c:	6f c0       	rjmp	.+222    	; 0x4c3c <__vector_47+0x14a>

INLINE void CodecSetLoadmodState(bool bOnOff) {
    if (bOnOff) {
        VPORT0.OUT |= CODEC_LOADMOD_MASK;
    } else {
        VPORT0.OUT &= ~CODEC_LOADMOD_MASK;
    4b5e:	8e 98       	cbi	0x11, 6	; 17
        return;


    LOADMOD_START_BIT1_LABEL:
        CodecSetLoadmodState(false);
        StateRegister = LOADMOD_DATA0;
    4b60:	86 e0       	ldi	r24, 0x06	; 6
    4b62:	81 b9       	out	0x01, r24	; 1
        ParityRegister = ~0;
    4b64:	8f ef       	ldi	r24, 0xFF	; 255
    4b66:	82 b9       	out	0x02, r24	; 2
        BitSent = 0;
    4b68:	14 b8       	out	0x04, r1	; 4
    4b6a:	15 b8       	out	0x05, r1	; 5

        /* Prefetch first byte */
        DataRegister = *CodecBufferPtr;
    4b6c:	e8 b1       	in	r30, 0x08	; 8
    4b6e:	f9 b1       	in	r31, 0x09	; 9
    4b70:	80 81       	ld	r24, Z
    4b72:	80 b9       	out	0x00, r24	; 0
        return;
    4b74:	70 c0       	rjmp	.+224    	; 0x4c56 <__vector_47+0x164>

    LOADMOD_DATA0_LABEL:
        if (DataRegister & 1) {
    4b76:	00 9b       	sbis	0x00, 0	; 0
    4b78:	05 c0       	rjmp	.+10     	; 0x4b84 <__vector_47+0x92>
    }
}

INLINE void CodecSetLoadmodState(bool bOnOff) {
    if (bOnOff) {
        VPORT0.OUT |= CODEC_LOADMOD_MASK;
    4b7a:	8e 9a       	sbi	0x11, 6	; 17
            CodecSetLoadmodState(true);
            ParityRegister = ~ParityRegister;
    4b7c:	82 b1       	in	r24, 0x02	; 2
    4b7e:	80 95       	com	r24
    4b80:	82 b9       	out	0x02, r24	; 2
    4b82:	01 c0       	rjmp	.+2      	; 0x4b86 <__vector_47+0x94>
    } else {
        VPORT0.OUT &= ~CODEC_LOADMOD_MASK;
    4b84:	8e 98       	cbi	0x11, 6	; 17
        } else {
            CodecSetLoadmodState(false);
        }

        StateRegister = LOADMOD_DATA1;
    4b86:	87 e0       	ldi	r24, 0x07	; 7
    4b88:	59 c0       	rjmp	.+178    	; 0x4c3c <__vector_47+0x14a>
        return;

    LOADMOD_DATA1_LABEL:
        if (DataRegister & 1) {
    4b8a:	00 9b       	sbis	0x00, 0	; 0
    4b8c:	02 c0       	rjmp	.+4      	; 0x4b92 <__vector_47+0xa0>
    4b8e:	8e 98       	cbi	0x11, 6	; 17
    4b90:	01 c0       	rjmp	.+2      	; 0x4b94 <__vector_47+0xa2>
    }
}

INLINE void CodecSetLoadmodState(bool bOnOff) {
    if (bOnOff) {
        VPORT0.OUT |= CODEC_LOADMOD_MASK;
    4b92:	8e 9a       	sbi	0x11, 6	; 17
            CodecSetLoadmodState(false);
        } else {
            CodecSetLoadmodState(true);
        }

        DataRegister = DataRegister >> 1;
    4b94:	80 b1       	in	r24, 0x00	; 0
    4b96:	86 95       	lsr	r24
    4b98:	80 b9       	out	0x00, r24	; 0
        BitSent++;
    4b9a:	84 b1       	in	r24, 0x04	; 4
    4b9c:	95 b1       	in	r25, 0x05	; 5
    4b9e:	01 96       	adiw	r24, 0x01	; 1
    4ba0:	84 b9       	out	0x04, r24	; 4
    4ba2:	95 b9       	out	0x05, r25	; 5

        if ((BitSent % 8) == 0) {
    4ba4:	84 b1       	in	r24, 0x04	; 4
    4ba6:	95 b1       	in	r25, 0x05	; 5
    4ba8:	87 70       	andi	r24, 0x07	; 7
    4baa:	99 27       	eor	r25, r25
    4bac:	89 2b       	or	r24, r25
    4bae:	11 f4       	brne	.+4      	; 0x4bb4 <__vector_47+0xc2>
            /* Byte boundary. Load parity bit and output it later. */
            StateRegister = LOADMOD_PARITY0;
    4bb0:	88 e0       	ldi	r24, 0x08	; 8
    4bb2:	44 c0       	rjmp	.+136    	; 0x4c3c <__vector_47+0x14a>
        } else if (BitSent == BitCount) {
    4bb4:	24 b1       	in	r18, 0x04	; 4
    4bb6:	35 b1       	in	r19, 0x05	; 5
    4bb8:	86 b1       	in	r24, 0x06	; 6
    4bba:	97 b1       	in	r25, 0x07	; 7
    4bbc:	28 17       	cp	r18, r24
    4bbe:	39 07       	cpc	r19, r25
    4bc0:	b1 f5       	brne	.+108    	; 0x4c2e <__vector_47+0x13c>
    4bc2:	2b c0       	rjmp	.+86     	; 0x4c1a <__vector_47+0x128>
        }

        return;

    LOADMOD_PARITY0_LABEL:
        if (ParityBufferPtr != NULL) {
    4bc4:	ea b1       	in	r30, 0x0a	; 10
    4bc6:	fb b1       	in	r31, 0x0b	; 11
    4bc8:	30 97       	sbiw	r30, 0x00	; 0
    4bca:	11 f0       	breq	.+4      	; 0x4bd0 <__vector_47+0xde>
            if (*ParityBufferPtr) {
    4bcc:	80 81       	ld	r24, Z
    4bce:	01 c0       	rjmp	.+2      	; 0x4bd2 <__vector_47+0xe0>
                CodecSetLoadmodState(true);
            } else {
                CodecSetLoadmodState(false);
            }
        } else {
            if (ParityRegister) {
    4bd0:	82 b1       	in	r24, 0x02	; 2
    4bd2:	88 23       	and	r24, r24
    4bd4:	11 f0       	breq	.+4      	; 0x4bda <__vector_47+0xe8>
    4bd6:	8e 9a       	sbi	0x11, 6	; 17
    4bd8:	01 c0       	rjmp	.+2      	; 0x4bdc <__vector_47+0xea>
    } else {
        VPORT0.OUT &= ~CODEC_LOADMOD_MASK;
    4bda:	8e 98       	cbi	0x11, 6	; 17
                CodecSetLoadmodState(true);
            } else {
                CodecSetLoadmodState(false);
            }
        }
        StateRegister = LOADMOD_PARITY1;
    4bdc:	89 e0       	ldi	r24, 0x09	; 9
    4bde:	2e c0       	rjmp	.+92     	; 0x4c3c <__vector_47+0x14a>
        return;

    LOADMOD_PARITY1_LABEL:
        if (ParityBufferPtr != NULL) {
    4be0:	ea b1       	in	r30, 0x0a	; 10
    4be2:	fb b1       	in	r31, 0x0b	; 11
    4be4:	30 97       	sbiw	r30, 0x00	; 0
    4be6:	51 f0       	breq	.+20     	; 0x4bfc <__vector_47+0x10a>
            if (*ParityBufferPtr) {
    4be8:	80 81       	ld	r24, Z
    4bea:	88 23       	and	r24, r24
    4bec:	11 f0       	breq	.+4      	; 0x4bf2 <__vector_47+0x100>
    4bee:	8e 98       	cbi	0x11, 6	; 17
    4bf0:	01 c0       	rjmp	.+2      	; 0x4bf4 <__vector_47+0x102>
    }
}

INLINE void CodecSetLoadmodState(bool bOnOff) {
    if (bOnOff) {
        VPORT0.OUT |= CODEC_LOADMOD_MASK;
    4bf2:	8e 9a       	sbi	0x11, 6	; 17
                CodecSetLoadmodState(false);
            } else {
                CodecSetLoadmodState(true);
            }

            ParityBufferPtr++;
    4bf4:	31 96       	adiw	r30, 0x01	; 1
    4bf6:	ea b9       	out	0x0a, r30	; 10
    4bf8:	fb b9       	out	0x0b, r31	; 11
    4bfa:	08 c0       	rjmp	.+16     	; 0x4c0c <__vector_47+0x11a>
        } else {
            if (ParityRegister) {
    4bfc:	82 b1       	in	r24, 0x02	; 2
    4bfe:	88 23       	and	r24, r24
    4c00:	11 f0       	breq	.+4      	; 0x4c06 <__vector_47+0x114>
    } else {
        VPORT0.OUT &= ~CODEC_LOADMOD_MASK;
    4c02:	8e 98       	cbi	0x11, 6	; 17
    4c04:	01 c0       	rjmp	.+2      	; 0x4c08 <__vector_47+0x116>
    }
}

INLINE void CodecSetLoadmodState(bool bOnOff) {
    if (bOnOff) {
        VPORT0.OUT |= CODEC_LOADMOD_MASK;
    4c06:	8e 9a       	sbi	0x11, 6	; 17
                CodecSetLoadmodState(false);
            } else {
                CodecSetLoadmodState(true);
            }

            ParityRegister = ~0;
    4c08:	8f ef       	ldi	r24, 0xFF	; 255
    4c0a:	82 b9       	out	0x02, r24	; 2
        }

        if (BitSent == BitCount) {
    4c0c:	24 b1       	in	r18, 0x04	; 4
    4c0e:	35 b1       	in	r19, 0x05	; 5
    4c10:	86 b1       	in	r24, 0x06	; 6
    4c12:	97 b1       	in	r25, 0x07	; 7
    4c14:	28 17       	cp	r18, r24
    4c16:	39 07       	cpc	r19, r25
    4c18:	11 f4       	brne	.+4      	; 0x4c1e <__vector_47+0x12c>
            /* No data left */
            StateRegister = LOADMOD_STOP_BIT0;
    4c1a:	8a e0       	ldi	r24, 0x0A	; 10
    4c1c:	0f c0       	rjmp	.+30     	; 0x4c3c <__vector_47+0x14a>
        } else {
            /* Fetch next data and continue sending bits. */
            DataRegister = *++CodecBufferPtr;
    4c1e:	e8 b1       	in	r30, 0x08	; 8
    4c20:	f9 b1       	in	r31, 0x09	; 9
    4c22:	cf 01       	movw	r24, r30
    4c24:	01 96       	adiw	r24, 0x01	; 1
    4c26:	88 b9       	out	0x08, r24	; 8
    4c28:	99 b9       	out	0x09, r25	; 9
    4c2a:	81 81       	ldd	r24, Z+1	; 0x01
    4c2c:	80 b9       	out	0x00, r24	; 0
            StateRegister = LOADMOD_DATA0;
    4c2e:	86 e0       	ldi	r24, 0x06	; 6
    4c30:	05 c0       	rjmp	.+10     	; 0x4c3c <__vector_47+0x14a>
    } else {
        VPORT0.OUT &= ~CODEC_LOADMOD_MASK;
    4c32:	8e 98       	cbi	0x11, 6	; 17

        return;

    LOADMOD_STOP_BIT0_LABEL:
        CodecSetLoadmodState(false);
        StateRegister = LOADMOD_STOP_BIT1;
    4c34:	8b e0       	ldi	r24, 0x0B	; 11
    4c36:	02 c0       	rjmp	.+4      	; 0x4c3c <__vector_47+0x14a>
    4c38:	8e 98       	cbi	0x11, 6	; 17
        return;

    LOADMOD_STOP_BIT1_LABEL:
        CodecSetLoadmodState(false);
        StateRegister = LOADMOD_FINISHED;
    4c3a:	8c e0       	ldi	r24, 0x0C	; 12
    4c3c:	81 b9       	out	0x01, r24	; 1
        return;
    4c3e:	0b c0       	rjmp	.+22     	; 0x4c56 <__vector_47+0x164>

    LOADMOD_FINISHED_LABEL:
        /* We have written all of our bits. Deactivate the loadmod
         * timer. Also disable the bit-rate interrupt again. And
         * stop the subcarrier divider. */
        CODEC_TIMER_LOADMOD.CTRLA = TC_CLKSEL_OFF_gc;
    4c40:	10 92 00 0a 	sts	0x0A00, r1
        CODEC_TIMER_LOADMOD.INTCTRLA = 0;
    4c44:	10 92 06 0a 	sts	0x0A06, r1
}

INLINE void CodecSetSubcarrier(SubcarrierModType ModType, uint16_t Divider)
{
    if (ModType == CODEC_SUBCARRIERMOD_OFF) {
        CODEC_SUBCARRIER_TIMER.CTRLA = TC_CLKSEL_OFF_gc;
    4c48:	10 92 40 08 	sts	0x0840, r1
        CODEC_SUBCARRIER_TIMER.CTRLB = 0;
    4c4c:	10 92 41 08 	sts	0x0841, r1
        CodecSetSubcarrier(CODEC_SUBCARRIERMOD_OFF, ISO14443A_SUBCARRIER_DIVIDER);

        /* Signal application that we have finished loadmod */
        Flags.LoadmodFinished = 1;
    4c50:	81 e0       	ldi	r24, 0x01	; 1
    4c52:	80 93 a1 2c 	sts	0x2CA1, r24
        return;
}
    4c56:	ff 91       	pop	r31
    4c58:	ef 91       	pop	r30
    4c5a:	9f 91       	pop	r25
    4c5c:	8f 91       	pop	r24
    4c5e:	3f 91       	pop	r19
    4c60:	2f 91       	pop	r18
    4c62:	0f 90       	pop	r0
    4c64:	0b be       	out	0x3b, r0	; 59
    4c66:	0f 90       	pop	r0
    4c68:	08 be       	out	0x38, r0	; 56
    4c6a:	0f 90       	pop	r0
    4c6c:	0f be       	out	0x3f, r0	; 63
    4c6e:	0f 90       	pop	r0
    4c70:	1f 90       	pop	r1
    4c72:	18 95       	reti

00004c74 <ISO14443ACodecInit>:

void ISO14443ACodecInit(void) {
    4c74:	cf 93       	push	r28
    4c76:	df 93       	push	r29
    /* Initialize some global vars and start looking out for reader commands */
    Flags.DemodFinished = 0;
    4c78:	e0 ea       	ldi	r30, 0xA0	; 160
    4c7a:	fc e2       	ldi	r31, 0x2C	; 44
    4c7c:	10 82       	st	Z, r1
    Flags.LoadmodFinished = 0;
    4c7e:	11 82       	std	Z+1, r1	; 0x01

    isr_func_TCD0_CCC_vect = &isr_Reader14443_2A_TCD0_CCC_vect;
    4c80:	8b e6       	ldi	r24, 0x6B	; 107
    4c82:	97 e2       	ldi	r25, 0x27	; 39
    4c84:	80 93 50 2e 	sts	0x2E50, r24
    4c88:	90 93 51 2e 	sts	0x2E51, r25
    isr_func_CODEC_DEMOD_IN_INT0_VECT = &isr_ISO14443_2A_TCD0_CCC_vect;
    4c8c:	8e e8       	ldi	r24, 0x8E	; 142
    4c8e:	94 e2       	ldi	r25, 0x24	; 36
    4c90:	80 93 52 2f 	sts	0x2F52, r24
    4c94:	90 93 53 2f 	sts	0x2F53, r25
{
    /* Configure CARRIER input pin and route it to EVSYS.
     * Multiply by 2 again by using both edges when externally
     * dividing by 2 */
#if CODEC_CARRIER_IN_DIV == 2
    CODEC_CARRIER_IN_PORT.CODEC_CARRIER_IN_PINCTRL = PORT_ISC_BOTHEDGES_gc;
    4c98:	e0 e4       	ldi	r30, 0x40	; 64
    4c9a:	f6 e0       	ldi	r31, 0x06	; 6
    4c9c:	12 8a       	std	Z+18, r1	; 0x12
#else
#error Option not supported
#endif
    CODEC_CARRIER_IN_PORT.DIRCLR = CODEC_CARRIER_IN_MASK;
    4c9e:	84 e0       	ldi	r24, 0x04	; 4
    4ca0:	82 83       	std	Z+2, r24	; 0x02
    EVSYS.CH6MUX = CODEC_CARRIER_IN_EVMUX;
    4ca2:	c0 e8       	ldi	r28, 0x80	; 128
    4ca4:	d1 e0       	ldi	r29, 0x01	; 1
    4ca6:	82 e6       	ldi	r24, 0x62	; 98
    4ca8:	8e 83       	std	Y+6, r24	; 0x06

    /* Configure two DEMOD pins for input.
     * Configure event channel 0 for rising edge (begin of modulation pause)
     * Configure event channel 1 for falling edge (end of modulation pause) */
    CODEC_DEMOD_POWER_PORT.OUTCLR = CODEC_DEMOD_POWER_MASK;
    4caa:	a0 e2       	ldi	r26, 0x20	; 32
    4cac:	b6 e0       	ldi	r27, 0x06	; 6
    4cae:	81 e0       	ldi	r24, 0x01	; 1
    4cb0:	16 96       	adiw	r26, 0x06	; 6
    4cb2:	8c 93       	st	X, r24
    4cb4:	16 97       	sbiw	r26, 0x06	; 6
    CODEC_DEMOD_POWER_PORT.DIRSET = CODEC_DEMOD_POWER_MASK;
    4cb6:	11 96       	adiw	r26, 0x01	; 1
    4cb8:	8c 93       	st	X, r24
    4cba:	11 97       	sbiw	r26, 0x01	; 1
    CODEC_DEMOD_IN_PORT.DIRCLR = CODEC_DEMOD_IN_MASK;
    4cbc:	96 e0       	ldi	r25, 0x06	; 6
    4cbe:	12 96       	adiw	r26, 0x02	; 2
    4cc0:	9c 93       	st	X, r25
    4cc2:	12 97       	sbiw	r26, 0x02	; 2
    CODEC_DEMOD_IN_PORT.CODEC_DEMOD_IN_PINCTRL0 = PORT_ISC_RISING_gc;
    4cc4:	51 96       	adiw	r26, 0x11	; 17
    4cc6:	8c 93       	st	X, r24
    4cc8:	51 97       	sbiw	r26, 0x11	; 17
    CODEC_DEMOD_IN_PORT.CODEC_DEMOD_IN_PINCTRL1 = PORT_ISC_FALLING_gc;
    4cca:	32 e0       	ldi	r19, 0x02	; 2
    4ccc:	52 96       	adiw	r26, 0x12	; 18
    4cce:	3c 93       	st	X, r19
    4cd0:	52 97       	sbiw	r26, 0x12	; 18
    CODEC_DEMOD_IN_PORT.INT0MASK = 0;
    4cd2:	1a 96       	adiw	r26, 0x0a	; 10
    4cd4:	1c 92       	st	X, r1
    4cd6:	1a 97       	sbiw	r26, 0x0a	; 10
    CODEC_DEMOD_IN_PORT.INT1MASK = 0;
    4cd8:	1b 96       	adiw	r26, 0x0b	; 11
    4cda:	1c 92       	st	X, r1
    4cdc:	1b 97       	sbiw	r26, 0x0b	; 11
    CODEC_DEMOD_IN_PORT.INTCTRL = PORT_INT0LVL_HI_gc | PORT_INT1LVL_HI_gc;
    4cde:	9f e0       	ldi	r25, 0x0F	; 15
    4ce0:	19 96       	adiw	r26, 0x09	; 9
    4ce2:	9c 93       	st	X, r25
    EVSYS.CH0MUX = CODEC_DEMOD_IN_EVMUX0;
    4ce4:	99 e5       	ldi	r25, 0x59	; 89
    4ce6:	98 83       	st	Y, r25
    EVSYS.CH1MUX = CODEC_DEMOD_IN_EVMUX1;
    4ce8:	2a e5       	ldi	r18, 0x5A	; 90
    4cea:	29 83       	std	Y+1, r18	; 0x01

    EVSYS.CH2MUX = CODEC_DEMOD_IN_EVMUX0;
    4cec:	9a 83       	std	Y+2, r25	; 0x02


    /* Configure loadmod pin configuration and use a virtual port configuration
     * for single instruction cycle access */
    CODEC_LOADMOD_PORT.DIRSET = CODEC_LOADMOD_MASK;
    4cee:	90 e4       	ldi	r25, 0x40	; 64
    4cf0:	91 83       	std	Z+1, r25	; 0x01
    CODEC_LOADMOD_PORT.OUTCLR = CODEC_LOADMOD_MASK;
    4cf2:	96 83       	std	Z+6, r25	; 0x06
    PORTCFG.VPCTRLA &= ~PORTCFG_VP0MAP_gm;
    4cf4:	a0 eb       	ldi	r26, 0xB0	; 176
    4cf6:	b0 e0       	ldi	r27, 0x00	; 0
    4cf8:	12 96       	adiw	r26, 0x02	; 2
    4cfa:	2c 91       	ld	r18, X
    4cfc:	12 97       	sbiw	r26, 0x02	; 2
    4cfe:	20 7f       	andi	r18, 0xF0	; 240
    4d00:	12 96       	adiw	r26, 0x02	; 2
    4d02:	2c 93       	st	X, r18
    4d04:	12 97       	sbiw	r26, 0x02	; 2
    PORTCFG.VPCTRLA |= PORTCFG_VP02MAP_PORTC_gc;
    4d06:	12 96       	adiw	r26, 0x02	; 2
    4d08:	2c 91       	ld	r18, X
    4d0a:	12 97       	sbiw	r26, 0x02	; 2
    4d0c:	22 60       	ori	r18, 0x02	; 2
    4d0e:	12 96       	adiw	r26, 0x02	; 2
    4d10:	2c 93       	st	X, r18

    /* Configure subcarrier pins for output */
    CODEC_SUBCARRIER_PORT.DIRSET = CODEC_SUBCARRIER_MASK;
    4d12:	20 e3       	ldi	r18, 0x30	; 48
    4d14:	21 83       	std	Z+1, r18	; 0x01
    CODEC_SUBCARRIER_PORT.OUTCLR = CODEC_SUBCARRIER_MASK;
    4d16:	26 83       	std	Z+6, r18	; 0x06

    /* Configure pins for reader field with the LEFT output being inverted
     * and all bridge outputs static high */
    CODEC_READER_PORT.CODEC_READER_PINCTRL_LEFT = PORT_INVEN_bm;
    4d18:	90 8b       	std	Z+16, r25	; 0x10
    CODEC_READER_PORT.OUTCLR = CODEC_READER_MASK_LEFT;
    4d1a:	86 83       	std	Z+6, r24	; 0x06
    CODEC_READER_PORT.OUTSET = CODEC_READER_MASK_RIGHT;
    4d1c:	35 83       	std	Z+5, r19	; 0x05
    CODEC_READER_PORT.DIRSET = CODEC_READER_MASK;
    4d1e:	83 e0       	ldi	r24, 0x03	; 3
    4d20:	81 83       	std	Z+1, r24	; 0x01

    /* Configure timer for generating reader field and configure AWEX for outputting pattern
     * with disabled outputs. */
    CODEC_READER_TIMER.CTRLB = TC0_CCAEN_bm | TC_WGMODE_SINGLESLOPE_gc;
    4d22:	e0 e0       	ldi	r30, 0x00	; 0
    4d24:	f8 e0       	ldi	r31, 0x08	; 8
    4d26:	83 e1       	ldi	r24, 0x13	; 19
    4d28:	81 83       	std	Z+1, r24	; 0x01
    CODEC_READER_TIMER.PER = F_CPU / CODEC_CARRIER_FREQ - 1;
    4d2a:	21 e0       	ldi	r18, 0x01	; 1
    4d2c:	30 e0       	ldi	r19, 0x00	; 0
    4d2e:	26 a3       	std	Z+38, r18	; 0x26
    4d30:	37 a3       	std	Z+39, r19	; 0x27
    CODEC_READER_TIMER.CCA = F_CPU / CODEC_CARRIER_FREQ / 2 ;
    4d32:	20 a7       	std	Z+40, r18	; 0x28
    4d34:	31 a7       	std	Z+41, r19	; 0x29

    AWEXC.OUTOVEN = 0x00;
    4d36:	e0 e8       	ldi	r30, 0x80	; 128
    4d38:	f8 e0       	ldi	r31, 0x08	; 8
    4d3a:	14 86       	std	Z+12, r1	; 0x0c
    AWEXC.CTRL = AWEX_CWCM_bm | AWEX_DTICCAEN_bm | AWEX_DTICCBEN_bm;
    4d3c:	80 83       	st	Z, r24

    /* Configure DAC for the reference voltage */
    DACB.EVCTRL = 0;
    4d3e:	e0 e2       	ldi	r30, 0x20	; 32
    4d40:	f3 e0       	ldi	r31, 0x03	; 3
    4d42:	13 82       	std	Z+3, r1	; 0x03
    DACB.CTRLB = DAC_CHSEL_SINGLE_gc;
    4d44:	11 82       	std	Z+1, r1	; 0x01
    DACB.CTRLC = DAC_REFSEL_AVCC_gc;
    4d46:	88 e0       	ldi	r24, 0x08	; 8
    4d48:	82 83       	std	Z+2, r24	; 0x02
    DACB.CTRLA = DAC_IDOEN_bm | DAC_ENABLE_bm;
    4d4a:	91 e1       	ldi	r25, 0x11	; 17
    4d4c:	90 83       	st	Z, r25
    DACB.CH0DATA = GlobalSettings.ActiveSettingPtr->ReaderThreshold; // real threshold voltage can be calculated with ch0data * Vref / 0xFFF
    4d4e:	a0 91 71 2f 	lds	r26, 0x2F71
    4d52:	b0 91 72 2f 	lds	r27, 0x2F72
    4d56:	1a 96       	adiw	r26, 0x0a	; 10
    4d58:	2d 91       	ld	r18, X+
    4d5a:	3c 91       	ld	r19, X
    4d5c:	1b 97       	sbiw	r26, 0x0b	; 11
    4d5e:	20 8f       	std	Z+24, r18	; 0x18
    4d60:	31 8f       	std	Z+25, r19	; 0x19

    /* Configure Analog Comparator 0 to detect changes in demodulated reader field */
    ACA.AC0MUXCTRL = AC_MUXPOS_DAC_gc | AC_MUXNEG_PIN7_gc;
    4d62:	e0 e8       	ldi	r30, 0x80	; 128
    4d64:	f3 e0       	ldi	r31, 0x03	; 3
    4d66:	9c e3       	ldi	r25, 0x3C	; 60
    4d68:	92 83       	std	Z+2, r25	; 0x02
    ACA.AC0CTRL = CODEC_AC_DEMOD_SETTINGS;
    4d6a:	80 83       	st	Z, r24

    /* Configure Analog Comparator 1 to detect SOC */
    ACA.AC1MUXCTRL = AC_MUXPOS_DAC_gc | AC_MUXNEG_PIN7_gc;
    4d6c:	93 83       	std	Z+3, r25	; 0x03
    ACA.AC1CTRL = CODEC_AC_DEMOD_SETTINGS;
    4d6e:	81 83       	std	Z+1, r24	; 0x01
    CodecInitCommon();
    StartDemod();
}
    4d70:	df 91       	pop	r29
    4d72:	cf 91       	pop	r28
    Flags.LoadmodFinished = 0;

    isr_func_TCD0_CCC_vect = &isr_Reader14443_2A_TCD0_CCC_vect;
    isr_func_CODEC_DEMOD_IN_INT0_VECT = &isr_ISO14443_2A_TCD0_CCC_vect;
    CodecInitCommon();
    StartDemod();
    4d74:	a5 cd       	rjmp	.-1206   	; 0x48c0 <StartDemod>

00004d76 <ISO14443ACodecDeInit>:
}

void ISO14443ACodecDeInit(void)
{
    /* Gracefully shutdown codec */
    CODEC_DEMOD_IN_PORT.INT0MASK = 0;
    4d76:	a0 e2       	ldi	r26, 0x20	; 32
    4d78:	b6 e0       	ldi	r27, 0x06	; 6
    4d7a:	1a 96       	adiw	r26, 0x0a	; 10
    4d7c:	1c 92       	st	X, r1
    4d7e:	1a 97       	sbiw	r26, 0x0a	; 10

    Flags.DemodFinished = 0;
    4d80:	e0 ea       	ldi	r30, 0xA0	; 160
    4d82:	fc e2       	ldi	r31, 0x2C	; 44
    4d84:	10 82       	st	Z, r1
    Flags.LoadmodFinished = 0;
    4d86:	11 82       	std	Z+1, r1	; 0x01

    CODEC_TIMER_SAMPLING.CTRLA = TC_CLKSEL_OFF_gc;
    4d88:	e0 e0       	ldi	r30, 0x00	; 0
    4d8a:	f9 e0       	ldi	r31, 0x09	; 9
    4d8c:	10 82       	st	Z, r1
    CODEC_TIMER_SAMPLING.CTRLD = TC_EVACT_OFF_gc;
    4d8e:	13 82       	std	Z+3, r1	; 0x03
    CODEC_TIMER_SAMPLING.INTCTRLB = TC_CCAINTLVL_OFF_gc;
    4d90:	17 82       	std	Z+7, r1	; 0x07
    CODEC_TIMER_SAMPLING.INTFLAGS = TC0_CCAIF_bm;
    4d92:	80 e1       	ldi	r24, 0x10	; 16
    4d94:	84 87       	std	Z+12, r24	; 0x0c


    CODEC_TIMER_LOADMOD.CTRLA = TC_CLKSEL_OFF_gc;
    4d96:	e0 e0       	ldi	r30, 0x00	; 0
    4d98:	fa e0       	ldi	r31, 0x0A	; 10
    4d9a:	10 82       	st	Z, r1
    CODEC_TIMER_LOADMOD.CTRLD = TC_EVACT_OFF_gc;
    4d9c:	13 82       	std	Z+3, r1	; 0x03
    CODEC_TIMER_LOADMOD.INTCTRLA = TC_OVFINTLVL_OFF_gc;
    4d9e:	16 82       	std	Z+6, r1	; 0x06
    CODEC_TIMER_LOADMOD.INTFLAGS = TC0_OVFIF_bm;
    4da0:	81 e0       	ldi	r24, 0x01	; 1
    4da2:	84 87       	std	Z+12, r24	; 0x0c
}

INLINE void CodecSetSubcarrier(SubcarrierModType ModType, uint16_t Divider)
{
    if (ModType == CODEC_SUBCARRIERMOD_OFF) {
        CODEC_SUBCARRIER_TIMER.CTRLA = TC_CLKSEL_OFF_gc;
    4da4:	e0 e4       	ldi	r30, 0x40	; 64
    4da6:	f8 e0       	ldi	r31, 0x08	; 8
    4da8:	10 82       	st	Z, r1
        CODEC_SUBCARRIER_TIMER.CTRLB = 0;
    4daa:	11 82       	std	Z+1, r1	; 0x01
INLINE void CodecSetDemodPower(bool bOnOff)
{
    if (bOnOff) {
        CODEC_DEMOD_POWER_PORT.OUTSET = CODEC_DEMOD_POWER_MASK;
    } else {
        CODEC_DEMOD_POWER_PORT.OUTCLR = CODEC_DEMOD_POWER_MASK;
    4dac:	16 96       	adiw	r26, 0x06	; 6
    4dae:	8c 93       	st	X, r24

INLINE void CodecSetLoadmodState(bool bOnOff) {
    if (bOnOff) {
        VPORT0.OUT |= CODEC_LOADMOD_MASK;
    } else {
        VPORT0.OUT &= ~CODEC_LOADMOD_MASK;
    4db0:	8e 98       	cbi	0x11, 6	; 17
    4db2:	08 95       	ret

00004db4 <ISO14443ACodecTask>:
    CodecSetDemodPower(false);
    CodecSetLoadmodState(false);

}

void ISO14443ACodecTask(void) {
    4db4:	cf 93       	push	r28
    4db6:	df 93       	push	r29
    if (Flags.DemodFinished) {
    4db8:	80 91 a0 2c 	lds	r24, 0x2CA0
    4dbc:	88 23       	and	r24, r24
    4dbe:	09 f4       	brne	.+2      	; 0x4dc2 <ISO14443ACodecTask+0xe>
    4dc0:	7e c0       	rjmp	.+252    	; 0x4ebe <ISO14443ACodecTask+0x10a>
        Flags.DemodFinished = 0;
    4dc2:	10 92 a0 2c 	sts	0x2CA0, r1
        /* Reception finished. Process the received bytes */
        uint16_t DemodBitCount = BitCount;
    4dc6:	c6 b1       	in	r28, 0x06	; 6
    4dc8:	d7 b1       	in	r29, 0x07	; 7
        uint16_t AnswerBitCount = ISO14443A_APP_NO_RESPONSE;

        if (DemodBitCount >= ISO14443A_MIN_BITS_PER_FRAME) {
    4dca:	c7 30       	cpi	r28, 0x07	; 7
    4dcc:	d1 05       	cpc	r29, r1
    4dce:	08 f4       	brcc	.+2      	; 0x4dd2 <ISO14443ACodecTask+0x1e>
    4dd0:	71 c0       	rjmp	.+226    	; 0x4eb4 <ISO14443ACodecTask+0x100>
            // For logging data
            LogEntry(LOG_INFO_CODEC_RX_DATA, CodecBuffer, (DemodBitCount+7)/8);
    4dd2:	ae 01       	movw	r20, r28
    4dd4:	49 5f       	subi	r20, 0xF9	; 249
    4dd6:	5f 4f       	sbci	r21, 0xFF	; 255
    4dd8:	93 e0       	ldi	r25, 0x03	; 3
    4dda:	56 95       	lsr	r21
    4ddc:	47 95       	ror	r20
    4dde:	9a 95       	dec	r25
    4de0:	e1 f7       	brne	.-8      	; 0x4dda <ISO14443ACodecTask+0x26>
void LogGetModeByName(char* Mode, uint16_t BufferSize);
void LogGetModeList(char* List, uint16_t BufferSize);
void LogSRAMToFRAM(void);

/* Wrapper function to call current logging function */
INLINE void LogEntry(LogEntryEnum Entry, const void* Data, uint8_t Length) { CurrentLogFunc(Entry, Data, Length); }
    4de2:	e0 91 6e 2f 	lds	r30, 0x2F6E
    4de6:	f0 91 6f 2f 	lds	r31, 0x2F6F
    4dea:	63 ed       	ldi	r22, 0xD3	; 211
    4dec:	71 e3       	ldi	r23, 0x31	; 49
    4dee:	80 e4       	ldi	r24, 0x40	; 64
    4df0:	19 95       	eicall

INLINE void LEDHook(LEDHookEnum Func, LEDActionEnum Action) {
    extern LEDActionEnum LEDGreenAction;
    extern LEDActionEnum LEDRedAction;

    if (GlobalSettings.ActiveSettingPtr->LEDGreenFunction == Func) {
    4df2:	e0 91 71 2f 	lds	r30, 0x2F71
    4df6:	f0 91 72 2f 	lds	r31, 0x2F72
    4dfa:	87 81       	ldd	r24, Z+7	; 0x07
    4dfc:	88 30       	cpi	r24, 0x08	; 8
    4dfe:	19 f4       	brne	.+6      	; 0x4e06 <ISO14443ACodecTask+0x52>
        LEDGreenAction = Action;
    4e00:	83 e1       	ldi	r24, 0x13	; 19
    4e02:	80 93 7d 2c 	sts	0x2C7D, r24
    }

    if (GlobalSettings.ActiveSettingPtr->LEDRedFunction == Func) {
    4e06:	86 81       	ldd	r24, Z+6	; 0x06
    4e08:	88 30       	cpi	r24, 0x08	; 8
    4e0a:	19 f4       	brne	.+6      	; 0x4e12 <ISO14443ACodecTask+0x5e>
        LEDRedAction = Action;
    4e0c:	83 e1       	ldi	r24, 0x13	; 19
    4e0e:	80 93 7c 2c 	sts	0x2C7C, r24
INLINE void ApplicationTick(void) {
	ActiveConfiguration.ApplicationTickFunc();
}

INLINE uint16_t ApplicationProcess(uint8_t* ByteBuffer, uint16_t ByteCount) {
    return ActiveConfiguration.ApplicationProcessFunc(ByteBuffer, ByteCount);
    4e12:	e0 91 64 2f 	lds	r30, 0x2F64
    4e16:	f0 91 65 2f 	lds	r31, 0x2F65
    4e1a:	be 01       	movw	r22, r28
    4e1c:	83 ed       	ldi	r24, 0xD3	; 211
    4e1e:	91 e3       	ldi	r25, 0x31	; 49
    4e20:	19 95       	eicall
    4e22:	ec 01       	movw	r28, r24
            LEDHook(LED_CODEC_RX, LED_PULSE);

            /* Call application if we received data */
            AnswerBitCount = ApplicationProcess(CodecBuffer, DemodBitCount);

            if (AnswerBitCount & ISO14443A_APP_CUSTOM_PARITY) {
    4e24:	94 ff       	sbrs	r25, 4
    4e26:	06 c0       	rjmp	.+12     	; 0x4e34 <ISO14443ACodecTask+0x80>
                /* Application has generated it's own parity bits.
                 * Clear this option bit. */
                AnswerBitCount &= ~ISO14443A_APP_CUSTOM_PARITY;
    4e28:	df 7e       	andi	r29, 0xEF	; 239
                ParityBufferPtr = &CodecBuffer[ISO14443A_BUFFER_PARITY_OFFSET];
    4e2a:	83 e5       	ldi	r24, 0x53	; 83
    4e2c:	92 e3       	ldi	r25, 0x32	; 50
    4e2e:	8a b9       	out	0x0a, r24	; 10
    4e30:	9b b9       	out	0x0b, r25	; 11
    4e32:	02 c0       	rjmp	.+4      	; 0x4e38 <ISO14443ACodecTask+0x84>
            } else {
                /* We have to generate the parity bits ourself */
                ParityBufferPtr = 0;
    4e34:	1a b8       	out	0x0a, r1	; 10
    4e36:	1b b8       	out	0x0b, r1	; 11
            }
        }

        if (AnswerBitCount != ISO14443A_APP_NO_RESPONSE) {
    4e38:	20 97       	sbiw	r28, 0x00	; 0
    4e3a:	e1 f1       	breq	.+120    	; 0x4eb4 <ISO14443ACodecTask+0x100>
            LogEntry(LOG_INFO_CODEC_TX_DATA, CodecBuffer, (AnswerBitCount + 7) / 8);
    4e3c:	ae 01       	movw	r20, r28
    4e3e:	49 5f       	subi	r20, 0xF9	; 249
    4e40:	5f 4f       	sbci	r21, 0xFF	; 255
    4e42:	83 e0       	ldi	r24, 0x03	; 3
    4e44:	56 95       	lsr	r21
    4e46:	47 95       	ror	r20
    4e48:	8a 95       	dec	r24
    4e4a:	e1 f7       	brne	.-8      	; 0x4e44 <ISO14443ACodecTask+0x90>
    4e4c:	e0 91 6e 2f 	lds	r30, 0x2F6E
    4e50:	f0 91 6f 2f 	lds	r31, 0x2F6F
    4e54:	63 ed       	ldi	r22, 0xD3	; 211
    4e56:	71 e3       	ldi	r23, 0x31	; 49
    4e58:	81 e4       	ldi	r24, 0x41	; 65
    4e5a:	19 95       	eicall

INLINE void LEDHook(LEDHookEnum Func, LEDActionEnum Action) {
    extern LEDActionEnum LEDGreenAction;
    extern LEDActionEnum LEDRedAction;

    if (GlobalSettings.ActiveSettingPtr->LEDGreenFunction == Func) {
    4e5c:	e0 91 71 2f 	lds	r30, 0x2F71
    4e60:	f0 91 72 2f 	lds	r31, 0x2F72
    4e64:	87 81       	ldd	r24, Z+7	; 0x07
    4e66:	89 30       	cpi	r24, 0x09	; 9
    4e68:	19 f4       	brne	.+6      	; 0x4e70 <ISO14443ACodecTask+0xbc>
        LEDGreenAction = Action;
    4e6a:	83 e1       	ldi	r24, 0x13	; 19
    4e6c:	80 93 7d 2c 	sts	0x2C7D, r24
    }

    if (GlobalSettings.ActiveSettingPtr->LEDRedFunction == Func) {
    4e70:	86 81       	ldd	r24, Z+6	; 0x06
    4e72:	89 30       	cpi	r24, 0x09	; 9
    4e74:	19 f4       	brne	.+6      	; 0x4e7c <ISO14443ACodecTask+0xc8>
        LEDRedAction = Action;
    4e76:	83 e1       	ldi	r24, 0x13	; 19
    4e78:	80 93 7c 2c 	sts	0x2C7C, r24
            LEDHook(LED_CODEC_TX, LED_PULSE);

            BitCount = AnswerBitCount;
    4e7c:	c6 b9       	out	0x06, r28	; 6
    4e7e:	d7 b9       	out	0x07, r29	; 7
            CodecBufferPtr = CodecBuffer;
    4e80:	83 ed       	ldi	r24, 0xD3	; 211
    4e82:	91 e3       	ldi	r25, 0x31	; 49
    4e84:	88 b9       	out	0x08, r24	; 8
    4e86:	99 b9       	out	0x09, r25	; 9
    if (ModType == CODEC_SUBCARRIERMOD_OFF) {
        CODEC_SUBCARRIER_TIMER.CTRLA = TC_CLKSEL_OFF_gc;
        CODEC_SUBCARRIER_TIMER.CTRLB = 0;
    } else if (ModType == CODEC_SUBCARRIERMOD_OOK) {
        /* Configure subcarrier generation with 50% DC output using OOK */
        CODEC_SUBCARRIER_TIMER.CNT = 0;
    4e88:	10 92 60 08 	sts	0x0860, r1
    4e8c:	10 92 61 08 	sts	0x0861, r1
        CODEC_SUBCARRIER_TIMER.PER = Divider - 1;
    4e90:	8f e0       	ldi	r24, 0x0F	; 15
    4e92:	90 e0       	ldi	r25, 0x00	; 0
    4e94:	80 93 66 08 	sts	0x0866, r24
    4e98:	90 93 67 08 	sts	0x0867, r25
        CODEC_SUBCARRIER_TIMER.CODEC_SUBCARRIER_CC_OOK = Divider/2;
    4e9c:	88 e0       	ldi	r24, 0x08	; 8
    4e9e:	90 e0       	ldi	r25, 0x00	; 0
    4ea0:	80 93 6a 08 	sts	0x086A, r24
    4ea4:	90 93 6b 08 	sts	0x086B, r25
        CODEC_SUBCARRIER_TIMER.CTRLB = CODEC_SUBCARRIER_CCEN_OOK | TC_WGMODE_SINGLESLOPE_gc;
    4ea8:	83 e2       	ldi	r24, 0x23	; 35
    4eaa:	80 93 41 08 	sts	0x0841, r24
            CodecSetSubcarrier(CODEC_SUBCARRIERMOD_OOK, ISO14443A_SUBCARRIER_DIVIDER);

            StateRegister = LOADMOD_START;
    4eae:	83 e0       	ldi	r24, 0x03	; 3
    4eb0:	81 b9       	out	0x01, r24	; 1
    4eb2:	05 c0       	rjmp	.+10     	; 0x4ebe <ISO14443ACodecTask+0x10a>
        } else {
            /* No data to be processed. Disable loadmodding and start listening again */
            CODEC_TIMER_LOADMOD.CTRLA = TC_CLKSEL_OFF_gc;
    4eb4:	10 92 00 0a 	sts	0x0A00, r1
            CODEC_TIMER_LOADMOD.INTCTRLA = 0;
    4eb8:	10 92 06 0a 	sts	0x0A06, r1

            StartDemod();
    4ebc:	01 dd       	rcall	.-1534   	; 0x48c0 <StartDemod>
        }
    }

    if (Flags.LoadmodFinished) {
    4ebe:	80 91 a1 2c 	lds	r24, 0x2CA1
    4ec2:	88 23       	and	r24, r24
    4ec4:	29 f0       	breq	.+10     	; 0x4ed0 <ISO14443ACodecTask+0x11c>
        Flags.LoadmodFinished = 0;
    4ec6:	10 92 a1 2c 	sts	0x2CA1, r1
        /* Load modulation has been finished. Stop it and start to listen
         * for incoming data again. */
        StartDemod();
    }
}
    4eca:	df 91       	pop	r29
    4ecc:	cf 91       	pop	r28

    if (Flags.LoadmodFinished) {
        Flags.LoadmodFinished = 0;
        /* Load modulation has been finished. Stop it and start to listen
         * for incoming data again. */
        StartDemod();
    4ece:	f8 cc       	rjmp	.-1552   	; 0x48c0 <StartDemod>
    }
}
    4ed0:	df 91       	pop	r29
    4ed2:	cf 91       	pop	r28
    4ed4:	08 95       	ret

00004ed6 <isr_Reader14443_2A_TCD0_CCC_vect>:
}

// ISR (TCD0_CCC_vect)
void isr_Reader14443_2A_TCD0_CCC_vect(void)  
{
    CODEC_TIMER_SAMPLING.INTFLAGS = TC0_CCCIF_bm;
    4ed6:	e0 e0       	ldi	r30, 0x00	; 0
    4ed8:	f9 e0       	ldi	r31, 0x09	; 9
    4eda:	80 e4       	ldi	r24, 0x40	; 64
    4edc:	84 87       	std	Z+12, r24	; 0x0c
    CODEC_TIMER_SAMPLING.INTCTRLB = TC_CCCINTLVL_OFF_gc;
    4ede:	17 82       	std	Z+7, r1	; 0x07

    /* Enable the AC interrupt, which either finds the SOC and then starts the pause-finding timer,
     * or it is triggered before the SOC, which mostly isn't bad at all, since the first pause
     * needs to be found. */
    ACA.STATUS = AC_AC1IF_bm;
    4ee0:	e0 e8       	ldi	r30, 0x80	; 128
    4ee2:	f3 e0       	ldi	r31, 0x03	; 3
    4ee4:	82 e0       	ldi	r24, 0x02	; 2
    4ee6:	87 83       	std	Z+7, r24	; 0x07
    ACA.AC1CTRL = AC_HSMODE_bm | AC_HYSMODE_NO_gc | AC_INTMODE_FALLING_gc | AC_INTLVL_HI_gc | AC_ENABLE_bm;
    4ee8:	89 eb       	ldi	r24, 0xB9	; 185
    4eea:	81 83       	std	Z+1, r24	; 0x01

    CodecBufferPtr = CodecBuffer; // use GPIOR for faster access
    4eec:	83 ed       	ldi	r24, 0xD3	; 211
    4eee:	91 e3       	ldi	r25, 0x31	; 49
    4ef0:	8a b9       	out	0x0a, r24	; 10
    4ef2:	9b b9       	out	0x0b, r25	; 11
    BitCount = 1; // FALSCH todo the first modulation of the SOC is "found" implicitly
    4ef4:	81 e0       	ldi	r24, 0x01	; 1
    4ef6:	90 e0       	ldi	r25, 0x00	; 0
    4ef8:	84 b9       	out	0x04, r24	; 4
    4efa:	95 b9       	out	0x05, r25	; 5
    SampleRegister = 0x00;
    4efc:	16 b8       	out	0x06, r1	; 6
    4efe:	8e b1       	in	r24, 0x0e	; 14
    4f00:	9f b1       	in	r25, 0x0f	; 15
    4f02:	20 91 08 04 	lds	r18, 0x0408
    4f06:	30 91 09 04 	lds	r19, 0x0409
    4f0a:	82 2b       	or	r24, r18
    4f0c:	93 2b       	or	r25, r19

    RxPendingSince = SystemGetSysTick();
    4f0e:	80 93 a3 2c 	sts	0x2CA3, r24
    4f12:	90 93 a4 2c 	sts	0x2CA4, r25
    Flags.RxPending = true;
    4f16:	81 e0       	ldi	r24, 0x01	; 1
    4f18:	80 93 a7 2c 	sts	0x2CA7, r24

    // reset for future use
    CodecBufferIdx = 0;
    4f1c:	18 b8       	out	0x08, r1	; 8
    BitCountUp = 0;
    4f1e:	17 b8       	out	0x07, r1	; 7

    State = STATE_IDLE;
    4f20:	10 92 a2 2c 	sts	0x2CA2, r1
    PORTE.OUTTGL = PIN3_bm;
    4f24:	88 e0       	ldi	r24, 0x08	; 8
    4f26:	80 93 87 06 	sts	0x0687, r24
    4f2a:	08 95       	ret

00004f2c <Reader14443ACodecInit>:
#define CodecBufferIdx	GPIOR8
#define CodecBufferPtr	CodecPtrRegister2

#define UINT8DIFF(a,b) ((uint8_t) (a-b))

void Reader14443ACodecInit(void) {
    4f2c:	cf 93       	push	r28
    4f2e:	df 93       	push	r29
{
    /* Configure CARRIER input pin and route it to EVSYS.
     * Multiply by 2 again by using both edges when externally
     * dividing by 2 */
#if CODEC_CARRIER_IN_DIV == 2
    CODEC_CARRIER_IN_PORT.CODEC_CARRIER_IN_PINCTRL = PORT_ISC_BOTHEDGES_gc;
    4f30:	e0 e4       	ldi	r30, 0x40	; 64
    4f32:	f6 e0       	ldi	r31, 0x06	; 6
    4f34:	12 8a       	std	Z+18, r1	; 0x12
#else
#error Option not supported
#endif
    CODEC_CARRIER_IN_PORT.DIRCLR = CODEC_CARRIER_IN_MASK;
    4f36:	84 e0       	ldi	r24, 0x04	; 4
    4f38:	82 83       	std	Z+2, r24	; 0x02
    EVSYS.CH6MUX = CODEC_CARRIER_IN_EVMUX;
    4f3a:	c0 e8       	ldi	r28, 0x80	; 128
    4f3c:	d1 e0       	ldi	r29, 0x01	; 1
    4f3e:	82 e6       	ldi	r24, 0x62	; 98
    4f40:	8e 83       	std	Y+6, r24	; 0x06

    /* Configure two DEMOD pins for input.
     * Configure event channel 0 for rising edge (begin of modulation pause)
     * Configure event channel 1 for falling edge (end of modulation pause) */
    CODEC_DEMOD_POWER_PORT.OUTCLR = CODEC_DEMOD_POWER_MASK;
    4f42:	a0 e2       	ldi	r26, 0x20	; 32
    4f44:	b6 e0       	ldi	r27, 0x06	; 6
    4f46:	81 e0       	ldi	r24, 0x01	; 1
    4f48:	16 96       	adiw	r26, 0x06	; 6
    4f4a:	8c 93       	st	X, r24
    4f4c:	16 97       	sbiw	r26, 0x06	; 6
    CODEC_DEMOD_POWER_PORT.DIRSET = CODEC_DEMOD_POWER_MASK;
    4f4e:	11 96       	adiw	r26, 0x01	; 1
    4f50:	8c 93       	st	X, r24
    4f52:	11 97       	sbiw	r26, 0x01	; 1
    CODEC_DEMOD_IN_PORT.DIRCLR = CODEC_DEMOD_IN_MASK;
    4f54:	96 e0       	ldi	r25, 0x06	; 6
    4f56:	12 96       	adiw	r26, 0x02	; 2
    4f58:	9c 93       	st	X, r25
    4f5a:	12 97       	sbiw	r26, 0x02	; 2
    CODEC_DEMOD_IN_PORT.CODEC_DEMOD_IN_PINCTRL0 = PORT_ISC_RISING_gc;
    4f5c:	51 96       	adiw	r26, 0x11	; 17
    4f5e:	8c 93       	st	X, r24
    4f60:	51 97       	sbiw	r26, 0x11	; 17
    CODEC_DEMOD_IN_PORT.CODEC_DEMOD_IN_PINCTRL1 = PORT_ISC_FALLING_gc;
    4f62:	32 e0       	ldi	r19, 0x02	; 2
    4f64:	52 96       	adiw	r26, 0x12	; 18
    4f66:	3c 93       	st	X, r19
    4f68:	52 97       	sbiw	r26, 0x12	; 18
    CODEC_DEMOD_IN_PORT.INT0MASK = 0;
    4f6a:	1a 96       	adiw	r26, 0x0a	; 10
    4f6c:	1c 92       	st	X, r1
    4f6e:	1a 97       	sbiw	r26, 0x0a	; 10
    CODEC_DEMOD_IN_PORT.INT1MASK = 0;
    4f70:	1b 96       	adiw	r26, 0x0b	; 11
    4f72:	1c 92       	st	X, r1
    4f74:	1b 97       	sbiw	r26, 0x0b	; 11
    CODEC_DEMOD_IN_PORT.INTCTRL = PORT_INT0LVL_HI_gc | PORT_INT1LVL_HI_gc;
    4f76:	9f e0       	ldi	r25, 0x0F	; 15
    4f78:	19 96       	adiw	r26, 0x09	; 9
    4f7a:	9c 93       	st	X, r25
    4f7c:	19 97       	sbiw	r26, 0x09	; 9
    EVSYS.CH0MUX = CODEC_DEMOD_IN_EVMUX0;
    4f7e:	99 e5       	ldi	r25, 0x59	; 89
    4f80:	98 83       	st	Y, r25
    EVSYS.CH1MUX = CODEC_DEMOD_IN_EVMUX1;
    4f82:	2a e5       	ldi	r18, 0x5A	; 90
    4f84:	29 83       	std	Y+1, r18	; 0x01

    EVSYS.CH2MUX = CODEC_DEMOD_IN_EVMUX0;
    4f86:	9a 83       	std	Y+2, r25	; 0x02


    /* Configure loadmod pin configuration and use a virtual port configuration
     * for single instruction cycle access */
    CODEC_LOADMOD_PORT.DIRSET = CODEC_LOADMOD_MASK;
    4f88:	90 e4       	ldi	r25, 0x40	; 64
    4f8a:	91 83       	std	Z+1, r25	; 0x01
    CODEC_LOADMOD_PORT.OUTCLR = CODEC_LOADMOD_MASK;
    4f8c:	96 83       	std	Z+6, r25	; 0x06
    PORTCFG.VPCTRLA &= ~PORTCFG_VP0MAP_gm;
    4f8e:	c0 eb       	ldi	r28, 0xB0	; 176
    4f90:	d0 e0       	ldi	r29, 0x00	; 0
    4f92:	2a 81       	ldd	r18, Y+2	; 0x02
    4f94:	20 7f       	andi	r18, 0xF0	; 240
    4f96:	2a 83       	std	Y+2, r18	; 0x02
    PORTCFG.VPCTRLA |= PORTCFG_VP02MAP_PORTC_gc;
    4f98:	2a 81       	ldd	r18, Y+2	; 0x02
    4f9a:	22 60       	ori	r18, 0x02	; 2
    4f9c:	2a 83       	std	Y+2, r18	; 0x02

    /* Configure subcarrier pins for output */
    CODEC_SUBCARRIER_PORT.DIRSET = CODEC_SUBCARRIER_MASK;
    4f9e:	20 e3       	ldi	r18, 0x30	; 48
    4fa0:	21 83       	std	Z+1, r18	; 0x01
    CODEC_SUBCARRIER_PORT.OUTCLR = CODEC_SUBCARRIER_MASK;
    4fa2:	26 83       	std	Z+6, r18	; 0x06

    /* Configure pins for reader field with the LEFT output being inverted
     * and all bridge outputs static high */
    CODEC_READER_PORT.CODEC_READER_PINCTRL_LEFT = PORT_INVEN_bm;
    4fa4:	90 8b       	std	Z+16, r25	; 0x10
    CODEC_READER_PORT.OUTCLR = CODEC_READER_MASK_LEFT;
    4fa6:	86 83       	std	Z+6, r24	; 0x06
    CODEC_READER_PORT.OUTSET = CODEC_READER_MASK_RIGHT;
    4fa8:	35 83       	std	Z+5, r19	; 0x05
    CODEC_READER_PORT.DIRSET = CODEC_READER_MASK;
    4faa:	93 e0       	ldi	r25, 0x03	; 3
    4fac:	91 83       	std	Z+1, r25	; 0x01

    /* Configure timer for generating reader field and configure AWEX for outputting pattern
     * with disabled outputs. */
    CODEC_READER_TIMER.CTRLB = TC0_CCAEN_bm | TC_WGMODE_SINGLESLOPE_gc;
    4fae:	e0 e0       	ldi	r30, 0x00	; 0
    4fb0:	f8 e0       	ldi	r31, 0x08	; 8
    4fb2:	93 e1       	ldi	r25, 0x13	; 19
    4fb4:	91 83       	std	Z+1, r25	; 0x01
    CODEC_READER_TIMER.PER = F_CPU / CODEC_CARRIER_FREQ - 1;
    4fb6:	21 e0       	ldi	r18, 0x01	; 1
    4fb8:	30 e0       	ldi	r19, 0x00	; 0
    4fba:	26 a3       	std	Z+38, r18	; 0x26
    4fbc:	37 a3       	std	Z+39, r19	; 0x27
    CODEC_READER_TIMER.CCA = F_CPU / CODEC_CARRIER_FREQ / 2 ;
    4fbe:	20 a7       	std	Z+40, r18	; 0x28
    4fc0:	31 a7       	std	Z+41, r19	; 0x29

    AWEXC.OUTOVEN = 0x00;
    4fc2:	e0 e8       	ldi	r30, 0x80	; 128
    4fc4:	f8 e0       	ldi	r31, 0x08	; 8
    4fc6:	14 86       	std	Z+12, r1	; 0x0c
    AWEXC.CTRL = AWEX_CWCM_bm | AWEX_DTICCAEN_bm | AWEX_DTICCBEN_bm;
    4fc8:	90 83       	st	Z, r25

    /* Configure DAC for the reference voltage */
    DACB.EVCTRL = 0;
    4fca:	e0 e2       	ldi	r30, 0x20	; 32
    4fcc:	f3 e0       	ldi	r31, 0x03	; 3
    4fce:	13 82       	std	Z+3, r1	; 0x03
    DACB.CTRLB = DAC_CHSEL_SINGLE_gc;
    4fd0:	11 82       	std	Z+1, r1	; 0x01
    DACB.CTRLC = DAC_REFSEL_AVCC_gc;
    4fd2:	98 e0       	ldi	r25, 0x08	; 8
    4fd4:	92 83       	std	Z+2, r25	; 0x02
    DACB.CTRLA = DAC_IDOEN_bm | DAC_ENABLE_bm;
    4fd6:	21 e1       	ldi	r18, 0x11	; 17
    4fd8:	20 83       	st	Z, r18
    DACB.CH0DATA = GlobalSettings.ActiveSettingPtr->ReaderThreshold; // real threshold voltage can be calculated with ch0data * Vref / 0xFFF
    4fda:	c0 91 71 2f 	lds	r28, 0x2F71
    4fde:	d0 91 72 2f 	lds	r29, 0x2F72
    4fe2:	2a 85       	ldd	r18, Y+10	; 0x0a
    4fe4:	3b 85       	ldd	r19, Y+11	; 0x0b
    4fe6:	20 8f       	std	Z+24, r18	; 0x18
    4fe8:	31 8f       	std	Z+25, r19	; 0x19

    /* Configure Analog Comparator 0 to detect changes in demodulated reader field */
    ACA.AC0MUXCTRL = AC_MUXPOS_DAC_gc | AC_MUXNEG_PIN7_gc;
    4fea:	e0 e8       	ldi	r30, 0x80	; 128
    4fec:	f3 e0       	ldi	r31, 0x03	; 3
    4fee:	2c e3       	ldi	r18, 0x3C	; 60
    4ff0:	22 83       	std	Z+2, r18	; 0x02
    ACA.AC0CTRL = CODEC_AC_DEMOD_SETTINGS;
    4ff2:	90 83       	st	Z, r25

    /* Configure Analog Comparator 1 to detect SOC */
    ACA.AC1MUXCTRL = AC_MUXPOS_DAC_gc | AC_MUXNEG_PIN7_gc;
    4ff4:	23 83       	std	Z+3, r18	; 0x03
    ACA.AC1CTRL = CODEC_AC_DEMOD_SETTINGS;
    4ff6:	91 83       	std	Z+1, r25	; 0x01
    /* Initialize common peripherals and start listening
     * for incoming data. */
    CodecInitCommon();
    isr_func_TCD0_CCC_vect = &isr_Reader14443_2A_TCD0_CCC_vect;
    4ff8:	2b e6       	ldi	r18, 0x6B	; 107
    4ffa:	37 e2       	ldi	r19, 0x27	; 39
    4ffc:	20 93 50 2e 	sts	0x2E50, r18
    5000:	30 93 51 2e 	sts	0x2E51, r19
}

INLINE void CodecSetDemodPower(bool bOnOff)
{
    if (bOnOff) {
        CODEC_DEMOD_POWER_PORT.OUTSET = CODEC_DEMOD_POWER_MASK;
    5004:	15 96       	adiw	r26, 0x05	; 5
    5006:	8c 93       	st	X, r24
    CodecSetDemodPower(true);

    CODEC_TIMER_SAMPLING.PER = SAMPLE_RATE_SYSTEM_CYCLES - 1;
    5008:	e0 e0       	ldi	r30, 0x00	; 0
    500a:	f9 e0       	ldi	r31, 0x09	; 9
    500c:	2f ef       	ldi	r18, 0xFF	; 255
    500e:	30 e0       	ldi	r19, 0x00	; 0
    5010:	26 a3       	std	Z+38, r18	; 0x26
    5012:	37 a3       	std	Z+39, r19	; 0x27
    CODEC_TIMER_SAMPLING.CCB = 0;
    5014:	12 a6       	std	Z+42, r1	; 0x2a
    5016:	13 a6       	std	Z+43, r1	; 0x2b
    CODEC_TIMER_SAMPLING.CCC = 0;
    5018:	14 a6       	std	Z+44, r1	; 0x2c
    501a:	15 a6       	std	Z+45, r1	; 0x2d
    CODEC_TIMER_SAMPLING.CTRLA = TC_CLKSEL_OFF_gc;
    501c:	10 82       	st	Z, r1
    CODEC_TIMER_SAMPLING.INTCTRLA = 0;
    501e:	16 82       	std	Z+6, r1	; 0x06
    CODEC_TIMER_SAMPLING.INTCTRLB = TC_CCBINTLVL_OFF_gc;
    5020:	17 82       	std	Z+7, r1	; 0x07
    CODEC_TIMER_SAMPLING.CTRLA = TC_CLKSEL_DIV1_gc;
    5022:	80 83       	st	Z, r24

    CODEC_TIMER_LOADMOD.CTRLA = 0;
    5024:	10 92 00 0a 	sts	0x0A00, r1
    State = STATE_IDLE;
    5028:	10 92 a2 2c 	sts	0x2CA2, r1

    Flags.Start = false;
    502c:	e5 ea       	ldi	r30, 0xA5	; 165
    502e:	fc e2       	ldi	r31, 0x2C	; 44
    5030:	10 82       	st	Z, r1
    Flags.RxPending = false;
    5032:	12 82       	std	Z+2, r1	; 0x02
    Flags.RxDone = false;
    5034:	11 82       	std	Z+1, r1	; 0x01
}
    5036:	df 91       	pop	r29
    5038:	cf 91       	pop	r28
    503a:	08 95       	ret

0000503c <Reader14443ACodecDeInit>:
    } else {
        CODEC_DEMOD_POWER_PORT.OUTCLR = CODEC_DEMOD_POWER_MASK;
    503c:	81 e0       	ldi	r24, 0x01	; 1
    503e:	80 93 26 06 	sts	0x0626, r24

void Reader14443ACodecDeInit(void) {
    CodecSetDemodPower(false);
    CodecReaderFieldStop();
    5042:	c2 db       	rcall	.-2172   	; 0x47c8 <CodecReaderFieldStop>
    CODEC_TIMER_SAMPLING.CTRLA = 0;
    5044:	e0 e0       	ldi	r30, 0x00	; 0
    5046:	f9 e0       	ldi	r31, 0x09	; 9
    5048:	10 82       	st	Z, r1
    CODEC_TIMER_SAMPLING.INTCTRLB = 0;
    504a:	17 82       	std	Z+7, r1	; 0x07
    CODEC_TIMER_LOADMOD.CTRLA = 0;
    504c:	e0 e0       	ldi	r30, 0x00	; 0
    504e:	fa e0       	ldi	r31, 0x0A	; 10
    5050:	10 82       	st	Z, r1
    CODEC_TIMER_LOADMOD.INTCTRLB = 0;
    5052:	17 82       	std	Z+7, r1	; 0x07
    Flags.RxDone = false;
    5054:	e5 ea       	ldi	r30, 0xA5	; 165
    5056:	fc e2       	ldi	r31, 0x2C	; 44
    5058:	11 82       	std	Z+1, r1	; 0x01
    Flags.RxPending = false;
    505a:	12 82       	std	Z+2, r1	; 0x02
    Flags.Start = false;
    505c:	10 82       	st	Z, r1
    505e:	08 95       	ret

00005060 <__vector_81>:
    if (BitCount % 8)
        CodecBuffer[BitCount / 8] = SampleRegister >> (8 - (BitCount % 8));
}
// Frame Delay Time PCD to PICC ends
ISR (CODEC_TIMER_SAMPLING_CCC_VECT)
{
    5060:	1f 92       	push	r1
    5062:	0f 92       	push	r0
    5064:	0f b6       	in	r0, 0x3f	; 63
    5066:	0f 92       	push	r0
    5068:	11 24       	eor	r1, r1
    506a:	08 b6       	in	r0, 0x38	; 56
    506c:	0f 92       	push	r0
    506e:	18 be       	out	0x38, r1	; 56
    5070:	09 b6       	in	r0, 0x39	; 57
    5072:	0f 92       	push	r0
    5074:	19 be       	out	0x39, r1	; 57
    5076:	0b b6       	in	r0, 0x3b	; 59
    5078:	0f 92       	push	r0
    507a:	1b be       	out	0x3b, r1	; 59
    507c:	2f 93       	push	r18
    507e:	3f 93       	push	r19
    5080:	4f 93       	push	r20
    5082:	5f 93       	push	r21
    5084:	6f 93       	push	r22
    5086:	7f 93       	push	r23
    5088:	8f 93       	push	r24
    508a:	9f 93       	push	r25
    508c:	af 93       	push	r26
    508e:	bf 93       	push	r27
    5090:	ef 93       	push	r30
    5092:	ff 93       	push	r31
  isr_func_TCD0_CCC_vect();
    5094:	e0 91 50 2e 	lds	r30, 0x2E50
    5098:	f0 91 51 2e 	lds	r31, 0x2E51
    509c:	19 95       	eicall
}
    509e:	ff 91       	pop	r31
    50a0:	ef 91       	pop	r30
    50a2:	bf 91       	pop	r27
    50a4:	af 91       	pop	r26
    50a6:	9f 91       	pop	r25
    50a8:	8f 91       	pop	r24
    50aa:	7f 91       	pop	r23
    50ac:	6f 91       	pop	r22
    50ae:	5f 91       	pop	r21
    50b0:	4f 91       	pop	r20
    50b2:	3f 91       	pop	r19
    50b4:	2f 91       	pop	r18
    50b6:	0f 90       	pop	r0
    50b8:	0b be       	out	0x3b, r0	; 59
    50ba:	0f 90       	pop	r0
    50bc:	09 be       	out	0x39, r0	; 57
    50be:	0f 90       	pop	r0
    50c0:	08 be       	out	0x38, r0	; 56
    50c2:	0f 90       	pop	r0
    50c4:	0f be       	out	0x3f, r0	; 63
    50c6:	0f 90       	pop	r0
    50c8:	1f 90       	pop	r1
    50ca:	18 95       	reti

000050cc <Reader14443AMillerEOC>:

// Reader -> card send bits finished
// Start Frame delay time PCD to PICC
void Reader14443AMillerEOC(void)
{
    CODEC_TIMER_SAMPLING.PER = 5*SAMPLE_RATE_SYSTEM_CYCLES - 1;
    50cc:	e0 e0       	ldi	r30, 0x00	; 0
    50ce:	f9 e0       	ldi	r31, 0x09	; 9
    50d0:	8f ef       	ldi	r24, 0xFF	; 255
    50d2:	94 e0       	ldi	r25, 0x04	; 4
    50d4:	86 a3       	std	Z+38, r24	; 0x26
    50d6:	97 a3       	std	Z+39, r25	; 0x27
    CODEC_TIMER_SAMPLING.INTFLAGS = TC0_CCBIF_bm | TC0_CCCIF_bm;
    50d8:	80 e6       	ldi	r24, 0x60	; 96
    50da:	84 87       	std	Z+12, r24	; 0x0c
    CODEC_TIMER_SAMPLING.INTCTRLB = TC_CCBINTLVL_OFF_gc | TC_CCCINTLVL_HI_gc;
    50dc:	80 e3       	ldi	r24, 0x30	; 48
    50de:	87 83       	std	Z+7, r24	; 0x07
    CODEC_TIMER_SAMPLING.PERBUF = SAMPLE_RATE_SYSTEM_CYCLES - 1;
    50e0:	8f ef       	ldi	r24, 0xFF	; 255
    50e2:	90 e0       	ldi	r25, 0x00	; 0
    50e4:	86 ab       	std	Z+54, r24	; 0x36
    50e6:	97 ab       	std	Z+55, r25	; 0x37
    PORTE.OUTTGL = PIN3_bm;
    50e8:	88 e0       	ldi	r24, 0x08	; 8
    50ea:	80 93 87 06 	sts	0x0687, r24
    50ee:	08 95       	ret

000050f0 <__vector_85>:
}

// EOC of Card->Reader found
ISR(CODEC_TIMER_TIMESTAMPS_CCA_VECT) // EOC found
{
    50f0:	1f 92       	push	r1
    50f2:	0f 92       	push	r0
    50f4:	0f b6       	in	r0, 0x3f	; 63
    50f6:	0f 92       	push	r0
    50f8:	11 24       	eor	r1, r1
    50fa:	08 b6       	in	r0, 0x38	; 56
    50fc:	0f 92       	push	r0
    50fe:	18 be       	out	0x38, r1	; 56
    5100:	0b b6       	in	r0, 0x3b	; 59
    5102:	0f 92       	push	r0
    5104:	1b be       	out	0x3b, r1	; 59
    5106:	2f 93       	push	r18
    5108:	3f 93       	push	r19
    510a:	4f 93       	push	r20
    510c:	5f 93       	push	r21
    510e:	8f 93       	push	r24
    5110:	9f 93       	push	r25
    5112:	ef 93       	push	r30
    5114:	ff 93       	push	r31


// End of Card-> reader communication and enter frame delay time
INLINE void Reader14443A_EOC(void)
{
    CODEC_TIMER_LOADMOD.INTCTRLB = 0;
    5116:	10 92 07 0a 	sts	0x0A07, r1
    CODEC_TIMER_LOADMOD.CTRLA = TC_CLKSEL_OFF_gc;
    511a:	10 92 00 0a 	sts	0x0A00, r1
    CODEC_TIMER_TIMESTAMPS.INTCTRLB = 0;
    511e:	10 92 47 09 	sts	0x0947, r1
    CODEC_TIMER_TIMESTAMPS.CTRLA = TC_CLKSEL_OFF_gc;
    5122:	10 92 40 09 	sts	0x0940, r1
    ACA.AC1CTRL &= ~AC_ENABLE_bm;
    5126:	80 91 81 03 	lds	r24, 0x0381
    512a:	8e 7f       	andi	r24, 0xFE	; 254
    512c:	80 93 81 03 	sts	0x0381, r24

    if (BitCount & 1)
    5130:	84 b1       	in	r24, 0x04	; 4
    5132:	95 b1       	in	r25, 0x05	; 5
    5134:	80 ff       	sbrs	r24, 0
    5136:	1a c0       	rjmp	.+52     	; 0x516c <__vector_85+0x7c>
    {
        if (SampleRegister & 0x80)
    5138:	37 9b       	sbis	0x06, 7	; 6
    513a:	03 c0       	rjmp	.+6      	; 0x5142 <__vector_85+0x52>
    Flags.Start = false;
}

INLINE void Insert0(void)
{
    SampleRegister >>= 1;
    513c:	86 b1       	in	r24, 0x06	; 6
    513e:	86 95       	lsr	r24
    5140:	03 c0       	rjmp	.+6      	; 0x5148 <__vector_85+0x58>
    *CodecBufferPtr++ = SampleRegister;
}

INLINE void Insert1(void)
{
    SampleRegister = (SampleRegister >> 1) | 0x80;
    5142:	86 b1       	in	r24, 0x06	; 6
    5144:	86 95       	lsr	r24
    5146:	80 68       	ori	r24, 0x80	; 128
    5148:	86 b9       	out	0x06, r24	; 6
    if (++BitCount % 8)
    514a:	84 b1       	in	r24, 0x04	; 4
    514c:	95 b1       	in	r25, 0x05	; 5
    514e:	01 96       	adiw	r24, 0x01	; 1
    5150:	84 b9       	out	0x04, r24	; 4
    5152:	95 b9       	out	0x05, r25	; 5
    5154:	87 70       	andi	r24, 0x07	; 7
    5156:	99 27       	eor	r25, r25
    5158:	89 2b       	or	r24, r25
    515a:	41 f4       	brne	.+16     	; 0x516c <__vector_85+0x7c>
        return;
    *CodecBufferPtr++ = SampleRegister;
    515c:	ea b1       	in	r30, 0x0a	; 10
    515e:	fb b1       	in	r31, 0x0b	; 11
    5160:	cf 01       	movw	r24, r30
    5162:	01 96       	adiw	r24, 0x01	; 1
    5164:	8a b9       	out	0x0a, r24	; 10
    5166:	9b b9       	out	0x0b, r25	; 11
    5168:	86 b1       	in	r24, 0x06	; 6
    516a:	80 83       	st	Z, r24
            Insert0();
        else
            Insert1();
    }

    if (BitCount % 8) // copy the last byte, if there is an incomplete byte
    516c:	84 b1       	in	r24, 0x04	; 4
    516e:	95 b1       	in	r25, 0x05	; 5
    5170:	87 70       	andi	r24, 0x07	; 7
    5172:	99 27       	eor	r25, r25
    5174:	89 2b       	or	r24, r25
    5176:	c9 f0       	breq	.+50     	; 0x51aa <__vector_85+0xba>
        CodecBuffer[BitCount / 8] = SampleRegister >> (8 - (BitCount % 8));
    5178:	e4 b1       	in	r30, 0x04	; 4
    517a:	f5 b1       	in	r31, 0x05	; 5
    517c:	86 b1       	in	r24, 0x06	; 6
    517e:	44 b1       	in	r20, 0x04	; 4
    5180:	55 b1       	in	r21, 0x05	; 5
    5182:	93 e0       	ldi	r25, 0x03	; 3
    5184:	f6 95       	lsr	r31
    5186:	e7 95       	ror	r30
    5188:	9a 95       	dec	r25
    518a:	e1 f7       	brne	.-8      	; 0x5184 <__vector_85+0x94>
    518c:	ed 52       	subi	r30, 0x2D	; 45
    518e:	fe 4c       	sbci	r31, 0xCE	; 206
    5190:	90 e0       	ldi	r25, 0x00	; 0
    5192:	47 70       	andi	r20, 0x07	; 7
    5194:	55 27       	eor	r21, r21
    5196:	28 e0       	ldi	r18, 0x08	; 8
    5198:	30 e0       	ldi	r19, 0x00	; 0
    519a:	24 1b       	sub	r18, r20
    519c:	35 0b       	sbc	r19, r21
    519e:	02 c0       	rjmp	.+4      	; 0x51a4 <__vector_85+0xb4>
    51a0:	95 95       	asr	r25
    51a2:	87 95       	ror	r24
    51a4:	2a 95       	dec	r18
    51a6:	e2 f7       	brpl	.-8      	; 0x51a0 <__vector_85+0xb0>
    51a8:	80 83       	st	Z, r24
    Flags.RxDone = true;
    51aa:	81 e0       	ldi	r24, 0x01	; 1
    51ac:	80 93 a6 2c 	sts	0x2CA6, r24
    Flags.RxPending = false;
    51b0:	10 92 a7 2c 	sts	0x2CA7, r1

    // set up timer that forces the minimum frame delay time from PICC to PCD
    CODEC_TIMER_LOADMOD.PER = 0xFFFF;
    51b4:	8f ef       	ldi	r24, 0xFF	; 255
    51b6:	9f ef       	ldi	r25, 0xFF	; 255
    51b8:	80 93 26 0a 	sts	0x0A26, r24
    51bc:	90 93 27 0a 	sts	0x0A27, r25
    CODEC_TIMER_LOADMOD.CNT = 0;
    51c0:	10 92 20 0a 	sts	0x0A20, r1
    51c4:	10 92 21 0a 	sts	0x0A21, r1
    CODEC_TIMER_LOADMOD.INTCTRLA = 0;
    51c8:	10 92 06 0a 	sts	0x0A06, r1
    CODEC_TIMER_LOADMOD.INTCTRLB = 0;
    51cc:	10 92 07 0a 	sts	0x0A07, r1
    CODEC_TIMER_LOADMOD.CTRLD = 0;
    51d0:	10 92 03 0a 	sts	0x0A03, r1
    CODEC_TIMER_LOADMOD.CTRLA = ISO14443A_PICC_TO_PCD_FDT_PRESCALER;
    51d4:	84 e0       	ldi	r24, 0x04	; 4
    51d6:	80 93 00 0a 	sts	0x0A00, r24

    State = STATE_FDT;
    51da:	83 e0       	ldi	r24, 0x03	; 3
    51dc:	80 93 a2 2c 	sts	0x2CA2, r24

// EOC of Card->Reader found
ISR(CODEC_TIMER_TIMESTAMPS_CCA_VECT) // EOC found
{
    Reader14443A_EOC();
}
    51e0:	ff 91       	pop	r31
    51e2:	ef 91       	pop	r30
    51e4:	9f 91       	pop	r25
    51e6:	8f 91       	pop	r24
    51e8:	5f 91       	pop	r21
    51ea:	4f 91       	pop	r20
    51ec:	3f 91       	pop	r19
    51ee:	2f 91       	pop	r18
    51f0:	0f 90       	pop	r0
    51f2:	0b be       	out	0x3b, r0	; 59
    51f4:	0f 90       	pop	r0
    51f6:	08 be       	out	0x38, r0	; 56
    51f8:	0f 90       	pop	r0
    51fa:	0f be       	out	0x3f, r0	; 63
    51fc:	0f 90       	pop	r0
    51fe:	1f 90       	pop	r1
    5200:	18 95       	reti

00005202 <__vector_69>:

// This interrupt find Card -> Reader SOC
ISR(ACA_AC1_vect) // this interrupt either finds the SOC or gets triggered before
{
    5202:	1f 92       	push	r1
    5204:	0f 92       	push	r0
    5206:	0f b6       	in	r0, 0x3f	; 63
    5208:	0f 92       	push	r0
    520a:	11 24       	eor	r1, r1
    520c:	08 b6       	in	r0, 0x38	; 56
    520e:	0f 92       	push	r0
    5210:	18 be       	out	0x38, r1	; 56
    5212:	0b b6       	in	r0, 0x3b	; 59
    5214:	0f 92       	push	r0
    5216:	1b be       	out	0x3b, r1	; 59
    5218:	8f 93       	push	r24
    521a:	ef 93       	push	r30
    521c:	ff 93       	push	r31
    ACA.AC1CTRL &= ~AC_INTLVL_HI_gc; // disable this interrupt
    521e:	e0 e8       	ldi	r30, 0x80	; 128
    5220:	f3 e0       	ldi	r31, 0x03	; 3
    5222:	81 81       	ldd	r24, Z+1	; 0x01
    5224:	8f 7c       	andi	r24, 0xCF	; 207
    5226:	81 83       	std	Z+1, r24	; 0x01
    // enable the pause-finding timer
    CODEC_TIMER_LOADMOD.CTRLD = TC_EVACT_RESTART_gc | TC_EVSEL_CH0_gc;
    5228:	e0 e0       	ldi	r30, 0x00	; 0
    522a:	fa e0       	ldi	r31, 0x0A	; 10
    522c:	88 e8       	ldi	r24, 0x88	; 136
    522e:	83 83       	std	Z+3, r24	; 0x03
    CODEC_TIMER_LOADMOD.CTRLA = TC_CLKSEL_DIV1_gc;
    5230:	81 e0       	ldi	r24, 0x01	; 1
    5232:	80 83       	st	Z, r24
}
    5234:	ff 91       	pop	r31
    5236:	ef 91       	pop	r30
    5238:	8f 91       	pop	r24
    523a:	0f 90       	pop	r0
    523c:	0b be       	out	0x3b, r0	; 59
    523e:	0f 90       	pop	r0
    5240:	08 be       	out	0x38, r0	; 56
    5242:	0f 90       	pop	r0
    5244:	0f be       	out	0x3f, r0	; 63
    5246:	0f 90       	pop	r0
    5248:	1f 90       	pop	r1
    524a:	18 95       	reti

0000524c <__vector_49>:
// Decode the Card -> Reader signal
// according to the pause and modulated period
// if the half bit duration is modulated, then add 1 to buffer
// if the half bit duration is not modulated, then add 0 to buffer
ISR(CODEC_TIMER_LOADMOD_CCA_VECT) // pause found
{
    524c:	1f 92       	push	r1
    524e:	0f 92       	push	r0
    5250:	0f b6       	in	r0, 0x3f	; 63
    5252:	0f 92       	push	r0
    5254:	11 24       	eor	r1, r1
    5256:	08 b6       	in	r0, 0x38	; 56
    5258:	0f 92       	push	r0
    525a:	18 be       	out	0x38, r1	; 56
    525c:	0b b6       	in	r0, 0x3b	; 59
    525e:	0f 92       	push	r0
    5260:	1b be       	out	0x3b, r1	; 59
    5262:	8f 93       	push	r24
    5264:	9f 93       	push	r25
    5266:	ef 93       	push	r30
    5268:	ff 93       	push	r31
    uint8_t tmp = CODEC_TIMER_TIMESTAMPS.CNTL;
    526a:	80 91 60 09 	lds	r24, 0x0960
    CODEC_TIMER_TIMESTAMPS.CNT = 0;
    526e:	10 92 60 09 	sts	0x0960, r1
    5272:	10 92 61 09 	sts	0x0961, r1

    /* This needs to be done only on the first call,
     * but doing this only on a condition means wasting time, so we do it every time. */
    CODEC_TIMER_TIMESTAMPS.CTRLA = TC_CLKSEL_DIV4_gc;
    5276:	93 e0       	ldi	r25, 0x03	; 3
    5278:	90 93 40 09 	sts	0x0940, r25

    switch (tmp) // decide how many half bit periods have been modulations
    527c:	81 35       	cpi	r24, 0x51	; 81
    527e:	20 f4       	brcc	.+8      	; 0x5288 <__vector_49+0x3c>
    5280:	81 33       	cpi	r24, 0x31	; 49
    5282:	08 f4       	brcc	.+2      	; 0x5286 <__vector_49+0x3a>
    5284:	72 c0       	rjmp	.+228    	; 0x536a <__vector_49+0x11e>
    5286:	1b c0       	rjmp	.+54     	; 0x52be <__vector_49+0x72>
    5288:	81 37       	cpi	r24, 0x71	; 113
    528a:	e8 f4       	brcc	.+58     	; 0x52c6 <__vector_49+0x7a>
        Insert1();
        Insert0();
        return;

    case 81 ... 112: // 96 ticks are 3 half bit periods
        if (BitCount & 1)
    528c:	84 b1       	in	r24, 0x04	; 4
    528e:	95 b1       	in	r25, 0x05	; 5
    5290:	80 ff       	sbrs	r24, 0
    5292:	2e c0       	rjmp	.+92     	; 0x52f0 <__vector_49+0xa4>
    *CodecBufferPtr++ = SampleRegister;
}

INLINE void Insert1(void)
{
    SampleRegister = (SampleRegister >> 1) | 0x80;
    5294:	86 b1       	in	r24, 0x06	; 6
    5296:	86 95       	lsr	r24
    5298:	80 68       	ori	r24, 0x80	; 128
    529a:	86 b9       	out	0x06, r24	; 6
    if (++BitCount % 8)
    529c:	84 b1       	in	r24, 0x04	; 4
    529e:	95 b1       	in	r25, 0x05	; 5
    52a0:	01 96       	adiw	r24, 0x01	; 1
    52a2:	84 b9       	out	0x04, r24	; 4
    52a4:	95 b9       	out	0x05, r25	; 5
    52a6:	87 70       	andi	r24, 0x07	; 7
    52a8:	99 27       	eor	r25, r25
    52aa:	89 2b       	or	r24, r25
    52ac:	41 f4       	brne	.+16     	; 0x52be <__vector_49+0x72>
        return;
    *CodecBufferPtr++ = SampleRegister;
    52ae:	ea b1       	in	r30, 0x0a	; 10
    52b0:	fb b1       	in	r31, 0x0b	; 11
    52b2:	cf 01       	movw	r24, r30
    52b4:	01 96       	adiw	r24, 0x01	; 1
    52b6:	8a b9       	out	0x0a, r24	; 10
    52b8:	9b b9       	out	0x0b, r25	; 11
    52ba:	86 b1       	in	r24, 0x06	; 6
    52bc:	80 83       	st	Z, r24
    *CodecBufferPtr++ = SampleRegister;
}

INLINE void Insert1(void)
{
    SampleRegister = (SampleRegister >> 1) | 0x80;
    52be:	86 b1       	in	r24, 0x06	; 6
    52c0:	86 95       	lsr	r24
    52c2:	80 68       	ori	r24, 0x80	; 128
    52c4:	2c c0       	rjmp	.+88     	; 0x531e <__vector_49+0xd2>
    52c6:	86 b1       	in	r24, 0x06	; 6
    52c8:	86 95       	lsr	r24
    52ca:	80 68       	ori	r24, 0x80	; 128
    52cc:	86 b9       	out	0x06, r24	; 6
    if (++BitCount % 8)
    52ce:	84 b1       	in	r24, 0x04	; 4
    52d0:	95 b1       	in	r25, 0x05	; 5
    52d2:	01 96       	adiw	r24, 0x01	; 1
    52d4:	84 b9       	out	0x04, r24	; 4
    52d6:	95 b9       	out	0x05, r25	; 5
    52d8:	87 70       	andi	r24, 0x07	; 7
    52da:	99 27       	eor	r25, r25
    52dc:	89 2b       	or	r24, r25
    52de:	41 f4       	brne	.+16     	; 0x52f0 <__vector_49+0xa4>
        return;
    *CodecBufferPtr++ = SampleRegister;
    52e0:	ea b1       	in	r30, 0x0a	; 10
    52e2:	fb b1       	in	r31, 0x0b	; 11
    52e4:	cf 01       	movw	r24, r30
    52e6:	01 96       	adiw	r24, 0x01	; 1
    52e8:	8a b9       	out	0x0a, r24	; 10
    52ea:	9b b9       	out	0x0b, r25	; 11
    52ec:	86 b1       	in	r24, 0x06	; 6
    52ee:	80 83       	st	Z, r24
    *CodecBufferPtr++ = SampleRegister;
}

INLINE void Insert1(void)
{
    SampleRegister = (SampleRegister >> 1) | 0x80;
    52f0:	86 b1       	in	r24, 0x06	; 6
    52f2:	86 95       	lsr	r24
    52f4:	80 68       	ori	r24, 0x80	; 128
    52f6:	86 b9       	out	0x06, r24	; 6
    if (++BitCount % 8)
    52f8:	84 b1       	in	r24, 0x04	; 4
    52fa:	95 b1       	in	r25, 0x05	; 5
    52fc:	01 96       	adiw	r24, 0x01	; 1
    52fe:	84 b9       	out	0x04, r24	; 4
    5300:	95 b9       	out	0x05, r25	; 5
    5302:	87 70       	andi	r24, 0x07	; 7
    5304:	99 27       	eor	r25, r25
    5306:	89 2b       	or	r24, r25
    5308:	41 f4       	brne	.+16     	; 0x531a <__vector_49+0xce>
        return;
    *CodecBufferPtr++ = SampleRegister;
    530a:	ea b1       	in	r30, 0x0a	; 10
    530c:	fb b1       	in	r31, 0x0b	; 11
    530e:	cf 01       	movw	r24, r30
    5310:	01 96       	adiw	r24, 0x01	; 1
    5312:	8a b9       	out	0x0a, r24	; 10
    5314:	9b b9       	out	0x0b, r25	; 11
    5316:	86 b1       	in	r24, 0x06	; 6
    5318:	80 83       	st	Z, r24
    Flags.Start = false;
}

INLINE void Insert0(void)
{
    SampleRegister >>= 1;
    531a:	86 b1       	in	r24, 0x06	; 6
    531c:	86 95       	lsr	r24
    531e:	86 b9       	out	0x06, r24	; 6
    if (++BitCount % 8)
    5320:	84 b1       	in	r24, 0x04	; 4
    5322:	95 b1       	in	r25, 0x05	; 5
    5324:	01 96       	adiw	r24, 0x01	; 1
    5326:	84 b9       	out	0x04, r24	; 4
    5328:	95 b9       	out	0x05, r25	; 5
    532a:	87 70       	andi	r24, 0x07	; 7
    532c:	99 27       	eor	r25, r25
    532e:	89 2b       	or	r24, r25
    5330:	41 f4       	brne	.+16     	; 0x5342 <__vector_49+0xf6>
        return;
    *CodecBufferPtr++ = SampleRegister;
    5332:	ea b1       	in	r30, 0x0a	; 10
    5334:	fb b1       	in	r31, 0x0b	; 11
    5336:	cf 01       	movw	r24, r30
    5338:	01 96       	adiw	r24, 0x01	; 1
    533a:	8a b9       	out	0x0a, r24	; 10
    533c:	9b b9       	out	0x0b, r25	; 11
    533e:	86 b1       	in	r24, 0x06	; 6
    5340:	80 83       	st	Z, r24
    Flags.Start = false;
}

INLINE void Insert0(void)
{
    SampleRegister >>= 1;
    5342:	86 b1       	in	r24, 0x06	; 6
    5344:	86 95       	lsr	r24
    5346:	86 b9       	out	0x06, r24	; 6
    if (++BitCount % 8)
    5348:	84 b1       	in	r24, 0x04	; 4
    534a:	95 b1       	in	r25, 0x05	; 5
    534c:	01 96       	adiw	r24, 0x01	; 1
    534e:	84 b9       	out	0x04, r24	; 4
    5350:	95 b9       	out	0x05, r25	; 5
    5352:	87 70       	andi	r24, 0x07	; 7
    5354:	99 27       	eor	r25, r25
    5356:	89 2b       	or	r24, r25
    5358:	41 f4       	brne	.+16     	; 0x536a <__vector_49+0x11e>
        return;
    *CodecBufferPtr++ = SampleRegister;
    535a:	ea b1       	in	r30, 0x0a	; 10
    535c:	fb b1       	in	r31, 0x0b	; 11
    535e:	cf 01       	movw	r24, r30
    5360:	01 96       	adiw	r24, 0x01	; 1
    5362:	8a b9       	out	0x0a, r24	; 10
    5364:	9b b9       	out	0x0b, r25	; 11
    5366:	86 b1       	in	r24, 0x06	; 6
    5368:	80 83       	st	Z, r24
        Insert0();
        Insert0();
        return;
    }
    return;
}
    536a:	ff 91       	pop	r31
    536c:	ef 91       	pop	r30
    536e:	9f 91       	pop	r25
    5370:	8f 91       	pop	r24
    5372:	0f 90       	pop	r0
    5374:	0b be       	out	0x3b, r0	; 59
    5376:	0f 90       	pop	r0
    5378:	08 be       	out	0x38, r0	; 56
    537a:	0f 90       	pop	r0
    537c:	0f be       	out	0x3f, r0	; 63
    537e:	0f 90       	pop	r0
    5380:	1f 90       	pop	r1
    5382:	18 95       	reti

00005384 <Reader14443ACodecTask>:

void Reader14443ACodecTask(void)
{
    5384:	0f 93       	push	r16
    5386:	1f 93       	push	r17
    5388:	cf 93       	push	r28
    538a:	df 93       	push	r29
    538c:	cd b7       	in	r28, 0x3d	; 61
    538e:	de b7       	in	r29, 0x3e	; 62
    5390:	da 95       	dec	r29
    5392:	cd bf       	out	0x3d, r28	; 61
    5394:	de bf       	out	0x3e, r29	; 62
    if (Flags.RxPending && SYSTICK_DIFF(RxPendingSince) > Reader_FWT + 1)
    5396:	80 91 a7 2c 	lds	r24, 0x2CA7
    539a:	88 23       	and	r24, r24
    539c:	09 f4       	brne	.+2      	; 0x53a0 <Reader14443ACodecTask+0x1c>
    539e:	83 c0       	rjmp	.+262    	; 0x54a6 <Reader14443ACodecTask+0x122>
    53a0:	8e b1       	in	r24, 0x0e	; 14
    53a2:	9f b1       	in	r25, 0x0f	; 15
    53a4:	40 91 08 04 	lds	r20, 0x0408
    53a8:	50 91 09 04 	lds	r21, 0x0409
    53ac:	20 91 a3 2c 	lds	r18, 0x2CA3
    53b0:	30 91 a4 2c 	lds	r19, 0x2CA4
    53b4:	84 2b       	or	r24, r20
    53b6:	95 2b       	or	r25, r21
    53b8:	82 1b       	sub	r24, r18
    53ba:	93 0b       	sbc	r25, r19
    53bc:	20 91 1e 20 	lds	r18, 0x201E
    53c0:	30 91 1f 20 	lds	r19, 0x201F
    53c4:	2f 5f       	subi	r18, 0xFF	; 255
    53c6:	3f 4f       	sbci	r19, 0xFF	; 255
    53c8:	28 17       	cp	r18, r24
    53ca:	39 07       	cpc	r19, r25
    53cc:	08 f0       	brcs	.+2      	; 0x53d0 <Reader14443ACodecTask+0x4c>
    53ce:	6b c0       	rjmp	.+214    	; 0x54a6 <Reader14443ACodecTask+0x122>


// End of Card-> reader communication and enter frame delay time
INLINE void Reader14443A_EOC(void)
{
    CODEC_TIMER_LOADMOD.INTCTRLB = 0;
    53d0:	10 92 07 0a 	sts	0x0A07, r1
    CODEC_TIMER_LOADMOD.CTRLA = TC_CLKSEL_OFF_gc;
    53d4:	10 92 00 0a 	sts	0x0A00, r1
    CODEC_TIMER_TIMESTAMPS.INTCTRLB = 0;
    53d8:	10 92 47 09 	sts	0x0947, r1
    CODEC_TIMER_TIMESTAMPS.CTRLA = TC_CLKSEL_OFF_gc;
    53dc:	10 92 40 09 	sts	0x0940, r1
    ACA.AC1CTRL &= ~AC_ENABLE_bm;
    53e0:	80 91 81 03 	lds	r24, 0x0381
    53e4:	8e 7f       	andi	r24, 0xFE	; 254
    53e6:	80 93 81 03 	sts	0x0381, r24

    if (BitCount & 1)
    53ea:	84 b1       	in	r24, 0x04	; 4
    53ec:	95 b1       	in	r25, 0x05	; 5
    53ee:	80 ff       	sbrs	r24, 0
    53f0:	1a c0       	rjmp	.+52     	; 0x5426 <Reader14443ACodecTask+0xa2>
    {
        if (SampleRegister & 0x80)
    53f2:	37 9b       	sbis	0x06, 7	; 6
    53f4:	03 c0       	rjmp	.+6      	; 0x53fc <Reader14443ACodecTask+0x78>
    Flags.Start = false;
}

INLINE void Insert0(void)
{
    SampleRegister >>= 1;
    53f6:	86 b1       	in	r24, 0x06	; 6
    53f8:	86 95       	lsr	r24
    53fa:	03 c0       	rjmp	.+6      	; 0x5402 <Reader14443ACodecTask+0x7e>
    *CodecBufferPtr++ = SampleRegister;
}

INLINE void Insert1(void)
{
    SampleRegister = (SampleRegister >> 1) | 0x80;
    53fc:	86 b1       	in	r24, 0x06	; 6
    53fe:	86 95       	lsr	r24
    5400:	80 68       	ori	r24, 0x80	; 128
    5402:	86 b9       	out	0x06, r24	; 6
    if (++BitCount % 8)
    5404:	84 b1       	in	r24, 0x04	; 4
    5406:	95 b1       	in	r25, 0x05	; 5
    5408:	01 96       	adiw	r24, 0x01	; 1
    540a:	84 b9       	out	0x04, r24	; 4
    540c:	95 b9       	out	0x05, r25	; 5
    540e:	87 70       	andi	r24, 0x07	; 7
    5410:	99 27       	eor	r25, r25
    5412:	89 2b       	or	r24, r25
    5414:	41 f4       	brne	.+16     	; 0x5426 <Reader14443ACodecTask+0xa2>
        return;
    *CodecBufferPtr++ = SampleRegister;
    5416:	ea b1       	in	r30, 0x0a	; 10
    5418:	fb b1       	in	r31, 0x0b	; 11
    541a:	cf 01       	movw	r24, r30
    541c:	01 96       	adiw	r24, 0x01	; 1
    541e:	8a b9       	out	0x0a, r24	; 10
    5420:	9b b9       	out	0x0b, r25	; 11
    5422:	86 b1       	in	r24, 0x06	; 6
    5424:	80 83       	st	Z, r24
            Insert0();
        else
            Insert1();
    }

    if (BitCount % 8) // copy the last byte, if there is an incomplete byte
    5426:	84 b1       	in	r24, 0x04	; 4
    5428:	95 b1       	in	r25, 0x05	; 5
    542a:	87 70       	andi	r24, 0x07	; 7
    542c:	99 27       	eor	r25, r25
    542e:	89 2b       	or	r24, r25
    5430:	c9 f0       	breq	.+50     	; 0x5464 <Reader14443ACodecTask+0xe0>
        CodecBuffer[BitCount / 8] = SampleRegister >> (8 - (BitCount % 8));
    5432:	e4 b1       	in	r30, 0x04	; 4
    5434:	f5 b1       	in	r31, 0x05	; 5
    5436:	86 b1       	in	r24, 0x06	; 6
    5438:	44 b1       	in	r20, 0x04	; 4
    543a:	55 b1       	in	r21, 0x05	; 5
    543c:	13 e0       	ldi	r17, 0x03	; 3
    543e:	f6 95       	lsr	r31
    5440:	e7 95       	ror	r30
    5442:	1a 95       	dec	r17
    5444:	e1 f7       	brne	.-8      	; 0x543e <Reader14443ACodecTask+0xba>
    5446:	ed 52       	subi	r30, 0x2D	; 45
    5448:	fe 4c       	sbci	r31, 0xCE	; 206
    544a:	90 e0       	ldi	r25, 0x00	; 0
    544c:	47 70       	andi	r20, 0x07	; 7
    544e:	55 27       	eor	r21, r21
    5450:	28 e0       	ldi	r18, 0x08	; 8
    5452:	30 e0       	ldi	r19, 0x00	; 0
    5454:	24 1b       	sub	r18, r20
    5456:	35 0b       	sbc	r19, r21
    5458:	02 c0       	rjmp	.+4      	; 0x545e <Reader14443ACodecTask+0xda>
    545a:	95 95       	asr	r25
    545c:	87 95       	ror	r24
    545e:	2a 95       	dec	r18
    5460:	e2 f7       	brpl	.-8      	; 0x545a <Reader14443ACodecTask+0xd6>
    5462:	80 83       	st	Z, r24
    Flags.RxDone = true;
    5464:	81 e0       	ldi	r24, 0x01	; 1
    5466:	80 93 a6 2c 	sts	0x2CA6, r24
    Flags.RxPending = false;
    546a:	10 92 a7 2c 	sts	0x2CA7, r1

    // set up timer that forces the minimum frame delay time from PICC to PCD
    CODEC_TIMER_LOADMOD.PER = 0xFFFF;
    546e:	2f ef       	ldi	r18, 0xFF	; 255
    5470:	3f ef       	ldi	r19, 0xFF	; 255
    5472:	20 93 26 0a 	sts	0x0A26, r18
    5476:	30 93 27 0a 	sts	0x0A27, r19
    CODEC_TIMER_LOADMOD.CNT = 0;
    547a:	10 92 20 0a 	sts	0x0A20, r1
    547e:	10 92 21 0a 	sts	0x0A21, r1
    CODEC_TIMER_LOADMOD.INTCTRLA = 0;
    5482:	10 92 06 0a 	sts	0x0A06, r1
    CODEC_TIMER_LOADMOD.INTCTRLB = 0;
    5486:	10 92 07 0a 	sts	0x0A07, r1
    CODEC_TIMER_LOADMOD.CTRLD = 0;
    548a:	10 92 03 0a 	sts	0x0A03, r1
    CODEC_TIMER_LOADMOD.CTRLA = ISO14443A_PICC_TO_PCD_FDT_PRESCALER;
    548e:	94 e0       	ldi	r25, 0x04	; 4
    5490:	90 93 00 0a 	sts	0x0A00, r25

    State = STATE_FDT;
    5494:	93 e0       	ldi	r25, 0x03	; 3
    5496:	90 93 a2 2c 	sts	0x2CA2, r25
void Reader14443ACodecTask(void)
{
    if (Flags.RxPending && SYSTICK_DIFF(RxPendingSince) > Reader_FWT + 1)
    {
        Reader14443A_EOC();
        BitCount = 0;
    549a:	14 b8       	out	0x04, r1	; 4
    549c:	15 b8       	out	0x05, r1	; 5
        Flags.RxDone = true;
    549e:	80 93 a6 2c 	sts	0x2CA6, r24
        Flags.RxPending = false;
    54a2:	10 92 a7 2c 	sts	0x2CA7, r1
    }
    if (CodecIsReaderToBeRestarted() || !CodecIsReaderFieldReady())
    54a6:	bd d9       	rcall	.-3206   	; 0x4822 <CodecIsReaderToBeRestarted>
    54a8:	81 11       	cpse	r24, r1
    54aa:	6f c2       	rjmp	.+1246   	; 0x598a <Reader14443ACodecTask+0x606>
    54ac:	96 d9       	rcall	.-3284   	; 0x47da <CodecIsReaderFieldReady>
    54ae:	88 23       	and	r24, r24
    54b0:	09 f4       	brne	.+2      	; 0x54b4 <Reader14443ACodecTask+0x130>
    54b2:	6b c2       	rjmp	.+1238   	; 0x598a <Reader14443ACodecTask+0x606>
        return;
    if (!Flags.RxPending && (Flags.Start || Flags.RxDone))
    54b4:	80 91 a7 2c 	lds	r24, 0x2CA7
    54b8:	81 11       	cpse	r24, r1
    54ba:	67 c2       	rjmp	.+1230   	; 0x598a <Reader14443ACodecTask+0x606>
    54bc:	80 91 a5 2c 	lds	r24, 0x2CA5
    54c0:	81 11       	cpse	r24, r1
    54c2:	05 c0       	rjmp	.+10     	; 0x54ce <Reader14443ACodecTask+0x14a>
    54c4:	80 91 a6 2c 	lds	r24, 0x2CA6
    54c8:	88 23       	and	r24, r24
    54ca:	09 f4       	brne	.+2      	; 0x54ce <Reader14443ACodecTask+0x14a>
    54cc:	5e c2       	rjmp	.+1212   	; 0x598a <Reader14443ACodecTask+0x606>
    {
        if (State == STATE_FDT && CODEC_TIMER_LOADMOD.CNT < ISO14443A_PICC_TO_PCD_MIN_FDT) // we are in frame delay time, so we can return later
    54ce:	80 91 a2 2c 	lds	r24, 0x2CA2
    54d2:	83 30       	cpi	r24, 0x03	; 3
    54d4:	41 f4       	brne	.+16     	; 0x54e6 <Reader14443ACodecTask+0x162>
    54d6:	80 91 20 0a 	lds	r24, 0x0A20
    54da:	90 91 21 0a 	lds	r25, 0x0A21
    54de:	85 32       	cpi	r24, 0x25	; 37
    54e0:	91 40       	sbci	r25, 0x01	; 1
    54e2:	08 f4       	brcc	.+2      	; 0x54e6 <Reader14443ACodecTask+0x162>
    54e4:	52 c2       	rjmp	.+1188   	; 0x598a <Reader14443ACodecTask+0x606>
            return;
        if (Flags.RxDone && BitCount > 0) // decode the raw received data
    54e6:	80 91 a6 2c 	lds	r24, 0x2CA6
    54ea:	88 23       	and	r24, r24
    54ec:	09 f4       	brne	.+2      	; 0x54f0 <Reader14443ACodecTask+0x16c>
    54ee:	a2 c0       	rjmp	.+324    	; 0x5634 <Reader14443ACodecTask+0x2b0>
    54f0:	84 b1       	in	r24, 0x04	; 4
    54f2:	95 b1       	in	r25, 0x05	; 5
    54f4:	89 2b       	or	r24, r25
    54f6:	09 f4       	brne	.+2      	; 0x54fa <Reader14443ACodecTask+0x176>
    54f8:	9d c0       	rjmp	.+314    	; 0x5634 <Reader14443ACodecTask+0x2b0>
        {
            if (BitCount < ISO14443A_RX_MINIMUM_BITCOUNT * 2)
    54fa:	84 b1       	in	r24, 0x04	; 4
    54fc:	95 b1       	in	r25, 0x05	; 5
    54fe:	08 97       	sbiw	r24, 0x08	; 8
    5500:	18 f4       	brcc	.+6      	; 0x5508 <Reader14443ACodecTask+0x184>
            {
                BitCount = 0;
    5502:	14 b8       	out	0x04, r1	; 4
    5504:	15 b8       	out	0x05, r1	; 5
    5506:	96 c0       	rjmp	.+300    	; 0x5634 <Reader14443ACodecTask+0x2b0>
            } else {
                uint8_t TmpCodecBuffer[CODEC_BUFFER_SIZE];
                memcpy(TmpCodecBuffer, CodecBuffer, (BitCount + 7) / 8);
    5508:	44 b1       	in	r20, 0x04	; 4
    550a:	55 b1       	in	r21, 0x05	; 5
    550c:	49 5f       	subi	r20, 0xF9	; 249
    550e:	5f 4f       	sbci	r21, 0xFF	; 255
    5510:	b3 e0       	ldi	r27, 0x03	; 3
    5512:	56 95       	lsr	r21
    5514:	47 95       	ror	r20
    5516:	ba 95       	dec	r27
    5518:	e1 f7       	brne	.-8      	; 0x5512 <Reader14443ACodecTask+0x18e>
    551a:	63 ed       	ldi	r22, 0xD3	; 211
    551c:	71 e3       	ldi	r23, 0x31	; 49
    551e:	ce 01       	movw	r24, r28
    5520:	01 96       	adiw	r24, 0x01	; 1
    5522:	0e 94 e7 65 	call	0xcbce	; 0xcbce <memcpy>

                CodecBufferPtr = CodecBuffer;
    5526:	83 ed       	ldi	r24, 0xD3	; 211
    5528:	91 e3       	ldi	r25, 0x31	; 49
    552a:	8a b9       	out	0x0a, r24	; 10
    552c:	9b b9       	out	0x0b, r25	; 11
                uint16_t BitCountTmp = 2, TotalBitCount = BitCount;
    552e:	44 b1       	in	r20, 0x04	; 4
    5530:	55 b1       	in	r21, 0x05	; 5
                BitCount = 0;
    5532:	14 b8       	out	0x04, r1	; 4
    5534:	15 b8       	out	0x05, r1	; 5

                bool breakflag = false;
                TmpCodecBuffer[0] >>= 2; // with this (and BitCountTmp = 2), the SOC is ignored
    5536:	89 81       	ldd	r24, Y+1	; 0x01
    5538:	86 95       	lsr	r24
    553a:	86 95       	lsr	r24
    553c:	89 83       	std	Y+1, r24	; 0x01
            } else {
                uint8_t TmpCodecBuffer[CODEC_BUFFER_SIZE];
                memcpy(TmpCodecBuffer, CodecBuffer, (BitCount + 7) / 8);

                CodecBufferPtr = CodecBuffer;
                uint16_t BitCountTmp = 2, TotalBitCount = BitCount;
    553e:	22 e0       	ldi	r18, 0x02	; 2
    5540:	30 e0       	ldi	r19, 0x00	; 0

                bool breakflag = false;
                TmpCodecBuffer[0] >>= 2; // with this (and BitCountTmp = 2), the SOC is ignored

                // Manchester Code ISO14443-2 8.2.5
                while (!breakflag && BitCountTmp < TotalBitCount)
    5542:	24 17       	cp	r18, r20
    5544:	35 07       	cpc	r19, r21
    5546:	b0 f5       	brcc	.+108    	; 0x55b4 <Reader14443ACodecTask+0x230>
                {
                    uint8_t Bit = TmpCodecBuffer[BitCountTmp / 8] & 0x03;
    5548:	f9 01       	movw	r30, r18
    554a:	a3 e0       	ldi	r26, 0x03	; 3
    554c:	f6 95       	lsr	r31
    554e:	e7 95       	ror	r30
    5550:	aa 95       	dec	r26
    5552:	e1 f7       	brne	.-8      	; 0x554c <Reader14443ACodecTask+0x1c8>
    5554:	81 e0       	ldi	r24, 0x01	; 1
    5556:	90 e0       	ldi	r25, 0x00	; 0
    5558:	8c 0f       	add	r24, r28
    555a:	9d 1f       	adc	r25, r29
    555c:	e8 0f       	add	r30, r24
    555e:	f9 1f       	adc	r31, r25
    5560:	80 81       	ld	r24, Z
                    TmpCodecBuffer[BitCountTmp / 8] >>= 2;
    5562:	98 2f       	mov	r25, r24
    5564:	96 95       	lsr	r25
    5566:	96 95       	lsr	r25
    5568:	90 83       	st	Z, r25
                TmpCodecBuffer[0] >>= 2; // with this (and BitCountTmp = 2), the SOC is ignored

                // Manchester Code ISO14443-2 8.2.5
                while (!breakflag && BitCountTmp < TotalBitCount)
                {
                    uint8_t Bit = TmpCodecBuffer[BitCountTmp / 8] & 0x03;
    556a:	83 70       	andi	r24, 0x03	; 3
                    TmpCodecBuffer[BitCountTmp / 8] >>= 2;
                    switch (Bit)
    556c:	81 30       	cpi	r24, 0x01	; 1
    556e:	49 f0       	breq	.+18     	; 0x5582 <Reader14443ACodecTask+0x1fe>
    5570:	30 f0       	brcs	.+12     	; 0x557e <Reader14443ACodecTask+0x1fa>
    5572:	82 30       	cpi	r24, 0x02	; 2
    5574:	d1 f4       	brne	.+52     	; 0x55aa <Reader14443ACodecTask+0x226>
    *CodecBufferPtr++ = SampleRegister;
}

INLINE void Insert1(void)
{
    SampleRegister = (SampleRegister >> 1) | 0x80;
    5576:	86 b1       	in	r24, 0x06	; 6
    5578:	86 95       	lsr	r24
    557a:	80 68       	ori	r24, 0x80	; 128
    557c:	04 c0       	rjmp	.+8      	; 0x5586 <Reader14443ACodecTask+0x202>
                    case 0b01:
                        Insert0();
                        break;

                    case 0b00: // EOC
                        breakflag = true;
    557e:	81 e0       	ldi	r24, 0x01	; 1
    5580:	15 c0       	rjmp	.+42     	; 0x55ac <Reader14443ACodecTask+0x228>
    Flags.Start = false;
}

INLINE void Insert0(void)
{
    SampleRegister >>= 1;
    5582:	86 b1       	in	r24, 0x06	; 6
    5584:	86 95       	lsr	r24
    5586:	86 b9       	out	0x06, r24	; 6
    if (++BitCount % 8)
    5588:	84 b1       	in	r24, 0x04	; 4
    558a:	95 b1       	in	r25, 0x05	; 5
    558c:	01 96       	adiw	r24, 0x01	; 1
    558e:	84 b9       	out	0x04, r24	; 4
    5590:	95 b9       	out	0x05, r25	; 5
    5592:	87 70       	andi	r24, 0x07	; 7
    5594:	99 27       	eor	r25, r25
    5596:	89 2b       	or	r24, r25
    5598:	41 f4       	brne	.+16     	; 0x55aa <Reader14443ACodecTask+0x226>
        return;
    *CodecBufferPtr++ = SampleRegister;
    559a:	ea b1       	in	r30, 0x0a	; 10
    559c:	fb b1       	in	r31, 0x0b	; 11
    559e:	cf 01       	movw	r24, r30
    55a0:	01 96       	adiw	r24, 0x01	; 1
    55a2:	8a b9       	out	0x0a, r24	; 10
    55a4:	9b b9       	out	0x0b, r25	; 11
    55a6:	86 b1       	in	r24, 0x06	; 6
    55a8:	80 83       	st	Z, r24
                // Manchester Code ISO14443-2 8.2.5
                while (!breakflag && BitCountTmp < TotalBitCount)
                {
                    uint8_t Bit = TmpCodecBuffer[BitCountTmp / 8] & 0x03;
                    TmpCodecBuffer[BitCountTmp / 8] >>= 2;
                    switch (Bit)
    55aa:	80 e0       	ldi	r24, 0x00	; 0

                    default:
                        // error, should not happen, TODO handle this
                        break;
                    }
                    BitCountTmp += 2;
    55ac:	2e 5f       	subi	r18, 0xFE	; 254
    55ae:	3f 4f       	sbci	r19, 0xFF	; 255

                bool breakflag = false;
                TmpCodecBuffer[0] >>= 2; // with this (and BitCountTmp = 2), the SOC is ignored

                // Manchester Code ISO14443-2 8.2.5
                while (!breakflag && BitCountTmp < TotalBitCount)
    55b0:	88 23       	and	r24, r24
    55b2:	39 f2       	breq	.-114    	; 0x5542 <Reader14443ACodecTask+0x1be>
                        // error, should not happen, TODO handle this
                        break;
                    }
                    BitCountTmp += 2;
                }
                if (BitCount % 8) // copy the last byte, if there is an incomplete byte
    55b4:	84 b1       	in	r24, 0x04	; 4
    55b6:	95 b1       	in	r25, 0x05	; 5
    55b8:	87 70       	andi	r24, 0x07	; 7
    55ba:	99 27       	eor	r25, r25
    55bc:	89 2b       	or	r24, r25
    55be:	c9 f0       	breq	.+50     	; 0x55f2 <Reader14443ACodecTask+0x26e>
                    CodecBuffer[BitCount / 8] = SampleRegister >> (8 - (BitCount % 8));
    55c0:	e4 b1       	in	r30, 0x04	; 4
    55c2:	f5 b1       	in	r31, 0x05	; 5
    55c4:	86 b1       	in	r24, 0x06	; 6
    55c6:	44 b1       	in	r20, 0x04	; 4
    55c8:	55 b1       	in	r21, 0x05	; 5
    55ca:	73 e0       	ldi	r23, 0x03	; 3
    55cc:	f6 95       	lsr	r31
    55ce:	e7 95       	ror	r30
    55d0:	7a 95       	dec	r23
    55d2:	e1 f7       	brne	.-8      	; 0x55cc <Reader14443ACodecTask+0x248>
    55d4:	ed 52       	subi	r30, 0x2D	; 45
    55d6:	fe 4c       	sbci	r31, 0xCE	; 206
    55d8:	90 e0       	ldi	r25, 0x00	; 0
    55da:	47 70       	andi	r20, 0x07	; 7
    55dc:	55 27       	eor	r21, r21
    55de:	28 e0       	ldi	r18, 0x08	; 8
    55e0:	30 e0       	ldi	r19, 0x00	; 0
    55e2:	24 1b       	sub	r18, r20
    55e4:	35 0b       	sbc	r19, r21
    55e6:	02 c0       	rjmp	.+4      	; 0x55ec <Reader14443ACodecTask+0x268>
    55e8:	95 95       	asr	r25
    55ea:	87 95       	ror	r24
    55ec:	2a 95       	dec	r18
    55ee:	e2 f7       	brpl	.-8      	; 0x55e8 <Reader14443ACodecTask+0x264>
    55f0:	80 83       	st	Z, r24

INLINE void LEDHook(LEDHookEnum Func, LEDActionEnum Action) {
    extern LEDActionEnum LEDGreenAction;
    extern LEDActionEnum LEDRedAction;

    if (GlobalSettings.ActiveSettingPtr->LEDGreenFunction == Func) {
    55f2:	e0 91 71 2f 	lds	r30, 0x2F71
    55f6:	f0 91 72 2f 	lds	r31, 0x2F72
    55fa:	87 81       	ldd	r24, Z+7	; 0x07
    55fc:	88 30       	cpi	r24, 0x08	; 8
    55fe:	19 f4       	brne	.+6      	; 0x5606 <Reader14443ACodecTask+0x282>
        LEDGreenAction = Action;
    5600:	83 e1       	ldi	r24, 0x13	; 19
    5602:	80 93 7d 2c 	sts	0x2C7D, r24
    }

    if (GlobalSettings.ActiveSettingPtr->LEDRedFunction == Func) {
    5606:	86 81       	ldd	r24, Z+6	; 0x06
    5608:	88 30       	cpi	r24, 0x08	; 8
    560a:	19 f4       	brne	.+6      	; 0x5612 <Reader14443ACodecTask+0x28e>
        LEDRedAction = Action;
    560c:	83 e1       	ldi	r24, 0x13	; 19
    560e:	80 93 7c 2c 	sts	0x2C7C, r24
                LEDHook(LED_CODEC_RX, LED_PULSE);
                LogEntry(LOG_INFO_CODEC_RX_DATA_W_PARITY, CodecBuffer, (BitCount + 7) / 8);
    5612:	44 b1       	in	r20, 0x04	; 4
    5614:	55 b1       	in	r21, 0x05	; 5
    5616:	49 5f       	subi	r20, 0xF9	; 249
    5618:	5f 4f       	sbci	r21, 0xFF	; 255
    561a:	63 e0       	ldi	r22, 0x03	; 3
    561c:	56 95       	lsr	r21
    561e:	47 95       	ror	r20
    5620:	6a 95       	dec	r22
    5622:	e1 f7       	brne	.-8      	; 0x561c <Reader14443ACodecTask+0x298>
    5624:	e0 91 6e 2f 	lds	r30, 0x2F6E
    5628:	f0 91 6f 2f 	lds	r31, 0x2F6F
    562c:	63 ed       	ldi	r22, 0xD3	; 211
    562e:	71 e3       	ldi	r23, 0x31	; 49
    5630:	82 e4       	ldi	r24, 0x42	; 66
    5632:	19 95       	eicall
            }
        }
        Flags.Start = false;
    5634:	10 92 a5 2c 	sts	0x2CA5, r1
        Flags.RxDone = false;
    5638:	10 92 a6 2c 	sts	0x2CA6, r1

        /* Call application with received data */
        BitCount = ApplicationProcess(CodecBuffer, BitCount);
    563c:	64 b1       	in	r22, 0x04	; 4
    563e:	75 b1       	in	r23, 0x05	; 5
    5640:	e0 91 64 2f 	lds	r30, 0x2F64
    5644:	f0 91 65 2f 	lds	r31, 0x2F65
    5648:	83 ed       	ldi	r24, 0xD3	; 211
    564a:	91 e3       	ldi	r25, 0x31	; 49
    564c:	19 95       	eicall
    564e:	84 b9       	out	0x04, r24	; 4
    5650:	95 b9       	out	0x05, r25	; 5

        if (BitCount > 0)
    5652:	84 b1       	in	r24, 0x04	; 4
    5654:	95 b1       	in	r25, 0x05	; 5
    5656:	89 2b       	or	r24, r25
    5658:	09 f4       	brne	.+2      	; 0x565c <Reader14443ACodecTask+0x2d8>
    565a:	97 c1       	rjmp	.+814    	; 0x598a <Reader14443ACodecTask+0x606>
             * assume there is a pause. Now we read the second timers count value and can decide how many
             * bit halves had modulations since the last pause.
             */

            /* Configure and enable the analog comparator for finding pauses in the DEMOD signal. */
            ACA.AC1CTRL = AC_HSMODE_bm | AC_HYSMODE_NO_gc | AC_INTMODE_FALLING_gc | AC_ENABLE_bm;
    565c:	89 e8       	ldi	r24, 0x89	; 137
    565e:	80 93 81 03 	sts	0x0381, r24

            /* This timer will be used to detect the pauses between the modulation sequences. */
            CODEC_TIMER_LOADMOD.CTRLA = 0;
    5662:	10 92 00 0a 	sts	0x0A00, r1
            CODEC_TIMER_LOADMOD.CNT = 0;
    5666:	10 92 20 0a 	sts	0x0A20, r1
    566a:	10 92 21 0a 	sts	0x0A21, r1
            CODEC_TIMER_LOADMOD.PER = 0xFFFF; // with 27.12 MHz this is exactly one half bit width
    566e:	2f ef       	ldi	r18, 0xFF	; 255
    5670:	3f ef       	ldi	r19, 0xFF	; 255
    5672:	20 93 26 0a 	sts	0x0A26, r18
    5676:	30 93 27 0a 	sts	0x0A27, r19
            CODEC_TIMER_LOADMOD.CCA = 95; // with 27.12 MHz this is 3/4 of a half bit width
    567a:	8f e5       	ldi	r24, 0x5F	; 95
    567c:	90 e0       	ldi	r25, 0x00	; 0
    567e:	80 93 28 0a 	sts	0x0A28, r24
    5682:	90 93 29 0a 	sts	0x0A29, r25
            CODEC_TIMER_LOADMOD.INTCTRLA = 0;
    5686:	10 92 06 0a 	sts	0x0A06, r1
            CODEC_TIMER_LOADMOD.INTFLAGS = TC1_CCAIF_bm;
    568a:	80 e1       	ldi	r24, 0x10	; 16
    568c:	80 93 0c 0a 	sts	0x0A0C, r24
            CODEC_TIMER_LOADMOD.INTCTRLB = TC_CCAINTLVL_HI_gc;
    5690:	93 e0       	ldi	r25, 0x03	; 3
    5692:	90 93 07 0a 	sts	0x0A07, r25

            /* This timer will be used to find out how many bit halfs since the last pause have been passed. */
            CODEC_TIMER_TIMESTAMPS.CNT = 0;
    5696:	10 92 60 09 	sts	0x0960, r1
    569a:	10 92 61 09 	sts	0x0961, r1
            CODEC_TIMER_TIMESTAMPS.PER = 0xFFFF;
    569e:	20 93 66 09 	sts	0x0966, r18
    56a2:	30 93 67 09 	sts	0x0967, r19
            CODEC_TIMER_TIMESTAMPS.CCA = 160;
    56a6:	20 ea       	ldi	r18, 0xA0	; 160
    56a8:	30 e0       	ldi	r19, 0x00	; 0
    56aa:	20 93 68 09 	sts	0x0968, r18
    56ae:	30 93 69 09 	sts	0x0969, r19
            CODEC_TIMER_TIMESTAMPS.INTCTRLA = 0;
    56b2:	10 92 46 09 	sts	0x0946, r1
            CODEC_TIMER_TIMESTAMPS.INTFLAGS = TC1_CCAIF_bm;
    56b6:	80 93 4c 09 	sts	0x094C, r24
            CODEC_TIMER_TIMESTAMPS.INTCTRLB = TC_CCAINTLVL_LO_gc;
    56ba:	81 e0       	ldi	r24, 0x01	; 1
    56bc:	80 93 47 09 	sts	0x0947, r24

            /* Use the event system for resetting the pause-detecting timer. */
            EVSYS.CH0MUX = EVSYS_CHMUX_ACA_CH1_gc; // on every ACA_AC1 INT
    56c0:	81 e1       	ldi	r24, 0x11	; 17
    56c2:	80 93 80 01 	sts	0x0180, r24
            EVSYS.CH0CTRL = EVSYS_DIGFILT_1SAMPLE_gc;
    56c6:	10 92 88 01 	sts	0x0188, r1

            ACA.AC0CTRL = 0;
    56ca:	10 92 80 03 	sts	0x0380, r1
            CODEC_DEMOD_IN_PORT.INTCTRL = 0;
    56ce:	10 92 29 06 	sts	0x0629, r1

INLINE void LEDHook(LEDHookEnum Func, LEDActionEnum Action) {
    extern LEDActionEnum LEDGreenAction;
    extern LEDActionEnum LEDRedAction;

    if (GlobalSettings.ActiveSettingPtr->LEDGreenFunction == Func) {
    56d2:	e0 91 71 2f 	lds	r30, 0x2F71
    56d6:	f0 91 72 2f 	lds	r31, 0x2F72
    56da:	87 81       	ldd	r24, Z+7	; 0x07
    56dc:	89 30       	cpi	r24, 0x09	; 9
    56de:	19 f4       	brne	.+6      	; 0x56e6 <Reader14443ACodecTask+0x362>
        LEDGreenAction = Action;
    56e0:	83 e1       	ldi	r24, 0x13	; 19
    56e2:	80 93 7d 2c 	sts	0x2C7D, r24
    }

    if (GlobalSettings.ActiveSettingPtr->LEDRedFunction == Func) {
    56e6:	86 81       	ldd	r24, Z+6	; 0x06
    56e8:	89 30       	cpi	r24, 0x09	; 9
    56ea:	19 f4       	brne	.+6      	; 0x56f2 <Reader14443ACodecTask+0x36e>
        LEDRedAction = Action;
    56ec:	83 e1       	ldi	r24, 0x13	; 19
    56ee:	80 93 7c 2c 	sts	0x2C7C, r24

            LEDHook(LED_CODEC_TX, LED_PULSE);
            LogEntry(LOG_INFO_CODEC_TX_DATA_W_PARITY, CodecBuffer, (BitCount + 7) / 8);
    56f2:	44 b1       	in	r20, 0x04	; 4
    56f4:	55 b1       	in	r21, 0x05	; 5
    56f6:	49 5f       	subi	r20, 0xF9	; 249
    56f8:	5f 4f       	sbci	r21, 0xFF	; 255
    56fa:	33 e0       	ldi	r19, 0x03	; 3
    56fc:	56 95       	lsr	r21
    56fe:	47 95       	ror	r20
    5700:	3a 95       	dec	r19
    5702:	e1 f7       	brne	.-8      	; 0x56fc <Reader14443ACodecTask+0x378>
    5704:	e0 91 6e 2f 	lds	r30, 0x2F6E
    5708:	f0 91 6f 2f 	lds	r31, 0x2F6F
    570c:	63 ed       	ldi	r22, 0xD3	; 211
    570e:	71 e3       	ldi	r23, 0x31	; 49
    5710:	83 e4       	ldi	r24, 0x43	; 67
    5712:	19 95       	eicall
    State = STATE_FDT;
}

INLINE void BufferToSequence(void)
{
    uint16_t count = BitCount;
    5714:	04 b1       	in	r16, 0x04	; 4
    5716:	15 b1       	in	r17, 0x05	; 5
    if (count > BITS_PER_BYTE * CODEC_BUFFER_SIZE / 2) // todo is this correct?
    5718:	01 30       	cpi	r16, 0x01	; 1
    571a:	94 e0       	ldi	r25, 0x04	; 4
    571c:	19 07       	cpc	r17, r25
    571e:	08 f0       	brcs	.+2      	; 0x5722 <Reader14443ACodecTask+0x39e>
    5720:	24 c1       	rjmp	.+584    	; 0x596a <Reader14443ACodecTask+0x5e6>
        return;

    BitCount = 0;
    5722:	14 b8       	out	0x04, r1	; 4
    5724:	15 b8       	out	0x05, r1	; 5

    memcpy(CodecBuffer + CODEC_BUFFER_SIZE / 2, CodecBuffer, (count + 7) / 8);
    5726:	a8 01       	movw	r20, r16
    5728:	49 5f       	subi	r20, 0xF9	; 249
    572a:	5f 4f       	sbci	r21, 0xFF	; 255
    572c:	23 e0       	ldi	r18, 0x03	; 3
    572e:	56 95       	lsr	r21
    5730:	47 95       	ror	r20
    5732:	2a 95       	dec	r18
    5734:	e1 f7       	brne	.-8      	; 0x572e <Reader14443ACodecTask+0x3aa>
    5736:	63 ed       	ldi	r22, 0xD3	; 211
    5738:	71 e3       	ldi	r23, 0x31	; 49
    573a:	83 e5       	ldi	r24, 0x53	; 83
    573c:	92 e3       	ldi	r25, 0x32	; 50
    573e:	0e 94 e7 65 	call	0xcbce	; 0xcbce <memcpy>
    uint8_t * Buffer = CodecBuffer + CODEC_BUFFER_SIZE / 2;
    CodecBufferPtr = CodecBuffer;
    5742:	83 ed       	ldi	r24, 0xD3	; 211
    5744:	91 e3       	ldi	r25, 0x31	; 49
    5746:	8a b9       	out	0x0a, r24	; 10
    5748:	9b b9       	out	0x0b, r25	; 11
    *CodecBufferPtr++ = SampleRegister;
}

INLINE void Insert1(void)
{
    SampleRegister = (SampleRegister >> 1) | 0x80;
    574a:	86 b1       	in	r24, 0x06	; 6
    574c:	86 95       	lsr	r24
    574e:	80 68       	ori	r24, 0x80	; 128
    5750:	86 b9       	out	0x06, r24	; 6
    if (++BitCount % 8)
    5752:	84 b1       	in	r24, 0x04	; 4
    5754:	95 b1       	in	r25, 0x05	; 5
    5756:	01 96       	adiw	r24, 0x01	; 1
    5758:	84 b9       	out	0x04, r24	; 4
    575a:	95 b9       	out	0x05, r25	; 5
    575c:	87 70       	andi	r24, 0x07	; 7
    575e:	99 27       	eor	r25, r25
    5760:	89 2b       	or	r24, r25
    5762:	39 f4       	brne	.+14     	; 0x5772 <Reader14443ACodecTask+0x3ee>
        return;
    *CodecBufferPtr++ = SampleRegister;
    5764:	84 ed       	ldi	r24, 0xD4	; 212
    5766:	91 e3       	ldi	r25, 0x31	; 49
    5768:	8a b9       	out	0x0a, r24	; 10
    576a:	9b b9       	out	0x0b, r25	; 11
    576c:	86 b1       	in	r24, 0x06	; 6
    576e:	80 93 d3 31 	sts	0x31D3, r24
    Flags.Start = false;
}

INLINE void Insert0(void)
{
    SampleRegister >>= 1;
    5772:	86 b1       	in	r24, 0x06	; 6
    5774:	86 95       	lsr	r24
    5776:	86 b9       	out	0x06, r24	; 6
    if (++BitCount % 8)
    5778:	84 b1       	in	r24, 0x04	; 4
    577a:	95 b1       	in	r25, 0x05	; 5
    577c:	01 96       	adiw	r24, 0x01	; 1
    577e:	84 b9       	out	0x04, r24	; 4
    5780:	95 b9       	out	0x05, r25	; 5
    5782:	87 70       	andi	r24, 0x07	; 7
    5784:	99 27       	eor	r25, r25
    5786:	89 2b       	or	r24, r25
    5788:	41 f4       	brne	.+16     	; 0x579a <Reader14443ACodecTask+0x416>
        return;
    *CodecBufferPtr++ = SampleRegister;
    578a:	ea b1       	in	r30, 0x0a	; 10
    578c:	fb b1       	in	r31, 0x0b	; 11
    578e:	cf 01       	movw	r24, r30
    5790:	01 96       	adiw	r24, 0x01	; 1
    5792:	8a b9       	out	0x0a, r24	; 10
    5794:	9b b9       	out	0x0b, r25	; 11
    5796:	86 b1       	in	r24, 0x06	; 6
    5798:	80 83       	st	Z, r24
                Insert0();
            } else {
                Insert1();
                Insert0();
            }
            last = 0;
    579a:	80 e0       	ldi	r24, 0x00	; 0
    579c:	41 e0       	ldi	r20, 0x01	; 1
    579e:	50 e0       	ldi	r21, 0x00	; 0
    57a0:	e3 e5       	ldi	r30, 0x53	; 83
    57a2:	f2 e3       	ldi	r31, 0x32	; 50
    Insert1(); // SOC
    Insert0();

    uint16_t i;
    uint8_t last = 0;
    for (i = 1; i <= count; i++)
    57a4:	04 17       	cp	r16, r20
    57a6:	15 07       	cpc	r17, r21
    57a8:	08 f4       	brcc	.+2      	; 0x57ac <Reader14443ACodecTask+0x428>
    57aa:	95 c0       	rjmp	.+298    	; 0x58d6 <Reader14443ACodecTask+0x552>
    {
        if ((*Buffer) & 1)
    57ac:	90 81       	ld	r25, Z
    57ae:	90 ff       	sbrs	r25, 0
    57b0:	2b c0       	rjmp	.+86     	; 0x5808 <Reader14443ACodecTask+0x484>
    Flags.Start = false;
}

INLINE void Insert0(void)
{
    SampleRegister >>= 1;
    57b2:	86 b1       	in	r24, 0x06	; 6
    57b4:	86 95       	lsr	r24
    57b6:	86 b9       	out	0x06, r24	; 6
    if (++BitCount % 8)
    57b8:	84 b1       	in	r24, 0x04	; 4
    57ba:	95 b1       	in	r25, 0x05	; 5
    57bc:	01 96       	adiw	r24, 0x01	; 1
    57be:	84 b9       	out	0x04, r24	; 4
    57c0:	95 b9       	out	0x05, r25	; 5
    57c2:	87 70       	andi	r24, 0x07	; 7
    57c4:	99 27       	eor	r25, r25
    57c6:	89 2b       	or	r24, r25
    57c8:	41 f4       	brne	.+16     	; 0x57da <Reader14443ACodecTask+0x456>
        return;
    *CodecBufferPtr++ = SampleRegister;
    57ca:	aa b1       	in	r26, 0x0a	; 10
    57cc:	bb b1       	in	r27, 0x0b	; 11
    57ce:	cd 01       	movw	r24, r26
    57d0:	01 96       	adiw	r24, 0x01	; 1
    57d2:	8a b9       	out	0x0a, r24	; 10
    57d4:	9b b9       	out	0x0b, r25	; 11
    57d6:	86 b1       	in	r24, 0x06	; 6
    57d8:	8c 93       	st	X, r24
}

INLINE void Insert1(void)
{
    SampleRegister = (SampleRegister >> 1) | 0x80;
    57da:	86 b1       	in	r24, 0x06	; 6
    57dc:	86 95       	lsr	r24
    57de:	80 68       	ori	r24, 0x80	; 128
    57e0:	86 b9       	out	0x06, r24	; 6
    if (++BitCount % 8)
    57e2:	84 b1       	in	r24, 0x04	; 4
    57e4:	95 b1       	in	r25, 0x05	; 5
    57e6:	01 96       	adiw	r24, 0x01	; 1
    57e8:	84 b9       	out	0x04, r24	; 4
    57ea:	95 b9       	out	0x05, r25	; 5
    57ec:	87 70       	andi	r24, 0x07	; 7
    57ee:	99 27       	eor	r25, r25
    57f0:	89 2b       	or	r24, r25
    57f2:	09 f0       	breq	.+2      	; 0x57f6 <Reader14443ACodecTask+0x472>
    57f4:	63 c0       	rjmp	.+198    	; 0x58bc <Reader14443ACodecTask+0x538>
        return;
    *CodecBufferPtr++ = SampleRegister;
    57f6:	aa b1       	in	r26, 0x0a	; 10
    57f8:	bb b1       	in	r27, 0x0b	; 11
    57fa:	cd 01       	movw	r24, r26
    57fc:	01 96       	adiw	r24, 0x01	; 1
    57fe:	8a b9       	out	0x0a, r24	; 10
    5800:	9b b9       	out	0x0b, r25	; 11
    5802:	86 b1       	in	r24, 0x06	; 6
    5804:	8c 93       	st	X, r24
    5806:	5a c0       	rjmp	.+180    	; 0x58bc <Reader14443ACodecTask+0x538>
        {
            Insert0();
            Insert1();
            last = 1;
        } else {
            if (last)
    5808:	88 23       	and	r24, r24
    580a:	51 f1       	breq	.+84     	; 0x5860 <Reader14443ACodecTask+0x4dc>
    Flags.Start = false;
}

INLINE void Insert0(void)
{
    SampleRegister >>= 1;
    580c:	86 b1       	in	r24, 0x06	; 6
    580e:	86 95       	lsr	r24
    5810:	86 b9       	out	0x06, r24	; 6
    if (++BitCount % 8)
    5812:	84 b1       	in	r24, 0x04	; 4
    5814:	95 b1       	in	r25, 0x05	; 5
    5816:	01 96       	adiw	r24, 0x01	; 1
    5818:	84 b9       	out	0x04, r24	; 4
    581a:	95 b9       	out	0x05, r25	; 5
    581c:	87 70       	andi	r24, 0x07	; 7
    581e:	99 27       	eor	r25, r25
    5820:	89 2b       	or	r24, r25
    5822:	41 f4       	brne	.+16     	; 0x5834 <Reader14443ACodecTask+0x4b0>
        return;
    *CodecBufferPtr++ = SampleRegister;
    5824:	aa b1       	in	r26, 0x0a	; 10
    5826:	bb b1       	in	r27, 0x0b	; 11
    5828:	cd 01       	movw	r24, r26
    582a:	01 96       	adiw	r24, 0x01	; 1
    582c:	8a b9       	out	0x0a, r24	; 10
    582e:	9b b9       	out	0x0b, r25	; 11
    5830:	86 b1       	in	r24, 0x06	; 6
    5832:	8c 93       	st	X, r24
    Flags.Start = false;
}

INLINE void Insert0(void)
{
    SampleRegister >>= 1;
    5834:	86 b1       	in	r24, 0x06	; 6
    5836:	86 95       	lsr	r24
    5838:	86 b9       	out	0x06, r24	; 6
    if (++BitCount % 8)
    583a:	84 b1       	in	r24, 0x04	; 4
    583c:	95 b1       	in	r25, 0x05	; 5
    583e:	01 96       	adiw	r24, 0x01	; 1
    5840:	84 b9       	out	0x04, r24	; 4
    5842:	95 b9       	out	0x05, r25	; 5
    5844:	87 70       	andi	r24, 0x07	; 7
    5846:	99 27       	eor	r25, r25
    5848:	89 2b       	or	r24, r25
    584a:	41 f4       	brne	.+16     	; 0x585c <Reader14443ACodecTask+0x4d8>
        return;
    *CodecBufferPtr++ = SampleRegister;
    584c:	aa b1       	in	r26, 0x0a	; 10
    584e:	bb b1       	in	r27, 0x0b	; 11
    5850:	cd 01       	movw	r24, r26
    5852:	01 96       	adiw	r24, 0x01	; 1
    5854:	8a b9       	out	0x0a, r24	; 10
    5856:	9b b9       	out	0x0b, r25	; 11
    5858:	86 b1       	in	r24, 0x06	; 6
    585a:	8c 93       	st	X, r24
                Insert0();
            } else {
                Insert1();
                Insert0();
            }
            last = 0;
    585c:	80 e0       	ldi	r24, 0x00	; 0
    585e:	2f c0       	rjmp	.+94     	; 0x58be <Reader14443ACodecTask+0x53a>
    *CodecBufferPtr++ = SampleRegister;
}

INLINE void Insert1(void)
{
    SampleRegister = (SampleRegister >> 1) | 0x80;
    5860:	96 b1       	in	r25, 0x06	; 6
    5862:	96 95       	lsr	r25
    5864:	90 68       	ori	r25, 0x80	; 128
    5866:	96 b9       	out	0x06, r25	; 6
    if (++BitCount % 8)
    5868:	24 b1       	in	r18, 0x04	; 4
    586a:	35 b1       	in	r19, 0x05	; 5
    586c:	2f 5f       	subi	r18, 0xFF	; 255
    586e:	3f 4f       	sbci	r19, 0xFF	; 255
    5870:	24 b9       	out	0x04, r18	; 4
    5872:	35 b9       	out	0x05, r19	; 5
    5874:	27 70       	andi	r18, 0x07	; 7
    5876:	33 27       	eor	r19, r19
    5878:	23 2b       	or	r18, r19
    587a:	49 f4       	brne	.+18     	; 0x588e <Reader14443ACodecTask+0x50a>
        return;
    *CodecBufferPtr++ = SampleRegister;
    587c:	aa b1       	in	r26, 0x0a	; 10
    587e:	bb b1       	in	r27, 0x0b	; 11
    5880:	9d 01       	movw	r18, r26
    5882:	2f 5f       	subi	r18, 0xFF	; 255
    5884:	3f 4f       	sbci	r19, 0xFF	; 255
    5886:	2a b9       	out	0x0a, r18	; 10
    5888:	3b b9       	out	0x0b, r19	; 11
    588a:	96 b1       	in	r25, 0x06	; 6
    588c:	9c 93       	st	X, r25
    Flags.Start = false;
}

INLINE void Insert0(void)
{
    SampleRegister >>= 1;
    588e:	96 b1       	in	r25, 0x06	; 6
    5890:	96 95       	lsr	r25
    5892:	96 b9       	out	0x06, r25	; 6
    if (++BitCount % 8)
    5894:	24 b1       	in	r18, 0x04	; 4
    5896:	35 b1       	in	r19, 0x05	; 5
    5898:	2f 5f       	subi	r18, 0xFF	; 255
    589a:	3f 4f       	sbci	r19, 0xFF	; 255
    589c:	24 b9       	out	0x04, r18	; 4
    589e:	35 b9       	out	0x05, r19	; 5
    58a0:	27 70       	andi	r18, 0x07	; 7
    58a2:	33 27       	eor	r19, r19
    58a4:	23 2b       	or	r18, r19
    58a6:	d1 f6       	brne	.-76     	; 0x585c <Reader14443ACodecTask+0x4d8>
        return;
    *CodecBufferPtr++ = SampleRegister;
    58a8:	aa b1       	in	r26, 0x0a	; 10
    58aa:	bb b1       	in	r27, 0x0b	; 11
    58ac:	9d 01       	movw	r18, r26
    58ae:	2f 5f       	subi	r18, 0xFF	; 255
    58b0:	3f 4f       	sbci	r19, 0xFF	; 255
    58b2:	2a b9       	out	0x0a, r18	; 10
    58b4:	3b b9       	out	0x0b, r19	; 11
    58b6:	96 b1       	in	r25, 0x06	; 6
    58b8:	9c 93       	st	X, r25
    58ba:	01 c0       	rjmp	.+2      	; 0x58be <Reader14443ACodecTask+0x53a>
    {
        if ((*Buffer) & 1)
        {
            Insert0();
            Insert1();
            last = 1;
    58bc:	81 e0       	ldi	r24, 0x01	; 1
                Insert1();
                Insert0();
            }
            last = 0;
        }
        *Buffer >>= 1;
    58be:	90 81       	ld	r25, Z
    58c0:	96 95       	lsr	r25
    58c2:	90 83       	st	Z, r25
        if ((i % 8) == 0)
    58c4:	9a 01       	movw	r18, r20
    58c6:	27 70       	andi	r18, 0x07	; 7
    58c8:	33 27       	eor	r19, r19
    58ca:	23 2b       	or	r18, r19
    58cc:	09 f4       	brne	.+2      	; 0x58d0 <Reader14443ACodecTask+0x54c>
            Buffer++;
    58ce:	31 96       	adiw	r30, 0x01	; 1
    Insert1(); // SOC
    Insert0();

    uint16_t i;
    uint8_t last = 0;
    for (i = 1; i <= count; i++)
    58d0:	4f 5f       	subi	r20, 0xFF	; 255
    58d2:	5f 4f       	sbci	r21, 0xFF	; 255
    58d4:	67 cf       	rjmp	.-306    	; 0x57a4 <Reader14443ACodecTask+0x420>
        *Buffer >>= 1;
        if ((i % 8) == 0)
            Buffer++;
    }

    if (last == 0) // EOC
    58d6:	81 11       	cpse	r24, r1
    58d8:	29 c0       	rjmp	.+82     	; 0x592c <Reader14443ACodecTask+0x5a8>
    *CodecBufferPtr++ = SampleRegister;
}

INLINE void Insert1(void)
{
    SampleRegister = (SampleRegister >> 1) | 0x80;
    58da:	86 b1       	in	r24, 0x06	; 6
    58dc:	86 95       	lsr	r24
    58de:	80 68       	ori	r24, 0x80	; 128
    58e0:	86 b9       	out	0x06, r24	; 6
    if (++BitCount % 8)
    58e2:	84 b1       	in	r24, 0x04	; 4
    58e4:	95 b1       	in	r25, 0x05	; 5
    58e6:	01 96       	adiw	r24, 0x01	; 1
    58e8:	84 b9       	out	0x04, r24	; 4
    58ea:	95 b9       	out	0x05, r25	; 5
    58ec:	87 70       	andi	r24, 0x07	; 7
    58ee:	99 27       	eor	r25, r25
    58f0:	89 2b       	or	r24, r25
    58f2:	41 f4       	brne	.+16     	; 0x5904 <Reader14443ACodecTask+0x580>
        return;
    *CodecBufferPtr++ = SampleRegister;
    58f4:	ea b1       	in	r30, 0x0a	; 10
    58f6:	fb b1       	in	r31, 0x0b	; 11
    58f8:	cf 01       	movw	r24, r30
    58fa:	01 96       	adiw	r24, 0x01	; 1
    58fc:	8a b9       	out	0x0a, r24	; 10
    58fe:	9b b9       	out	0x0b, r25	; 11
    5900:	86 b1       	in	r24, 0x06	; 6
    5902:	80 83       	st	Z, r24
    Flags.Start = false;
}

INLINE void Insert0(void)
{
    SampleRegister >>= 1;
    5904:	86 b1       	in	r24, 0x06	; 6
    5906:	86 95       	lsr	r24
    5908:	86 b9       	out	0x06, r24	; 6
    if (++BitCount % 8)
    590a:	84 b1       	in	r24, 0x04	; 4
    590c:	95 b1       	in	r25, 0x05	; 5
    590e:	01 96       	adiw	r24, 0x01	; 1
    5910:	84 b9       	out	0x04, r24	; 4
    5912:	95 b9       	out	0x05, r25	; 5
    5914:	87 70       	andi	r24, 0x07	; 7
    5916:	99 27       	eor	r25, r25
    5918:	89 2b       	or	r24, r25
    591a:	41 f4       	brne	.+16     	; 0x592c <Reader14443ACodecTask+0x5a8>
        return;
    *CodecBufferPtr++ = SampleRegister;
    591c:	ea b1       	in	r30, 0x0a	; 10
    591e:	fb b1       	in	r31, 0x0b	; 11
    5920:	cf 01       	movw	r24, r30
    5922:	01 96       	adiw	r24, 0x01	; 1
    5924:	8a b9       	out	0x0a, r24	; 10
    5926:	9b b9       	out	0x0b, r25	; 11
    5928:	86 b1       	in	r24, 0x06	; 6
    592a:	80 83       	st	Z, r24
    {
        Insert1();
        Insert0();
    }

    if (BitCount % 8)
    592c:	84 b1       	in	r24, 0x04	; 4
    592e:	95 b1       	in	r25, 0x05	; 5
    5930:	87 70       	andi	r24, 0x07	; 7
    5932:	99 27       	eor	r25, r25
    5934:	89 2b       	or	r24, r25
    5936:	c9 f0       	breq	.+50     	; 0x596a <Reader14443ACodecTask+0x5e6>
        CodecBuffer[BitCount / 8] = SampleRegister >> (8 - (BitCount % 8));
    5938:	e4 b1       	in	r30, 0x04	; 4
    593a:	f5 b1       	in	r31, 0x05	; 5
    593c:	86 b1       	in	r24, 0x06	; 6
    593e:	44 b1       	in	r20, 0x04	; 4
    5940:	55 b1       	in	r21, 0x05	; 5
    5942:	93 e0       	ldi	r25, 0x03	; 3
    5944:	f6 95       	lsr	r31
    5946:	e7 95       	ror	r30
    5948:	9a 95       	dec	r25
    594a:	e1 f7       	brne	.-8      	; 0x5944 <Reader14443ACodecTask+0x5c0>
    594c:	ed 52       	subi	r30, 0x2D	; 45
    594e:	fe 4c       	sbci	r31, 0xCE	; 206
    5950:	90 e0       	ldi	r25, 0x00	; 0
    5952:	47 70       	andi	r20, 0x07	; 7
    5954:	55 27       	eor	r21, r21
    5956:	28 e0       	ldi	r18, 0x08	; 8
    5958:	30 e0       	ldi	r19, 0x00	; 0
    595a:	24 1b       	sub	r18, r20
    595c:	35 0b       	sbc	r19, r21
    595e:	02 c0       	rjmp	.+4      	; 0x5964 <Reader14443ACodecTask+0x5e0>
    5960:	95 95       	asr	r25
    5962:	87 95       	ror	r24
    5964:	2a 95       	dec	r18
    5966:	e2 f7       	brpl	.-8      	; 0x5960 <Reader14443ACodecTask+0x5dc>
    5968:	80 83       	st	Z, r24
            LogEntry(LOG_INFO_CODEC_TX_DATA_W_PARITY, CodecBuffer, (BitCount + 7) / 8);

            /* Set state and start timer for Miller encoding. */
            // Send bits to card using TCD0_CCB interrupt (See Reader14443-ISR.S)
            BufferToSequence();
            State = STATE_MILLER_SEND;
    596a:	81 e0       	ldi	r24, 0x01	; 1
    596c:	80 93 a2 2c 	sts	0x2CA2, r24
            CodecBufferPtr = CodecBuffer;
    5970:	83 ed       	ldi	r24, 0xD3	; 211
    5972:	91 e3       	ldi	r25, 0x31	; 49
    5974:	8a b9       	out	0x0a, r24	; 10
    5976:	9b b9       	out	0x0b, r25	; 11
            CODEC_TIMER_SAMPLING.INTFLAGS = TC0_CCBIF_bm;
    5978:	80 e2       	ldi	r24, 0x20	; 32
    597a:	80 93 0c 09 	sts	0x090C, r24
            CODEC_TIMER_SAMPLING.INTCTRLB = TC_CCBINTLVL_HI_gc;
    597e:	8c e0       	ldi	r24, 0x0C	; 12
    5980:	80 93 07 09 	sts	0x0907, r24
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    5984:	85 e5       	ldi	r24, 0x55	; 85
    5986:	8a 95       	dec	r24
    5988:	f1 f7       	brne	.-4      	; 0x5986 <Reader14443ACodecTask+0x602>
            _delay_loop_1(85);
        }
    }
}
    598a:	d3 95       	inc	r29
    598c:	cd bf       	out	0x3d, r28	; 61
    598e:	de bf       	out	0x3e, r29	; 62
    5990:	df 91       	pop	r29
    5992:	cf 91       	pop	r28
    5994:	1f 91       	pop	r17
    5996:	0f 91       	pop	r16
    5998:	08 95       	ret

0000599a <Reader14443ACodecStart>:

void Reader14443ACodecStart(void)
{
    /* Application wants us to start a card transaction */
    BitCount = 0;
    599a:	14 b8       	out	0x04, r1	; 4
    599c:	15 b8       	out	0x05, r1	; 5
    Flags.Start = true;
    599e:	81 e0       	ldi	r24, 0x01	; 1
    59a0:	80 93 a5 2c 	sts	0x2CA5, r24

    CodecReaderFieldStart();
    59a4:	0c 94 bf 23 	jmp	0x477e	; 0x477e <CodecReaderFieldStart>

000059a8 <Reader14443ACodecReset>:


// End of Card-> reader communication and enter frame delay time
INLINE void Reader14443A_EOC(void)
{
    CODEC_TIMER_LOADMOD.INTCTRLB = 0;
    59a8:	10 92 07 0a 	sts	0x0A07, r1
    CODEC_TIMER_LOADMOD.CTRLA = TC_CLKSEL_OFF_gc;
    59ac:	10 92 00 0a 	sts	0x0A00, r1
    CODEC_TIMER_TIMESTAMPS.INTCTRLB = 0;
    59b0:	10 92 47 09 	sts	0x0947, r1
    CODEC_TIMER_TIMESTAMPS.CTRLA = TC_CLKSEL_OFF_gc;
    59b4:	10 92 40 09 	sts	0x0940, r1
    ACA.AC1CTRL &= ~AC_ENABLE_bm;
    59b8:	80 91 81 03 	lds	r24, 0x0381
    59bc:	8e 7f       	andi	r24, 0xFE	; 254
    59be:	80 93 81 03 	sts	0x0381, r24

    if (BitCount & 1)
    59c2:	84 b1       	in	r24, 0x04	; 4
    59c4:	95 b1       	in	r25, 0x05	; 5
    59c6:	80 ff       	sbrs	r24, 0
    59c8:	1a c0       	rjmp	.+52     	; 0x59fe <Reader14443ACodecReset+0x56>
    {
        if (SampleRegister & 0x80)
    59ca:	37 9b       	sbis	0x06, 7	; 6
    59cc:	03 c0       	rjmp	.+6      	; 0x59d4 <Reader14443ACodecReset+0x2c>
    Flags.Start = false;
}

INLINE void Insert0(void)
{
    SampleRegister >>= 1;
    59ce:	86 b1       	in	r24, 0x06	; 6
    59d0:	86 95       	lsr	r24
    59d2:	03 c0       	rjmp	.+6      	; 0x59da <Reader14443ACodecReset+0x32>
    *CodecBufferPtr++ = SampleRegister;
}

INLINE void Insert1(void)
{
    SampleRegister = (SampleRegister >> 1) | 0x80;
    59d4:	86 b1       	in	r24, 0x06	; 6
    59d6:	86 95       	lsr	r24
    59d8:	80 68       	ori	r24, 0x80	; 128
    59da:	86 b9       	out	0x06, r24	; 6
    if (++BitCount % 8)
    59dc:	84 b1       	in	r24, 0x04	; 4
    59de:	95 b1       	in	r25, 0x05	; 5
    59e0:	01 96       	adiw	r24, 0x01	; 1
    59e2:	84 b9       	out	0x04, r24	; 4
    59e4:	95 b9       	out	0x05, r25	; 5
    59e6:	87 70       	andi	r24, 0x07	; 7
    59e8:	99 27       	eor	r25, r25
    59ea:	89 2b       	or	r24, r25
    59ec:	41 f4       	brne	.+16     	; 0x59fe <Reader14443ACodecReset+0x56>
        return;
    *CodecBufferPtr++ = SampleRegister;
    59ee:	ea b1       	in	r30, 0x0a	; 10
    59f0:	fb b1       	in	r31, 0x0b	; 11
    59f2:	cf 01       	movw	r24, r30
    59f4:	01 96       	adiw	r24, 0x01	; 1
    59f6:	8a b9       	out	0x0a, r24	; 10
    59f8:	9b b9       	out	0x0b, r25	; 11
    59fa:	86 b1       	in	r24, 0x06	; 6
    59fc:	80 83       	st	Z, r24
            Insert0();
        else
            Insert1();
    }

    if (BitCount % 8) // copy the last byte, if there is an incomplete byte
    59fe:	84 b1       	in	r24, 0x04	; 4
    5a00:	95 b1       	in	r25, 0x05	; 5
    5a02:	87 70       	andi	r24, 0x07	; 7
    5a04:	99 27       	eor	r25, r25
    5a06:	89 2b       	or	r24, r25
    5a08:	c9 f0       	breq	.+50     	; 0x5a3c <Reader14443ACodecReset+0x94>
        CodecBuffer[BitCount / 8] = SampleRegister >> (8 - (BitCount % 8));
    5a0a:	e4 b1       	in	r30, 0x04	; 4
    5a0c:	f5 b1       	in	r31, 0x05	; 5
    5a0e:	86 b1       	in	r24, 0x06	; 6
    5a10:	44 b1       	in	r20, 0x04	; 4
    5a12:	55 b1       	in	r21, 0x05	; 5
    5a14:	93 e0       	ldi	r25, 0x03	; 3
    5a16:	f6 95       	lsr	r31
    5a18:	e7 95       	ror	r30
    5a1a:	9a 95       	dec	r25
    5a1c:	e1 f7       	brne	.-8      	; 0x5a16 <Reader14443ACodecReset+0x6e>
    5a1e:	ed 52       	subi	r30, 0x2D	; 45
    5a20:	fe 4c       	sbci	r31, 0xCE	; 206
    5a22:	90 e0       	ldi	r25, 0x00	; 0
    5a24:	47 70       	andi	r20, 0x07	; 7
    5a26:	55 27       	eor	r21, r21
    5a28:	28 e0       	ldi	r18, 0x08	; 8
    5a2a:	30 e0       	ldi	r19, 0x00	; 0
    5a2c:	24 1b       	sub	r18, r20
    5a2e:	35 0b       	sbc	r19, r21
    5a30:	02 c0       	rjmp	.+4      	; 0x5a36 <Reader14443ACodecReset+0x8e>
    5a32:	95 95       	asr	r25
    5a34:	87 95       	ror	r24
    5a36:	2a 95       	dec	r18
    5a38:	e2 f7       	brpl	.-8      	; 0x5a32 <Reader14443ACodecReset+0x8a>
    5a3a:	80 83       	st	Z, r24
    Flags.RxDone = true;
    5a3c:	81 e0       	ldi	r24, 0x01	; 1
    5a3e:	80 93 a6 2c 	sts	0x2CA6, r24
    Flags.RxPending = false;
    5a42:	10 92 a7 2c 	sts	0x2CA7, r1

    // set up timer that forces the minimum frame delay time from PICC to PCD
    CODEC_TIMER_LOADMOD.PER = 0xFFFF;
    5a46:	8f ef       	ldi	r24, 0xFF	; 255
    5a48:	9f ef       	ldi	r25, 0xFF	; 255
    5a4a:	80 93 26 0a 	sts	0x0A26, r24
    5a4e:	90 93 27 0a 	sts	0x0A27, r25
    CODEC_TIMER_LOADMOD.CNT = 0;
    5a52:	10 92 20 0a 	sts	0x0A20, r1
    5a56:	10 92 21 0a 	sts	0x0A21, r1
    CODEC_TIMER_LOADMOD.INTCTRLA = 0;
    5a5a:	10 92 06 0a 	sts	0x0A06, r1
    CODEC_TIMER_LOADMOD.INTCTRLB = 0;
    5a5e:	10 92 07 0a 	sts	0x0A07, r1
    CODEC_TIMER_LOADMOD.CTRLD = 0;
    5a62:	10 92 03 0a 	sts	0x0A03, r1
    CODEC_TIMER_LOADMOD.CTRLA = ISO14443A_PICC_TO_PCD_FDT_PRESCALER;
    5a66:	84 e0       	ldi	r24, 0x04	; 4
    5a68:	80 93 00 0a 	sts	0x0A00, r24

    State = STATE_FDT;
    5a6c:	83 e0       	ldi	r24, 0x03	; 3
    5a6e:	80 93 a2 2c 	sts	0x2CA2, r24
}

void Reader14443ACodecReset(void)
{
    Reader14443A_EOC(); // this breaks every interrupt etc.
    State = STATE_IDLE;
    5a72:	10 92 a2 2c 	sts	0x2CA2, r1
    Flags.RxDone = false;
    5a76:	10 92 a6 2c 	sts	0x2CA6, r1
    Flags.Start = false;
    5a7a:	10 92 a5 2c 	sts	0x2CA5, r1
    CodecReaderFieldStop();
    5a7e:	0c 94 e4 23 	jmp	0x47c8	; 0x47c8 <CodecReaderFieldStop>

00005a82 <isr_SniffISO14443_2A_CODEC_TIMER_LOADMOD_CCB_VECT>:
// if the half bit duration is modulated, then add 1 to buffer
// if the half bit duration is not modulated, then add 0 to buffer
//ISR(CODEC_TIMER_LOADMOD_CCB_VECT) // pause found
void isr_SniffISO14443_2A_CODEC_TIMER_LOADMOD_CCB_VECT(void)
{
    uint8_t tmp = CODEC_TIMER_TIMESTAMPS.CNTL;
    5a82:	80 91 60 09 	lds	r24, 0x0960
    CODEC_TIMER_TIMESTAMPS.CNT = 0;
    5a86:	10 92 60 09 	sts	0x0960, r1
    5a8a:	10 92 61 09 	sts	0x0961, r1

    /* This needs to be done only on the first call,
     * but doing this only on a condition means wasting time, so we do it every time. */
    CODEC_TIMER_TIMESTAMPS.CTRLA = TC_CLKSEL_DIV4_gc;
    5a8e:	93 e0       	ldi	r25, 0x03	; 3
    5a90:	90 93 40 09 	sts	0x0940, r25

    // Remember, LSB is send first
    // If current raw bit count is odd, then the previous raw bit must be 0
    switch (tmp) // decide how many half bit periods have been modulations
    5a94:	81 35       	cpi	r24, 0x51	; 81
    5a96:	20 f4       	brcc	.+8      	; 0x5aa0 <isr_SniffISO14443_2A_CODEC_TIMER_LOADMOD_CCB_VECT+0x1e>
    5a98:	81 33       	cpi	r24, 0x31	; 49
    5a9a:	08 f4       	brcc	.+2      	; 0x5a9e <isr_SniffISO14443_2A_CODEC_TIMER_LOADMOD_CCB_VECT+0x1c>
    5a9c:	a7 c0       	rjmp	.+334    	; 0x5bec <isr_SniffISO14443_2A_CODEC_TIMER_LOADMOD_CCB_VECT+0x16a>
    5a9e:	03 c0       	rjmp	.+6      	; 0x5aa6 <isr_SniffISO14443_2A_CODEC_TIMER_LOADMOD_CCB_VECT+0x24>
    5aa0:	81 37       	cpi	r24, 0x71	; 113
    5aa2:	58 f1       	brcs	.+86     	; 0x5afa <isr_SniffISO14443_2A_CODEC_TIMER_LOADMOD_CCB_VECT+0x78>
    5aa4:	65 c0       	rjmp	.+202    	; 0x5b70 <isr_SniffISO14443_2A_CODEC_TIMER_LOADMOD_CCB_VECT+0xee>
        case 0 ... 48: // 32 ticks is one half of a bit period
            return;

        case 49 ... 80: // 64 ticks are a full bit period
            // Got 01
            if(rawBitCount & 1){
    5aa6:	80 91 a8 2c 	lds	r24, 0x2CA8
    5aaa:	90 91 a9 2c 	lds	r25, 0x2CA9
    5aae:	80 ff       	sbrs	r24, 0
    5ab0:	0a c0       	rjmp	.+20     	; 0x5ac6 <isr_SniffISO14443_2A_CODEC_TIMER_LOADMOD_CCB_VECT+0x44>
                // 01 + 0 -> 0 10
                // 10 -> 1, last 0 is ignored
                if(rawBitCount > 1) {
    5ab2:	80 91 a8 2c 	lds	r24, 0x2CA8
    5ab6:	90 91 a9 2c 	lds	r25, 0x2CA9
    5aba:	02 97       	sbiw	r24, 0x02	; 2
    5abc:	c0 f0       	brcs	.+48     	; 0x5aee <isr_SniffISO14443_2A_CODEC_TIMER_LOADMOD_CCB_VECT+0x6c>
    *CardBufferPtr++ = CardSampleR;
}

INLINE void Insert1(void)
{
    CardSampleR = (CardSampleR >> 1) | 0x80;
    5abe:	85 b1       	in	r24, 0x05	; 5
    5ac0:	86 95       	lsr	r24
    5ac2:	80 68       	ori	r24, 0x80	; 128
    5ac4:	02 c0       	rjmp	.+4      	; 0x5aca <isr_SniffISO14443_2A_CODEC_TIMER_LOADMOD_CCB_VECT+0x48>



INLINE void Insert0(void)
{
    CardSampleR >>= 1;
    5ac6:	85 b1       	in	r24, 0x05	; 5
    5ac8:	86 95       	lsr	r24
    5aca:	85 b9       	out	0x05, r24	; 5
    if (++BitCount % 8)
    5acc:	86 b1       	in	r24, 0x06	; 6
    5ace:	97 b1       	in	r25, 0x07	; 7
    5ad0:	01 96       	adiw	r24, 0x01	; 1
    5ad2:	86 b9       	out	0x06, r24	; 6
    5ad4:	97 b9       	out	0x07, r25	; 7
    5ad6:	87 70       	andi	r24, 0x07	; 7
    5ad8:	99 27       	eor	r25, r25
    5ada:	89 2b       	or	r24, r25
    5adc:	41 f4       	brne	.+16     	; 0x5aee <isr_SniffISO14443_2A_CODEC_TIMER_LOADMOD_CCB_VECT+0x6c>
        return;
    *CardBufferPtr++ = CardSampleR;
    5ade:	ec b1       	in	r30, 0x0c	; 12
    5ae0:	fd b1       	in	r31, 0x0d	; 13
    5ae2:	cf 01       	movw	r24, r30
    5ae4:	01 96       	adiw	r24, 0x01	; 1
    5ae6:	8c b9       	out	0x0c, r24	; 12
    5ae8:	9d b9       	out	0x0d, r25	; 13
    5aea:	85 b1       	in	r24, 0x05	; 5
    5aec:	80 83       	st	Z, r24
            } else{
                // Current sampled bit count is even, decode directly
                // 01 -> 0
                Insert0();
            }
            rawBitCount += 2;
    5aee:	80 91 a8 2c 	lds	r24, 0x2CA8
    5af2:	90 91 a9 2c 	lds	r25, 0x2CA9
    5af6:	02 96       	adiw	r24, 0x02	; 2
    5af8:	75 c0       	rjmp	.+234    	; 0x5be4 <isr_SniffISO14443_2A_CODEC_TIMER_LOADMOD_CCB_VECT+0x162>
            return;

        case 81 ... 112: // 96 ticks are 3 half bit periods
            if (rawBitCount & 1) {
    5afa:	80 91 a8 2c 	lds	r24, 0x2CA8
    5afe:	90 91 a9 2c 	lds	r25, 0x2CA9
    5b02:	80 ff       	sbrs	r24, 0
    5b04:	1b c0       	rjmp	.+54     	; 0x5b3c <isr_SniffISO14443_2A_CODEC_TIMER_LOADMOD_CCB_VECT+0xba>
                // Current sampled bit count is odd
                // Got 011
                // 011 + 0 -> 01 10 -> 01
                if(rawBitCount > 1) {
    5b06:	80 91 a8 2c 	lds	r24, 0x2CA8
    5b0a:	90 91 a9 2c 	lds	r25, 0x2CA9
    5b0e:	02 97       	sbiw	r24, 0x02	; 2
    5b10:	a8 f0       	brcs	.+42     	; 0x5b3c <isr_SniffISO14443_2A_CODEC_TIMER_LOADMOD_CCB_VECT+0xba>
    *CardBufferPtr++ = CardSampleR;
}

INLINE void Insert1(void)
{
    CardSampleR = (CardSampleR >> 1) | 0x80;
    5b12:	85 b1       	in	r24, 0x05	; 5
    5b14:	86 95       	lsr	r24
    5b16:	80 68       	ori	r24, 0x80	; 128
    5b18:	85 b9       	out	0x05, r24	; 5
    if (++BitCount % 8)
    5b1a:	86 b1       	in	r24, 0x06	; 6
    5b1c:	97 b1       	in	r25, 0x07	; 7
    5b1e:	01 96       	adiw	r24, 0x01	; 1
    5b20:	86 b9       	out	0x06, r24	; 6
    5b22:	97 b9       	out	0x07, r25	; 7
    5b24:	87 70       	andi	r24, 0x07	; 7
    5b26:	99 27       	eor	r25, r25
    5b28:	89 2b       	or	r24, r25
    5b2a:	41 f4       	brne	.+16     	; 0x5b3c <isr_SniffISO14443_2A_CODEC_TIMER_LOADMOD_CCB_VECT+0xba>
        return;
    *CardBufferPtr++ = CardSampleR;
    5b2c:	ec b1       	in	r30, 0x0c	; 12
    5b2e:	fd b1       	in	r31, 0x0d	; 13
    5b30:	cf 01       	movw	r24, r30
    5b32:	01 96       	adiw	r24, 0x01	; 1
    5b34:	8c b9       	out	0x0c, r24	; 12
    5b36:	9d b9       	out	0x0d, r25	; 13
    5b38:	85 b1       	in	r24, 0x05	; 5
    5b3a:	80 83       	st	Z, r24



INLINE void Insert0(void)
{
    CardSampleR >>= 1;
    5b3c:	85 b1       	in	r24, 0x05	; 5
    5b3e:	86 95       	lsr	r24
    5b40:	85 b9       	out	0x05, r24	; 5
    if (++BitCount % 8)
    5b42:	86 b1       	in	r24, 0x06	; 6
    5b44:	97 b1       	in	r25, 0x07	; 7
    5b46:	01 96       	adiw	r24, 0x01	; 1
    5b48:	86 b9       	out	0x06, r24	; 6
    5b4a:	97 b9       	out	0x07, r25	; 7
    5b4c:	87 70       	andi	r24, 0x07	; 7
    5b4e:	99 27       	eor	r25, r25
    5b50:	89 2b       	or	r24, r25
    5b52:	41 f4       	brne	.+16     	; 0x5b64 <isr_SniffISO14443_2A_CODEC_TIMER_LOADMOD_CCB_VECT+0xe2>
        return;
    *CardBufferPtr++ = CardSampleR;
    5b54:	ec b1       	in	r30, 0x0c	; 12
    5b56:	fd b1       	in	r31, 0x0d	; 13
    5b58:	cf 01       	movw	r24, r30
    5b5a:	01 96       	adiw	r24, 0x01	; 1
    5b5c:	8c b9       	out	0x0c, r24	; 12
    5b5e:	9d b9       	out	0x0d, r25	; 13
    5b60:	85 b1       	in	r24, 0x05	; 5
    5b62:	80 83       	st	Z, r24
                // Got 001
                // 001 -> 0 01, The last 0 is ignored
                // 01 -> 0
                Insert0();
            }
            rawBitCount += 3;
    5b64:	80 91 a8 2c 	lds	r24, 0x2CA8
    5b68:	90 91 a9 2c 	lds	r25, 0x2CA9
    5b6c:	03 96       	adiw	r24, 0x03	; 3
    5b6e:	3a c0       	rjmp	.+116    	; 0x5be4 <isr_SniffISO14443_2A_CODEC_TIMER_LOADMOD_CCB_VECT+0x162>

            return;

        default: // every value over 96 + 16 (tolerance) is considered to be 4 half bit periods
            // Got 00 11
            if(rawBitCount & 1){
    5b70:	80 91 a8 2c 	lds	r24, 0x2CA8
    5b74:	90 91 a9 2c 	lds	r25, 0x2CA9
    5b78:	80 ff       	sbrs	r24, 0
    5b7a:	2f c0       	rjmp	.+94     	; 0x5bda <isr_SniffISO14443_2A_CODEC_TIMER_LOADMOD_CCB_VECT+0x158>
                // 00 11 + 0 -> 0 01 10
                // 01 -> 0, 10 -> 1, Ignore last 0
                if(rawBitCount > 1) {
    5b7c:	80 91 a8 2c 	lds	r24, 0x2CA8
    5b80:	90 91 a9 2c 	lds	r25, 0x2CA9
    5b84:	02 97       	sbiw	r24, 0x02	; 2
    5b86:	a8 f0       	brcs	.+42     	; 0x5bb2 <isr_SniffISO14443_2A_CODEC_TIMER_LOADMOD_CCB_VECT+0x130>
    *CardBufferPtr++ = CardSampleR;
}

INLINE void Insert1(void)
{
    CardSampleR = (CardSampleR >> 1) | 0x80;
    5b88:	85 b1       	in	r24, 0x05	; 5
    5b8a:	86 95       	lsr	r24
    5b8c:	80 68       	ori	r24, 0x80	; 128
    5b8e:	85 b9       	out	0x05, r24	; 5
    if (++BitCount % 8)
    5b90:	86 b1       	in	r24, 0x06	; 6
    5b92:	97 b1       	in	r25, 0x07	; 7
    5b94:	01 96       	adiw	r24, 0x01	; 1
    5b96:	86 b9       	out	0x06, r24	; 6
    5b98:	97 b9       	out	0x07, r25	; 7
    5b9a:	87 70       	andi	r24, 0x07	; 7
    5b9c:	99 27       	eor	r25, r25
    5b9e:	89 2b       	or	r24, r25
    5ba0:	41 f4       	brne	.+16     	; 0x5bb2 <isr_SniffISO14443_2A_CODEC_TIMER_LOADMOD_CCB_VECT+0x130>
        return;
    *CardBufferPtr++ = CardSampleR;
    5ba2:	ec b1       	in	r30, 0x0c	; 12
    5ba4:	fd b1       	in	r31, 0x0d	; 13
    5ba6:	cf 01       	movw	r24, r30
    5ba8:	01 96       	adiw	r24, 0x01	; 1
    5baa:	8c b9       	out	0x0c, r24	; 12
    5bac:	9d b9       	out	0x0d, r25	; 13
    5bae:	85 b1       	in	r24, 0x05	; 5
    5bb0:	80 83       	st	Z, r24



INLINE void Insert0(void)
{
    CardSampleR >>= 1;
    5bb2:	85 b1       	in	r24, 0x05	; 5
    5bb4:	86 95       	lsr	r24
    5bb6:	85 b9       	out	0x05, r24	; 5
    if (++BitCount % 8)
    5bb8:	86 b1       	in	r24, 0x06	; 6
    5bba:	97 b1       	in	r25, 0x07	; 7
    5bbc:	01 96       	adiw	r24, 0x01	; 1
    5bbe:	86 b9       	out	0x06, r24	; 6
    5bc0:	97 b9       	out	0x07, r25	; 7
    5bc2:	87 70       	andi	r24, 0x07	; 7
    5bc4:	99 27       	eor	r25, r25
    5bc6:	89 2b       	or	r24, r25
    5bc8:	41 f4       	brne	.+16     	; 0x5bda <isr_SniffISO14443_2A_CODEC_TIMER_LOADMOD_CCB_VECT+0x158>
        return;
    *CardBufferPtr++ = CardSampleR;
    5bca:	ec b1       	in	r30, 0x0c	; 12
    5bcc:	fd b1       	in	r31, 0x0d	; 13
    5bce:	cf 01       	movw	r24, r30
    5bd0:	01 96       	adiw	r24, 0x01	; 1
    5bd2:	8c b9       	out	0x0c, r24	; 12
    5bd4:	9d b9       	out	0x0d, r25	; 13
    5bd6:	85 b1       	in	r24, 0x05	; 5
    5bd8:	80 83       	st	Z, r24
            } else {
                // Should not happen
                // If modulation is correct,
                // there should not be a full bit period modulation in even bit count
            }
            rawBitCount += 4;
    5bda:	80 91 a8 2c 	lds	r24, 0x2CA8
    5bde:	90 91 a9 2c 	lds	r25, 0x2CA9
    5be2:	04 96       	adiw	r24, 0x04	; 4
    5be4:	80 93 a8 2c 	sts	0x2CA8, r24
    5be8:	90 93 a9 2c 	sts	0x2CA9, r25
    5bec:	08 95       	ret

00005bee <__vector_35>:
    CODEC_TIMER_SAMPLING.INTFLAGS = TC0_CCDIF_bm;
}


// Find first pause and start sampling
ISR(CODEC_DEMOD_IN_INT1_VECT) {
    5bee:	1f 92       	push	r1
    5bf0:	0f 92       	push	r0
    5bf2:	0f b6       	in	r0, 0x3f	; 63
    5bf4:	0f 92       	push	r0
    5bf6:	11 24       	eor	r1, r1
    5bf8:	08 b6       	in	r0, 0x38	; 56
    5bfa:	0f 92       	push	r0
    5bfc:	18 be       	out	0x38, r1	; 56
    5bfe:	0b b6       	in	r0, 0x3b	; 59
    5c00:	0f 92       	push	r0
    5c02:	1b be       	out	0x3b, r1	; 59
    5c04:	8f 93       	push	r24
    5c06:	9f 93       	push	r25
    5c08:	ef 93       	push	r30
    5c0a:	ff 93       	push	r31
    PORTE.OUTSET = PIN2_bm;
    5c0c:	84 e0       	ldi	r24, 0x04	; 4
    5c0e:	80 93 85 06 	sts	0x0685, r24
     * XYZBUF mechanism of the xmega to automatically double the sampling rate on the
     * next overflow. For this we have to temporarily deactivate the automatical alignment
     * in order to catch next overflow event for updating the BUF registers.
     * We want to sample the demodulated data stream in the first quarter of the half-bit
     * where the pulsed miller encoded is located. */
    CODEC_TIMER_SAMPLING.CTRLD = TC_EVACT_OFF_gc;
    5c12:	e0 e0       	ldi	r30, 0x00	; 0
    5c14:	f9 e0       	ldi	r31, 0x09	; 9
    5c16:	13 82       	std	Z+3, r1	; 0x03
    CODEC_TIMER_SAMPLING.PERBUF = SAMPLE_RATE_SYSTEM_CYCLES/2 - 1; /* Half bit width */
    5c18:	8f e7       	ldi	r24, 0x7F	; 127
    5c1a:	90 e0       	ldi	r25, 0x00	; 0
    5c1c:	86 ab       	std	Z+54, r24	; 0x36
    5c1e:	97 ab       	std	Z+55, r25	; 0x37
    CODEC_TIMER_SAMPLING.CCDBUF = SAMPLE_RATE_SYSTEM_CYCLES/8 - 14 - 1; /* Compensate for DIGFILT and ISR prolog */
    5c20:	81 e1       	ldi	r24, 0x11	; 17
    5c22:	90 e0       	ldi	r25, 0x00	; 0
    5c24:	80 93 3e 09 	sts	0x093E, r24
    5c28:	90 93 3f 09 	sts	0x093F, r25

    /* Disable this interrupt */
    CODEC_DEMOD_IN_PORT.INT1MASK = 0;
    5c2c:	10 92 2b 06 	sts	0x062B, r1
}
    5c30:	ff 91       	pop	r31
    5c32:	ef 91       	pop	r30
    5c34:	9f 91       	pop	r25
    5c36:	8f 91       	pop	r24
    5c38:	0f 90       	pop	r0
    5c3a:	0b be       	out	0x3b, r0	; 59
    5c3c:	0f 90       	pop	r0
    5c3e:	08 be       	out	0x38, r0	; 56
    5c40:	0f 90       	pop	r0
    5c42:	0f be       	out	0x3f, r0	; 63
    5c44:	0f 90       	pop	r0
    5c46:	1f 90       	pop	r1
    5c48:	18 95       	reti

00005c4a <__vector_82>:

// Sampling with timer and demod
ISR(CODEC_TIMER_SAMPLING_CCD_VECT) {
    5c4a:	1f 92       	push	r1
    5c4c:	0f 92       	push	r0
    5c4e:	0f b6       	in	r0, 0x3f	; 63
    5c50:	0f 92       	push	r0
    5c52:	11 24       	eor	r1, r1
    5c54:	08 b6       	in	r0, 0x38	; 56
    5c56:	0f 92       	push	r0
    5c58:	18 be       	out	0x38, r1	; 56
    5c5a:	0b b6       	in	r0, 0x3b	; 59
    5c5c:	0f 92       	push	r0
    5c5e:	1b be       	out	0x3b, r1	; 59
    5c60:	2f 93       	push	r18
    5c62:	3f 93       	push	r19
    5c64:	4f 93       	push	r20
    5c66:	5f 93       	push	r21
    5c68:	8f 93       	push	r24
    5c6a:	9f 93       	push	r25
    5c6c:	ef 93       	push	r30
    5c6e:	ff 93       	push	r31
    /* This interrupt gets called twice for every bit to sample it. */
    uint8_t SamplePin = CODEC_DEMOD_IN_PORT.IN & CODEC_DEMOD_IN_MASK;
    5c70:	20 91 28 06 	lds	r18, 0x0628

    /* Shift sampled bit into sampling register */
    ReaderSampleR = (ReaderSampleR << 1) | (!SamplePin ? 0x01 : 0x00);
    5c74:	94 b1       	in	r25, 0x04	; 4
}

// Sampling with timer and demod
ISR(CODEC_TIMER_SAMPLING_CCD_VECT) {
    /* This interrupt gets called twice for every bit to sample it. */
    uint8_t SamplePin = CODEC_DEMOD_IN_PORT.IN & CODEC_DEMOD_IN_MASK;
    5c76:	26 70       	andi	r18, 0x06	; 6

    /* Shift sampled bit into sampling register */
    ReaderSampleR = (ReaderSampleR << 1) | (!SamplePin ? 0x01 : 0x00);
    5c78:	81 e0       	ldi	r24, 0x01	; 1
    5c7a:	09 f0       	breq	.+2      	; 0x5c7e <__vector_82+0x34>
    5c7c:	80 e0       	ldi	r24, 0x00	; 0
    5c7e:	99 0f       	add	r25, r25
    5c80:	89 2b       	or	r24, r25
    5c82:	84 b9       	out	0x04, r24	; 4

    if (SampleIdxRegister) {
    5c84:	83 b1       	in	r24, 0x03	; 3
    5c86:	88 23       	and	r24, r24
    5c88:	09 f4       	brne	.+2      	; 0x5c8c <__vector_82+0x42>
    5c8a:	e5 c0       	rjmp	.+458    	; 0x5e56 <__vector_82+0x20c>
        SampleIdxRegister = 0;
    5c8c:	13 b8       	out	0x03, r1	; 3
        /* Analyze the sampling register after 2 samples. */
        if ((ReaderSampleR & 0x07) == 0x07) {
    5c8e:	84 b1       	in	r24, 0x04	; 4
    5c90:	87 70       	andi	r24, 0x07	; 7
    5c92:	87 30       	cpi	r24, 0x07	; 7
    5c94:	09 f0       	breq	.+2      	; 0x5c98 <__vector_82+0x4e>
    5c96:	b5 c0       	rjmp	.+362    	; 0x5e02 <__vector_82+0x1b8>
            /* No carrier modulation for 3 sample points. EOC! */

            // Shutdown the Reader->Card Sniffing,
            // disable the sampling timer
            PORTE.OUTCLR = PIN2_bm;
    5c98:	84 e0       	ldi	r24, 0x04	; 4
    5c9a:	80 93 86 06 	sts	0x0686, r24



            CODEC_TIMER_SAMPLING.CTRLA = TC_CLKSEL_OFF_gc;
    5c9e:	10 92 00 09 	sts	0x0900, r1
            CODEC_TIMER_SAMPLING.INTFLAGS = TC0_CCDIF_bm;
    5ca2:	80 e8       	ldi	r24, 0x80	; 128
    5ca4:	80 93 0c 09 	sts	0x090C, r24
            CODEC_TIMER_SAMPLING.INTCTRLB = TC_CCDINTLVL_OFF_gc;
    5ca8:	10 92 07 09 	sts	0x0907, r1
            CODEC_DEMOD_IN_PORT.INTCTRL = 0;                        // Disable CODEC_DEMOD_IN_PORT interrupt
    5cac:	10 92 29 06 	sts	0x0629, r1
            // so no need to disable it again it here

            /* Determine if we did not receive a multiple of 8 bits.
             * If this is the case, right-align the remaining data and
             * store it into the buffer. */
            uint8_t RemainingBits = BitCount % 8;
    5cb0:	86 b1       	in	r24, 0x06	; 6
    5cb2:	97 b1       	in	r25, 0x07	; 7
    5cb4:	87 70       	andi	r24, 0x07	; 7
            if (RemainingBits != 0) {
    5cb6:	49 f0       	breq	.+18     	; 0x5cca <__vector_82+0x80>
                uint8_t NewDataRegister = DataRegister;
    5cb8:	90 b1       	in	r25, 0x00	; 0

                while (RemainingBits++ < 8) {
    5cba:	8f 5f       	subi	r24, 0xFF	; 255
    5cbc:	89 30       	cpi	r24, 0x09	; 9
    5cbe:	11 f0       	breq	.+4      	; 0x5cc4 <__vector_82+0x7a>
                    /* Pad with zeroes to right-align. */
                    NewDataRegister >>= 1;
    5cc0:	96 95       	lsr	r25
    5cc2:	fb cf       	rjmp	.-10     	; 0x5cba <__vector_82+0x70>
                }

                /* TODO: Prevent buffer overflow */
                *ReaderBufferPtr = NewDataRegister;
    5cc4:	e8 b1       	in	r30, 0x08	; 8
    5cc6:	f9 b1       	in	r31, 0x09	; 9
    5cc8:	90 83       	st	Z, r25
            }

            /* Signal, that we have finished sampling */
            ReaderBitCount = BitCount;
    5cca:	86 b1       	in	r24, 0x06	; 6
    5ccc:	97 b1       	in	r25, 0x07	; 7
    5cce:	80 93 ac 2c 	sts	0x2CAC, r24
    5cd2:	90 93 ad 2c 	sts	0x2CAD, r25

            // If we are have got data
            // Start Card->Reader Sniffing without waiting for the complete of CodecTask
            // Otherwise some bit will not be captured
            if (ReaderBitCount >= ISO14443A_MIN_BITS_PER_FRAME) {
    5cd6:	80 91 ac 2c 	lds	r24, 0x2CAC
    5cda:	90 91 ad 2c 	lds	r25, 0x2CAD
    5cde:	07 97       	sbiw	r24, 0x07	; 7
    5ce0:	08 f4       	brcc	.+2      	; 0x5ce4 <__vector_82+0x9a>
    5ce2:	5c c0       	rjmp	.+184    	; 0x5d9c <__vector_82+0x152>
                Flags.ReaderDataAvaliable = true;
    5ce4:	81 e0       	ldi	r24, 0x01	; 1
    5ce6:	80 93 b0 2c 	sts	0x2CB0, r24
{

    /* Initialize common peripherals and start listening
     * for incoming data. */

    CardBufferPtr = CodecBuffer2; // use GPIOR for faster access
    5cea:	23 ed       	ldi	r18, 0xD3	; 211
    5cec:	32 e3       	ldi	r19, 0x32	; 50
    5cee:	2c b9       	out	0x0c, r18	; 12
    5cf0:	3d b9       	out	0x0d, r19	; 13
    rawBitCount = 1; // FALSCH todo the first modulation of the SOC is "found" implicitly
    5cf2:	21 e0       	ldi	r18, 0x01	; 1
    5cf4:	30 e0       	ldi	r19, 0x00	; 0
    5cf6:	20 93 a8 2c 	sts	0x2CA8, r18
    5cfa:	30 93 a9 2c 	sts	0x2CA9, r19
    BitCount = 0;
    5cfe:	16 b8       	out	0x06, r1	; 6
    5d00:	17 b8       	out	0x07, r1	; 7
    CardSampleR = 0x00;
    5d02:	15 b8       	out	0x05, r1	; 5
     * bit halves had modulations since the last pause.
     */

    // Comparator ADC
    /* Configure and enable the analog comparator for finding pauses in the DEMOD signal. */
    ACA.AC0CTRL = AC_HSMODE_bm | AC_HYSMODE_NO_gc | AC_INTMODE_FALLING_gc | AC_ENABLE_bm;
    5d04:	99 e8       	ldi	r25, 0x89	; 137
    5d06:	90 93 80 03 	sts	0x0380, r25

    /* This timer will be used to detect the pauses between the modulation sequences. */
    CODEC_TIMER_LOADMOD.CTRLA = 0;
    5d0a:	10 92 00 0a 	sts	0x0A00, r1
    CODEC_TIMER_LOADMOD.CNT = 0;
    5d0e:	10 92 20 0a 	sts	0x0A20, r1
    5d12:	10 92 21 0a 	sts	0x0A21, r1
    CODEC_TIMER_LOADMOD.PER = 0xFFFF; // with 27.12 MHz this is exactly one half bit width
    5d16:	4f ef       	ldi	r20, 0xFF	; 255
    5d18:	5f ef       	ldi	r21, 0xFF	; 255
    5d1a:	40 93 26 0a 	sts	0x0A26, r20
    5d1e:	50 93 27 0a 	sts	0x0A27, r21
    CODEC_TIMER_LOADMOD.CCB = 95; // with 27.12 MHz this is 3/4 of a half bit width
    5d22:	2f e5       	ldi	r18, 0x5F	; 95
    5d24:	30 e0       	ldi	r19, 0x00	; 0
    5d26:	20 93 2a 0a 	sts	0x0A2A, r18
    5d2a:	30 93 2b 0a 	sts	0x0A2B, r19
    CODEC_TIMER_LOADMOD.INTCTRLA = 0;
    5d2e:	10 92 06 0a 	sts	0x0A06, r1
    CODEC_TIMER_LOADMOD.INTFLAGS = TC1_CCBIF_bm;
    5d32:	20 e2       	ldi	r18, 0x20	; 32
    5d34:	20 93 0c 0a 	sts	0x0A0C, r18
    CODEC_TIMER_LOADMOD.INTCTRLB = TC_CCBINTLVL_HI_gc;
    5d38:	9c e0       	ldi	r25, 0x0C	; 12
    5d3a:	90 93 07 0a 	sts	0x0A07, r25

    /* This timer will be used to find out how many bit halfs since the last pause have been passed. */
    CODEC_TIMER_TIMESTAMPS.CNT = 0;                         // Reset timer
    5d3e:	10 92 60 09 	sts	0x0960, r1
    5d42:	10 92 61 09 	sts	0x0961, r1
    CODEC_TIMER_TIMESTAMPS.PER = 0xFFFF;
    5d46:	40 93 66 09 	sts	0x0966, r20
    5d4a:	50 93 67 09 	sts	0x0967, r21
    CODEC_TIMER_TIMESTAMPS.CCB = 160;
    5d4e:	40 ea       	ldi	r20, 0xA0	; 160
    5d50:	50 e0       	ldi	r21, 0x00	; 0
    5d52:	40 93 6a 09 	sts	0x096A, r20
    5d56:	50 93 6b 09 	sts	0x096B, r21
    CODEC_TIMER_TIMESTAMPS.INTCTRLA = 0;
    5d5a:	10 92 46 09 	sts	0x0946, r1
    CODEC_TIMER_TIMESTAMPS.INTFLAGS = TC1_CCBIF_bm;         // Clear interrupt flag
    5d5e:	20 93 4c 09 	sts	0x094C, r18
//    CODEC_TIMER_TIMESTAMPS.INTCTRLB = TC_CCBINTLVL_LO_gc;
        CODEC_TIMER_TIMESTAMPS.INTCTRLB = TC_CCBINTLVL_HI_gc;
    5d62:	90 93 47 09 	sts	0x0947, r25

    /* Use the event system for resetting the pause-detecting timer. */
    EVSYS.CH2MUX = EVSYS_CHMUX_ACA_CH0_gc; // on every ACA_AC0 INT
    5d66:	90 e1       	ldi	r25, 0x10	; 16
    5d68:	90 93 82 01 	sts	0x0182, r25
    EVSYS.CH2CTRL = EVSYS_DIGFILT_1SAMPLE_gc;
    5d6c:	10 92 8a 01 	sts	0x018A, r1

    /* Enable the AC interrupt, which either finds the SOC and then starts the pause-finding timer,
     * or it is triggered before the SOC, which mostly isn't bad at all, since the first pause
     * needs to be found. */
    ACA.AC1CTRL = 0;
    5d70:	10 92 81 03 	sts	0x0381, r1
    ACA.STATUS = AC_AC0IF_bm;
    5d74:	80 93 87 03 	sts	0x0387, r24
    ACA.AC0CTRL = AC_HSMODE_bm | AC_HYSMODE_NO_gc | AC_INTMODE_FALLING_gc | AC_INTLVL_HI_gc | AC_ENABLE_bm;
    5d78:	89 eb       	ldi	r24, 0xB9	; 185
    5d7a:	80 93 80 03 	sts	0x0380, r24
    5d7e:	8e b1       	in	r24, 0x0e	; 14
    5d80:	9f b1       	in	r25, 0x0f	; 15
    5d82:	20 91 08 04 	lds	r18, 0x0408
    5d86:	30 91 09 04 	lds	r19, 0x0409
    5d8a:	82 2b       	or	r24, r18
    5d8c:	93 2b       	or	r25, r19

    RxPendingSince = SystemGetSysTick();
    5d8e:	80 93 ae 2c 	sts	0x2CAE, r24
    5d92:	90 93 af 2c 	sts	0x2CAF, r25
    StateRegister = PCD_PICC_FDT;
    5d96:	82 e0       	ldi	r24, 0x02	; 2
    5d98:	81 b9       	out	0x01, r24	; 1
    5d9a:	63 c0       	rjmp	.+198    	; 0x5e62 <__vector_82+0x218>
INLINE void ReaderSniffInit(void)
{
//    PORTE.OUTSET = PIN3_bm;

    // Configure interrupt for demod
    CODEC_DEMOD_IN_PORT.INTCTRL = PORT_INT1LVL_HI_gc;
    5d9c:	8c e0       	ldi	r24, 0x0C	; 12
    5d9e:	80 93 29 06 	sts	0x0629, r24

    /* Initialize some global vars and start looking out for reader commands */

    ReaderBufferPtr = CodecBuffer;
    5da2:	83 ed       	ldi	r24, 0xD3	; 211
    5da4:	91 e3       	ldi	r25, 0x31	; 49
    5da6:	88 b9       	out	0x08, r24	; 8
    5da8:	99 b9       	out	0x09, r25	; 9
    ParityBufferPtr = &CodecBuffer[ISO14443A_BUFFER_PARITY_OFFSET];
    5daa:	83 e5       	ldi	r24, 0x53	; 83
    5dac:	92 e3       	ldi	r25, 0x32	; 50
    5dae:	8a b9       	out	0x0a, r24	; 10
    5db0:	9b b9       	out	0x0b, r25	; 11
    DataRegister = 0;
    5db2:	10 b8       	out	0x00, r1	; 0
    ReaderSampleR = 0;
    5db4:	14 b8       	out	0x04, r1	; 4
    SampleIdxRegister = 0;
    5db6:	13 b8       	out	0x03, r1	; 3
    BitCount = 0;
    5db8:	16 b8       	out	0x06, r1	; 6
    5dba:	17 b8       	out	0x07, r1	; 7
    StateRegister = DEMOD_DATA_BIT;
    5dbc:	11 b8       	out	0x01, r1	; 1


    /* Configure sampling-timer free running and sync to first modulation-pause. */
    CODEC_TIMER_SAMPLING.CNT = 0;                               // Reset the timer count
    5dbe:	10 92 20 09 	sts	0x0920, r1
    5dc2:	10 92 21 09 	sts	0x0921, r1
    CODEC_TIMER_SAMPLING.PER = SAMPLE_RATE_SYSTEM_CYCLES - 1;   // Set Period regisiter
    5dc6:	8f ef       	ldi	r24, 0xFF	; 255
    5dc8:	90 e0       	ldi	r25, 0x00	; 0
    5dca:	80 93 26 09 	sts	0x0926, r24
    5dce:	90 93 27 09 	sts	0x0927, r25
    CODEC_TIMER_SAMPLING.CCD = 0xFFFF; /* CCD Interrupt is not active! */
    5dd2:	8f ef       	ldi	r24, 0xFF	; 255
    5dd4:	9f ef       	ldi	r25, 0xFF	; 255
    5dd6:	80 93 2e 09 	sts	0x092E, r24
    5dda:	90 93 2f 09 	sts	0x092F, r25
    CODEC_TIMER_SAMPLING.CTRLA = TC_CLKSEL_DIV1_gc;
    5dde:	81 e0       	ldi	r24, 0x01	; 1
    5de0:	80 93 00 09 	sts	0x0900, r24
    CODEC_TIMER_SAMPLING.CTRLD = TC_EVACT_RESTART_gc | CODEC_TIMER_MODSTART_EVSEL;
    5de4:	88 e8       	ldi	r24, 0x88	; 136
    5de6:	80 93 03 09 	sts	0x0903, r24
    CODEC_TIMER_SAMPLING.INTFLAGS = TC0_CCDIF_bm;
    5dea:	80 e8       	ldi	r24, 0x80	; 128
    5dec:	80 93 0c 09 	sts	0x090C, r24
    CODEC_TIMER_SAMPLING.INTCTRLB = TC_CCDINTLVL_HI_gc;
    5df0:	80 ec       	ldi	r24, 0xC0	; 192
    5df2:	80 93 07 09 	sts	0x0907, r24

    /* Start looking out for modulation pause via interrupt. */
    CODEC_DEMOD_IN_PORT.INTFLAGS = PORT_INT1IF_bm;
    5df6:	82 e0       	ldi	r24, 0x02	; 2
    5df8:	80 93 2c 06 	sts	0x062C, r24
    CODEC_DEMOD_IN_PORT.INT1MASK = CODEC_DEMOD_IN_MASK0;
    5dfc:	80 93 2b 06 	sts	0x062B, r24
    5e00:	30 c0       	rjmp	.+96     	; 0x5e62 <__vector_82+0x218>
            return;

        }
        else {
            /* Otherwise, we check the two sample bits from the bit before. */
            uint8_t BitSample = ReaderSampleR & 0xC;
    5e02:	94 b1       	in	r25, 0x04	; 4
    5e04:	89 2f       	mov	r24, r25
    5e06:	8c 70       	andi	r24, 0x0C	; 12
            uint8_t Bit = 0;

            if (BitSample != (0x0 << 2)) {
    5e08:	49 f1       	breq	.+82     	; 0x5e5c <__vector_82+0x212>
                else {
                    /* 10 sequence -> This is a one bit */
                    Bit = 1;
                }

                if (StateRegister == DEMOD_DATA_BIT) {
    5e0a:	81 b1       	in	r24, 0x01	; 1
    5e0c:	81 11       	cpse	r24, r1
    5e0e:	1e c0       	rjmp	.+60     	; 0x5e4c <__vector_82+0x202>
                    /* This is a data bit, so shift it into the data register and
                     * hold a local copy of it. */
                    uint8_t NewDataRegister = DataRegister >> 1;
    5e10:	80 b1       	in	r24, 0x00	; 0
    5e12:	86 95       	lsr	r24
                    NewDataRegister |= (Bit ? 0x80 : 0x00);
    5e14:	92 ff       	sbrs	r25, 2
    5e16:	02 c0       	rjmp	.+4      	; 0x5e1c <__vector_82+0x1d2>
    5e18:	90 e0       	ldi	r25, 0x00	; 0
    5e1a:	01 c0       	rjmp	.+2      	; 0x5e1e <__vector_82+0x1d4>
    5e1c:	90 e8       	ldi	r25, 0x80	; 128
    5e1e:	89 2b       	or	r24, r25
                    DataRegister = NewDataRegister;
    5e20:	80 b9       	out	0x00, r24	; 0

                    /* Update bitcount */
                    uint16_t NewBitCount = ++BitCount;
    5e22:	26 b1       	in	r18, 0x06	; 6
    5e24:	37 b1       	in	r19, 0x07	; 7
    5e26:	2f 5f       	subi	r18, 0xFF	; 255
    5e28:	3f 4f       	sbci	r19, 0xFF	; 255
    5e2a:	26 b9       	out	0x06, r18	; 6
    5e2c:	37 b9       	out	0x07, r19	; 7
                    if ((NewBitCount & 0x07) == 0) {
    5e2e:	27 70       	andi	r18, 0x07	; 7
    5e30:	33 27       	eor	r19, r19
    5e32:	23 2b       	or	r18, r19
    5e34:	99 f4       	brne	.+38     	; 0x5e5c <__vector_82+0x212>
                        /* We have reached a byte boundary! Store the data register. */
                        /* TODO: Prevent buffer overflow */
                        *ReaderBufferPtr++ = NewDataRegister;
    5e36:	e8 b1       	in	r30, 0x08	; 8
    5e38:	f9 b1       	in	r31, 0x09	; 9
    5e3a:	9f 01       	movw	r18, r30
    5e3c:	2f 5f       	subi	r18, 0xFF	; 255
    5e3e:	3f 4f       	sbci	r19, 0xFF	; 255
    5e40:	28 b9       	out	0x08, r18	; 8
    5e42:	39 b9       	out	0x09, r19	; 9
    5e44:	80 83       	st	Z, r24

                        /* Store bit for determining FDT at EOC and enable parity
                         * handling on next bit. */
                        StateRegister = DEMOD_PARITY_BIT;
    5e46:	81 e0       	ldi	r24, 0x01	; 1
    5e48:	81 b9       	out	0x01, r24	; 1
    5e4a:	08 c0       	rjmp	.+16     	; 0x5e5c <__vector_82+0x212>
                    }

                }
                else if (StateRegister == DEMOD_PARITY_BIT) {
    5e4c:	81 b1       	in	r24, 0x01	; 1
    5e4e:	81 30       	cpi	r24, 0x01	; 1
    5e50:	29 f4       	brne	.+10     	; 0x5e5c <__vector_82+0x212>
                    /* This is a parity bit. Store it */
//                    *ParityBufferPtr++ = Bit;
                    StateRegister = DEMOD_DATA_BIT;
    5e52:	11 b8       	out	0x01, r1	; 1
    5e54:	03 c0       	rjmp	.+6      	; 0x5e5c <__vector_82+0x212>
            }
        }
    }
    else {
        /* On odd sample position just sample. */
        SampleIdxRegister = ~SampleIdxRegister;
    5e56:	83 b1       	in	r24, 0x03	; 3
    5e58:	80 95       	com	r24
    5e5a:	83 b9       	out	0x03, r24	; 3

    /* Make sure the sampling timer gets automatically aligned to the
     * modulation pauses by using the RESTART event.
     * This can be understood as a "poor mans PLL" and makes sure that we are
     * never too far out the bit-grid while sampling. */
    CODEC_TIMER_SAMPLING.CTRLD = TC_EVACT_RESTART_gc | CODEC_TIMER_MODSTART_EVSEL;
    5e5c:	88 e8       	ldi	r24, 0x88	; 136
    5e5e:	80 93 03 09 	sts	0x0903, r24
}
    5e62:	ff 91       	pop	r31
    5e64:	ef 91       	pop	r30
    5e66:	9f 91       	pop	r25
    5e68:	8f 91       	pop	r24
    5e6a:	5f 91       	pop	r21
    5e6c:	4f 91       	pop	r20
    5e6e:	3f 91       	pop	r19
    5e70:	2f 91       	pop	r18
    5e72:	0f 90       	pop	r0
    5e74:	0b be       	out	0x3b, r0	; 59
    5e76:	0f 90       	pop	r0
    5e78:	08 be       	out	0x38, r0	; 56
    5e7a:	0f 90       	pop	r0
    5e7c:	0f be       	out	0x3f, r0	; 63
    5e7e:	0f 90       	pop	r0
    5e80:	1f 90       	pop	r1
    5e82:	18 95       	reti

00005e84 <__vector_68>:
    *CardBufferPtr++ = CardSampleR;
}

// This interrupt find Card -> Reader SOC
ISR(ACA_AC0_vect) // this interrupt either finds the SOC or gets triggered before
{
    5e84:	1f 92       	push	r1
    5e86:	0f 92       	push	r0
    5e88:	0f b6       	in	r0, 0x3f	; 63
    5e8a:	0f 92       	push	r0
    5e8c:	11 24       	eor	r1, r1
    5e8e:	08 b6       	in	r0, 0x38	; 56
    5e90:	0f 92       	push	r0
    5e92:	18 be       	out	0x38, r1	; 56
    5e94:	0b b6       	in	r0, 0x3b	; 59
    5e96:	0f 92       	push	r0
    5e98:	1b be       	out	0x3b, r1	; 59
    5e9a:	8f 93       	push	r24
    5e9c:	ef 93       	push	r30
    5e9e:	ff 93       	push	r31

    ACA.AC0CTRL &= ~AC_INTLVL_HI_gc; // disable this interrupt
    5ea0:	e0 e8       	ldi	r30, 0x80	; 128
    5ea2:	f3 e0       	ldi	r31, 0x03	; 3
    5ea4:	80 81       	ld	r24, Z
    5ea6:	8f 7c       	andi	r24, 0xCF	; 207
    5ea8:	80 83       	st	Z, r24
    // enable the pause-finding timer
    CODEC_TIMER_LOADMOD.CTRLD = TC_EVACT_RESTART_gc | TC_EVSEL_CH2_gc;
    5eaa:	e0 e0       	ldi	r30, 0x00	; 0
    5eac:	fa e0       	ldi	r31, 0x0A	; 10
    5eae:	8a e8       	ldi	r24, 0x8A	; 138
    5eb0:	83 83       	std	Z+3, r24	; 0x03
    CODEC_TIMER_LOADMOD.CTRLA = TC_CLKSEL_DIV1_gc;
    5eb2:	81 e0       	ldi	r24, 0x01	; 1
    5eb4:	80 83       	st	Z, r24
    StateRegister = PICC_FRAME;
    5eb6:	83 e0       	ldi	r24, 0x03	; 3
    5eb8:	81 b9       	out	0x01, r24	; 1
}
    5eba:	ff 91       	pop	r31
    5ebc:	ef 91       	pop	r30
    5ebe:	8f 91       	pop	r24
    5ec0:	0f 90       	pop	r0
    5ec2:	0b be       	out	0x3b, r0	; 59
    5ec4:	0f 90       	pop	r0
    5ec6:	08 be       	out	0x38, r0	; 56
    5ec8:	0f 90       	pop	r0
    5eca:	0f be       	out	0x3f, r0	; 63
    5ecc:	0f 90       	pop	r0
    5ece:	1f 90       	pop	r1
    5ed0:	18 95       	reti

00005ed2 <__vector_50>:

ISR(CODEC_TIMER_LOADMOD_CCB_VECT) // pause found
{
    5ed2:	1f 92       	push	r1
    5ed4:	0f 92       	push	r0
    5ed6:	0f b6       	in	r0, 0x3f	; 63
    5ed8:	0f 92       	push	r0
    5eda:	11 24       	eor	r1, r1
    5edc:	08 b6       	in	r0, 0x38	; 56
    5ede:	0f 92       	push	r0
    5ee0:	18 be       	out	0x38, r1	; 56
    5ee2:	09 b6       	in	r0, 0x39	; 57
    5ee4:	0f 92       	push	r0
    5ee6:	19 be       	out	0x39, r1	; 57
    5ee8:	0b b6       	in	r0, 0x3b	; 59
    5eea:	0f 92       	push	r0
    5eec:	1b be       	out	0x3b, r1	; 59
    5eee:	2f 93       	push	r18
    5ef0:	3f 93       	push	r19
    5ef2:	4f 93       	push	r20
    5ef4:	5f 93       	push	r21
    5ef6:	6f 93       	push	r22
    5ef8:	7f 93       	push	r23
    5efa:	8f 93       	push	r24
    5efc:	9f 93       	push	r25
    5efe:	af 93       	push	r26
    5f00:	bf 93       	push	r27
    5f02:	ef 93       	push	r30
    5f04:	ff 93       	push	r31
    isr_func_CODEC_TIMER_LOADMOD_CCB_VECT();
    5f06:	e0 91 4e 2e 	lds	r30, 0x2E4E
    5f0a:	f0 91 4f 2e 	lds	r31, 0x2E4F
    5f0e:	19 95       	eicall
}
    5f10:	ff 91       	pop	r31
    5f12:	ef 91       	pop	r30
    5f14:	bf 91       	pop	r27
    5f16:	af 91       	pop	r26
    5f18:	9f 91       	pop	r25
    5f1a:	8f 91       	pop	r24
    5f1c:	7f 91       	pop	r23
    5f1e:	6f 91       	pop	r22
    5f20:	5f 91       	pop	r21
    5f22:	4f 91       	pop	r20
    5f24:	3f 91       	pop	r19
    5f26:	2f 91       	pop	r18
    5f28:	0f 90       	pop	r0
    5f2a:	0b be       	out	0x3b, r0	; 59
    5f2c:	0f 90       	pop	r0
    5f2e:	09 be       	out	0x39, r0	; 57
    5f30:	0f 90       	pop	r0
    5f32:	08 be       	out	0x38, r0	; 56
    5f34:	0f 90       	pop	r0
    5f36:	0f be       	out	0x3f, r0	; 63
    5f38:	0f 90       	pop	r0
    5f3a:	1f 90       	pop	r1
    5f3c:	18 95       	reti

00005f3e <__vector_86>:
            return;
    }
}
// EOC of Card->Reader found
ISR(CODEC_TIMER_TIMESTAMPS_CCB_VECT) // EOC found
{
    5f3e:	1f 92       	push	r1
    5f40:	0f 92       	push	r0
    5f42:	0f b6       	in	r0, 0x3f	; 63
    5f44:	0f 92       	push	r0
    5f46:	11 24       	eor	r1, r1
    5f48:	08 b6       	in	r0, 0x38	; 56
    5f4a:	0f 92       	push	r0
    5f4c:	18 be       	out	0x38, r1	; 56
    5f4e:	0b b6       	in	r0, 0x3b	; 59
    5f50:	0f 92       	push	r0
    5f52:	1b be       	out	0x3b, r1	; 59
    5f54:	2f 93       	push	r18
    5f56:	3f 93       	push	r19
    5f58:	4f 93       	push	r20
    5f5a:	5f 93       	push	r21
    5f5c:	8f 93       	push	r24
    5f5e:	9f 93       	push	r25
    5f60:	ef 93       	push	r30
    5f62:	ff 93       	push	r31

    // Disable LOADMOD Timer
    CODEC_TIMER_LOADMOD.INTCTRLB = 0;               // Disable Interrupt
    5f64:	10 92 07 0a 	sts	0x0A07, r1
    CODEC_TIMER_LOADMOD.CTRLA = TC_CLKSEL_OFF_gc;   // Disable Clock
    5f68:	10 92 00 0a 	sts	0x0A00, r1
    CODEC_TIMER_LOADMOD.CTRLD = 0;                  // Disable connection to event channel
    5f6c:	10 92 03 0a 	sts	0x0A03, r1

    CODEC_TIMER_TIMESTAMPS.INTCTRLB = 0;
    5f70:	10 92 47 09 	sts	0x0947, r1
    CODEC_TIMER_TIMESTAMPS.CTRLA = TC_CLKSEL_OFF_gc;
    5f74:	10 92 40 09 	sts	0x0940, r1
    ACA.AC0CTRL &= ~AC_ENABLE_bm;
    5f78:	80 91 80 03 	lds	r24, 0x0380
    5f7c:	8e 7f       	andi	r24, 0xFE	; 254
    5f7e:	80 93 80 03 	sts	0x0380, r24

    // If finished in odd sample count
    // There must been an incomplete decoded bit
    // Since only EOC is no modulation in full bit period, and previous raw bit must be 0
    // so the last not modulated bit must be 1
    if (rawBitCount & 1) {
    5f82:	80 91 a8 2c 	lds	r24, 0x2CA8
    5f86:	90 91 a9 2c 	lds	r25, 0x2CA9
    5f8a:	80 ff       	sbrs	r24, 0
    5f8c:	15 c0       	rjmp	.+42     	; 0x5fb8 <__vector_86+0x7a>
    *CardBufferPtr++ = CardSampleR;
}

INLINE void Insert1(void)
{
    CardSampleR = (CardSampleR >> 1) | 0x80;
    5f8e:	85 b1       	in	r24, 0x05	; 5
    5f90:	86 95       	lsr	r24
    5f92:	80 68       	ori	r24, 0x80	; 128
    5f94:	85 b9       	out	0x05, r24	; 5
    if (++BitCount % 8)
    5f96:	86 b1       	in	r24, 0x06	; 6
    5f98:	97 b1       	in	r25, 0x07	; 7
    5f9a:	01 96       	adiw	r24, 0x01	; 1
    5f9c:	86 b9       	out	0x06, r24	; 6
    5f9e:	97 b9       	out	0x07, r25	; 7
    5fa0:	87 70       	andi	r24, 0x07	; 7
    5fa2:	99 27       	eor	r25, r25
    5fa4:	89 2b       	or	r24, r25
    5fa6:	41 f4       	brne	.+16     	; 0x5fb8 <__vector_86+0x7a>
        return;
    *CardBufferPtr++ = CardSampleR;
    5fa8:	ec b1       	in	r30, 0x0c	; 12
    5faa:	fd b1       	in	r31, 0x0d	; 13
    5fac:	cf 01       	movw	r24, r30
    5fae:	01 96       	adiw	r24, 0x01	; 1
    5fb0:	8c b9       	out	0x0c, r24	; 12
    5fb2:	9d b9       	out	0x0d, r25	; 13
    5fb4:	85 b1       	in	r24, 0x05	; 5
    5fb6:	80 83       	st	Z, r24
        // The previous raw bit must be 0
        // 1 + 0 -> 10 -> 1
        Insert1();
    }

    if (BitCount % 8) // copy the last byte, if there is an incomplete byte
    5fb8:	86 b1       	in	r24, 0x06	; 6
    5fba:	97 b1       	in	r25, 0x07	; 7
    5fbc:	87 70       	andi	r24, 0x07	; 7
    5fbe:	99 27       	eor	r25, r25
    5fc0:	89 2b       	or	r24, r25
    5fc2:	c9 f0       	breq	.+50     	; 0x5ff6 <__vector_86+0xb8>
        CodecBuffer2[BitCount / 8] = CardSampleR >> (8 - (BitCount % 8));
    5fc4:	e6 b1       	in	r30, 0x06	; 6
    5fc6:	f7 b1       	in	r31, 0x07	; 7
    5fc8:	85 b1       	in	r24, 0x05	; 5
    5fca:	46 b1       	in	r20, 0x06	; 6
    5fcc:	57 b1       	in	r21, 0x07	; 7
    5fce:	93 e0       	ldi	r25, 0x03	; 3
    5fd0:	f6 95       	lsr	r31
    5fd2:	e7 95       	ror	r30
    5fd4:	9a 95       	dec	r25
    5fd6:	e1 f7       	brne	.-8      	; 0x5fd0 <__vector_86+0x92>
    5fd8:	ed 52       	subi	r30, 0x2D	; 45
    5fda:	fd 4c       	sbci	r31, 0xCD	; 205
    5fdc:	90 e0       	ldi	r25, 0x00	; 0
    5fde:	47 70       	andi	r20, 0x07	; 7
    5fe0:	55 27       	eor	r21, r21
    5fe2:	28 e0       	ldi	r18, 0x08	; 8
    5fe4:	30 e0       	ldi	r19, 0x00	; 0
    5fe6:	24 1b       	sub	r18, r20
    5fe8:	35 0b       	sbc	r19, r21
    5fea:	02 c0       	rjmp	.+4      	; 0x5ff0 <__vector_86+0xb2>
    5fec:	95 95       	asr	r25
    5fee:	87 95       	ror	r24
    5ff0:	2a 95       	dec	r18
    5ff2:	e2 f7       	brpl	.-8      	; 0x5fec <__vector_86+0xae>
    5ff4:	80 83       	st	Z, r24

    CardBitCount = BitCount;
    5ff6:	86 b1       	in	r24, 0x06	; 6
    5ff8:	97 b1       	in	r25, 0x07	; 7
    5ffa:	80 93 aa 2c 	sts	0x2CAA, r24
    5ffe:	90 93 ab 2c 	sts	0x2CAB, r25
    if (BitCount >= ISO14443A_RX_MINIMUM_BITCOUNT) {
    6002:	86 b1       	in	r24, 0x06	; 6
    6004:	97 b1       	in	r25, 0x07	; 7
    6006:	04 97       	sbiw	r24, 0x04	; 4
    6008:	18 f0       	brcs	.+6      	; 0x6010 <__vector_86+0xd2>
        Flags.CardDataAvaliable = true;
    600a:	81 e0       	ldi	r24, 0x01	; 1
    600c:	80 93 b1 2c 	sts	0x2CB1, r24
}

INLINE void CardSniffDeinit(void)
{

    CODEC_TIMER_LOADMOD.CTRLA = 0;
    6010:	10 92 00 0a 	sts	0x0A00, r1
    CODEC_TIMER_LOADMOD.INTCTRLB = 0;
    6014:	10 92 07 0a 	sts	0x0A07, r1

    // Disable event system CH2
    EVSYS.CH2MUX = 0;
    6018:	10 92 82 01 	sts	0x0182, r1
    EVSYS.CH2CTRL = 0;
    601c:	10 92 8a 01 	sts	0x018A, r1
    // Reset ACA AC0 to default setting
    ACA.AC0MUXCTRL = AC_MUXPOS_DAC_gc | AC_MUXNEG_PIN7_gc;
    6020:	8c e3       	ldi	r24, 0x3C	; 60
    6022:	80 93 82 03 	sts	0x0382, r24
    ACA.AC0CTRL = CODEC_AC_DEMOD_SETTINGS;
    6026:	88 e0       	ldi	r24, 0x08	; 8
    6028:	80 93 80 03 	sts	0x0380, r24
INLINE void ReaderSniffInit(void)
{
//    PORTE.OUTSET = PIN3_bm;

    // Configure interrupt for demod
    CODEC_DEMOD_IN_PORT.INTCTRL = PORT_INT1LVL_HI_gc;
    602c:	8c e0       	ldi	r24, 0x0C	; 12
    602e:	80 93 29 06 	sts	0x0629, r24

    /* Initialize some global vars and start looking out for reader commands */

    ReaderBufferPtr = CodecBuffer;
    6032:	83 ed       	ldi	r24, 0xD3	; 211
    6034:	91 e3       	ldi	r25, 0x31	; 49
    6036:	88 b9       	out	0x08, r24	; 8
    6038:	99 b9       	out	0x09, r25	; 9
    ParityBufferPtr = &CodecBuffer[ISO14443A_BUFFER_PARITY_OFFSET];
    603a:	83 e5       	ldi	r24, 0x53	; 83
    603c:	92 e3       	ldi	r25, 0x32	; 50
    603e:	8a b9       	out	0x0a, r24	; 10
    6040:	9b b9       	out	0x0b, r25	; 11
    DataRegister = 0;
    6042:	10 b8       	out	0x00, r1	; 0
    ReaderSampleR = 0;
    6044:	14 b8       	out	0x04, r1	; 4
    SampleIdxRegister = 0;
    6046:	13 b8       	out	0x03, r1	; 3
    BitCount = 0;
    6048:	16 b8       	out	0x06, r1	; 6
    604a:	17 b8       	out	0x07, r1	; 7
    StateRegister = DEMOD_DATA_BIT;
    604c:	11 b8       	out	0x01, r1	; 1


    /* Configure sampling-timer free running and sync to first modulation-pause. */
    CODEC_TIMER_SAMPLING.CNT = 0;                               // Reset the timer count
    604e:	10 92 20 09 	sts	0x0920, r1
    6052:	10 92 21 09 	sts	0x0921, r1
    CODEC_TIMER_SAMPLING.PER = SAMPLE_RATE_SYSTEM_CYCLES - 1;   // Set Period regisiter
    6056:	8f ef       	ldi	r24, 0xFF	; 255
    6058:	90 e0       	ldi	r25, 0x00	; 0
    605a:	80 93 26 09 	sts	0x0926, r24
    605e:	90 93 27 09 	sts	0x0927, r25
    CODEC_TIMER_SAMPLING.CCD = 0xFFFF; /* CCD Interrupt is not active! */
    6062:	8f ef       	ldi	r24, 0xFF	; 255
    6064:	9f ef       	ldi	r25, 0xFF	; 255
    6066:	80 93 2e 09 	sts	0x092E, r24
    606a:	90 93 2f 09 	sts	0x092F, r25
    CODEC_TIMER_SAMPLING.CTRLA = TC_CLKSEL_DIV1_gc;
    606e:	81 e0       	ldi	r24, 0x01	; 1
    6070:	80 93 00 09 	sts	0x0900, r24
    CODEC_TIMER_SAMPLING.CTRLD = TC_EVACT_RESTART_gc | CODEC_TIMER_MODSTART_EVSEL;
    6074:	88 e8       	ldi	r24, 0x88	; 136
    6076:	80 93 03 09 	sts	0x0903, r24
    CODEC_TIMER_SAMPLING.INTFLAGS = TC0_CCDIF_bm;
    607a:	80 e8       	ldi	r24, 0x80	; 128
    607c:	80 93 0c 09 	sts	0x090C, r24
    CODEC_TIMER_SAMPLING.INTCTRLB = TC_CCDINTLVL_HI_gc;
    6080:	80 ec       	ldi	r24, 0xC0	; 192
    6082:	80 93 07 09 	sts	0x0907, r24

    /* Start looking out for modulation pause via interrupt. */
    CODEC_DEMOD_IN_PORT.INTFLAGS = PORT_INT1IF_bm;
    6086:	82 e0       	ldi	r24, 0x02	; 2
    6088:	80 93 2c 06 	sts	0x062C, r24
    CODEC_DEMOD_IN_PORT.INT1MASK = CODEC_DEMOD_IN_MASK0;
    608c:	80 93 2b 06 	sts	0x062B, r24
    }

    CardSniffDeinit();
    ReaderSniffInit();

}
    6090:	ff 91       	pop	r31
    6092:	ef 91       	pop	r30
    6094:	9f 91       	pop	r25
    6096:	8f 91       	pop	r24
    6098:	5f 91       	pop	r21
    609a:	4f 91       	pop	r20
    609c:	3f 91       	pop	r19
    609e:	2f 91       	pop	r18
    60a0:	0f 90       	pop	r0
    60a2:	0b be       	out	0x3b, r0	; 59
    60a4:	0f 90       	pop	r0
    60a6:	08 be       	out	0x38, r0	; 56
    60a8:	0f 90       	pop	r0
    60aa:	0f be       	out	0x3f, r0	; 63
    60ac:	0f 90       	pop	r0
    60ae:	1f 90       	pop	r1
    60b0:	18 95       	reti

000060b2 <Sniff14443ACodecInit>:
/////////////////////////////////////////////////
// Init and deInit, task, functions for this codec
/////////////////////////////////////////////////

void Sniff14443ACodecInit(void)
{
    60b2:	cf 93       	push	r28
    60b4:	df 93       	push	r29

    PORTE.DIRSET= PIN3_bm | PIN2_bm;
    60b6:	4c e0       	ldi	r20, 0x0C	; 12
    60b8:	40 93 81 06 	sts	0x0681, r20
{
    /* Configure CARRIER input pin and route it to EVSYS.
     * Multiply by 2 again by using both edges when externally
     * dividing by 2 */
#if CODEC_CARRIER_IN_DIV == 2
    CODEC_CARRIER_IN_PORT.CODEC_CARRIER_IN_PINCTRL = PORT_ISC_BOTHEDGES_gc;
    60bc:	a0 e4       	ldi	r26, 0x40	; 64
    60be:	b6 e0       	ldi	r27, 0x06	; 6
    60c0:	52 96       	adiw	r26, 0x12	; 18
    60c2:	1c 92       	st	X, r1
    60c4:	52 97       	sbiw	r26, 0x12	; 18
#else
#error Option not supported
#endif
    CODEC_CARRIER_IN_PORT.DIRCLR = CODEC_CARRIER_IN_MASK;
    60c6:	84 e0       	ldi	r24, 0x04	; 4
    60c8:	12 96       	adiw	r26, 0x02	; 2
    60ca:	8c 93       	st	X, r24
    60cc:	12 97       	sbiw	r26, 0x02	; 2
    EVSYS.CH6MUX = CODEC_CARRIER_IN_EVMUX;
    60ce:	c0 e8       	ldi	r28, 0x80	; 128
    60d0:	d1 e0       	ldi	r29, 0x01	; 1
    60d2:	82 e6       	ldi	r24, 0x62	; 98
    60d4:	8e 83       	std	Y+6, r24	; 0x06

    /* Configure two DEMOD pins for input.
     * Configure event channel 0 for rising edge (begin of modulation pause)
     * Configure event channel 1 for falling edge (end of modulation pause) */
    CODEC_DEMOD_POWER_PORT.OUTCLR = CODEC_DEMOD_POWER_MASK;
    60d6:	e0 e2       	ldi	r30, 0x20	; 32
    60d8:	f6 e0       	ldi	r31, 0x06	; 6
    60da:	81 e0       	ldi	r24, 0x01	; 1
    60dc:	86 83       	std	Z+6, r24	; 0x06
    CODEC_DEMOD_POWER_PORT.DIRSET = CODEC_DEMOD_POWER_MASK;
    60de:	81 83       	std	Z+1, r24	; 0x01
    CODEC_DEMOD_IN_PORT.DIRCLR = CODEC_DEMOD_IN_MASK;
    60e0:	96 e0       	ldi	r25, 0x06	; 6
    60e2:	92 83       	std	Z+2, r25	; 0x02
    CODEC_DEMOD_IN_PORT.CODEC_DEMOD_IN_PINCTRL0 = PORT_ISC_RISING_gc;
    60e4:	81 8b       	std	Z+17, r24	; 0x11
    CODEC_DEMOD_IN_PORT.CODEC_DEMOD_IN_PINCTRL1 = PORT_ISC_FALLING_gc;
    60e6:	92 e0       	ldi	r25, 0x02	; 2
    60e8:	92 8b       	std	Z+18, r25	; 0x12
    CODEC_DEMOD_IN_PORT.INT0MASK = 0;
    60ea:	12 86       	std	Z+10, r1	; 0x0a
    CODEC_DEMOD_IN_PORT.INT1MASK = 0;
    60ec:	13 86       	std	Z+11, r1	; 0x0b
    CODEC_DEMOD_IN_PORT.INTCTRL = PORT_INT0LVL_HI_gc | PORT_INT1LVL_HI_gc;
    60ee:	2f e0       	ldi	r18, 0x0F	; 15
    60f0:	21 87       	std	Z+9, r18	; 0x09
    EVSYS.CH0MUX = CODEC_DEMOD_IN_EVMUX0;
    60f2:	29 e5       	ldi	r18, 0x59	; 89
    60f4:	28 83       	st	Y, r18
    EVSYS.CH1MUX = CODEC_DEMOD_IN_EVMUX1;
    60f6:	3a e5       	ldi	r19, 0x5A	; 90
    60f8:	39 83       	std	Y+1, r19	; 0x01

    EVSYS.CH2MUX = CODEC_DEMOD_IN_EVMUX0;
    60fa:	2a 83       	std	Y+2, r18	; 0x02


    /* Configure loadmod pin configuration and use a virtual port configuration
     * for single instruction cycle access */
    CODEC_LOADMOD_PORT.DIRSET = CODEC_LOADMOD_MASK;
    60fc:	20 e4       	ldi	r18, 0x40	; 64
    60fe:	11 96       	adiw	r26, 0x01	; 1
    6100:	2c 93       	st	X, r18
    6102:	11 97       	sbiw	r26, 0x01	; 1
    CODEC_LOADMOD_PORT.OUTCLR = CODEC_LOADMOD_MASK;
    6104:	16 96       	adiw	r26, 0x06	; 6
    6106:	2c 93       	st	X, r18
    6108:	16 97       	sbiw	r26, 0x06	; 6
    PORTCFG.VPCTRLA &= ~PORTCFG_VP0MAP_gm;
    610a:	c0 eb       	ldi	r28, 0xB0	; 176
    610c:	d0 e0       	ldi	r29, 0x00	; 0
    610e:	3a 81       	ldd	r19, Y+2	; 0x02
    6110:	30 7f       	andi	r19, 0xF0	; 240
    6112:	3a 83       	std	Y+2, r19	; 0x02
    PORTCFG.VPCTRLA |= PORTCFG_VP02MAP_PORTC_gc;
    6114:	3a 81       	ldd	r19, Y+2	; 0x02
    6116:	32 60       	ori	r19, 0x02	; 2
    6118:	3a 83       	std	Y+2, r19	; 0x02

    /* Configure subcarrier pins for output */
    CODEC_SUBCARRIER_PORT.DIRSET = CODEC_SUBCARRIER_MASK;
    611a:	30 e3       	ldi	r19, 0x30	; 48
    611c:	11 96       	adiw	r26, 0x01	; 1
    611e:	3c 93       	st	X, r19
    6120:	11 97       	sbiw	r26, 0x01	; 1
    CODEC_SUBCARRIER_PORT.OUTCLR = CODEC_SUBCARRIER_MASK;
    6122:	16 96       	adiw	r26, 0x06	; 6
    6124:	3c 93       	st	X, r19
    6126:	16 97       	sbiw	r26, 0x06	; 6

    /* Configure pins for reader field with the LEFT output being inverted
     * and all bridge outputs static high */
    CODEC_READER_PORT.CODEC_READER_PINCTRL_LEFT = PORT_INVEN_bm;
    6128:	50 96       	adiw	r26, 0x10	; 16
    612a:	2c 93       	st	X, r18
    612c:	50 97       	sbiw	r26, 0x10	; 16
    CODEC_READER_PORT.OUTCLR = CODEC_READER_MASK_LEFT;
    612e:	16 96       	adiw	r26, 0x06	; 6
    6130:	8c 93       	st	X, r24
    6132:	16 97       	sbiw	r26, 0x06	; 6
    CODEC_READER_PORT.OUTSET = CODEC_READER_MASK_RIGHT;
    6134:	15 96       	adiw	r26, 0x05	; 5
    6136:	9c 93       	st	X, r25
    6138:	15 97       	sbiw	r26, 0x05	; 5
    CODEC_READER_PORT.DIRSET = CODEC_READER_MASK;
    613a:	23 e0       	ldi	r18, 0x03	; 3
    613c:	11 96       	adiw	r26, 0x01	; 1
    613e:	2c 93       	st	X, r18

    /* Configure timer for generating reader field and configure AWEX for outputting pattern
     * with disabled outputs. */
    CODEC_READER_TIMER.CTRLB = TC0_CCAEN_bm | TC_WGMODE_SINGLESLOPE_gc;
    6140:	a0 e0       	ldi	r26, 0x00	; 0
    6142:	b8 e0       	ldi	r27, 0x08	; 8
    6144:	23 e1       	ldi	r18, 0x13	; 19
    6146:	11 96       	adiw	r26, 0x01	; 1
    6148:	2c 93       	st	X, r18
    614a:	11 97       	sbiw	r26, 0x01	; 1
    CODEC_READER_TIMER.PER = F_CPU / CODEC_CARRIER_FREQ - 1;
    614c:	61 e0       	ldi	r22, 0x01	; 1
    614e:	70 e0       	ldi	r23, 0x00	; 0
    6150:	96 96       	adiw	r26, 0x26	; 38
    6152:	6d 93       	st	X+, r22
    6154:	7c 93       	st	X, r23
    6156:	97 97       	sbiw	r26, 0x27	; 39
    CODEC_READER_TIMER.CCA = F_CPU / CODEC_CARRIER_FREQ / 2 ;
    6158:	98 96       	adiw	r26, 0x28	; 40
    615a:	6d 93       	st	X+, r22
    615c:	7c 93       	st	X, r23
    615e:	99 97       	sbiw	r26, 0x29	; 41

    AWEXC.OUTOVEN = 0x00;
    6160:	a0 e8       	ldi	r26, 0x80	; 128
    6162:	b8 e0       	ldi	r27, 0x08	; 8
    6164:	1c 96       	adiw	r26, 0x0c	; 12
    6166:	1c 92       	st	X, r1
    6168:	1c 97       	sbiw	r26, 0x0c	; 12
    AWEXC.CTRL = AWEX_CWCM_bm | AWEX_DTICCAEN_bm | AWEX_DTICCBEN_bm;
    616a:	2c 93       	st	X, r18

    /* Configure DAC for the reference voltage */
    DACB.EVCTRL = 0;
    616c:	a0 e2       	ldi	r26, 0x20	; 32
    616e:	b3 e0       	ldi	r27, 0x03	; 3
    6170:	13 96       	adiw	r26, 0x03	; 3
    6172:	1c 92       	st	X, r1
    6174:	13 97       	sbiw	r26, 0x03	; 3
    DACB.CTRLB = DAC_CHSEL_SINGLE_gc;
    6176:	11 96       	adiw	r26, 0x01	; 1
    6178:	1c 92       	st	X, r1
    617a:	11 97       	sbiw	r26, 0x01	; 1
    DACB.CTRLC = DAC_REFSEL_AVCC_gc;
    617c:	28 e0       	ldi	r18, 0x08	; 8
    617e:	12 96       	adiw	r26, 0x02	; 2
    6180:	2c 93       	st	X, r18
    6182:	12 97       	sbiw	r26, 0x02	; 2
    DACB.CTRLA = DAC_IDOEN_bm | DAC_ENABLE_bm;
    6184:	31 e1       	ldi	r19, 0x11	; 17
    6186:	3c 93       	st	X, r19
    DACB.CH0DATA = GlobalSettings.ActiveSettingPtr->ReaderThreshold; // real threshold voltage can be calculated with ch0data * Vref / 0xFFF
    6188:	c0 91 71 2f 	lds	r28, 0x2F71
    618c:	d0 91 72 2f 	lds	r29, 0x2F72
    6190:	6a 85       	ldd	r22, Y+10	; 0x0a
    6192:	7b 85       	ldd	r23, Y+11	; 0x0b
    6194:	58 96       	adiw	r26, 0x18	; 24
    6196:	6d 93       	st	X+, r22
    6198:	7c 93       	st	X, r23
    619a:	59 97       	sbiw	r26, 0x19	; 25

    /* Configure Analog Comparator 0 to detect changes in demodulated reader field */
    ACA.AC0MUXCTRL = AC_MUXPOS_DAC_gc | AC_MUXNEG_PIN7_gc;
    619c:	a0 e8       	ldi	r26, 0x80	; 128
    619e:	b3 e0       	ldi	r27, 0x03	; 3
    61a0:	3c e3       	ldi	r19, 0x3C	; 60
    61a2:	12 96       	adiw	r26, 0x02	; 2
    61a4:	3c 93       	st	X, r19
    61a6:	12 97       	sbiw	r26, 0x02	; 2
    ACA.AC0CTRL = CODEC_AC_DEMOD_SETTINGS;
    61a8:	2c 93       	st	X, r18

    /* Configure Analog Comparator 1 to detect SOC */
    ACA.AC1MUXCTRL = AC_MUXPOS_DAC_gc | AC_MUXNEG_PIN7_gc;
    61aa:	13 96       	adiw	r26, 0x03	; 3
    61ac:	3c 93       	st	X, r19
    61ae:	13 97       	sbiw	r26, 0x03	; 3
    ACA.AC1CTRL = CODEC_AC_DEMOD_SETTINGS;
    61b0:	11 96       	adiw	r26, 0x01	; 1
    61b2:	2c 93       	st	X, r18
    // Common Codec Register settings
    CodecInitCommon();
    isr_func_CODEC_TIMER_LOADMOD_CCB_VECT = &isr_SniffISO14443_2A_CODEC_TIMER_LOADMOD_CCB_VECT;
    61b4:	21 e4       	ldi	r18, 0x41	; 65
    61b6:	3d e2       	ldi	r19, 0x2D	; 45
    61b8:	20 93 4e 2e 	sts	0x2E4E, r18
    61bc:	30 93 4f 2e 	sts	0x2E4F, r19
}

INLINE void CodecSetDemodPower(bool bOnOff)
{
    if (bOnOff) {
        CODEC_DEMOD_POWER_PORT.OUTSET = CODEC_DEMOD_POWER_MASK;
    61c0:	85 83       	std	Z+5, r24	; 0x05
    // Enable demodulator power
    CodecSetDemodPower(true);

    // Start with sniffing Reader->Card direction traffic
    Flags.ReaderDataAvaliable = false;
    61c2:	a0 eb       	ldi	r26, 0xB0	; 176
    61c4:	bc e2       	ldi	r27, 0x2C	; 44
    61c6:	1c 92       	st	X, r1
    Flags.CardDataAvaliable = false;
    61c8:	11 96       	adiw	r26, 0x01	; 1
    61ca:	1c 92       	st	X, r1
INLINE void ReaderSniffInit(void)
{
//    PORTE.OUTSET = PIN3_bm;

    // Configure interrupt for demod
    CODEC_DEMOD_IN_PORT.INTCTRL = PORT_INT1LVL_HI_gc;
    61cc:	41 87       	std	Z+9, r20	; 0x09

    /* Initialize some global vars and start looking out for reader commands */

    ReaderBufferPtr = CodecBuffer;
    61ce:	23 ed       	ldi	r18, 0xD3	; 211
    61d0:	31 e3       	ldi	r19, 0x31	; 49
    61d2:	28 b9       	out	0x08, r18	; 8
    61d4:	39 b9       	out	0x09, r19	; 9
    ParityBufferPtr = &CodecBuffer[ISO14443A_BUFFER_PARITY_OFFSET];
    61d6:	23 e5       	ldi	r18, 0x53	; 83
    61d8:	32 e3       	ldi	r19, 0x32	; 50
    61da:	2a b9       	out	0x0a, r18	; 10
    61dc:	3b b9       	out	0x0b, r19	; 11
    DataRegister = 0;
    61de:	10 b8       	out	0x00, r1	; 0
    ReaderSampleR = 0;
    61e0:	14 b8       	out	0x04, r1	; 4
    SampleIdxRegister = 0;
    61e2:	13 b8       	out	0x03, r1	; 3
    BitCount = 0;
    61e4:	16 b8       	out	0x06, r1	; 6
    61e6:	17 b8       	out	0x07, r1	; 7
    StateRegister = DEMOD_DATA_BIT;
    61e8:	11 b8       	out	0x01, r1	; 1


    /* Configure sampling-timer free running and sync to first modulation-pause. */
    CODEC_TIMER_SAMPLING.CNT = 0;                               // Reset the timer count
    61ea:	a0 e0       	ldi	r26, 0x00	; 0
    61ec:	b9 e0       	ldi	r27, 0x09	; 9
    61ee:	90 96       	adiw	r26, 0x20	; 32
    61f0:	1d 92       	st	X+, r1
    61f2:	1c 92       	st	X, r1
    61f4:	91 97       	sbiw	r26, 0x21	; 33
    CODEC_TIMER_SAMPLING.PER = SAMPLE_RATE_SYSTEM_CYCLES - 1;   // Set Period regisiter
    61f6:	2f ef       	ldi	r18, 0xFF	; 255
    61f8:	30 e0       	ldi	r19, 0x00	; 0
    61fa:	96 96       	adiw	r26, 0x26	; 38
    61fc:	2d 93       	st	X+, r18
    61fe:	3c 93       	st	X, r19
    6200:	97 97       	sbiw	r26, 0x27	; 39
    CODEC_TIMER_SAMPLING.CCD = 0xFFFF; /* CCD Interrupt is not active! */
    6202:	2f ef       	ldi	r18, 0xFF	; 255
    6204:	3f ef       	ldi	r19, 0xFF	; 255
    6206:	9e 96       	adiw	r26, 0x2e	; 46
    6208:	2d 93       	st	X+, r18
    620a:	3c 93       	st	X, r19
    620c:	9f 97       	sbiw	r26, 0x2f	; 47
    CODEC_TIMER_SAMPLING.CTRLA = TC_CLKSEL_DIV1_gc;
    620e:	8c 93       	st	X, r24
    CODEC_TIMER_SAMPLING.CTRLD = TC_EVACT_RESTART_gc | CODEC_TIMER_MODSTART_EVSEL;
    6210:	88 e8       	ldi	r24, 0x88	; 136
    6212:	13 96       	adiw	r26, 0x03	; 3
    6214:	8c 93       	st	X, r24
    6216:	13 97       	sbiw	r26, 0x03	; 3
    CODEC_TIMER_SAMPLING.INTFLAGS = TC0_CCDIF_bm;
    6218:	80 e8       	ldi	r24, 0x80	; 128
    621a:	1c 96       	adiw	r26, 0x0c	; 12
    621c:	8c 93       	st	X, r24
    621e:	1c 97       	sbiw	r26, 0x0c	; 12
    CODEC_TIMER_SAMPLING.INTCTRLB = TC_CCDINTLVL_HI_gc;
    6220:	80 ec       	ldi	r24, 0xC0	; 192
    6222:	17 96       	adiw	r26, 0x07	; 7
    6224:	8c 93       	st	X, r24

    /* Start looking out for modulation pause via interrupt. */
    CODEC_DEMOD_IN_PORT.INTFLAGS = PORT_INT1IF_bm;
    6226:	94 87       	std	Z+12, r25	; 0x0c
    CODEC_DEMOD_IN_PORT.INT1MASK = CODEC_DEMOD_IN_MASK0;
    6228:	93 87       	std	Z+11, r25	; 0x0b
    // Start with sniffing Reader->Card direction traffic
    Flags.ReaderDataAvaliable = false;
    Flags.CardDataAvaliable = false;

    ReaderSniffInit();
}
    622a:	df 91       	pop	r29
    622c:	cf 91       	pop	r28
    622e:	08 95       	ret

00006230 <Sniff14443ACodecDeInit>:
}

INLINE void CardSniffDeinit(void)
{

    CODEC_TIMER_LOADMOD.CTRLA = 0;
    6230:	e0 e0       	ldi	r30, 0x00	; 0
    6232:	fa e0       	ldi	r31, 0x0A	; 10
    6234:	10 82       	st	Z, r1
    CODEC_TIMER_LOADMOD.INTCTRLB = 0;
    6236:	17 82       	std	Z+7, r1	; 0x07

    // Disable event system CH2
    EVSYS.CH2MUX = 0;
    6238:	e0 e8       	ldi	r30, 0x80	; 128
    623a:	f1 e0       	ldi	r31, 0x01	; 1
    623c:	12 82       	std	Z+2, r1	; 0x02
    EVSYS.CH2CTRL = 0;
    623e:	12 86       	std	Z+10, r1	; 0x0a
    // Reset ACA AC0 to default setting
    ACA.AC0MUXCTRL = AC_MUXPOS_DAC_gc | AC_MUXNEG_PIN7_gc;
    6240:	e0 e8       	ldi	r30, 0x80	; 128
    6242:	f3 e0       	ldi	r31, 0x03	; 3
    6244:	8c e3       	ldi	r24, 0x3C	; 60
    6246:	82 83       	std	Z+2, r24	; 0x02
    ACA.AC0CTRL = CODEC_AC_DEMOD_SETTINGS;
    6248:	88 e0       	ldi	r24, 0x08	; 8
    624a:	80 83       	st	Z, r24
INLINE void ReaderSniffDeInit(void)
{
//    PORTE.OUTCLR = PIN3_bm;

    /* Gracefully shutdown codec */
    CODEC_DEMOD_IN_PORT.INT1MASK = 0;
    624c:	a0 e2       	ldi	r26, 0x20	; 32
    624e:	b6 e0       	ldi	r27, 0x06	; 6
    6250:	1b 96       	adiw	r26, 0x0b	; 11
    6252:	1c 92       	st	X, r1
    6254:	1b 97       	sbiw	r26, 0x0b	; 11
    CODEC_DEMOD_IN_PORT.INTCTRL = 0;
    6256:	19 96       	adiw	r26, 0x09	; 9
    6258:	1c 92       	st	X, r1
    625a:	19 97       	sbiw	r26, 0x09	; 9

    CODEC_TIMER_SAMPLING.CTRLA = TC_CLKSEL_OFF_gc;
    625c:	e0 e0       	ldi	r30, 0x00	; 0
    625e:	f9 e0       	ldi	r31, 0x09	; 9
    6260:	10 82       	st	Z, r1
    CODEC_TIMER_SAMPLING.CTRLD = TC_EVACT_OFF_gc;
    6262:	13 82       	std	Z+3, r1	; 0x03
    CODEC_TIMER_SAMPLING.INTCTRLB = TC_CCDINTLVL_OFF_gc;
    6264:	17 82       	std	Z+7, r1	; 0x07
    CODEC_TIMER_SAMPLING.INTFLAGS = TC0_CCDIF_bm;
    6266:	80 e8       	ldi	r24, 0x80	; 128
    6268:	84 87       	std	Z+12, r24	; 0x0c
    } else {
        CODEC_DEMOD_POWER_PORT.OUTCLR = CODEC_DEMOD_POWER_MASK;
    626a:	81 e0       	ldi	r24, 0x01	; 1
    626c:	16 96       	adiw	r26, 0x06	; 6
    626e:	8c 93       	st	X, r24
    6270:	08 95       	ret

00006272 <Sniff14443ACodecTask>:
}


void Sniff14443ACodecTask(void)
{
    PORTE.OUTSET = PIN3_bm;
    6272:	88 e0       	ldi	r24, 0x08	; 8
    6274:	80 93 85 06 	sts	0x0685, r24
    if(Flags.ReaderDataAvaliable){
    6278:	80 91 b0 2c 	lds	r24, 0x2CB0
    627c:	88 23       	and	r24, r24
    627e:	91 f1       	breq	.+100    	; 0x62e4 <Sniff14443ACodecTask+0x72>
        Flags.ReaderDataAvaliable = false;
    6280:	10 92 b0 2c 	sts	0x2CB0, r1

        LogEntry(LOG_INFO_CODEC_SNI_READER_DATA, CodecBuffer, (ReaderBitCount+7)/8);
    6284:	40 91 ac 2c 	lds	r20, 0x2CAC
    6288:	50 91 ad 2c 	lds	r21, 0x2CAD
    628c:	49 5f       	subi	r20, 0xF9	; 249
    628e:	5f 4f       	sbci	r21, 0xFF	; 255
    6290:	93 e0       	ldi	r25, 0x03	; 3
    6292:	56 95       	lsr	r21
    6294:	47 95       	ror	r20
    6296:	9a 95       	dec	r25
    6298:	e1 f7       	brne	.-8      	; 0x6292 <Sniff14443ACodecTask+0x20>
    629a:	e0 91 6e 2f 	lds	r30, 0x2F6E
    629e:	f0 91 6f 2f 	lds	r31, 0x2F6F
    62a2:	63 ed       	ldi	r22, 0xD3	; 211
    62a4:	71 e3       	ldi	r23, 0x31	; 49
    62a6:	84 e4       	ldi	r24, 0x44	; 68
    62a8:	19 95       	eicall

INLINE void LEDHook(LEDHookEnum Func, LEDActionEnum Action) {
    extern LEDActionEnum LEDGreenAction;
    extern LEDActionEnum LEDRedAction;

    if (GlobalSettings.ActiveSettingPtr->LEDGreenFunction == Func) {
    62aa:	e0 91 71 2f 	lds	r30, 0x2F71
    62ae:	f0 91 72 2f 	lds	r31, 0x2F72
    62b2:	87 81       	ldd	r24, Z+7	; 0x07
    62b4:	88 30       	cpi	r24, 0x08	; 8
    62b6:	19 f4       	brne	.+6      	; 0x62be <Sniff14443ACodecTask+0x4c>
        LEDGreenAction = Action;
    62b8:	83 e1       	ldi	r24, 0x13	; 19
    62ba:	80 93 7d 2c 	sts	0x2C7D, r24
    }

    if (GlobalSettings.ActiveSettingPtr->LEDRedFunction == Func) {
    62be:	86 81       	ldd	r24, Z+6	; 0x06
    62c0:	88 30       	cpi	r24, 0x08	; 8
    62c2:	19 f4       	brne	.+6      	; 0x62ca <Sniff14443ACodecTask+0x58>
        LEDRedAction = Action;
    62c4:	83 e1       	ldi	r24, 0x13	; 19
    62c6:	80 93 7c 2c 	sts	0x2C7C, r24
        // Let the Application layer know where this data comes from
        LEDHook(LED_CODEC_RX, LED_PULSE);

        TrafficSource = TRAFFIC_READER;
    62ca:	10 92 4d 2e 	sts	0x2E4D, r1
        ApplicationProcess(CodecBuffer, ReaderBitCount);
    62ce:	60 91 ac 2c 	lds	r22, 0x2CAC
    62d2:	70 91 ad 2c 	lds	r23, 0x2CAD
    62d6:	e0 91 64 2f 	lds	r30, 0x2F64
    62da:	f0 91 65 2f 	lds	r31, 0x2F65
    62de:	83 ed       	ldi	r24, 0xD3	; 211
    62e0:	91 e3       	ldi	r25, 0x31	; 49
    62e2:	19 95       	eicall
    }


    if (Flags.CardDataAvaliable){
    62e4:	80 91 b1 2c 	lds	r24, 0x2CB1
    62e8:	88 23       	and	r24, r24
    62ea:	99 f1       	breq	.+102    	; 0x6352 <Sniff14443ACodecTask+0xe0>
        Flags.CardDataAvaliable = false;
    62ec:	10 92 b1 2c 	sts	0x2CB1, r1

//        CardBitCount = removeParityBits(CodecBuffer2,CardBitCount );
        LogEntry(LOG_INFO_CODEC_SNI_CARD_DATA_W_PARITY, CodecBuffer2, (CardBitCount + 7) / 8);
    62f0:	40 91 aa 2c 	lds	r20, 0x2CAA
    62f4:	50 91 ab 2c 	lds	r21, 0x2CAB
    62f8:	49 5f       	subi	r20, 0xF9	; 249
    62fa:	5f 4f       	sbci	r21, 0xFF	; 255
    62fc:	83 e0       	ldi	r24, 0x03	; 3
    62fe:	56 95       	lsr	r21
    6300:	47 95       	ror	r20
    6302:	8a 95       	dec	r24
    6304:	e1 f7       	brne	.-8      	; 0x62fe <Sniff14443ACodecTask+0x8c>
    6306:	e0 91 6e 2f 	lds	r30, 0x2F6E
    630a:	f0 91 6f 2f 	lds	r31, 0x2F6F
    630e:	63 ed       	ldi	r22, 0xD3	; 211
    6310:	72 e3       	ldi	r23, 0x32	; 50
    6312:	87 e4       	ldi	r24, 0x47	; 71
    6314:	19 95       	eicall

INLINE void LEDHook(LEDHookEnum Func, LEDActionEnum Action) {
    extern LEDActionEnum LEDGreenAction;
    extern LEDActionEnum LEDRedAction;

    if (GlobalSettings.ActiveSettingPtr->LEDGreenFunction == Func) {
    6316:	e0 91 71 2f 	lds	r30, 0x2F71
    631a:	f0 91 72 2f 	lds	r31, 0x2F72
    631e:	87 81       	ldd	r24, Z+7	; 0x07
    6320:	88 30       	cpi	r24, 0x08	; 8
    6322:	19 f4       	brne	.+6      	; 0x632a <Sniff14443ACodecTask+0xb8>
        LEDGreenAction = Action;
    6324:	83 e1       	ldi	r24, 0x13	; 19
    6326:	80 93 7d 2c 	sts	0x2C7D, r24
    }

    if (GlobalSettings.ActiveSettingPtr->LEDRedFunction == Func) {
    632a:	86 81       	ldd	r24, Z+6	; 0x06
    632c:	88 30       	cpi	r24, 0x08	; 8
    632e:	19 f4       	brne	.+6      	; 0x6336 <Sniff14443ACodecTask+0xc4>
        LEDRedAction = Action;
    6330:	83 e1       	ldi	r24, 0x13	; 19
    6332:	80 93 7c 2c 	sts	0x2C7C, r24
        LEDHook(LED_CODEC_RX, LED_PULSE);

        // Let the Application layer know where this data comes from
        TrafficSource = TRAFFIC_CARD;
    6336:	81 e0       	ldi	r24, 0x01	; 1
    6338:	80 93 4d 2e 	sts	0x2E4D, r24
        ApplicationProcess(CodecBuffer2, CardBitCount);
    633c:	60 91 aa 2c 	lds	r22, 0x2CAA
    6340:	70 91 ab 2c 	lds	r23, 0x2CAB
    6344:	e0 91 64 2f 	lds	r30, 0x2F64
    6348:	f0 91 65 2f 	lds	r31, 0x2F65
    634c:	83 ed       	ldi	r24, 0xD3	; 211
    634e:	92 e3       	ldi	r25, 0x32	; 50
    6350:	19 95       	eicall
    }


    if(StateRegister == PCD_PICC_FDT && (SYSTICK_DIFF(RxPendingSince) > Reader_FWT)){
    6352:	21 b1       	in	r18, 0x01	; 1
    6354:	22 30       	cpi	r18, 0x02	; 2
    6356:	09 f0       	breq	.+2      	; 0x635a <Sniff14443ACodecTask+0xe8>
    6358:	55 c0       	rjmp	.+170    	; 0x6404 <Sniff14443ACodecTask+0x192>
    635a:	8e b1       	in	r24, 0x0e	; 14
    635c:	9f b1       	in	r25, 0x0f	; 15
    635e:	60 91 08 04 	lds	r22, 0x0408
    6362:	70 91 09 04 	lds	r23, 0x0409
    6366:	40 91 ae 2c 	lds	r20, 0x2CAE
    636a:	50 91 af 2c 	lds	r21, 0x2CAF
    636e:	86 2b       	or	r24, r22
    6370:	97 2b       	or	r25, r23
    6372:	84 1b       	sub	r24, r20
    6374:	95 0b       	sbc	r25, r21
    6376:	40 91 1e 20 	lds	r20, 0x201E
    637a:	50 91 1f 20 	lds	r21, 0x201F
    637e:	48 17       	cp	r20, r24
    6380:	59 07       	cpc	r21, r25
    6382:	08 f0       	brcs	.+2      	; 0x6386 <Sniff14443ACodecTask+0x114>
    6384:	3f c0       	rjmp	.+126    	; 0x6404 <Sniff14443ACodecTask+0x192>
}

INLINE void CardSniffDeinit(void)
{

    CODEC_TIMER_LOADMOD.CTRLA = 0;
    6386:	10 92 00 0a 	sts	0x0A00, r1
    CODEC_TIMER_LOADMOD.INTCTRLB = 0;
    638a:	10 92 07 0a 	sts	0x0A07, r1

    // Disable event system CH2
    EVSYS.CH2MUX = 0;
    638e:	10 92 82 01 	sts	0x0182, r1
    EVSYS.CH2CTRL = 0;
    6392:	10 92 8a 01 	sts	0x018A, r1
    // Reset ACA AC0 to default setting
    ACA.AC0MUXCTRL = AC_MUXPOS_DAC_gc | AC_MUXNEG_PIN7_gc;
    6396:	8c e3       	ldi	r24, 0x3C	; 60
    6398:	80 93 82 03 	sts	0x0382, r24
    ACA.AC0CTRL = CODEC_AC_DEMOD_SETTINGS;
    639c:	88 e0       	ldi	r24, 0x08	; 8
    639e:	80 93 80 03 	sts	0x0380, r24
INLINE void ReaderSniffInit(void)
{
//    PORTE.OUTSET = PIN3_bm;

    // Configure interrupt for demod
    CODEC_DEMOD_IN_PORT.INTCTRL = PORT_INT1LVL_HI_gc;
    63a2:	8c e0       	ldi	r24, 0x0C	; 12
    63a4:	80 93 29 06 	sts	0x0629, r24

    /* Initialize some global vars and start looking out for reader commands */

    ReaderBufferPtr = CodecBuffer;
    63a8:	83 ed       	ldi	r24, 0xD3	; 211
    63aa:	91 e3       	ldi	r25, 0x31	; 49
    63ac:	88 b9       	out	0x08, r24	; 8
    63ae:	99 b9       	out	0x09, r25	; 9
    ParityBufferPtr = &CodecBuffer[ISO14443A_BUFFER_PARITY_OFFSET];
    63b0:	83 e5       	ldi	r24, 0x53	; 83
    63b2:	92 e3       	ldi	r25, 0x32	; 50
    63b4:	8a b9       	out	0x0a, r24	; 10
    63b6:	9b b9       	out	0x0b, r25	; 11
    DataRegister = 0;
    63b8:	10 b8       	out	0x00, r1	; 0
    ReaderSampleR = 0;
    63ba:	14 b8       	out	0x04, r1	; 4
    SampleIdxRegister = 0;
    63bc:	13 b8       	out	0x03, r1	; 3
    BitCount = 0;
    63be:	16 b8       	out	0x06, r1	; 6
    63c0:	17 b8       	out	0x07, r1	; 7
    StateRegister = DEMOD_DATA_BIT;
    63c2:	11 b8       	out	0x01, r1	; 1


    /* Configure sampling-timer free running and sync to first modulation-pause. */
    CODEC_TIMER_SAMPLING.CNT = 0;                               // Reset the timer count
    63c4:	10 92 20 09 	sts	0x0920, r1
    63c8:	10 92 21 09 	sts	0x0921, r1
    CODEC_TIMER_SAMPLING.PER = SAMPLE_RATE_SYSTEM_CYCLES - 1;   // Set Period regisiter
    63cc:	8f ef       	ldi	r24, 0xFF	; 255
    63ce:	90 e0       	ldi	r25, 0x00	; 0
    63d0:	80 93 26 09 	sts	0x0926, r24
    63d4:	90 93 27 09 	sts	0x0927, r25
    CODEC_TIMER_SAMPLING.CCD = 0xFFFF; /* CCD Interrupt is not active! */
    63d8:	8f ef       	ldi	r24, 0xFF	; 255
    63da:	9f ef       	ldi	r25, 0xFF	; 255
    63dc:	80 93 2e 09 	sts	0x092E, r24
    63e0:	90 93 2f 09 	sts	0x092F, r25
    CODEC_TIMER_SAMPLING.CTRLA = TC_CLKSEL_DIV1_gc;
    63e4:	81 e0       	ldi	r24, 0x01	; 1
    63e6:	80 93 00 09 	sts	0x0900, r24
    CODEC_TIMER_SAMPLING.CTRLD = TC_EVACT_RESTART_gc | CODEC_TIMER_MODSTART_EVSEL;
    63ea:	88 e8       	ldi	r24, 0x88	; 136
    63ec:	80 93 03 09 	sts	0x0903, r24
    CODEC_TIMER_SAMPLING.INTFLAGS = TC0_CCDIF_bm;
    63f0:	80 e8       	ldi	r24, 0x80	; 128
    63f2:	80 93 0c 09 	sts	0x090C, r24
    CODEC_TIMER_SAMPLING.INTCTRLB = TC_CCDINTLVL_HI_gc;
    63f6:	80 ec       	ldi	r24, 0xC0	; 192
    63f8:	80 93 07 09 	sts	0x0907, r24

    /* Start looking out for modulation pause via interrupt. */
    CODEC_DEMOD_IN_PORT.INTFLAGS = PORT_INT1IF_bm;
    63fc:	20 93 2c 06 	sts	0x062C, r18
    CODEC_DEMOD_IN_PORT.INT1MASK = CODEC_DEMOD_IN_MASK0;
    6400:	20 93 2b 06 	sts	0x062B, r18

    if(StateRegister == PCD_PICC_FDT && (SYSTICK_DIFF(RxPendingSince) > Reader_FWT)){
        CardSniffDeinit();
        ReaderSniffInit();
    }
    PORTE.OUTCLR = PIN3_bm;
    6404:	88 e0       	ldi	r24, 0x08	; 8
    6406:	80 93 86 06 	sts	0x0686, r24
    640a:	08 95       	ret

0000640c <VerifyAuthentication>:
{

}

static bool VerifyAuthentication(uint8_t PageAddress)
{
    640c:	28 2f       	mov	r18, r24
    /* No authentication for EV0 cards; always pass */
    if (Flavor < UL_EV1) {
    640e:	80 91 ba 2c 	lds	r24, 0x2CBA
    6412:	88 23       	and	r24, r24
    6414:	59 f0       	breq	.+22     	; 0x642c <VerifyAuthentication+0x20>
        return true;
    }
    /* If authenticated, no verification needed */
    if (Authenticated) {
    6416:	80 91 b4 2c 	lds	r24, 0x2CB4
    641a:	81 11       	cpse	r24, r1
    641c:	08 c0       	rjmp	.+16     	; 0x642e <VerifyAuthentication+0x22>
        return true;
    }
    /* Otherwise, verify the accessed page is below the limit */
    return PageAddress < FirstAuthenticatedPage;
    641e:	81 e0       	ldi	r24, 0x01	; 1
    6420:	90 91 b3 2c 	lds	r25, 0x2CB3
    6424:	29 17       	cp	r18, r25
    6426:	18 f0       	brcs	.+6      	; 0x642e <VerifyAuthentication+0x22>
    6428:	80 e0       	ldi	r24, 0x00	; 0
    642a:	08 95       	ret

static bool VerifyAuthentication(uint8_t PageAddress)
{
    /* No authentication for EV0 cards; always pass */
    if (Flavor < UL_EV1) {
        return true;
    642c:	81 e0       	ldi	r24, 0x01	; 1
    if (Authenticated) {
        return true;
    }
    /* Otherwise, verify the accessed page is below the limit */
    return PageAddress < FirstAuthenticatedPage;
}
    642e:	08 95       	ret

00006430 <AppInitEV1Common>:
    ReadAccessProtected = false;
    AppInitCommon();
}

static void AppInitEV1Common(void)
{
    6430:	ff 92       	push	r15
    6432:	0f 93       	push	r16
    6434:	1f 93       	push	r17
    6436:	cf 93       	push	r28
    6438:	df 93       	push	r29
    643a:	1f 92       	push	r1
    643c:	cd b7       	in	r28, 0x3d	; 61
    643e:	de b7       	in	r29, 0x3e	; 62
    uint8_t ConfigAreaAddress = PageCount * MIFARE_ULTRALIGHT_PAGE_SIZE - CONFIG_AREA_SIZE;
    6440:	00 91 b7 2c 	lds	r16, 0x2CB7
    6444:	00 0f       	add	r16, r16
    6446:	00 0f       	add	r16, r16
    6448:	00 51       	subi	r16, 0x10	; 16
    uint8_t Access;

    /* Set up the emulation flavor */
    Flavor = UL_EV1;
    644a:	ff 24       	eor	r15, r15
    644c:	f3 94       	inc	r15
    644e:	f0 92 ba 2c 	sts	0x2CBA, r15
    /* Fetch some of the configuration into RAM */
    MemoryReadBlock(&FirstAuthenticatedPage, ConfigAreaAddress + CONF_AUTH0_OFFSET, 1);
    6452:	10 e0       	ldi	r17, 0x00	; 0
    6454:	b8 01       	movw	r22, r16
    6456:	6d 5f       	subi	r22, 0xFD	; 253
    6458:	7f 4f       	sbci	r23, 0xFF	; 255
    645a:	41 e0       	ldi	r20, 0x01	; 1
    645c:	50 e0       	ldi	r21, 0x00	; 0
    645e:	83 eb       	ldi	r24, 0xB3	; 179
    6460:	9c e2       	ldi	r25, 0x2C	; 44
    6462:	0e 94 a1 0f 	call	0x1f42	; 0x1f42 <MemoryReadBlock>
    MemoryReadBlock(&Access, ConfigAreaAddress + CONF_ACCESS_OFFSET, 1);
    6466:	b8 01       	movw	r22, r16
    6468:	6c 5f       	subi	r22, 0xFC	; 252
    646a:	7f 4f       	sbci	r23, 0xFF	; 255
    646c:	41 e0       	ldi	r20, 0x01	; 1
    646e:	50 e0       	ldi	r21, 0x00	; 0
    6470:	ce 01       	movw	r24, r28
    6472:	01 96       	adiw	r24, 0x01	; 1
    6474:	0e 94 a1 0f 	call	0x1f42	; 0x1f42 <MemoryReadBlock>
    ReadAccessProtected = !!(Access & CONF_ACCESS_PROT);
    6478:	89 81       	ldd	r24, Y+1	; 0x01
    647a:	88 1f       	adc	r24, r24
    647c:	88 27       	eor	r24, r24
    647e:	88 1f       	adc	r24, r24
    6480:	80 93 b2 2c 	sts	0x2CB2, r24
static uint8_t FirstAuthenticatedPage;
static bool ReadAccessProtected;

static void AppInitCommon(void)
{
    State = STATE_IDLE;
    6484:	f0 92 b9 2c 	sts	0x2CB9, r15
    FromHalt = false;
    6488:	10 92 b8 2c 	sts	0x2CB8, r1
    Authenticated = false;
    648c:	10 92 b4 2c 	sts	0x2CB4, r1
    ArmedForCompatWrite = false;
    6490:	10 92 b6 2c 	sts	0x2CB6, r1
    /* Fetch some of the configuration into RAM */
    MemoryReadBlock(&FirstAuthenticatedPage, ConfigAreaAddress + CONF_AUTH0_OFFSET, 1);
    MemoryReadBlock(&Access, ConfigAreaAddress + CONF_ACCESS_OFFSET, 1);
    ReadAccessProtected = !!(Access & CONF_ACCESS_PROT);
    AppInitCommon();
}
    6494:	0f 90       	pop	r0
    6496:	df 91       	pop	r29
    6498:	cf 91       	pop	r28
    649a:	1f 91       	pop	r17
    649c:	0f 91       	pop	r16
    649e:	ff 90       	pop	r15
    64a0:	08 95       	ret

000064a2 <MifareUltralightAppInit>:
}

void MifareUltralightAppInit(void)
{
    /* Set up the emulation flavor */
    Flavor = UL_EV0;
    64a2:	10 92 ba 2c 	sts	0x2CBA, r1
    /* EV0 cards have fixed size */
    PageCount = MIFARE_ULTRALIGHT_PAGES;
    64a6:	80 e1       	ldi	r24, 0x10	; 16
    64a8:	80 93 b7 2c 	sts	0x2CB7, r24
    /* Default values */
    FirstAuthenticatedPage = 0xFF;
    64ac:	8f ef       	ldi	r24, 0xFF	; 255
    64ae:	80 93 b3 2c 	sts	0x2CB3, r24
    ReadAccessProtected = false;
    64b2:	10 92 b2 2c 	sts	0x2CB2, r1
static uint8_t FirstAuthenticatedPage;
static bool ReadAccessProtected;

static void AppInitCommon(void)
{
    State = STATE_IDLE;
    64b6:	81 e0       	ldi	r24, 0x01	; 1
    64b8:	80 93 b9 2c 	sts	0x2CB9, r24
    FromHalt = false;
    64bc:	10 92 b8 2c 	sts	0x2CB8, r1
    Authenticated = false;
    64c0:	10 92 b4 2c 	sts	0x2CB4, r1
    ArmedForCompatWrite = false;
    64c4:	10 92 b6 2c 	sts	0x2CB6, r1
    64c8:	08 95       	ret

000064ca <MifareUltralightEV11AppInit>:
    AppInitCommon();
}

void MifareUltralightEV11AppInit(void)
{
    PageCount = MIFARE_ULTRALIGHT_EV11_PAGES;
    64ca:	84 e1       	ldi	r24, 0x14	; 20
    64cc:	80 93 b7 2c 	sts	0x2CB7, r24
    AppInitEV1Common();
    64d0:	af cf       	rjmp	.-162    	; 0x6430 <AppInitEV1Common>

000064d2 <MifareUltralightEV12AppInit>:
}

void MifareUltralightEV12AppInit(void)
{
    PageCount = MIFARE_ULTRALIGHT_EV12_PAGES;
    64d2:	89 e2       	ldi	r24, 0x29	; 41
    64d4:	80 93 b7 2c 	sts	0x2CB7, r24
    AppInitEV1Common();
    64d8:	ab cf       	rjmp	.-170    	; 0x6430 <AppInitEV1Common>

000064da <MifareUltralightAppReset>:
}

void MifareUltralightAppReset(void)
{
    State = STATE_IDLE;
    64da:	81 e0       	ldi	r24, 0x01	; 1
    64dc:	80 93 b9 2c 	sts	0x2CB9, r24
    64e0:	08 95       	ret

000064e2 <MifareUltralightAppTask>:
}

void MifareUltralightAppTask(void)
{
    64e2:	08 95       	ret

000064e4 <MifareUltralightAppProcess>:
    State = STATE_IDLE;
    return ISO14443A_APP_NO_RESPONSE;
}

uint16_t MifareUltralightAppProcess(uint8_t* Buffer, uint16_t BitCount)
{
    64e4:	8f 92       	push	r8
    64e6:	9f 92       	push	r9
    64e8:	af 92       	push	r10
    64ea:	bf 92       	push	r11
    64ec:	cf 92       	push	r12
    64ee:	df 92       	push	r13
    64f0:	ef 92       	push	r14
    64f2:	ff 92       	push	r15
    64f4:	0f 93       	push	r16
    64f6:	1f 93       	push	r17
    64f8:	cf 93       	push	r28
    64fa:	df 93       	push	r29
    64fc:	cd b7       	in	r28, 0x3d	; 61
    64fe:	de b7       	in	r29, 0x3e	; 62
    6500:	25 97       	sbiw	r28, 0x05	; 5
    6502:	cd bf       	out	0x3d, r28	; 61
    6504:	de bf       	out	0x3e, r29	; 62
    6506:	8c 01       	movw	r16, r24
    uint8_t Cmd = Buffer[0];
    6508:	fc 01       	movw	r30, r24
    650a:	80 81       	ld	r24, Z
    uint16_t ByteCount;

    switch(State) {
    650c:	90 91 b9 2c 	lds	r25, 0x2CB9
    6510:	92 30       	cpi	r25, 0x02	; 2
    6512:	e9 f0       	breq	.+58     	; 0x654e <MifareUltralightAppProcess+0x6a>
    6514:	28 f0       	brcs	.+10     	; 0x6520 <MifareUltralightAppProcess+0x3c>
    6516:	93 30       	cpi	r25, 0x03	; 3
    6518:	19 f1       	breq	.+70     	; 0x6560 <MifareUltralightAppProcess+0x7c>
    651a:	94 30       	cpi	r25, 0x04	; 4
    651c:	59 f1       	breq	.+86     	; 0x6574 <MifareUltralightAppProcess+0x90>
    651e:	4f c0       	rjmp	.+158    	; 0x65be <MifareUltralightAppProcess+0xda>
    6520:	21 e0       	ldi	r18, 0x01	; 1
    6522:	92 27       	eor	r25, r18
    case STATE_IDLE:
    case STATE_HALT:
        FromHalt = State == STATE_HALT;
    6524:	29 2f       	mov	r18, r25
    6526:	21 70       	andi	r18, 0x01	; 1
    6528:	20 93 b8 2c 	sts	0x2CB8, r18
INLINE
bool ISO14443AWakeUp(void* Buffer, uint16_t* BitCount, uint16_t ATQAValue, bool FromHalt)
{
    uint8_t* DataPtr = (uint8_t*) Buffer;

    if ( ((! FromHalt) && (DataPtr[0] == ISO14443A_CMD_REQA)) ||
    652c:	91 11       	cpse	r25, r1
    652e:	02 c0       	rjmp	.+4      	; 0x6534 <MifareUltralightAppProcess+0x50>
    6530:	86 32       	cpi	r24, 0x26	; 38
    6532:	19 f0       	breq	.+6      	; 0x653a <MifareUltralightAppProcess+0x56>
    6534:	82 35       	cpi	r24, 0x52	; 82
    6536:	09 f0       	breq	.+2      	; 0x653a <MifareUltralightAppProcess+0x56>
    6538:	42 c0       	rjmp	.+132    	; 0x65be <MifareUltralightAppProcess+0xda>
         (DataPtr[0] == ISO14443A_CMD_WUPA) ){
        DataPtr[0] = (ATQAValue >> 0) & 0x00FF;
    653a:	84 e4       	ldi	r24, 0x44	; 68
    653c:	f8 01       	movw	r30, r16
    653e:	80 83       	st	Z, r24
        DataPtr[1] = (ATQAValue >> 8) & 0x00FF;
    6540:	11 82       	std	Z+1, r1	; 0x01
        if (ISO14443AWakeUp(Buffer, &BitCount, ATQA_VALUE, FromHalt)) {
            /* We received a REQA or WUPA command, so wake up. */
            State = STATE_READY1;
    6542:	82 e0       	ldi	r24, 0x02	; 2
    6544:	80 93 b9 2c 	sts	0x2CB9, r24

        *BitCount = ISO14443A_ATQA_FRAME_SIZE;
    6548:	80 e1       	ldi	r24, 0x10	; 16
    654a:	90 e0       	ldi	r25, 0x00	; 0
            return BitCount;
    654c:	dc c2       	rjmp	.+1464   	; 0x6b06 <MifareUltralightAppProcess+0x622>
        }
        break;

    case STATE_READY1:
        if (ISO14443AWakeUp(Buffer, &BitCount, ATQA_VALUE, FromHalt)) {
    654e:	90 91 b8 2c 	lds	r25, 0x2CB8
INLINE
bool ISO14443AWakeUp(void* Buffer, uint16_t* BitCount, uint16_t ATQAValue, bool FromHalt)
{
    uint8_t* DataPtr = (uint8_t*) Buffer;

    if ( ((! FromHalt) && (DataPtr[0] == ISO14443A_CMD_REQA)) ||
    6552:	91 11       	cpse	r25, r1
    6554:	02 c0       	rjmp	.+4      	; 0x655a <MifareUltralightAppProcess+0x76>
    6556:	86 32       	cpi	r24, 0x26	; 38
    6558:	b1 f0       	breq	.+44     	; 0x6586 <MifareUltralightAppProcess+0xa2>
    655a:	82 35       	cpi	r24, 0x52	; 82
    655c:	99 f5       	brne	.+102    	; 0x65c4 <MifareUltralightAppProcess+0xe0>
    655e:	13 c0       	rjmp	.+38     	; 0x6586 <MifareUltralightAppProcess+0xa2>
            State = STATE_IDLE;
        }
        break;

    case STATE_READY2:
        if (ISO14443AWakeUp(Buffer, &BitCount, ATQA_VALUE, FromHalt)) {
    6560:	90 91 b8 2c 	lds	r25, 0x2CB8
    6564:	91 11       	cpse	r25, r1
    6566:	02 c0       	rjmp	.+4      	; 0x656c <MifareUltralightAppProcess+0x88>
    6568:	86 32       	cpi	r24, 0x26	; 38
    656a:	69 f0       	breq	.+26     	; 0x6586 <MifareUltralightAppProcess+0xa2>
    656c:	82 35       	cpi	r24, 0x52	; 82
    656e:	09 f0       	breq	.+2      	; 0x6572 <MifareUltralightAppProcess+0x8e>
    6570:	5b c0       	rjmp	.+182    	; 0x6628 <MifareUltralightAppProcess+0x144>
    6572:	09 c0       	rjmp	.+18     	; 0x6586 <MifareUltralightAppProcess+0xa2>
        break;

    case STATE_ACTIVE:
        /* Preserve incoming data length */
        ByteCount = (BitCount + 7) >> 3;
        if (ISO14443AWakeUp(Buffer, &BitCount, ATQA_VALUE, FromHalt)) {
    6574:	90 91 b8 2c 	lds	r25, 0x2CB8
    6578:	91 11       	cpse	r25, r1
    657a:	02 c0       	rjmp	.+4      	; 0x6580 <MifareUltralightAppProcess+0x9c>
    657c:	86 32       	cpi	r24, 0x26	; 38
    657e:	19 f0       	breq	.+6      	; 0x6586 <MifareUltralightAppProcess+0xa2>
    6580:	82 35       	cpi	r24, 0x52	; 82
    6582:	09 f0       	breq	.+2      	; 0x6586 <MifareUltralightAppProcess+0xa2>
    6584:	f2 c0       	rjmp	.+484    	; 0x676a <MifareUltralightAppProcess+0x286>
         (DataPtr[0] == ISO14443A_CMD_WUPA) ){
        DataPtr[0] = (ATQAValue >> 0) & 0x00FF;
    6586:	84 e4       	ldi	r24, 0x44	; 68
    6588:	f8 01       	movw	r30, r16
    658a:	80 83       	st	Z, r24
        DataPtr[1] = (ATQAValue >> 8) & 0x00FF;
    658c:	11 82       	std	Z+1, r1	; 0x01
            State = FromHalt ? STATE_HALT : STATE_IDLE;
    658e:	81 e0       	ldi	r24, 0x01	; 1
    6590:	89 27       	eor	r24, r25
    6592:	13 c0       	rjmp	.+38     	; 0x65ba <MifareUltralightAppProcess+0xd6>
}

/* Handles processing of MF commands */
static uint16_t AppProcess(uint8_t* const Buffer, uint16_t ByteCount)
{
    uint8_t Cmd = Buffer[0];
    6594:	f8 01       	movw	r30, r16
    6596:	80 81       	ld	r24, Z

    /* Handle the compatibility write command */
    if (ArmedForCompatWrite) {
    6598:	90 91 b6 2c 	lds	r25, 0x2CB6
    659c:	91 11       	cpse	r25, r1
    659e:	f9 c0       	rjmp	.+498    	; 0x6792 <MifareUltralightAppProcess+0x2ae>
        Buffer[0] = ACK_VALUE;
        return ACK_FRAME_SIZE;
    }

    /* Handle EV0 commands */
    switch (Cmd) {
    65a0:	80 35       	cpi	r24, 0x50	; 80
    65a2:	09 f4       	brne	.+2      	; 0x65a6 <MifareUltralightAppProcess+0xc2>
    65a4:	75 c1       	rjmp	.+746    	; 0x6890 <MifareUltralightAppProcess+0x3ac>
    65a6:	08 f0       	brcs	.+2      	; 0x65aa <MifareUltralightAppProcess+0xc6>
    65a8:	05 c1       	rjmp	.+522    	; 0x67b4 <MifareUltralightAppProcess+0x2d0>
    65aa:	80 33       	cpi	r24, 0x30	; 48
    65ac:	09 f4       	brne	.+2      	; 0x65b0 <MifareUltralightAppProcess+0xcc>
    65ae:	08 c1       	rjmp	.+528    	; 0x67c0 <MifareUltralightAppProcess+0x2dc>
        }
        default:
            break;
    }
    /* Handle EV1 commands */
    if (Flavor >= UL_EV1) {
    65b0:	90 91 ba 2c 	lds	r25, 0x2CBA
    65b4:	91 11       	cpse	r25, r1
    65b6:	73 c1       	rjmp	.+742    	; 0x689e <MifareUltralightAppProcess+0x3ba>
            default:
                break;
        }
    }
    /* Command not handled. Switch to idle. */
    State = STATE_IDLE;
    65b8:	81 e0       	ldi	r24, 0x01	; 1
    65ba:	80 93 b9 2c 	sts	0x2CB9, r24
        /* Unknown state? Should never happen. */
        break;
    }

    /* No response has been sent, when we reach here */
    return ISO14443A_APP_NO_RESPONSE;
    65be:	80 e0       	ldi	r24, 0x00	; 0
    65c0:	90 e0       	ldi	r25, 0x00	; 0
    65c2:	a1 c2       	rjmp	.+1346   	; 0x6b06 <MifareUltralightAppProcess+0x622>

    case STATE_READY1:
        if (ISO14443AWakeUp(Buffer, &BitCount, ATQA_VALUE, FromHalt)) {
            State = FromHalt ? STATE_HALT : STATE_IDLE;
            return ISO14443A_APP_NO_RESPONSE;
        } else if (Cmd == ISO14443A_CMD_SELECT_CL1) {
    65c4:	83 39       	cpi	r24, 0x93	; 147
    65c6:	c1 f7       	brne	.-16     	; 0x65b8 <MifareUltralightAppProcess+0xd4>
            /* Load UID CL1 and perform anticollision. Since
            * MF Ultralight use a double-sized UID, the first byte
            * of CL1 has to be the cascade-tag byte. */
            uint8_t UidCL1[ISO14443A_CL_UID_SIZE] = { [0] = ISO14443A_UID0_CT };
    65c8:	19 82       	std	Y+1, r1	; 0x01
    65ca:	1a 82       	std	Y+2, r1	; 0x02
    65cc:	1b 82       	std	Y+3, r1	; 0x03
    65ce:	1c 82       	std	Y+4, r1	; 0x04
    65d0:	88 e8       	ldi	r24, 0x88	; 136
    65d2:	89 83       	std	Y+1, r24	; 0x01

            MemoryReadBlock(&UidCL1[1], UID_CL1_ADDRESS, UID_CL1_SIZE);
    65d4:	43 e0       	ldi	r20, 0x03	; 3
    65d6:	50 e0       	ldi	r21, 0x00	; 0
    65d8:	60 e0       	ldi	r22, 0x00	; 0
    65da:	70 e0       	ldi	r23, 0x00	; 0
    65dc:	ce 01       	movw	r24, r28
    65de:	02 96       	adiw	r24, 0x02	; 2
    65e0:	0e 94 a1 0f 	call	0x1f42	; 0x1f42 <MemoryReadBlock>

INLINE
bool ISO14443ASelect(void* Buffer, uint16_t* BitCount, uint8_t* UidCL, uint8_t SAKValue)
{
    uint8_t* DataPtr = (uint8_t*) Buffer;
    uint8_t NVB = DataPtr[1];
    65e4:	f8 01       	movw	r30, r16
    65e6:	81 81       	ldd	r24, Z+1	; 0x01
    //uint8_t CollisionByteCount = (NVB >> 4) & 0x0F;
    //uint8_t CollisionBitCount =  (NVB >> 0) & 0x0F;

    switch (NVB) {
    65e8:	80 32       	cpi	r24, 0x20	; 32
    65ea:	09 f4       	brne	.+2      	; 0x65ee <MifareUltralightAppProcess+0x10a>
    65ec:	aa c0       	rjmp	.+340    	; 0x6742 <MifareUltralightAppProcess+0x25e>
    65ee:	80 37       	cpi	r24, 0x70	; 112
    65f0:	09 f0       	breq	.+2      	; 0x65f4 <MifareUltralightAppProcess+0x110>
    65f2:	47 c0       	rjmp	.+142    	; 0x6682 <MifareUltralightAppProcess+0x19e>
        return false;

    case ISO14443A_NVB_AC_END:
        /* End of anticollision procedure.
        * Send SAK CLn if we are selected. */
        if (    (DataPtr[2] == UidCL[0]) &&
    65f4:	f8 01       	movw	r30, r16
    65f6:	92 81       	ldd	r25, Z+2	; 0x02
    65f8:	89 81       	ldd	r24, Y+1	; 0x01
    65fa:	98 13       	cpse	r25, r24
    65fc:	b1 c0       	rjmp	.+354    	; 0x6760 <MifareUltralightAppProcess+0x27c>
    65fe:	93 81       	ldd	r25, Z+3	; 0x03
    6600:	8a 81       	ldd	r24, Y+2	; 0x02
    6602:	98 13       	cpse	r25, r24
    6604:	ad c0       	rjmp	.+346    	; 0x6760 <MifareUltralightAppProcess+0x27c>
                (DataPtr[3] == UidCL[1]) &&
    6606:	94 81       	ldd	r25, Z+4	; 0x04
    6608:	8b 81       	ldd	r24, Y+3	; 0x03
    660a:	98 13       	cpse	r25, r24
    660c:	a9 c0       	rjmp	.+338    	; 0x6760 <MifareUltralightAppProcess+0x27c>
                (DataPtr[4] == UidCL[2]) &&
    660e:	95 81       	ldd	r25, Z+5	; 0x05
    6610:	8c 81       	ldd	r24, Y+4	; 0x04
    6612:	98 13       	cpse	r25, r24
    6614:	a5 c0       	rjmp	.+330    	; 0x6760 <MifareUltralightAppProcess+0x27c>
                (DataPtr[5] == UidCL[3]) ) {

            DataPtr[0] = SAKValue;
    6616:	84 e0       	ldi	r24, 0x04	; 4
    6618:	80 83       	st	Z, r24
            ISO14443AAppendCRCA(Buffer, 1);
    661a:	61 e0       	ldi	r22, 0x01	; 1
    661c:	70 e0       	ldi	r23, 0x00	; 0
    661e:	c8 01       	movw	r24, r16
    6620:	0e 94 63 3d 	call	0x7ac6	; 0x7ac6 <ISO14443AAppendCRCA>

            if (ISO14443ASelect(Buffer, &BitCount, UidCL1, SAK_CL1_VALUE)) {
                /* CL1 stage has ended successfully */
                State = STATE_READY2;
    6624:	83 e0       	ldi	r24, 0x03	; 3
    6626:	29 c0       	rjmp	.+82     	; 0x667a <MifareUltralightAppProcess+0x196>

    case STATE_READY2:
        if (ISO14443AWakeUp(Buffer, &BitCount, ATQA_VALUE, FromHalt)) {
            State = FromHalt ? STATE_HALT : STATE_IDLE;
            return ISO14443A_APP_NO_RESPONSE;
        } else if (Cmd == ISO14443A_CMD_SELECT_CL2) {
    6628:	85 39       	cpi	r24, 0x95	; 149
    662a:	31 f6       	brne	.-116    	; 0x65b8 <MifareUltralightAppProcess+0xd4>
            /* Load UID CL2 and perform anticollision */
            uint8_t UidCL2[ISO14443A_CL_UID_SIZE];

            MemoryReadBlock(UidCL2, UID_CL2_ADDRESS, UID_CL2_SIZE);
    662c:	44 e0       	ldi	r20, 0x04	; 4
    662e:	50 e0       	ldi	r21, 0x00	; 0
    6630:	64 e0       	ldi	r22, 0x04	; 4
    6632:	70 e0       	ldi	r23, 0x00	; 0
    6634:	ce 01       	movw	r24, r28
    6636:	01 96       	adiw	r24, 0x01	; 1
    6638:	0e 94 a1 0f 	call	0x1f42	; 0x1f42 <MemoryReadBlock>

INLINE
bool ISO14443ASelect(void* Buffer, uint16_t* BitCount, uint8_t* UidCL, uint8_t SAKValue)
{
    uint8_t* DataPtr = (uint8_t*) Buffer;
    uint8_t NVB = DataPtr[1];
    663c:	f8 01       	movw	r30, r16
    663e:	81 81       	ldd	r24, Z+1	; 0x01
    //uint8_t CollisionByteCount = (NVB >> 4) & 0x0F;
    //uint8_t CollisionBitCount =  (NVB >> 0) & 0x0F;

    switch (NVB) {
    6640:	80 32       	cpi	r24, 0x20	; 32
    6642:	09 f4       	brne	.+2      	; 0x6646 <MifareUltralightAppProcess+0x162>
    6644:	7e c0       	rjmp	.+252    	; 0x6742 <MifareUltralightAppProcess+0x25e>
    6646:	80 37       	cpi	r24, 0x70	; 112
    6648:	e1 f4       	brne	.+56     	; 0x6682 <MifareUltralightAppProcess+0x19e>
        return false;

    case ISO14443A_NVB_AC_END:
        /* End of anticollision procedure.
        * Send SAK CLn if we are selected. */
        if (    (DataPtr[2] == UidCL[0]) &&
    664a:	f8 01       	movw	r30, r16
    664c:	92 81       	ldd	r25, Z+2	; 0x02
    664e:	89 81       	ldd	r24, Y+1	; 0x01
    6650:	98 13       	cpse	r25, r24
    6652:	86 c0       	rjmp	.+268    	; 0x6760 <MifareUltralightAppProcess+0x27c>
    6654:	93 81       	ldd	r25, Z+3	; 0x03
    6656:	8a 81       	ldd	r24, Y+2	; 0x02
    6658:	98 13       	cpse	r25, r24
    665a:	82 c0       	rjmp	.+260    	; 0x6760 <MifareUltralightAppProcess+0x27c>
                (DataPtr[3] == UidCL[1]) &&
    665c:	94 81       	ldd	r25, Z+4	; 0x04
    665e:	8b 81       	ldd	r24, Y+3	; 0x03
    6660:	98 13       	cpse	r25, r24
    6662:	7e c0       	rjmp	.+252    	; 0x6760 <MifareUltralightAppProcess+0x27c>
                (DataPtr[4] == UidCL[2]) &&
    6664:	95 81       	ldd	r25, Z+5	; 0x05
    6666:	8c 81       	ldd	r24, Y+4	; 0x04
    6668:	98 13       	cpse	r25, r24
    666a:	7a c0       	rjmp	.+244    	; 0x6760 <MifareUltralightAppProcess+0x27c>
                (DataPtr[5] == UidCL[3]) ) {

            DataPtr[0] = SAKValue;
    666c:	10 82       	st	Z, r1
            ISO14443AAppendCRCA(Buffer, 1);
    666e:	61 e0       	ldi	r22, 0x01	; 1
    6670:	70 e0       	ldi	r23, 0x00	; 0
    6672:	c8 01       	movw	r24, r16
    6674:	0e 94 63 3d 	call	0x7ac6	; 0x7ac6 <ISO14443AAppendCRCA>

            if (ISO14443ASelect(Buffer, &BitCount, UidCL2, SAK_CL2_VALUE)) {
                /* CL2 stage has ended successfully. This means
                * our complete UID has been sent to the reader. */
                State = STATE_ACTIVE;
    6678:	84 e0       	ldi	r24, 0x04	; 4
    667a:	80 93 b9 2c 	sts	0x2CB9, r24
    667e:	38 e1       	ldi	r19, 0x18	; 24
    6680:	70 c0       	rjmp	.+224    	; 0x6762 <MifareUltralightAppProcess+0x27e>
            *BitCount = 0;
            return false;
        }
    default:
    {
        uint8_t CollisionByteCount = ((NVB >> 4) & 0x0f) - 2;
    6682:	e8 2e       	mov	r14, r24
    6684:	e2 94       	swap	r14
    6686:	af e0       	ldi	r26, 0x0F	; 15
    6688:	ea 22       	and	r14, r26
    668a:	2e ef       	ldi	r18, 0xFE	; 254
    668c:	2e 0d       	add	r18, r14
        uint8_t CollisionBitCount  = (NVB >> 0) & 0x0f;
    668e:	8f 70       	andi	r24, 0x0F	; 15
    6690:	f8 2e       	mov	r15, r24
        uint8_t mask = 0xFF >> (8 - CollisionBitCount);
    6692:	88 e0       	ldi	r24, 0x08	; 8
    6694:	90 e0       	ldi	r25, 0x00	; 0
    6696:	8f 19       	sub	r24, r15
    6698:	91 09       	sbc	r25, r1
    669a:	4f ef       	ldi	r20, 0xFF	; 255
    669c:	50 e0       	ldi	r21, 0x00	; 0
    669e:	6a 01       	movw	r12, r20
    66a0:	02 c0       	rjmp	.+4      	; 0x66a6 <MifareUltralightAppProcess+0x1c2>
    66a2:	d5 94       	asr	r13
    66a4:	c7 94       	ror	r12
    66a6:	8a 95       	dec	r24
    66a8:	e2 f7       	brpl	.-8      	; 0x66a2 <MifareUltralightAppProcess+0x1be>
        // Since the UidCL does not contain the BCC, we have to distinguish here
        if (
    66aa:	25 30       	cpi	r18, 0x05	; 5
    66ac:	21 f0       	breq	.+8      	; 0x66b6 <MifareUltralightAppProcess+0x1d2>
                ((CollisionByteCount == 5 || (CollisionByteCount == 4 && CollisionBitCount > 0)) && memcmp(UidCL, &DataPtr[2], 4) == 0 && (ISO14443A_CALC_BCC(UidCL) & mask) == (DataPtr[6] & mask))
    66ae:	24 30       	cpi	r18, 0x04	; 4
    66b0:	59 f5       	brne	.+86     	; 0x6708 <MifareUltralightAppProcess+0x224>
    66b2:	ff 20       	and	r15, r15
    66b4:	e9 f0       	breq	.+58     	; 0x66f0 <MifareUltralightAppProcess+0x20c>
    66b6:	44 e0       	ldi	r20, 0x04	; 4
    66b8:	50 e0       	ldi	r21, 0x00	; 0
    66ba:	b8 01       	movw	r22, r16
    66bc:	6e 5f       	subi	r22, 0xFE	; 254
    66be:	7f 4f       	sbci	r23, 0xFF	; 255
    66c0:	ce 01       	movw	r24, r28
    66c2:	01 96       	adiw	r24, 0x01	; 1
    66c4:	2d 83       	std	Y+5, r18	; 0x05
    66c6:	0e 94 da 65 	call	0xcbb4	; 0xcbb4 <memcmp>
    66ca:	2d 81       	ldd	r18, Y+5	; 0x05
    66cc:	89 2b       	or	r24, r25
    66ce:	61 f4       	brne	.+24     	; 0x66e8 <MifareUltralightAppProcess+0x204>
    66d0:	9a 81       	ldd	r25, Y+2	; 0x02
    66d2:	89 81       	ldd	r24, Y+1	; 0x01
    66d4:	89 27       	eor	r24, r25
    66d6:	9b 81       	ldd	r25, Y+3	; 0x03
    66d8:	89 27       	eor	r24, r25
    66da:	9c 81       	ldd	r25, Y+4	; 0x04
    66dc:	89 27       	eor	r24, r25
    66de:	f8 01       	movw	r30, r16
    66e0:	96 81       	ldd	r25, Z+6	; 0x06
    66e2:	89 27       	eor	r24, r25
    66e4:	8c 21       	and	r24, r12
    66e6:	69 f1       	breq	.+90     	; 0x6742 <MifareUltralightAppProcess+0x25e>
                ||
    66e8:	24 30       	cpi	r18, 0x04	; 4
    66ea:	71 f4       	brne	.+28     	; 0x6708 <MifareUltralightAppProcess+0x224>
                (CollisionByteCount == 4 && CollisionBitCount == 0 && memcmp(UidCL, &DataPtr[2], 4) == 0)
    66ec:	f1 10       	cpse	r15, r1
    66ee:	38 c0       	rjmp	.+112    	; 0x6760 <MifareUltralightAppProcess+0x27c>
    66f0:	44 e0       	ldi	r20, 0x04	; 4
    66f2:	50 e0       	ldi	r21, 0x00	; 0
    66f4:	b8 01       	movw	r22, r16
    66f6:	6e 5f       	subi	r22, 0xFE	; 254
    66f8:	7f 4f       	sbci	r23, 0xFF	; 255
    66fa:	ce 01       	movw	r24, r28
    66fc:	01 96       	adiw	r24, 0x01	; 1
    66fe:	0e 94 da 65 	call	0xcbb4	; 0xcbb4 <memcmp>
    6702:	89 2b       	or	r24, r25
    6704:	f1 f0       	breq	.+60     	; 0x6742 <MifareUltralightAppProcess+0x25e>
    6706:	2c c0       	rjmp	.+88     	; 0x6760 <MifareUltralightAppProcess+0x27c>
                ||
    6708:	24 30       	cpi	r18, 0x04	; 4
    670a:	50 f5       	brcc	.+84     	; 0x6760 <MifareUltralightAppProcess+0x27c>
                (CollisionByteCount < 4 && memcmp(UidCL, &DataPtr[2], CollisionByteCount) == 0 && (UidCL[CollisionByteCount] & mask) == (DataPtr[CollisionByteCount + 2] & mask))
    670c:	e2 2e       	mov	r14, r18
    670e:	f1 2c       	mov	r15, r1
    6710:	a7 01       	movw	r20, r14
    6712:	b8 01       	movw	r22, r16
    6714:	6e 5f       	subi	r22, 0xFE	; 254
    6716:	7f 4f       	sbci	r23, 0xFF	; 255
    6718:	ce 01       	movw	r24, r28
    671a:	01 96       	adiw	r24, 0x01	; 1
    671c:	0e 94 da 65 	call	0xcbb4	; 0xcbb4 <memcmp>
    6720:	89 2b       	or	r24, r25
    6722:	f1 f4       	brne	.+60     	; 0x6760 <MifareUltralightAppProcess+0x27c>
    6724:	d8 01       	movw	r26, r16
    6726:	ae 0d       	add	r26, r14
    6728:	bf 1d       	adc	r27, r15
    672a:	e1 e0       	ldi	r30, 0x01	; 1
    672c:	f0 e0       	ldi	r31, 0x00	; 0
    672e:	ec 0f       	add	r30, r28
    6730:	fd 1f       	adc	r31, r29
    6732:	ee 0d       	add	r30, r14
    6734:	ff 1d       	adc	r31, r15
    6736:	12 96       	adiw	r26, 0x02	; 2
    6738:	9c 91       	ld	r25, X
    673a:	80 81       	ld	r24, Z
    673c:	89 27       	eor	r24, r25
    673e:	c8 22       	and	r12, r24
    6740:	79 f4       	brne	.+30     	; 0x6760 <MifareUltralightAppProcess+0x27c>
        )
        {
            DataPtr[0] = UidCL[0];
    6742:	29 81       	ldd	r18, Y+1	; 0x01
    6744:	f8 01       	movw	r30, r16
    6746:	20 83       	st	Z, r18
            DataPtr[1] = UidCL[1];
    6748:	3a 81       	ldd	r19, Y+2	; 0x02
    674a:	31 83       	std	Z+1, r19	; 0x01
            DataPtr[2] = UidCL[2];
    674c:	9b 81       	ldd	r25, Y+3	; 0x03
    674e:	92 83       	std	Z+2, r25	; 0x02
            DataPtr[3] = UidCL[3];
    6750:	8c 81       	ldd	r24, Y+4	; 0x04
    6752:	83 83       	std	Z+3, r24	; 0x03
            DataPtr[4] = ISO14443A_CALC_BCC(DataPtr);
    6754:	23 27       	eor	r18, r19
    6756:	92 27       	eor	r25, r18
    6758:	89 27       	eor	r24, r25
    675a:	84 83       	std	Z+4, r24	; 0x04

            *BitCount = ISO14443A_CL_FRAME_SIZE;
    675c:	38 e2       	ldi	r19, 0x28	; 40
    675e:	01 c0       	rjmp	.+2      	; 0x6762 <MifareUltralightAppProcess+0x27e>
        uint8_t mask = 0xFF >> (8 - CollisionBitCount);
        // Since the UidCL does not contain the BCC, we have to distinguish here
        if (
                ((CollisionByteCount == 5 || (CollisionByteCount == 4 && CollisionBitCount > 0)) && memcmp(UidCL, &DataPtr[2], 4) == 0 && (ISO14443A_CALC_BCC(UidCL) & mask) == (DataPtr[6] & mask))
                ||
                (CollisionByteCount == 4 && CollisionBitCount == 0 && memcmp(UidCL, &DataPtr[2], 4) == 0)
    6760:	30 e0       	ldi	r19, 0x00	; 0
    6762:	20 e0       	ldi	r18, 0x00	; 0
    6764:	83 2f       	mov	r24, r19
    6766:	92 2f       	mov	r25, r18
    6768:	ce c1       	rjmp	.+924    	; 0x6b06 <MifareUltralightAppProcess+0x622>
        }
        break;

    case STATE_ACTIVE:
        /* Preserve incoming data length */
        ByteCount = (BitCount + 7) >> 3;
    676a:	69 5f       	subi	r22, 0xF9	; 249
    676c:	7f 4f       	sbci	r23, 0xFF	; 255
    676e:	83 e0       	ldi	r24, 0x03	; 3
    6770:	76 95       	lsr	r23
    6772:	67 95       	ror	r22
    6774:	8a 95       	dec	r24
    6776:	e1 f7       	brne	.-8      	; 0x6770 <MifareUltralightAppProcess+0x28c>
        if (ISO14443AWakeUp(Buffer, &BitCount, ATQA_VALUE, FromHalt)) {
            State = FromHalt ? STATE_HALT : STATE_IDLE;
            return ISO14443A_APP_NO_RESPONSE;
        }
        /* At the very least, there should be 3 bytes in the buffer. */
        if (ByteCount < (1 + ISO14443A_CRCA_SIZE)) {
    6778:	63 30       	cpi	r22, 0x03	; 3
    677a:	71 05       	cpc	r23, r1
    677c:	08 f4       	brcc	.+2      	; 0x6780 <MifareUltralightAppProcess+0x29c>
    677e:	1c cf       	rjmp	.-456    	; 0x65b8 <MifareUltralightAppProcess+0xd4>
            State = STATE_IDLE;
            return ISO14443A_APP_NO_RESPONSE;
        }
        /* All commands here have CRCA appended; verify it right away */
        ByteCount -= 2;
    6780:	62 50       	subi	r22, 0x02	; 2
    6782:	71 09       	sbc	r23, r1
        if (!ISO14443ACheckCRCA(Buffer, ByteCount)) {
    6784:	c8 01       	movw	r24, r16
    6786:	0e 94 8e 3d 	call	0x7b1c	; 0x7b1c <ISO14443ACheckCRCA>
    678a:	81 11       	cpse	r24, r1
    678c:	03 cf       	rjmp	.-506    	; 0x6594 <MifareUltralightAppProcess+0xb0>
            Buffer[0] = NAK_CRC_ERROR;
    678e:	81 e0       	ldi	r24, 0x01	; 1
    6790:	94 c1       	rjmp	.+808    	; 0x6aba <MifareUltralightAppProcess+0x5d6>
{
    uint8_t Cmd = Buffer[0];

    /* Handle the compatibility write command */
    if (ArmedForCompatWrite) {
        ArmedForCompatWrite = false;
    6792:	10 92 b6 2c 	sts	0x2CB6, r1
        AppWritePage(CompatWritePageAddress, &Buffer[2]);
    6796:	60 91 b5 2c 	lds	r22, 0x2CB5
}

/* Perform access verification and commit data if passed */
static uint8_t AppWritePage(uint8_t PageAddress, uint8_t* const Buffer)
{
    if (!ActiveConfiguration.ReadOnly) {
    679a:	80 91 6d 2f 	lds	r24, 0x2F6D
    679e:	81 11       	cpse	r24, r1
    67a0:	8b c1       	rjmp	.+790    	; 0x6ab8 <MifareUltralightAppProcess+0x5d4>
        MemoryWriteBlock(Buffer, PageAddress * MIFARE_ULTRALIGHT_PAGE_SIZE, MIFARE_ULTRALIGHT_PAGE_SIZE);
    67a2:	f4 e0       	ldi	r31, 0x04	; 4
    67a4:	6f 9f       	mul	r22, r31
    67a6:	b0 01       	movw	r22, r0
    67a8:	11 24       	eor	r1, r1
    67aa:	44 e0       	ldi	r20, 0x04	; 4
    67ac:	50 e0       	ldi	r21, 0x00	; 0
    67ae:	c8 01       	movw	r24, r16
    67b0:	02 96       	adiw	r24, 0x02	; 2
    67b2:	80 c1       	rjmp	.+768    	; 0x6ab4 <MifareUltralightAppProcess+0x5d0>
        Buffer[0] = ACK_VALUE;
        return ACK_FRAME_SIZE;
    }

    /* Handle EV0 commands */
    switch (Cmd) {
    67b4:	80 3a       	cpi	r24, 0xA0	; 160
    67b6:	09 f4       	brne	.+2      	; 0x67ba <MifareUltralightAppProcess+0x2d6>
    67b8:	55 c0       	rjmp	.+170    	; 0x6864 <MifareUltralightAppProcess+0x380>
    67ba:	82 3a       	cpi	r24, 0xA2	; 162
    67bc:	c1 f1       	breq	.+112    	; 0x682e <MifareUltralightAppProcess+0x34a>
    67be:	f8 ce       	rjmp	.-528    	; 0x65b0 <MifareUltralightAppProcess+0xcc>

        case CMD_READ: {
            uint8_t PageAddress = Buffer[1];
    67c0:	f8 01       	movw	r30, r16
    67c2:	f1 80       	ldd	r15, Z+1	; 0x01
            uint8_t PageLimit;
            uint8_t Offset;
            /* For EV1+ cards, ensure the wraparound is at the first protected page */
            if (Flavor >= UL_EV1 && ReadAccessProtected && !Authenticated) {
    67c4:	80 91 ba 2c 	lds	r24, 0x2CBA
    67c8:	88 23       	and	r24, r24
    67ca:	59 f0       	breq	.+22     	; 0x67e2 <MifareUltralightAppProcess+0x2fe>
    67cc:	80 91 b2 2c 	lds	r24, 0x2CB2
    67d0:	88 23       	and	r24, r24
    67d2:	39 f0       	breq	.+14     	; 0x67e2 <MifareUltralightAppProcess+0x2fe>
    67d4:	80 91 b4 2c 	lds	r24, 0x2CB4
    67d8:	81 11       	cpse	r24, r1
    67da:	03 c0       	rjmp	.+6      	; 0x67e2 <MifareUltralightAppProcess+0x2fe>
                PageLimit = FirstAuthenticatedPage;
    67dc:	e0 90 b3 2c 	lds	r14, 0x2CB3
    67e0:	02 c0       	rjmp	.+4      	; 0x67e6 <MifareUltralightAppProcess+0x302>
            } else {
                PageLimit = PageCount;
    67e2:	e0 90 b7 2c 	lds	r14, 0x2CB7
            }
            /* Validation */
            if (PageAddress >= PageLimit) {
    67e6:	fe 14       	cp	r15, r14
    67e8:	10 f0       	brcs	.+4      	; 0x67ee <MifareUltralightAppProcess+0x30a>
                Buffer[0] = NAK_INVALID_ARG;
    67ea:	f8 01       	movw	r30, r16
    67ec:	31 c1       	rjmp	.+610    	; 0x6a50 <MifareUltralightAppProcess+0x56c>
                PageLimit = FirstAuthenticatedPage;
            } else {
                PageLimit = PageCount;
            }
            /* Validation */
            if (PageAddress >= PageLimit) {
    67ee:	c1 2c       	mov	r12, r1
    67f0:	d1 2c       	mov	r13, r1
                Buffer[0] = NAK_INVALID_ARG;
                return NAK_FRAME_SIZE;
            }
            /* Read out, emulating the wraparound */
            for (Offset = 0; Offset < BYTES_PER_READ; Offset += 4) {
                MemoryReadBlock(&Buffer[Offset], PageAddress * MIFARE_ULTRALIGHT_PAGE_SIZE, MIFARE_ULTRALIGHT_PAGE_SIZE);
    67f2:	f4 e0       	ldi	r31, 0x04	; 4
    67f4:	ff 9e       	mul	r15, r31
    67f6:	b0 01       	movw	r22, r0
    67f8:	11 24       	eor	r1, r1
    67fa:	44 e0       	ldi	r20, 0x04	; 4
    67fc:	50 e0       	ldi	r21, 0x00	; 0
    67fe:	c8 01       	movw	r24, r16
    6800:	8c 0d       	add	r24, r12
    6802:	9d 1d       	adc	r25, r13
    6804:	0e 94 a1 0f 	call	0x1f42	; 0x1f42 <MemoryReadBlock>
                PageAddress++;
    6808:	f3 94       	inc	r15
                if (PageAddress == PageLimit) {
    680a:	fe 10       	cpse	r15, r14
    680c:	01 c0       	rjmp	.+2      	; 0x6810 <MifareUltralightAppProcess+0x32c>
                    PageAddress = 0;
    680e:	f1 2c       	mov	r15, r1
    6810:	24 e0       	ldi	r18, 0x04	; 4
    6812:	c2 0e       	add	r12, r18
    6814:	d1 1c       	adc	r13, r1
            if (PageAddress >= PageLimit) {
                Buffer[0] = NAK_INVALID_ARG;
                return NAK_FRAME_SIZE;
            }
            /* Read out, emulating the wraparound */
            for (Offset = 0; Offset < BYTES_PER_READ; Offset += 4) {
    6816:	80 e1       	ldi	r24, 0x10	; 16
    6818:	c8 16       	cp	r12, r24
    681a:	d1 04       	cpc	r13, r1
    681c:	51 f7       	brne	.-44     	; 0x67f2 <MifareUltralightAppProcess+0x30e>
                PageAddress++;
                if (PageAddress == PageLimit) {
                    PageAddress = 0;
                }
            }
            ISO14443AAppendCRCA(Buffer, BYTES_PER_READ);
    681e:	60 e1       	ldi	r22, 0x10	; 16
    6820:	70 e0       	ldi	r23, 0x00	; 0
    6822:	c8 01       	movw	r24, r16
    6824:	0e 94 63 3d 	call	0x7ac6	; 0x7ac6 <ISO14443AAppendCRCA>
            return (BYTES_PER_READ + ISO14443A_CRCA_SIZE) * 8;
    6828:	80 e9       	ldi	r24, 0x90	; 144
    682a:	90 e0       	ldi	r25, 0x00	; 0
    682c:	6c c1       	rjmp	.+728    	; 0x6b06 <MifareUltralightAppProcess+0x622>
        }

        case CMD_WRITE: {
            /* This is a write command containing 4 bytes of data that
            * should be written to the given page address. */
            uint8_t PageAddress = Buffer[1];
    682e:	f8 01       	movw	r30, r16
    6830:	f1 80       	ldd	r15, Z+1	; 0x01
            /* Validation */
            if ((PageAddress < PAGE_WRITE_MIN) || (PageAddress >= PageCount)) {
    6832:	f1 e0       	ldi	r31, 0x01	; 1
    6834:	ff 15       	cp	r31, r15
    6836:	c8 f6       	brcc	.-78     	; 0x67ea <MifareUltralightAppProcess+0x306>
    6838:	80 91 b7 2c 	lds	r24, 0x2CB7
    683c:	f8 16       	cp	r15, r24
    683e:	a8 f6       	brcc	.-86     	; 0x67ea <MifareUltralightAppProcess+0x306>
                Buffer[0] = NAK_INVALID_ARG;
                return NAK_FRAME_SIZE;
            }
            if (!VerifyAuthentication(PageAddress)) {
    6840:	8f 2d       	mov	r24, r15
    6842:	e4 dd       	rcall	.-1080   	; 0x640c <VerifyAuthentication>
    6844:	88 23       	and	r24, r24
    6846:	09 f4       	brne	.+2      	; 0x684a <MifareUltralightAppProcess+0x366>
    6848:	c2 c0       	rjmp	.+388    	; 0x69ce <MifareUltralightAppProcess+0x4ea>
                Buffer[0] = NAK_AUTH_REQUIRED;
                return NAK_FRAME_SIZE;
            }
            AppWritePage(PageAddress, &Buffer[2]);
    684a:	c8 01       	movw	r24, r16
    684c:	02 96       	adiw	r24, 0x02	; 2
}

/* Perform access verification and commit data if passed */
static uint8_t AppWritePage(uint8_t PageAddress, uint8_t* const Buffer)
{
    if (!ActiveConfiguration.ReadOnly) {
    684e:	20 91 6d 2f 	lds	r18, 0x2F6D
    6852:	21 11       	cpse	r18, r1
    6854:	31 c1       	rjmp	.+610    	; 0x6ab8 <MifareUltralightAppProcess+0x5d4>
        MemoryWriteBlock(Buffer, PageAddress * MIFARE_ULTRALIGHT_PAGE_SIZE, MIFARE_ULTRALIGHT_PAGE_SIZE);
    6856:	f4 e0       	ldi	r31, 0x04	; 4
    6858:	ff 9e       	mul	r15, r31
    685a:	b0 01       	movw	r22, r0
    685c:	11 24       	eor	r1, r1
    685e:	44 e0       	ldi	r20, 0x04	; 4
    6860:	50 e0       	ldi	r21, 0x00	; 0
    6862:	28 c1       	rjmp	.+592    	; 0x6ab4 <MifareUltralightAppProcess+0x5d0>
            Buffer[0] = ACK_VALUE;
            return ACK_FRAME_SIZE;
        }

        case CMD_COMPAT_WRITE: {
            uint8_t PageAddress = Buffer[1];
    6864:	f8 01       	movw	r30, r16
    6866:	f1 80       	ldd	r15, Z+1	; 0x01
            /* Validation */
            if ((PageAddress < PAGE_WRITE_MIN) || (PageAddress >= PageCount)) {
    6868:	f1 e0       	ldi	r31, 0x01	; 1
    686a:	ff 15       	cp	r31, r15
    686c:	08 f0       	brcs	.+2      	; 0x6870 <MifareUltralightAppProcess+0x38c>
    686e:	bd cf       	rjmp	.-134    	; 0x67ea <MifareUltralightAppProcess+0x306>
    6870:	80 91 b7 2c 	lds	r24, 0x2CB7
    6874:	f8 16       	cp	r15, r24
    6876:	08 f0       	brcs	.+2      	; 0x687a <MifareUltralightAppProcess+0x396>
    6878:	b8 cf       	rjmp	.-144    	; 0x67ea <MifareUltralightAppProcess+0x306>
                Buffer[0] = NAK_INVALID_ARG;
                return NAK_FRAME_SIZE;
            }
            if (!VerifyAuthentication(PageAddress)) {
    687a:	8f 2d       	mov	r24, r15
    687c:	c7 dd       	rcall	.-1138   	; 0x640c <VerifyAuthentication>
    687e:	88 23       	and	r24, r24
    6880:	09 f4       	brne	.+2      	; 0x6884 <MifareUltralightAppProcess+0x3a0>
    6882:	a5 c0       	rjmp	.+330    	; 0x69ce <MifareUltralightAppProcess+0x4ea>
                Buffer[0] = NAK_AUTH_REQUIRED;
                return NAK_FRAME_SIZE;
            }
            /* CRC check passed and page-address is within bounds.
            * Store address and proceed to receiving the data. */
            CompatWritePageAddress = PageAddress;
    6884:	f0 92 b5 2c 	sts	0x2CB5, r15
            ArmedForCompatWrite = true;
    6888:	81 e0       	ldi	r24, 0x01	; 1
    688a:	80 93 b6 2c 	sts	0x2CB6, r24
    688e:	14 c1       	rjmp	.+552    	; 0x6ab8 <MifareUltralightAppProcess+0x5d4>
        }

        case CMD_HALT: {
            /* Halts the tag. According to the ISO14443, the second
            * byte is supposed to be 0. */
            if (Buffer[1] == 0) {
    6890:	f8 01       	movw	r30, r16
    6892:	81 81       	ldd	r24, Z+1	; 0x01
    6894:	81 11       	cpse	r24, r1
    6896:	a9 cf       	rjmp	.-174    	; 0x67ea <MifareUltralightAppProcess+0x306>
                /* According to ISO14443, we must not send anything
                * in order to acknowledge the HALT command. */
                State = STATE_HALT;
    6898:	10 92 b9 2c 	sts	0x2CB9, r1
    689c:	90 ce       	rjmp	.-736    	; 0x65be <MifareUltralightAppProcess+0xda>
        default:
            break;
    }
    /* Handle EV1 commands */
    if (Flavor >= UL_EV1) {
        switch (Cmd) {
    689e:	8c 33       	cpi	r24, 0x3C	; 60
    68a0:	09 f4       	brne	.+2      	; 0x68a4 <MifareUltralightAppProcess+0x3c0>
    68a2:	10 c1       	rjmp	.+544    	; 0x6ac4 <MifareUltralightAppProcess+0x5e0>
    68a4:	48 f4       	brcc	.+18     	; 0x68b8 <MifareUltralightAppProcess+0x3d4>
    68a6:	89 33       	cpi	r24, 0x39	; 57
    68a8:	09 f4       	brne	.+2      	; 0x68ac <MifareUltralightAppProcess+0x3c8>
    68aa:	a6 c0       	rjmp	.+332    	; 0x69f8 <MifareUltralightAppProcess+0x514>
    68ac:	8a 33       	cpi	r24, 0x3A	; 58
    68ae:	91 f1       	breq	.+100    	; 0x6914 <MifareUltralightAppProcess+0x430>
    68b0:	8b 31       	cpi	r24, 0x1B	; 27
    68b2:	09 f0       	breq	.+2      	; 0x68b6 <MifareUltralightAppProcess+0x3d2>
    68b4:	81 ce       	rjmp	.-766    	; 0x65b8 <MifareUltralightAppProcess+0xd4>
    68b6:	6a c0       	rjmp	.+212    	; 0x698c <MifareUltralightAppProcess+0x4a8>
    68b8:	8b 34       	cpi	r24, 0x4B	; 75
    68ba:	09 f4       	brne	.+2      	; 0x68be <MifareUltralightAppProcess+0x3da>
    68bc:	11 c1       	rjmp	.+546    	; 0x6ae0 <MifareUltralightAppProcess+0x5fc>
    68be:	38 f4       	brcc	.+14     	; 0x68ce <MifareUltralightAppProcess+0x3ea>
    68c0:	8e 33       	cpi	r24, 0x3E	; 62
    68c2:	09 f0       	breq	.+2      	; 0x68c6 <MifareUltralightAppProcess+0x3e2>
    68c4:	79 ce       	rjmp	.-782    	; 0x65b8 <MifareUltralightAppProcess+0xd4>
                ISO14443AAppendCRCA(Buffer, SIGNATURE_LENGTH);
                return (SIGNATURE_LENGTH + ISO14443A_CRCA_SIZE) * 8;

            case CMD_CHECK_TEARING_EVENT:
                /* Hardcoded response */
                Buffer[0] = 0xBD;
    68c6:	8d eb       	ldi	r24, 0xBD	; 189
    68c8:	f8 01       	movw	r30, r16
    68ca:	80 83       	st	Z, r24
    68cc:	16 c1       	rjmp	.+556    	; 0x6afa <MifareUltralightAppProcess+0x616>
        default:
            break;
    }
    /* Handle EV1 commands */
    if (Flavor >= UL_EV1) {
        switch (Cmd) {
    68ce:	80 36       	cpi	r24, 0x60	; 96
    68d0:	21 f0       	breq	.+8      	; 0x68da <MifareUltralightAppProcess+0x3f6>
    68d2:	85 3a       	cpi	r24, 0xA5	; 165
    68d4:	09 f4       	brne	.+2      	; 0x68d8 <MifareUltralightAppProcess+0x3f4>
    68d6:	ab c0       	rjmp	.+342    	; 0x6a2e <MifareUltralightAppProcess+0x54a>
    68d8:	6f ce       	rjmp	.-802    	; 0x65b8 <MifareUltralightAppProcess+0xd4>

            case CMD_GET_VERSION: {
                /* Provide hardcoded version response */
                Buffer[0] = 0x00;
    68da:	f8 01       	movw	r30, r16
    68dc:	10 82       	st	Z, r1
                Buffer[1] = 0x04;
    68de:	84 e0       	ldi	r24, 0x04	; 4
    68e0:	81 83       	std	Z+1, r24	; 0x01
                Buffer[2] = 0x03;
    68e2:	83 e0       	ldi	r24, 0x03	; 3
    68e4:	82 83       	std	Z+2, r24	; 0x02
                Buffer[3] = 0x01; /**/
    68e6:	81 e0       	ldi	r24, 0x01	; 1
    68e8:	83 83       	std	Z+3, r24	; 0x03
                Buffer[4] = 0x01;
    68ea:	84 83       	std	Z+4, r24	; 0x04
                Buffer[5] = 0x00;
    68ec:	15 82       	std	Z+5, r1	; 0x05
                Buffer[6] = PageCount == MIFARE_ULTRALIGHT_EV11_PAGES ? 0x0B : 0x0E;
    68ee:	80 91 b7 2c 	lds	r24, 0x2CB7
    68f2:	84 31       	cpi	r24, 0x14	; 20
    68f4:	11 f0       	breq	.+4      	; 0x68fa <MifareUltralightAppProcess+0x416>
    68f6:	8e e0       	ldi	r24, 0x0E	; 14
    68f8:	01 c0       	rjmp	.+2      	; 0x68fc <MifareUltralightAppProcess+0x418>
    68fa:	8b e0       	ldi	r24, 0x0B	; 11
    68fc:	f8 01       	movw	r30, r16
    68fe:	86 83       	std	Z+6, r24	; 0x06
                Buffer[7] = 0x03;
    6900:	83 e0       	ldi	r24, 0x03	; 3
    6902:	87 83       	std	Z+7, r24	; 0x07
                ISO14443AAppendCRCA(Buffer, VERSION_INFO_LENGTH);
    6904:	68 e0       	ldi	r22, 0x08	; 8
    6906:	70 e0       	ldi	r23, 0x00	; 0
    6908:	c8 01       	movw	r24, r16
    690a:	0e 94 63 3d 	call	0x7ac6	; 0x7ac6 <ISO14443AAppendCRCA>
                return (VERSION_INFO_LENGTH + ISO14443A_CRCA_SIZE) * 8;
    690e:	80 e5       	ldi	r24, 0x50	; 80
    6910:	90 e0       	ldi	r25, 0x00	; 0
    6912:	f9 c0       	rjmp	.+498    	; 0x6b06 <MifareUltralightAppProcess+0x622>
            }

            case CMD_FAST_READ: {
                uint8_t StartPageAddress = Buffer[1];
    6914:	f8 01       	movw	r30, r16
    6916:	d1 80       	ldd	r13, Z+1	; 0x01
                uint8_t EndPageAddress = Buffer[2];
    6918:	e2 80       	ldd	r14, Z+2	; 0x02
                /* Validation */
                if ((StartPageAddress > EndPageAddress) || (StartPageAddress >= PageCount) || (EndPageAddress >= PageCount)) {
    691a:	ed 14       	cp	r14, r13
    691c:	08 f4       	brcc	.+2      	; 0x6920 <MifareUltralightAppProcess+0x43c>
    691e:	65 cf       	rjmp	.-310    	; 0x67ea <MifareUltralightAppProcess+0x306>
    6920:	80 91 b7 2c 	lds	r24, 0x2CB7
    6924:	d8 16       	cp	r13, r24
    6926:	08 f0       	brcs	.+2      	; 0x692a <MifareUltralightAppProcess+0x446>
    6928:	60 cf       	rjmp	.-320    	; 0x67ea <MifareUltralightAppProcess+0x306>
    692a:	e8 16       	cp	r14, r24
    692c:	08 f0       	brcs	.+2      	; 0x6930 <MifareUltralightAppProcess+0x44c>
    692e:	5d cf       	rjmp	.-326    	; 0x67ea <MifareUltralightAppProcess+0x306>
                    Buffer[0] = NAK_INVALID_ARG;
                    return NAK_FRAME_SIZE;
                }
                /* Check authentication only if protection is read&write */
                if (ReadAccessProtected) {
    6930:	80 91 b2 2c 	lds	r24, 0x2CB2
    6934:	88 23       	and	r24, r24
    6936:	51 f0       	breq	.+20     	; 0x694c <MifareUltralightAppProcess+0x468>
                    if (!VerifyAuthentication(StartPageAddress) || !VerifyAuthentication(EndPageAddress)) {
    6938:	8d 2d       	mov	r24, r13
    693a:	68 dd       	rcall	.-1328   	; 0x640c <VerifyAuthentication>
    693c:	88 23       	and	r24, r24
    693e:	09 f4       	brne	.+2      	; 0x6942 <MifareUltralightAppProcess+0x45e>
    6940:	46 c0       	rjmp	.+140    	; 0x69ce <MifareUltralightAppProcess+0x4ea>
    6942:	8e 2d       	mov	r24, r14
    6944:	63 dd       	rcall	.-1338   	; 0x640c <VerifyAuthentication>
    6946:	88 23       	and	r24, r24
    6948:	09 f4       	brne	.+2      	; 0x694c <MifareUltralightAppProcess+0x468>
    694a:	41 c0       	rjmp	.+130    	; 0x69ce <MifareUltralightAppProcess+0x4ea>
                        Buffer[0] = NAK_AUTH_REQUIRED;
                        return NAK_FRAME_SIZE;
                    }
                }
                /* NOTE: With the current implementation, reading the password out is possible. */
                ByteCount = (EndPageAddress - StartPageAddress + 1) * MIFARE_ULTRALIGHT_PAGE_SIZE;
    694c:	f1 2c       	mov	r15, r1
    694e:	6d 2d       	mov	r22, r13
    6950:	70 e0       	ldi	r23, 0x00	; 0
    6952:	e6 1a       	sub	r14, r22
    6954:	f7 0a       	sbc	r15, r23
    6956:	ff ef       	ldi	r31, 0xFF	; 255
    6958:	ef 1a       	sub	r14, r31
    695a:	ff 0a       	sbc	r15, r31
    695c:	ee 0c       	add	r14, r14
    695e:	ff 1c       	adc	r15, r15
    6960:	ee 0c       	add	r14, r14
    6962:	ff 1c       	adc	r15, r15
                MemoryReadBlock(Buffer, StartPageAddress * MIFARE_ULTRALIGHT_PAGE_SIZE, ByteCount);
    6964:	66 0f       	add	r22, r22
    6966:	77 1f       	adc	r23, r23
    6968:	66 0f       	add	r22, r22
    696a:	77 1f       	adc	r23, r23
    696c:	a7 01       	movw	r20, r14
    696e:	c8 01       	movw	r24, r16
    6970:	0e 94 a1 0f 	call	0x1f42	; 0x1f42 <MemoryReadBlock>
                ISO14443AAppendCRCA(Buffer, ByteCount);
    6974:	b7 01       	movw	r22, r14
    6976:	c8 01       	movw	r24, r16
    6978:	0e 94 63 3d 	call	0x7ac6	; 0x7ac6 <ISO14443AAppendCRCA>
                return (ByteCount + ISO14443A_CRCA_SIZE) * 8;
    697c:	c7 01       	movw	r24, r14
    697e:	02 96       	adiw	r24, 0x02	; 2
    6980:	f3 e0       	ldi	r31, 0x03	; 3
    6982:	88 0f       	add	r24, r24
    6984:	99 1f       	adc	r25, r25
    6986:	fa 95       	dec	r31
    6988:	e1 f7       	brne	.-8      	; 0x6982 <MifareUltralightAppProcess+0x49e>
    698a:	bd c0       	rjmp	.+378    	; 0x6b06 <MifareUltralightAppProcess+0x622>
            }

            case CMD_PWD_AUTH: {
                uint8_t ConfigAreaAddress = PageCount * MIFARE_ULTRALIGHT_PAGE_SIZE - CONFIG_AREA_SIZE;
    698c:	60 91 b7 2c 	lds	r22, 0x2CB7
    6990:	66 0f       	add	r22, r22
    6992:	66 0f       	add	r22, r22
    6994:	60 51       	subi	r22, 0x10	; 16
                    /* Too many failed attempts */
                    Buffer[0] = NAK_AUTH_FAILED;
                    return NAK_FRAME_SIZE;
                }
                /* Read and compare the password */
                MemoryReadBlock(Password, ConfigAreaAddress + CONF_PASSWORD_OFFSET, 4);
    6996:	e6 2e       	mov	r14, r22
    6998:	f1 2c       	mov	r15, r1
    699a:	b7 01       	movw	r22, r14
    699c:	68 5f       	subi	r22, 0xF8	; 248
    699e:	7f 4f       	sbci	r23, 0xFF	; 255
    69a0:	44 e0       	ldi	r20, 0x04	; 4
    69a2:	50 e0       	ldi	r21, 0x00	; 0
    69a4:	ce 01       	movw	r24, r28
    69a6:	01 96       	adiw	r24, 0x01	; 1
    69a8:	0e 94 a1 0f 	call	0x1f42	; 0x1f42 <MemoryReadBlock>
                if (Password[0] != Buffer[1] || Password[1] != Buffer[2] || Password[2] != Buffer[3] || Password[3] != Buffer[4]) {
    69ac:	99 81       	ldd	r25, Y+1	; 0x01
    69ae:	f8 01       	movw	r30, r16
    69b0:	81 81       	ldd	r24, Z+1	; 0x01
    69b2:	98 13       	cpse	r25, r24
    69b4:	0c c0       	rjmp	.+24     	; 0x69ce <MifareUltralightAppProcess+0x4ea>
    69b6:	9a 81       	ldd	r25, Y+2	; 0x02
    69b8:	82 81       	ldd	r24, Z+2	; 0x02
    69ba:	98 13       	cpse	r25, r24
    69bc:	08 c0       	rjmp	.+16     	; 0x69ce <MifareUltralightAppProcess+0x4ea>
    69be:	9b 81       	ldd	r25, Y+3	; 0x03
    69c0:	83 81       	ldd	r24, Z+3	; 0x03
    69c2:	98 13       	cpse	r25, r24
    69c4:	04 c0       	rjmp	.+8      	; 0x69ce <MifareUltralightAppProcess+0x4ea>
    69c6:	9c 81       	ldd	r25, Y+4	; 0x04
    69c8:	84 81       	ldd	r24, Z+4	; 0x04
    69ca:	98 17       	cp	r25, r24
    69cc:	11 f0       	breq	.+4      	; 0x69d2 <MifareUltralightAppProcess+0x4ee>
                    Buffer[0] = NAK_AUTH_FAILED;
    69ce:	86 e0       	ldi	r24, 0x06	; 6
    69d0:	74 c0       	rjmp	.+232    	; 0x6aba <MifareUltralightAppProcess+0x5d6>
                    return NAK_FRAME_SIZE;
                }
                /* Authenticate the user */
                AuthCounterReset();
                Authenticated = 1;
    69d2:	81 e0       	ldi	r24, 0x01	; 1
    69d4:	80 93 b4 2c 	sts	0x2CB4, r24
                /* Send the PACK value back */
                MemoryReadBlock(Buffer, ConfigAreaAddress + CONF_PACK_OFFSET, 2);
    69d8:	b7 01       	movw	r22, r14
    69da:	64 5f       	subi	r22, 0xF4	; 244
    69dc:	7f 4f       	sbci	r23, 0xFF	; 255
    69de:	42 e0       	ldi	r20, 0x02	; 2
    69e0:	50 e0       	ldi	r21, 0x00	; 0
    69e2:	c8 01       	movw	r24, r16
    69e4:	0e 94 a1 0f 	call	0x1f42	; 0x1f42 <MemoryReadBlock>
                ISO14443AAppendCRCA(Buffer, 2);
    69e8:	62 e0       	ldi	r22, 0x02	; 2
    69ea:	70 e0       	ldi	r23, 0x00	; 0
    69ec:	c8 01       	movw	r24, r16
    69ee:	0e 94 63 3d 	call	0x7ac6	; 0x7ac6 <ISO14443AAppendCRCA>
                return (2 + ISO14443A_CRCA_SIZE) * 8;
    69f2:	80 e2       	ldi	r24, 0x20	; 32
    69f4:	90 e0       	ldi	r25, 0x00	; 0
    69f6:	87 c0       	rjmp	.+270    	; 0x6b06 <MifareUltralightAppProcess+0x622>
            }

            case CMD_READ_CNT: {
                uint8_t CounterId = Buffer[1];
    69f8:	f8 01       	movw	r30, r16
    69fa:	61 81       	ldd	r22, Z+1	; 0x01
                /* Validation */
                if (CounterId > CNT_MAX) {
    69fc:	63 30       	cpi	r22, 0x03	; 3
    69fe:	08 f0       	brcs	.+2      	; 0x6a02 <MifareUltralightAppProcess+0x51e>
    6a00:	f4 ce       	rjmp	.-536    	; 0x67ea <MifareUltralightAppProcess+0x306>
                    Buffer[0] = NAK_INVALID_ARG;
                    return NAK_FRAME_SIZE;
                }
                /* Returned counter length is 3 bytes */
                MemoryReadBlock(Buffer, (PageCount + CounterId) * MIFARE_ULTRALIGHT_PAGE_SIZE, 3);
    6a02:	80 91 b7 2c 	lds	r24, 0x2CB7
    6a06:	70 e0       	ldi	r23, 0x00	; 0
    6a08:	68 0f       	add	r22, r24
    6a0a:	71 1d       	adc	r23, r1
    6a0c:	66 0f       	add	r22, r22
    6a0e:	77 1f       	adc	r23, r23
    6a10:	66 0f       	add	r22, r22
    6a12:	77 1f       	adc	r23, r23
    6a14:	43 e0       	ldi	r20, 0x03	; 3
    6a16:	50 e0       	ldi	r21, 0x00	; 0
    6a18:	c8 01       	movw	r24, r16
    6a1a:	0e 94 a1 0f 	call	0x1f42	; 0x1f42 <MemoryReadBlock>
                ISO14443AAppendCRCA(Buffer, 3);
    6a1e:	63 e0       	ldi	r22, 0x03	; 3
    6a20:	70 e0       	ldi	r23, 0x00	; 0
    6a22:	c8 01       	movw	r24, r16
    6a24:	0e 94 63 3d 	call	0x7ac6	; 0x7ac6 <ISO14443AAppendCRCA>
                return (3 + ISO14443A_CRCA_SIZE) * 8;
    6a28:	88 e2       	ldi	r24, 0x28	; 40
    6a2a:	90 e0       	ldi	r25, 0x00	; 0
    6a2c:	6c c0       	rjmp	.+216    	; 0x6b06 <MifareUltralightAppProcess+0x622>
            }

            case CMD_INCREMENT_CNT: {
                uint8_t CounterId = Buffer[1];
    6a2e:	f8 01       	movw	r30, r16
    6a30:	21 81       	ldd	r18, Z+1	; 0x01
                uint32_t Addend = (Buffer[0]) | (Buffer[1] << 8) | ((uint32_t)Buffer[2] << 16);
    6a32:	e2 2e       	mov	r14, r18
    6a34:	f1 2c       	mov	r15, r1
    6a36:	9e 2d       	mov	r25, r14
    6a38:	88 27       	eor	r24, r24
    6a3a:	85 6a       	ori	r24, 0xA5	; 165
    6a3c:	09 2e       	mov	r0, r25
    6a3e:	00 0c       	add	r0, r0
    6a40:	aa 0b       	sbc	r26, r26
    6a42:	bb 0b       	sbc	r27, r27
    6a44:	32 81       	ldd	r19, Z+2	; 0x02
    6a46:	4c 01       	movw	r8, r24
    6a48:	5d 01       	movw	r10, r26
    6a4a:	a3 2a       	or	r10, r19
                uint32_t Counter;
                /* Validation */
                if (CounterId > CNT_MAX) {
    6a4c:	23 30       	cpi	r18, 0x03	; 3
    6a4e:	10 f0       	brcs	.+4      	; 0x6a54 <MifareUltralightAppProcess+0x570>
                    Buffer[0] = NAK_INVALID_ARG;
    6a50:	10 82       	st	Z, r1
    6a52:	35 c0       	rjmp	.+106    	; 0x6abe <MifareUltralightAppProcess+0x5da>
                    return NAK_FRAME_SIZE;
                }
                /* Read the value out */
                MemoryReadBlock(&Counter, (PageCount + CounterId) * MIFARE_ULTRALIGHT_PAGE_SIZE, MIFARE_ULTRALIGHT_PAGE_SIZE);
    6a54:	80 91 b7 2c 	lds	r24, 0x2CB7
    6a58:	b7 01       	movw	r22, r14
    6a5a:	68 0f       	add	r22, r24
    6a5c:	71 1d       	adc	r23, r1
    6a5e:	66 0f       	add	r22, r22
    6a60:	77 1f       	adc	r23, r23
    6a62:	66 0f       	add	r22, r22
    6a64:	77 1f       	adc	r23, r23
    6a66:	44 e0       	ldi	r20, 0x04	; 4
    6a68:	50 e0       	ldi	r21, 0x00	; 0
    6a6a:	ce 01       	movw	r24, r28
    6a6c:	01 96       	adiw	r24, 0x01	; 1
    6a6e:	0e 94 a1 0f 	call	0x1f42	; 0x1f42 <MemoryReadBlock>
                /* Add and check for overflow */
                Counter += Addend;
    6a72:	49 81       	ldd	r20, Y+1	; 0x01
    6a74:	5a 81       	ldd	r21, Y+2	; 0x02
    6a76:	6b 81       	ldd	r22, Y+3	; 0x03
    6a78:	7c 81       	ldd	r23, Y+4	; 0x04
    6a7a:	d5 01       	movw	r26, r10
    6a7c:	c4 01       	movw	r24, r8
    6a7e:	84 0f       	add	r24, r20
    6a80:	95 1f       	adc	r25, r21
    6a82:	a6 1f       	adc	r26, r22
    6a84:	b7 1f       	adc	r27, r23
    6a86:	89 83       	std	Y+1, r24	; 0x01
    6a88:	9a 83       	std	Y+2, r25	; 0x02
    6a8a:	ab 83       	std	Y+3, r26	; 0x03
    6a8c:	bc 83       	std	Y+4, r27	; 0x04
                if (Counter > CNT_MAX_VALUE) {
    6a8e:	00 97       	sbiw	r24, 0x00	; 0
    6a90:	a1 05       	cpc	r26, r1
    6a92:	b1 40       	sbci	r27, 0x01	; 1
    6a94:	10 f0       	brcs	.+4      	; 0x6a9a <MifareUltralightAppProcess+0x5b6>
                    Buffer[0] = NAK_CTR_ERROR;
    6a96:	84 e0       	ldi	r24, 0x04	; 4
    6a98:	10 c0       	rjmp	.+32     	; 0x6aba <MifareUltralightAppProcess+0x5d6>
                    return NAK_FRAME_SIZE;
                }
                /* Update memory */
                MemoryWriteBlock(&Counter, (PageCount + CounterId) * MIFARE_ULTRALIGHT_PAGE_SIZE, MIFARE_ULTRALIGHT_PAGE_SIZE);
    6a9a:	80 91 b7 2c 	lds	r24, 0x2CB7
    6a9e:	b7 01       	movw	r22, r14
    6aa0:	68 0f       	add	r22, r24
    6aa2:	71 1d       	adc	r23, r1
    6aa4:	66 0f       	add	r22, r22
    6aa6:	77 1f       	adc	r23, r23
    6aa8:	66 0f       	add	r22, r22
    6aaa:	77 1f       	adc	r23, r23
    6aac:	44 e0       	ldi	r20, 0x04	; 4
    6aae:	50 e0       	ldi	r21, 0x00	; 0
    6ab0:	ce 01       	movw	r24, r28
    6ab2:	01 96       	adiw	r24, 0x01	; 1
    6ab4:	0e 94 ef 0f 	call	0x1fde	; 0x1fde <MemoryWriteBlock>
                Buffer[0] = ACK_VALUE;
    6ab8:	8a e0       	ldi	r24, 0x0A	; 10
    6aba:	f8 01       	movw	r30, r16
    6abc:	80 83       	st	Z, r24
    6abe:	84 e0       	ldi	r24, 0x04	; 4
    6ac0:	90 e0       	ldi	r25, 0x00	; 0
    6ac2:	21 c0       	rjmp	.+66     	; 0x6b06 <MifareUltralightAppProcess+0x622>
                return ACK_FRAME_SIZE;
            }

            case CMD_READ_SIG:
                /* Hardcoded response */
                memset(Buffer, 0xCA, SIGNATURE_LENGTH);
    6ac4:	40 e2       	ldi	r20, 0x20	; 32
    6ac6:	50 e0       	ldi	r21, 0x00	; 0
    6ac8:	6a ec       	ldi	r22, 0xCA	; 202
    6aca:	70 e0       	ldi	r23, 0x00	; 0
    6acc:	c8 01       	movw	r24, r16
    6ace:	0e 94 01 66 	call	0xcc02	; 0xcc02 <memset>
                ISO14443AAppendCRCA(Buffer, SIGNATURE_LENGTH);
    6ad2:	60 e2       	ldi	r22, 0x20	; 32
    6ad4:	70 e0       	ldi	r23, 0x00	; 0
    6ad6:	c8 01       	movw	r24, r16
    6ad8:	f6 d7       	rcall	.+4076   	; 0x7ac6 <ISO14443AAppendCRCA>
                return (SIGNATURE_LENGTH + ISO14443A_CRCA_SIZE) * 8;
    6ada:	80 e1       	ldi	r24, 0x10	; 16
    6adc:	91 e0       	ldi	r25, 0x01	; 1
    6ade:	13 c0       	rjmp	.+38     	; 0x6b06 <MifareUltralightAppProcess+0x622>
                Buffer[0] = 0xBD;
                ISO14443AAppendCRCA(Buffer, 1);
                return (1 + ISO14443A_CRCA_SIZE) * 8;

            case CMD_VCSL: {
                uint8_t ConfigAreaAddress = PageCount * MIFARE_ULTRALIGHT_PAGE_SIZE - CONFIG_AREA_SIZE;
    6ae0:	60 91 b7 2c 	lds	r22, 0x2CB7
    6ae4:	66 0f       	add	r22, r22
    6ae6:	66 0f       	add	r22, r22
    6ae8:	60 51       	subi	r22, 0x10	; 16
                /* Input is ignored completely */
                /* Read out the value */
                MemoryReadBlock(Buffer, ConfigAreaAddress + CONF_VCTID_OFFSET, 1);
    6aea:	70 e0       	ldi	r23, 0x00	; 0
    6aec:	6b 5f       	subi	r22, 0xFB	; 251
    6aee:	7f 4f       	sbci	r23, 0xFF	; 255
    6af0:	41 e0       	ldi	r20, 0x01	; 1
    6af2:	50 e0       	ldi	r21, 0x00	; 0
    6af4:	c8 01       	movw	r24, r16
    6af6:	0e 94 a1 0f 	call	0x1f42	; 0x1f42 <MemoryReadBlock>
                ISO14443AAppendCRCA(Buffer, 1);
    6afa:	61 e0       	ldi	r22, 0x01	; 1
    6afc:	70 e0       	ldi	r23, 0x00	; 0
    6afe:	c8 01       	movw	r24, r16
    6b00:	e2 d7       	rcall	.+4036   	; 0x7ac6 <ISO14443AAppendCRCA>
                return (1 + ISO14443A_CRCA_SIZE) * 8;
    6b02:	88 e1       	ldi	r24, 0x18	; 24
    6b04:	90 e0       	ldi	r25, 0x00	; 0
        break;
    }

    /* No response has been sent, when we reach here */
    return ISO14443A_APP_NO_RESPONSE;
}
    6b06:	25 96       	adiw	r28, 0x05	; 5
    6b08:	cd bf       	out	0x3d, r28	; 61
    6b0a:	de bf       	out	0x3e, r29	; 62
    6b0c:	df 91       	pop	r29
    6b0e:	cf 91       	pop	r28
    6b10:	1f 91       	pop	r17
    6b12:	0f 91       	pop	r16
    6b14:	ff 90       	pop	r15
    6b16:	ef 90       	pop	r14
    6b18:	df 90       	pop	r13
    6b1a:	cf 90       	pop	r12
    6b1c:	bf 90       	pop	r11
    6b1e:	af 90       	pop	r10
    6b20:	9f 90       	pop	r9
    6b22:	8f 90       	pop	r8
    6b24:	08 95       	ret

00006b26 <MifareUltralightGetUid>:

void MifareUltralightGetUid(ConfigurationUidType Uid)
{
    6b26:	cf 93       	push	r28
    6b28:	df 93       	push	r29
    6b2a:	ec 01       	movw	r28, r24
    /* Read UID from memory */
    MemoryReadBlock(&Uid[0], UID_CL1_ADDRESS, UID_CL1_SIZE);
    6b2c:	43 e0       	ldi	r20, 0x03	; 3
    6b2e:	50 e0       	ldi	r21, 0x00	; 0
    6b30:	60 e0       	ldi	r22, 0x00	; 0
    6b32:	70 e0       	ldi	r23, 0x00	; 0
    6b34:	0e 94 a1 0f 	call	0x1f42	; 0x1f42 <MemoryReadBlock>
    MemoryReadBlock(&Uid[UID_CL1_SIZE], UID_CL2_ADDRESS, UID_CL2_SIZE);
    6b38:	44 e0       	ldi	r20, 0x04	; 4
    6b3a:	50 e0       	ldi	r21, 0x00	; 0
    6b3c:	64 e0       	ldi	r22, 0x04	; 4
    6b3e:	70 e0       	ldi	r23, 0x00	; 0
    6b40:	ce 01       	movw	r24, r28
    6b42:	03 96       	adiw	r24, 0x03	; 3
}
    6b44:	df 91       	pop	r29
    6b46:	cf 91       	pop	r28

void MifareUltralightGetUid(ConfigurationUidType Uid)
{
    /* Read UID from memory */
    MemoryReadBlock(&Uid[0], UID_CL1_ADDRESS, UID_CL1_SIZE);
    MemoryReadBlock(&Uid[UID_CL1_SIZE], UID_CL2_ADDRESS, UID_CL2_SIZE);
    6b48:	0c 94 a1 0f 	jmp	0x1f42	; 0x1f42 <MemoryReadBlock>

00006b4c <MifareUltralightSetUid>:
}

void MifareUltralightSetUid(ConfigurationUidType Uid)
{
    6b4c:	0f 93       	push	r16
    6b4e:	1f 93       	push	r17
    6b50:	cf 93       	push	r28
    6b52:	df 93       	push	r29
    6b54:	1f 92       	push	r1
    6b56:	1f 92       	push	r1
    6b58:	cd b7       	in	r28, 0x3d	; 61
    6b5a:	de b7       	in	r29, 0x3e	; 62
    6b5c:	8c 01       	movw	r16, r24
    /* Calculate check bytes and write everything into memory */
    uint8_t BCC1 = ISO14443A_UID0_CT ^ Uid[0] ^ Uid[1] ^ Uid[2];
    6b5e:	fc 01       	movw	r30, r24
    6b60:	90 81       	ld	r25, Z
    6b62:	81 81       	ldd	r24, Z+1	; 0x01
    6b64:	89 27       	eor	r24, r25
    6b66:	98 e8       	ldi	r25, 0x88	; 136
    6b68:	89 27       	eor	r24, r25
    6b6a:	92 81       	ldd	r25, Z+2	; 0x02
    6b6c:	89 27       	eor	r24, r25
    6b6e:	8a 83       	std	Y+2, r24	; 0x02
    uint8_t BCC2 = Uid[3] ^ Uid[4] ^ Uid[5] ^ Uid[6];
    6b70:	94 81       	ldd	r25, Z+4	; 0x04
    6b72:	83 81       	ldd	r24, Z+3	; 0x03
    6b74:	89 27       	eor	r24, r25
    6b76:	95 81       	ldd	r25, Z+5	; 0x05
    6b78:	89 27       	eor	r24, r25
    6b7a:	96 81       	ldd	r25, Z+6	; 0x06
    6b7c:	89 27       	eor	r24, r25
    6b7e:	89 83       	std	Y+1, r24	; 0x01

    MemoryWriteBlock(&Uid[0], UID_CL1_ADDRESS, UID_CL1_SIZE);
    6b80:	43 e0       	ldi	r20, 0x03	; 3
    6b82:	50 e0       	ldi	r21, 0x00	; 0
    6b84:	60 e0       	ldi	r22, 0x00	; 0
    6b86:	70 e0       	ldi	r23, 0x00	; 0
    6b88:	c8 01       	movw	r24, r16
    6b8a:	0e 94 ef 0f 	call	0x1fde	; 0x1fde <MemoryWriteBlock>
    MemoryWriteBlock(&BCC1, UID_BCC1_ADDRESS, ISO14443A_CL_BCC_SIZE);
    6b8e:	41 e0       	ldi	r20, 0x01	; 1
    6b90:	50 e0       	ldi	r21, 0x00	; 0
    6b92:	63 e0       	ldi	r22, 0x03	; 3
    6b94:	70 e0       	ldi	r23, 0x00	; 0
    6b96:	ce 01       	movw	r24, r28
    6b98:	02 96       	adiw	r24, 0x02	; 2
    6b9a:	0e 94 ef 0f 	call	0x1fde	; 0x1fde <MemoryWriteBlock>
    MemoryWriteBlock(&Uid[UID_CL1_SIZE], UID_CL2_ADDRESS, UID_CL2_SIZE);
    6b9e:	44 e0       	ldi	r20, 0x04	; 4
    6ba0:	50 e0       	ldi	r21, 0x00	; 0
    6ba2:	64 e0       	ldi	r22, 0x04	; 4
    6ba4:	70 e0       	ldi	r23, 0x00	; 0
    6ba6:	c8 01       	movw	r24, r16
    6ba8:	03 96       	adiw	r24, 0x03	; 3
    6baa:	0e 94 ef 0f 	call	0x1fde	; 0x1fde <MemoryWriteBlock>
    MemoryWriteBlock(&BCC2, UID_BCC2_ADDRESS, ISO14443A_CL_BCC_SIZE);
    6bae:	41 e0       	ldi	r20, 0x01	; 1
    6bb0:	50 e0       	ldi	r21, 0x00	; 0
    6bb2:	68 e0       	ldi	r22, 0x08	; 8
    6bb4:	70 e0       	ldi	r23, 0x00	; 0
    6bb6:	ce 01       	movw	r24, r28
    6bb8:	01 96       	adiw	r24, 0x01	; 1
    6bba:	0e 94 ef 0f 	call	0x1fde	; 0x1fde <MemoryWriteBlock>
}
    6bbe:	0f 90       	pop	r0
    6bc0:	0f 90       	pop	r0
    6bc2:	df 91       	pop	r29
    6bc4:	cf 91       	pop	r28
    6bc6:	1f 91       	pop	r17
    6bc8:	0f 91       	pop	r16
    6bca:	08 95       	ret

00006bcc <MifareClassicAppInit1K>:
    Block[11] = Block[3];
}

void MifareClassicAppInit1K(void)
{
    State = STATE_IDLE;
    6bcc:	81 e0       	ldi	r24, 0x01	; 1
    6bce:	80 93 de 2c 	sts	0x2CDE, r24
    CardATQAValue = MFCLASSIC_1K_ATQA_VALUE;
    6bd2:	84 e0       	ldi	r24, 0x04	; 4
    6bd4:	90 e0       	ldi	r25, 0x00	; 0
    6bd6:	80 93 bd 2c 	sts	0x2CBD, r24
    6bda:	90 93 be 2c 	sts	0x2CBE, r25
    CardSAKValue = MFCLASSIC_1K_SAK_VALUE;
    6bde:	88 e0       	ldi	r24, 0x08	; 8
    6be0:	80 93 bc 2c 	sts	0x2CBC, r24
    FromHalt = false;
    6be4:	10 92 bb 2c 	sts	0x2CBB, r1
    6be8:	08 95       	ret

00006bea <MifareClassicAppInit1K7B>:
}

void MifareClassicAppInit1K7B(void)
{
    State = STATE_IDLE;
    6bea:	81 e0       	ldi	r24, 0x01	; 1
    6bec:	80 93 de 2c 	sts	0x2CDE, r24
    CardATQAValue = MFCLASSIC_1K_7B_ATQA_VALUE;
    6bf0:	84 e4       	ldi	r24, 0x44	; 68
    6bf2:	90 e0       	ldi	r25, 0x00	; 0
    6bf4:	80 93 bd 2c 	sts	0x2CBD, r24
    6bf8:	90 93 be 2c 	sts	0x2CBE, r25
    CardSAKValue = MFCLASSIC_1K_SAK_VALUE;
    6bfc:	88 e0       	ldi	r24, 0x08	; 8
    6bfe:	80 93 bc 2c 	sts	0x2CBC, r24
    FromHalt = false;
    6c02:	10 92 bb 2c 	sts	0x2CBB, r1
    6c06:	08 95       	ret

00006c08 <MifareClassicAppInit4K>:
}


void MifareClassicAppInit4K(void)
{
    State = STATE_IDLE;
    6c08:	81 e0       	ldi	r24, 0x01	; 1
    6c0a:	80 93 de 2c 	sts	0x2CDE, r24
    CardATQAValue = MFCLASSIC_4K_ATQA_VALUE;
    6c0e:	82 e0       	ldi	r24, 0x02	; 2
    6c10:	90 e0       	ldi	r25, 0x00	; 0
    6c12:	80 93 bd 2c 	sts	0x2CBD, r24
    6c16:	90 93 be 2c 	sts	0x2CBE, r25
    CardSAKValue = MFCLASSIC_4K_SAK_VALUE;
    6c1a:	88 e1       	ldi	r24, 0x18	; 24
    6c1c:	80 93 bc 2c 	sts	0x2CBC, r24
    FromHalt = false;
    6c20:	10 92 bb 2c 	sts	0x2CBB, r1
    6c24:	08 95       	ret

00006c26 <MifareClassicAppInit4K7B>:
}

void MifareClassicAppInit4K7B(void)
{
    State = STATE_IDLE;
    6c26:	81 e0       	ldi	r24, 0x01	; 1
    6c28:	80 93 de 2c 	sts	0x2CDE, r24
    CardATQAValue = MFCLASSIC_4K_7B_ATQA_VALUE;
    6c2c:	82 e4       	ldi	r24, 0x42	; 66
    6c2e:	90 e0       	ldi	r25, 0x00	; 0
    6c30:	80 93 bd 2c 	sts	0x2CBD, r24
    6c34:	90 93 be 2c 	sts	0x2CBE, r25
    CardSAKValue = MFCLASSIC_4K_SAK_VALUE;
    6c38:	88 e1       	ldi	r24, 0x18	; 24
    6c3a:	80 93 bc 2c 	sts	0x2CBC, r24
    FromHalt = false;
    6c3e:	10 92 bb 2c 	sts	0x2CBB, r1
    6c42:	08 95       	ret

00006c44 <MifareClassicAppReset>:
}

void MifareClassicAppReset(void)
{
    State = STATE_IDLE;
    6c44:	81 e0       	ldi	r24, 0x01	; 1
    6c46:	80 93 de 2c 	sts	0x2CDE, r24
    6c4a:	08 95       	ret

00006c4c <MifareClassicAppTask>:
}

void MifareClassicAppTask(void)
{
    6c4c:	08 95       	ret

00006c4e <MifareClassicAppProcess>:

}

uint16_t MifareClassicAppProcess(uint8_t* Buffer, uint16_t BitCount)
{
    6c4e:	8f 92       	push	r8
    6c50:	9f 92       	push	r9
    6c52:	af 92       	push	r10
    6c54:	bf 92       	push	r11
    6c56:	cf 92       	push	r12
    6c58:	df 92       	push	r13
    6c5a:	ef 92       	push	r14
    6c5c:	ff 92       	push	r15
    6c5e:	0f 93       	push	r16
    6c60:	1f 93       	push	r17
    6c62:	cf 93       	push	r28
    6c64:	df 93       	push	r29
    6c66:	cd b7       	in	r28, 0x3d	; 61
    6c68:	de b7       	in	r29, 0x3e	; 62
    6c6a:	63 97       	sbiw	r28, 0x13	; 19
    6c6c:	cd bf       	out	0x3d, r28	; 61
    6c6e:	de bf       	out	0x3e, r29	; 62
    6c70:	8c 01       	movw	r16, r24
    6c72:	5b 01       	movw	r10, r22
    6c74:	80 91 de 2c 	lds	r24, 0x2CDE
    /* Wakeup and Request may occure in all states */
    if ( (BitCount == 7) &&
    6c78:	67 30       	cpi	r22, 0x07	; 7
    6c7a:	71 05       	cpc	r23, r1
    6c7c:	01 f5       	brne	.+64     	; 0x6cbe <MifareClassicAppProcess+0x70>
    6c7e:	f8 01       	movw	r30, r16
    6c80:	90 81       	ld	r25, Z
    6c82:	88 23       	and	r24, r24
    6c84:	11 f0       	breq	.+4      	; 0x6c8a <MifareClassicAppProcess+0x3c>
         /* precheck of WUP/REQ because ISO14443AWakeUp destroys BitCount */
         (((State != STATE_HALT) && (Buffer[0] == ISO14443A_CMD_REQA)) ||
    6c86:	96 32       	cpi	r25, 0x26	; 38
    6c88:	11 f0       	breq	.+4      	; 0x6c8e <MifareClassicAppProcess+0x40>
    6c8a:	92 35       	cpi	r25, 0x52	; 82
    6c8c:	c1 f4       	brne	.+48     	; 0x6cbe <MifareClassicAppProcess+0x70>
         (Buffer[0] == ISO14443A_CMD_WUPA) )){
    	FromHalt = State == STATE_HALT;
    6c8e:	21 e0       	ldi	r18, 0x01	; 1
    6c90:	81 11       	cpse	r24, r1
    6c92:	20 e0       	ldi	r18, 0x00	; 0
    6c94:	20 93 bb 2c 	sts	0x2CBB, r18
        if (ISO14443AWakeUp(Buffer, &BitCount, CardATQAValue, FromHalt)) {
    6c98:	40 91 bd 2c 	lds	r20, 0x2CBD
    6c9c:	30 91 be 2c 	lds	r19, 0x2CBE
INLINE
bool ISO14443AWakeUp(void* Buffer, uint16_t* BitCount, uint16_t ATQAValue, bool FromHalt)
{
    uint8_t* DataPtr = (uint8_t*) Buffer;

    if ( ((! FromHalt) && (DataPtr[0] == ISO14443A_CMD_REQA)) ||
    6ca0:	21 11       	cpse	r18, r1
    6ca2:	02 c0       	rjmp	.+4      	; 0x6ca8 <MifareClassicAppProcess+0x5a>
    6ca4:	96 32       	cpi	r25, 0x26	; 38
    6ca6:	11 f0       	breq	.+4      	; 0x6cac <MifareClassicAppProcess+0x5e>
    6ca8:	92 35       	cpi	r25, 0x52	; 82
    6caa:	39 f4       	brne	.+14     	; 0x6cba <MifareClassicAppProcess+0x6c>
         (DataPtr[0] == ISO14443A_CMD_WUPA) ){
        DataPtr[0] = (ATQAValue >> 0) & 0x00FF;
    6cac:	f8 01       	movw	r30, r16
    6cae:	40 83       	st	Z, r20
        DataPtr[1] = (ATQAValue >> 8) & 0x00FF;
    6cb0:	31 83       	std	Z+1, r19	; 0x01
            AccessAddress = 0xff;
    6cb2:	8f ef       	ldi	r24, 0xFF	; 255
    6cb4:	80 93 bf 2c 	sts	0x2CBF, r24
    6cb8:	38 c0       	rjmp	.+112    	; 0x6d2a <MifareClassicAppProcess+0xdc>

        *BitCount = ISO14443A_ATQA_FRAME_SIZE;

        return true;
    } else {
        *BitCount = 0;
    6cba:	a1 2c       	mov	r10, r1
    6cbc:	b1 2c       	mov	r11, r1
            State = STATE_READY1;
            return BitCount;
        }
    }

    switch(State) {
    6cbe:	85 30       	cpi	r24, 0x05	; 5
    6cc0:	09 f4       	brne	.+2      	; 0x6cc4 <MifareClassicAppProcess+0x76>
    6cc2:	9c c0       	rjmp	.+312    	; 0x6dfc <MifareClassicAppProcess+0x1ae>
    6cc4:	50 f4       	brcc	.+20     	; 0x6cda <MifareClassicAppProcess+0x8c>
    6cc6:	82 30       	cpi	r24, 0x02	; 2
    6cc8:	a9 f1       	breq	.+106    	; 0x6d34 <MifareClassicAppProcess+0xe6>
    6cca:	c8 f0       	brcs	.+50     	; 0x6cfe <MifareClassicAppProcess+0xb0>
    6ccc:	83 30       	cpi	r24, 0x03	; 3
    6cce:	09 f4       	brne	.+2      	; 0x6cd2 <MifareClassicAppProcess+0x84>
    6cd0:	69 c0       	rjmp	.+210    	; 0x6da4 <MifareClassicAppProcess+0x156>
    6cd2:	84 30       	cpi	r24, 0x04	; 4
    6cd4:	09 f4       	brne	.+2      	; 0x6cd8 <MifareClassicAppProcess+0x8a>
    6cd6:	82 c0       	rjmp	.+260    	; 0x6ddc <MifareClassicAppProcess+0x18e>
    6cd8:	c2 c5       	rjmp	.+2948   	; 0x785e <MifareClassicAppProcess+0xc10>
    6cda:	88 30       	cpi	r24, 0x08	; 8
    6cdc:	09 f4       	brne	.+2      	; 0x6ce0 <MifareClassicAppProcess+0x92>
    6cde:	25 c1       	rjmp	.+586    	; 0x6f2a <MifareClassicAppProcess+0x2dc>
    6ce0:	38 f4       	brcc	.+14     	; 0x6cf0 <MifareClassicAppProcess+0xa2>
    6ce2:	86 30       	cpi	r24, 0x06	; 6
    6ce4:	09 f4       	brne	.+2      	; 0x6ce8 <MifareClassicAppProcess+0x9a>
    6ce6:	9a c0       	rjmp	.+308    	; 0x6e1c <MifareClassicAppProcess+0x1ce>
    6ce8:	87 30       	cpi	r24, 0x07	; 7
    6cea:	09 f4       	brne	.+2      	; 0x6cee <MifareClassicAppProcess+0xa0>
    6cec:	d3 c0       	rjmp	.+422    	; 0x6e94 <MifareClassicAppProcess+0x246>
    6cee:	b7 c5       	rjmp	.+2926   	; 0x785e <MifareClassicAppProcess+0xc10>
    6cf0:	89 30       	cpi	r24, 0x09	; 9
    6cf2:	09 f4       	brne	.+2      	; 0x6cf6 <MifareClassicAppProcess+0xa8>
    6cf4:	4f c3       	rjmp	.+1694   	; 0x7394 <MifareClassicAppProcess+0x746>
    6cf6:	8d 30       	cpi	r24, 0x0D	; 13
    6cf8:	08 f4       	brcc	.+2      	; 0x6cfc <MifareClassicAppProcess+0xae>
    6cfa:	71 c3       	rjmp	.+1762   	; 0x73de <MifareClassicAppProcess+0x790>
    6cfc:	b0 c5       	rjmp	.+2912   	; 0x785e <MifareClassicAppProcess+0xc10>
    6cfe:	91 e0       	ldi	r25, 0x01	; 1
    6d00:	89 27       	eor	r24, r25
    case STATE_IDLE:
    case STATE_HALT:
    	FromHalt = State == STATE_HALT;
    6d02:	98 2f       	mov	r25, r24
    6d04:	91 70       	andi	r25, 0x01	; 1
    6d06:	90 93 bb 2c 	sts	0x2CBB, r25
        if (ISO14443AWakeUp(Buffer, &BitCount, CardATQAValue, FromHalt)) {
    6d0a:	30 91 bd 2c 	lds	r19, 0x2CBD
    6d0e:	20 91 be 2c 	lds	r18, 0x2CBE
    6d12:	f8 01       	movw	r30, r16
    6d14:	90 81       	ld	r25, Z
INLINE
bool ISO14443AWakeUp(void* Buffer, uint16_t* BitCount, uint16_t ATQAValue, bool FromHalt)
{
    uint8_t* DataPtr = (uint8_t*) Buffer;

    if ( ((! FromHalt) && (DataPtr[0] == ISO14443A_CMD_REQA)) ||
    6d16:	81 11       	cpse	r24, r1
    6d18:	02 c0       	rjmp	.+4      	; 0x6d1e <MifareClassicAppProcess+0xd0>
    6d1a:	96 32       	cpi	r25, 0x26	; 38
    6d1c:	19 f0       	breq	.+6      	; 0x6d24 <MifareClassicAppProcess+0xd6>
    6d1e:	92 35       	cpi	r25, 0x52	; 82
    6d20:	09 f0       	breq	.+2      	; 0x6d24 <MifareClassicAppProcess+0xd6>
    6d22:	19 c4       	rjmp	.+2098   	; 0x7556 <MifareClassicAppProcess+0x908>
         (DataPtr[0] == ISO14443A_CMD_WUPA) ){
        DataPtr[0] = (ATQAValue >> 0) & 0x00FF;
    6d24:	f8 01       	movw	r30, r16
    6d26:	30 83       	st	Z, r19
        DataPtr[1] = (ATQAValue >> 8) & 0x00FF;
    6d28:	21 83       	std	Z+1, r18	; 0x01
            State = STATE_READY1;
    6d2a:	84 e0       	ldi	r24, 0x04	; 4
    6d2c:	80 93 de 2c 	sts	0x2CDE, r24

        *BitCount = ISO14443A_ATQA_FRAME_SIZE;
    6d30:	80 e1       	ldi	r24, 0x10	; 16
    6d32:	96 c5       	rjmp	.+2860   	; 0x7860 <MifareClassicAppProcess+0xc12>
        break;

#ifdef SUPPORT_MF_CLASSIC_MAGIC_MODE
    case STATE_CHINESE_IDLE:
        /* Support special china commands that dont require authentication. */
        if (Buffer[0] == CMD_CHINESE_UNLOCK_RW) {
    6d34:	f8 01       	movw	r30, r16
    6d36:	80 81       	ld	r24, Z
            /* Unlock read and write commands */
            Buffer[0] = ACK_VALUE;
            return ACK_NAK_FRAME_SIZE;
        } else if (Buffer[0] == CMD_CHINESE_WIPE) {
    6d38:	98 2f       	mov	r25, r24
    6d3a:	9d 7f       	andi	r25, 0xFD	; 253
    6d3c:	91 34       	cpi	r25, 0x41	; 65
    6d3e:	19 f4       	brne	.+6      	; 0x6d46 <MifareClassicAppProcess+0xf8>
#ifdef SUPPORT_MF_CLASSIC_MAGIC_MODE
    case STATE_CHINESE_IDLE:
        /* Support special china commands that dont require authentication. */
        if (Buffer[0] == CMD_CHINESE_UNLOCK_RW) {
            /* Unlock read and write commands */
            Buffer[0] = ACK_VALUE;
    6d40:	8a e0       	ldi	r24, 0x0A	; 10
    6d42:	80 83       	st	Z, r24
    6d44:	67 c3       	rjmp	.+1742   	; 0x7414 <MifareClassicAppProcess+0x7c6>
            return ACK_NAK_FRAME_SIZE;
        } else if (Buffer[0] == CMD_CHINESE_WIPE) {
            /* Wipe memory */
            Buffer[0] = ACK_VALUE;
            return ACK_NAK_FRAME_SIZE;
        } else if (Buffer[0] == CMD_READ) {
    6d46:	80 33       	cpi	r24, 0x30	; 48
    6d48:	c1 f4       	brne	.+48     	; 0x6d7a <MifareClassicAppProcess+0x12c>
            if (ISO14443ACheckCRCA(Buffer, CMD_READ_FRAME_SIZE)) {
    6d4a:	62 e0       	ldi	r22, 0x02	; 2
    6d4c:	70 e0       	ldi	r23, 0x00	; 0
    6d4e:	c8 01       	movw	r24, r16
    6d50:	e5 d6       	rcall	.+3530   	; 0x7b1c <ISO14443ACheckCRCA>
    6d52:	88 23       	and	r24, r24
    6d54:	09 f4       	brne	.+2      	; 0x6d58 <MifareClassicAppProcess+0x10a>
    6d56:	9c c0       	rjmp	.+312    	; 0x6e90 <MifareClassicAppProcess+0x242>
                /* Read command. Read data from memory and append CRCA. */
                MemoryReadBlock(Buffer, (uint16_t)Buffer[1] * MEM_BYTES_PER_BLOCK, MEM_BYTES_PER_BLOCK);
    6d58:	f8 01       	movw	r30, r16
    6d5a:	61 81       	ldd	r22, Z+1	; 0x01
    6d5c:	f0 e1       	ldi	r31, 0x10	; 16
    6d5e:	6f 9f       	mul	r22, r31
    6d60:	b0 01       	movw	r22, r0
    6d62:	11 24       	eor	r1, r1
    6d64:	40 e1       	ldi	r20, 0x10	; 16
    6d66:	50 e0       	ldi	r21, 0x00	; 0
    6d68:	c8 01       	movw	r24, r16
    6d6a:	0e 94 a1 0f 	call	0x1f42	; 0x1f42 <MemoryReadBlock>
                ISO14443AAppendCRCA(Buffer, MEM_BYTES_PER_BLOCK);
    6d6e:	60 e1       	ldi	r22, 0x10	; 16
    6d70:	70 e0       	ldi	r23, 0x00	; 0
    6d72:	c8 01       	movw	r24, r16
    6d74:	a8 d6       	rcall	.+3408   	; 0x7ac6 <ISO14443AAppendCRCA>

                return (CMD_READ_RESPONSE_FRAME_SIZE + ISO14443A_CRCA_SIZE )
    6d76:	80 e9       	ldi	r24, 0x90	; 144
    6d78:	73 c5       	rjmp	.+2790   	; 0x7860 <MifareClassicAppProcess+0xc12>
                        * BITS_PER_BYTE;
            } else {
                Buffer[0] = NAK_CRC_ERROR;
                return ACK_NAK_FRAME_SIZE;
            }
        } else if (Buffer[0] == CMD_WRITE) {
    6d7a:	80 3a       	cpi	r24, 0xA0	; 160
    6d7c:	79 f4       	brne	.+30     	; 0x6d9c <MifareClassicAppProcess+0x14e>
            if (ISO14443ACheckCRCA(Buffer, CMD_WRITE_FRAME_SIZE)) {
    6d7e:	62 e0       	ldi	r22, 0x02	; 2
    6d80:	70 e0       	ldi	r23, 0x00	; 0
    6d82:	c8 01       	movw	r24, r16
    6d84:	cb d6       	rcall	.+3478   	; 0x7b1c <ISO14443ACheckCRCA>
    6d86:	88 23       	and	r24, r24
    6d88:	09 f4       	brne	.+2      	; 0x6d8c <MifareClassicAppProcess+0x13e>
    6d8a:	82 c0       	rjmp	.+260    	; 0x6e90 <MifareClassicAppProcess+0x242>
                /* Write command. Store the address and prepare for the upcoming data.
                * Respond with ACK. */
                CurrentAddress = Buffer[1];
    6d8c:	f8 01       	movw	r30, r16
    6d8e:	81 81       	ldd	r24, Z+1	; 0x01
    6d90:	80 93 d5 2c 	sts	0x2CD5, r24
                State = STATE_CHINESE_WRITE;
    6d94:	83 e0       	ldi	r24, 0x03	; 3
    6d96:	80 93 de 2c 	sts	0x2CDE, r24
    6d9a:	d2 cf       	rjmp	.-92     	; 0x6d40 <MifareClassicAppProcess+0xf2>
                return ACK_NAK_FRAME_SIZE;
            } else {
                Buffer[0] = NAK_CRC_ERROR;
                return ACK_NAK_FRAME_SIZE;
            }
        } else if (Buffer[0] == CMD_HALT) {
    6d9c:	80 35       	cpi	r24, 0x50	; 80
    6d9e:	09 f0       	breq	.+2      	; 0x6da2 <MifareClassicAppProcess+0x154>
    6da0:	5e c5       	rjmp	.+2748   	; 0x785e <MifareClassicAppProcess+0xc10>
    6da2:	52 c0       	rjmp	.+164    	; 0x6e48 <MifareClassicAppProcess+0x1fa>
            }
        }
        break;

    case STATE_CHINESE_WRITE:
        if (ISO14443ACheckCRCA(Buffer, MEM_BYTES_PER_BLOCK)) {
    6da4:	60 e1       	ldi	r22, 0x10	; 16
    6da6:	70 e0       	ldi	r23, 0x00	; 0
    6da8:	c8 01       	movw	r24, r16
    6daa:	b8 d6       	rcall	.+3440   	; 0x7b1c <ISO14443ACheckCRCA>
    6dac:	88 23       	and	r24, r24
    6dae:	89 f0       	breq	.+34     	; 0x6dd2 <MifareClassicAppProcess+0x184>
            /* CRC check passed. Write data into memory and send ACK. */
            if (!ActiveConfiguration.ReadOnly) {
    6db0:	80 91 6d 2f 	lds	r24, 0x2F6D
    6db4:	81 11       	cpse	r24, r1
    6db6:	0b c0       	rjmp	.+22     	; 0x6dce <MifareClassicAppProcess+0x180>
                MemoryWriteBlock(Buffer, CurrentAddress * MEM_BYTES_PER_BLOCK, MEM_BYTES_PER_BLOCK);
    6db8:	60 91 d5 2c 	lds	r22, 0x2CD5
    6dbc:	f0 e1       	ldi	r31, 0x10	; 16
    6dbe:	6f 9f       	mul	r22, r31
    6dc0:	b0 01       	movw	r22, r0
    6dc2:	11 24       	eor	r1, r1
    6dc4:	40 e1       	ldi	r20, 0x10	; 16
    6dc6:	50 e0       	ldi	r21, 0x00	; 0
    6dc8:	c8 01       	movw	r24, r16
    6dca:	0e 94 ef 0f 	call	0x1fde	; 0x1fde <MemoryWriteBlock>
            }

            Buffer[0] = ACK_VALUE;
    6dce:	8a e0       	ldi	r24, 0x0A	; 10
    6dd0:	01 c0       	rjmp	.+2      	; 0x6dd4 <MifareClassicAppProcess+0x186>
        } else {
            /* CRC Error. */
            Buffer[0] = NAK_CRC_ERROR;
    6dd2:	81 e0       	ldi	r24, 0x01	; 1
    6dd4:	f8 01       	movw	r30, r16
    6dd6:	80 83       	st	Z, r24
        }

        State = STATE_CHINESE_IDLE;
    6dd8:	82 e0       	ldi	r24, 0x02	; 2
    6dda:	1a c3       	rjmp	.+1588   	; 0x7410 <MifareClassicAppProcess+0x7c2>

        return ACK_NAK_FRAME_SIZE;
#endif

    case STATE_READY1:
        if (ISO14443AWakeUp(Buffer, &BitCount, CardATQAValue, FromHalt)) {
    6ddc:	90 91 bb 2c 	lds	r25, 0x2CBB
    6de0:	30 91 bd 2c 	lds	r19, 0x2CBD
    6de4:	20 91 be 2c 	lds	r18, 0x2CBE
    6de8:	f8 01       	movw	r30, r16
    6dea:	80 81       	ld	r24, Z
INLINE
bool ISO14443AWakeUp(void* Buffer, uint16_t* BitCount, uint16_t ATQAValue, bool FromHalt)
{
    uint8_t* DataPtr = (uint8_t*) Buffer;

    if ( ((! FromHalt) && (DataPtr[0] == ISO14443A_CMD_REQA)) ||
    6dec:	91 11       	cpse	r25, r1
    6dee:	02 c0       	rjmp	.+4      	; 0x6df4 <MifareClassicAppProcess+0x1a6>
    6df0:	86 32       	cpi	r24, 0x26	; 38
    6df2:	11 f1       	breq	.+68     	; 0x6e38 <MifareClassicAppProcess+0x1ea>
    6df4:	82 35       	cpi	r24, 0x52	; 82
    6df6:	09 f0       	breq	.+2      	; 0x6dfa <MifareClassicAppProcess+0x1ac>
    6df8:	b6 c3       	rjmp	.+1900   	; 0x7566 <MifareClassicAppProcess+0x918>
    6dfa:	1e c0       	rjmp	.+60     	; 0x6e38 <MifareClassicAppProcess+0x1ea>
            State = STATE_HALT;
        }
        break;

    case STATE_READY2:
    if (ISO14443AWakeUp(Buffer, &BitCount, CardATQAValue, FromHalt)) {
    6dfc:	90 91 bb 2c 	lds	r25, 0x2CBB
    6e00:	30 91 bd 2c 	lds	r19, 0x2CBD
    6e04:	20 91 be 2c 	lds	r18, 0x2CBE
    6e08:	f8 01       	movw	r30, r16
    6e0a:	80 81       	ld	r24, Z
    6e0c:	91 11       	cpse	r25, r1
    6e0e:	02 c0       	rjmp	.+4      	; 0x6e14 <MifareClassicAppProcess+0x1c6>
    6e10:	86 32       	cpi	r24, 0x26	; 38
    6e12:	91 f0       	breq	.+36     	; 0x6e38 <MifareClassicAppProcess+0x1ea>
    6e14:	82 35       	cpi	r24, 0x52	; 82
    6e16:	09 f0       	breq	.+2      	; 0x6e1a <MifareClassicAppProcess+0x1cc>
    6e18:	53 c4       	rjmp	.+2214   	; 0x76c0 <MifareClassicAppProcess+0xa72>
    6e1a:	0e c0       	rjmp	.+28     	; 0x6e38 <MifareClassicAppProcess+0x1ea>
	    /* Unknown command. Enter HALT state. */
	    State = STATE_HALT;
    }
    break;
    case STATE_ACTIVE:
        if (ISO14443AWakeUp(Buffer, &BitCount, CardATQAValue, FromHalt)) {
    6e1c:	90 91 bb 2c 	lds	r25, 0x2CBB
    6e20:	30 91 bd 2c 	lds	r19, 0x2CBD
    6e24:	20 91 be 2c 	lds	r18, 0x2CBE
    6e28:	f8 01       	movw	r30, r16
    6e2a:	80 81       	ld	r24, Z
    6e2c:	91 11       	cpse	r25, r1
    6e2e:	02 c0       	rjmp	.+4      	; 0x6e34 <MifareClassicAppProcess+0x1e6>
    6e30:	86 32       	cpi	r24, 0x26	; 38
    6e32:	11 f0       	breq	.+4      	; 0x6e38 <MifareClassicAppProcess+0x1ea>
    6e34:	82 35       	cpi	r24, 0x52	; 82
    6e36:	31 f4       	brne	.+12     	; 0x6e44 <MifareClassicAppProcess+0x1f6>
         (DataPtr[0] == ISO14443A_CMD_WUPA) ){
        DataPtr[0] = (ATQAValue >> 0) & 0x00FF;
    6e38:	f8 01       	movw	r30, r16
    6e3a:	30 83       	st	Z, r19
        DataPtr[1] = (ATQAValue >> 8) & 0x00FF;
    6e3c:	21 83       	std	Z+1, r18	; 0x01
            State = FromHalt ? STATE_HALT : STATE_IDLE;
    6e3e:	81 e0       	ldi	r24, 0x01	; 1
    6e40:	89 27       	eor	r24, r25
    6e42:	86 c3       	rjmp	.+1804   	; 0x7550 <MifareClassicAppProcess+0x902>
            return ISO14443A_APP_NO_RESPONSE;
        } else if (Buffer[0] == CMD_HALT) {
    6e44:	80 35       	cpi	r24, 0x50	; 80
    6e46:	c9 f4       	brne	.+50     	; 0x6e7a <MifareClassicAppProcess+0x22c>
            /* Halts the tag. According to the ISO14443, the second
            * byte is supposed to be 0. */
            if (Buffer[1] == 0) {
    6e48:	f8 01       	movw	r30, r16
    6e4a:	81 81       	ldd	r24, Z+1	; 0x01
    6e4c:	88 23       	and	r24, r24
    6e4e:	19 f0       	breq	.+6      	; 0x6e56 <MifareClassicAppProcess+0x208>
                } else {
                    Buffer[0] = NAK_CRC_ERROR;
                    return ACK_NAK_FRAME_SIZE;
                }
            } else {
                Buffer[0] = NAK_INVALID_ARG;
    6e50:	f8 01       	movw	r30, r16
    6e52:	10 82       	st	Z, r1
    6e54:	df c2       	rjmp	.+1470   	; 0x7414 <MifareClassicAppProcess+0x7c6>
            return ISO14443A_APP_NO_RESPONSE;
        } else if (Buffer[0] == CMD_HALT) {
            /* Halts the tag. According to the ISO14443, the second
            * byte is supposed to be 0. */
            if (Buffer[1] == 0) {
                if (ISO14443ACheckCRCA(Buffer, CMD_HALT_FRAME_SIZE)) {
    6e56:	62 e0       	ldi	r22, 0x02	; 2
    6e58:	70 e0       	ldi	r23, 0x00	; 0
    6e5a:	c8 01       	movw	r24, r16
    6e5c:	5f d6       	rcall	.+3262   	; 0x7b1c <ISO14443ACheckCRCA>
    6e5e:	88 23       	and	r24, r24
    6e60:	b9 f0       	breq	.+46     	; 0x6e90 <MifareClassicAppProcess+0x242>
void LogGetModeByName(char* Mode, uint16_t BufferSize);
void LogGetModeList(char* List, uint16_t BufferSize);
void LogSRAMToFRAM(void);

/* Wrapper function to call current logging function */
INLINE void LogEntry(LogEntryEnum Entry, const void* Data, uint8_t Length) { CurrentLogFunc(Entry, Data, Length); }
    6e62:	e0 91 6e 2f 	lds	r30, 0x2F6E
    6e66:	f0 91 6f 2f 	lds	r31, 0x2F6F
    6e6a:	40 e0       	ldi	r20, 0x00	; 0
    6e6c:	60 e0       	ldi	r22, 0x00	; 0
    6e6e:	70 e0       	ldi	r23, 0x00	; 0
    6e70:	81 e9       	ldi	r24, 0x91	; 145
    6e72:	19 95       	eicall
                    /* According to ISO14443, we must not send anything
                    * in order to acknowledge the HALT command. */
                	LogEntry(LOG_INFO_APP_CMD_HALT, NULL, 0);

                	State = STATE_HALT;
    6e74:	10 92 de 2c 	sts	0x2CDE, r1
    6e78:	f2 c4       	rjmp	.+2532   	; 0x785e <MifareClassicAppProcess+0xc10>
                }
            } else {
                Buffer[0] = NAK_INVALID_ARG;
                return ACK_NAK_FRAME_SIZE;
            }
        } else if ( (Buffer[0] == CMD_AUTH_A) || (Buffer[0] == CMD_AUTH_B)) {
    6e7a:	90 ea       	ldi	r25, 0xA0	; 160
    6e7c:	98 0f       	add	r25, r24
    6e7e:	92 30       	cpi	r25, 0x02	; 2
    6e80:	08 f0       	brcs	.+2      	; 0x6e84 <MifareClassicAppProcess+0x236>
    6e82:	c1 c4       	rjmp	.+2434   	; 0x7806 <MifareClassicAppProcess+0xbb8>
        	if (ISO14443ACheckCRCA(Buffer, CMD_AUTH_FRAME_SIZE)) {
    6e84:	62 e0       	ldi	r22, 0x02	; 2
    6e86:	70 e0       	ldi	r23, 0x00	; 0
    6e88:	c8 01       	movw	r24, r16
    6e8a:	48 d6       	rcall	.+3216   	; 0x7b1c <ISO14443ACheckCRCA>
    6e8c:	81 11       	cpse	r24, r1
    6e8e:	ea c4       	rjmp	.+2516   	; 0x7864 <MifareClassicAppProcess+0xc16>
	        && (Key[3] == 0xea) && (Key[4] == 0x7b) && (Key[5] == 0xcc) ) {
	    /* no response! */
	    /* Reader will send a HALT */
	    return ISO14443A_APP_NO_RESPONSE;
            } else {
                Buffer[0] = NAK_CRC_ERROR;
    6e90:	81 e0       	ldi	r24, 0x01	; 1
    6e92:	54 c2       	rjmp	.+1192   	; 0x733c <MifareClassicAppProcess+0x6ee>

    case STATE_AUTHING:
        /* Reader delivers an encrypted nonce. We use it
        * to setup the crypto1 LFSR in nonlinear feedback mode.
        * Furthermore it delivers an encrypted answer. Decrypt and check it */
	Crypto1Auth(&Buffer[0]);
    6e94:	c8 01       	movw	r24, r16
    6e96:	0e 94 61 43 	call	0x86c2	; 0x86c2 <Crypto1Auth>

        Crypto1ByteArray(&Buffer[4], 4);
    6e9a:	64 e0       	ldi	r22, 0x04	; 4
    6e9c:	78 01       	movw	r14, r16
    6e9e:	f4 e0       	ldi	r31, 0x04	; 4
    6ea0:	ef 0e       	add	r14, r31
    6ea2:	f1 1c       	adc	r15, r1
    6ea4:	c7 01       	movw	r24, r14
    6ea6:	0e 94 78 46 	call	0x8cf0	; 0x8cf0 <Crypto1ByteArray>
    6eaa:	e0 91 6e 2f 	lds	r30, 0x2F6E
    6eae:	f0 91 6f 2f 	lds	r31, 0x2F6F
    6eb2:	44 e0       	ldi	r20, 0x04	; 4
    6eb4:	b7 01       	movw	r22, r14
    6eb6:	80 ea       	ldi	r24, 0xA0	; 160
    6eb8:	19 95       	eicall

        LogEntry(LOG_INFO_APP_AUTHING, &Buffer[4], 4);

        if ((Buffer[4] == ReaderResponse[0]) &&
    6eba:	f8 01       	movw	r30, r16
    6ebc:	94 81       	ldd	r25, Z+4	; 0x04
    6ebe:	80 91 d6 2c 	lds	r24, 0x2CD6
    6ec2:	98 13       	cpse	r25, r24
    6ec4:	29 c0       	rjmp	.+82     	; 0x6f18 <MifareClassicAppProcess+0x2ca>
    6ec6:	95 81       	ldd	r25, Z+5	; 0x05
    6ec8:	80 91 d7 2c 	lds	r24, 0x2CD7
    6ecc:	98 13       	cpse	r25, r24
    6ece:	24 c0       	rjmp	.+72     	; 0x6f18 <MifareClassicAppProcess+0x2ca>
            (Buffer[5] == ReaderResponse[1]) &&
    6ed0:	96 81       	ldd	r25, Z+6	; 0x06
    6ed2:	80 91 d8 2c 	lds	r24, 0x2CD8
    6ed6:	98 13       	cpse	r25, r24
    6ed8:	1f c0       	rjmp	.+62     	; 0x6f18 <MifareClassicAppProcess+0x2ca>
            (Buffer[6] == ReaderResponse[2]) &&
    6eda:	97 81       	ldd	r25, Z+7	; 0x07
    6edc:	80 91 d9 2c 	lds	r24, 0x2CD9
    6ee0:	98 13       	cpse	r25, r24
    6ee2:	1a c0       	rjmp	.+52     	; 0x6f18 <MifareClassicAppProcess+0x2ca>
            (Buffer[7] == ReaderResponse[3])) {

            /* Reader is authenticated. Encrypt the precalculated card response
            * and generate the parity bits. */
            Buffer[0] = CardResponse[0];
    6ee4:	80 91 da 2c 	lds	r24, 0x2CDA
    6ee8:	80 83       	st	Z, r24
            Buffer[1] = CardResponse[1];
    6eea:	80 91 db 2c 	lds	r24, 0x2CDB
    6eee:	81 83       	std	Z+1, r24	; 0x01
            Buffer[2] = CardResponse[2];
    6ef0:	80 91 dc 2c 	lds	r24, 0x2CDC
    6ef4:	82 83       	std	Z+2, r24	; 0x02
            Buffer[3] = CardResponse[3];
    6ef6:	80 91 dd 2c 	lds	r24, 0x2CDD
    6efa:	83 83       	std	Z+3, r24	; 0x03
            Crypto1ByteArrayWithParity(Buffer, 4);
    6efc:	64 e0       	ldi	r22, 0x04	; 4
    6efe:	c8 01       	movw	r24, r16
    6f00:	0e 94 6a 48 	call	0x90d4	; 0x90d4 <Crypto1ByteArrayWithParity>
    6f04:	e0 91 6e 2f 	lds	r30, 0x2F6E
    6f08:	f0 91 6f 2f 	lds	r31, 0x2F6F
    6f0c:	44 e0       	ldi	r20, 0x04	; 4
    6f0e:	b8 01       	movw	r22, r16
    6f10:	81 ea       	ldi	r24, 0xA1	; 161
    6f12:	19 95       	eicall

            LogEntry(LOG_INFO_APP_AUTHED, Buffer, sizeof(CardResponse));

            State = STATE_AUTHED_IDLE;
    6f14:	88 e0       	ldi	r24, 0x08	; 8
    6f16:	09 c2       	rjmp	.+1042   	; 0x732a <MifareClassicAppProcess+0x6dc>
    6f18:	e0 91 6e 2f 	lds	r30, 0x2F6E
    6f1c:	f0 91 6f 2f 	lds	r31, 0x2F6F
    6f20:	44 e0       	ldi	r20, 0x04	; 4
    6f22:	66 ed       	ldi	r22, 0xD6	; 214
    6f24:	7c e2       	ldi	r23, 0x2C	; 44
    6f26:	80 ec       	ldi	r24, 0xC0	; 192
    6f28:	32 c2       	rjmp	.+1124   	; 0x738e <MifareClassicAppProcess+0x740>
        }
        break;

    case STATE_AUTHED_IDLE:
    	/* If something went wrong the reader might send an unencrypted halt */
    	if ((Buffer[0] == CMD_HALT) &&
    6f2a:	f8 01       	movw	r30, r16
    6f2c:	80 81       	ld	r24, Z
    6f2e:	80 35       	cpi	r24, 0x50	; 80
    6f30:	51 f4       	brne	.+20     	; 0x6f46 <MifareClassicAppProcess+0x2f8>
    6f32:	81 81       	ldd	r24, Z+1	; 0x01
    6f34:	81 11       	cpse	r24, r1
    6f36:	07 c0       	rjmp	.+14     	; 0x6f46 <MifareClassicAppProcess+0x2f8>
    			(Buffer[1] == 0) &&
    6f38:	82 81       	ldd	r24, Z+2	; 0x02
    6f3a:	87 35       	cpi	r24, 0x57	; 87
    6f3c:	21 f4       	brne	.+8      	; 0x6f46 <MifareClassicAppProcess+0x2f8>
				(Buffer[2] == 0x57) &&
    6f3e:	83 81       	ldd	r24, Z+3	; 0x03
    6f40:	8d 3c       	cpi	r24, 0xCD	; 205
    6f42:	09 f4       	brne	.+2      	; 0x6f46 <MifareClassicAppProcess+0x2f8>
    6f44:	0a c2       	rjmp	.+1044   	; 0x735a <MifareClassicAppProcess+0x70c>
    		LogEntry(LOG_INFO_APP_CMD_HALT, NULL, 0);
    		return ISO14443A_APP_NO_RESPONSE;
    	}
    	/* In this state, all communication is encrypted. Thus we first have to encrypt
    	 * the incoming data. */
    	Crypto1ByteArray(Buffer, 4);
    6f46:	64 e0       	ldi	r22, 0x04	; 4
    6f48:	c8 01       	movw	r24, r16
    6f4a:	0e 94 78 46 	call	0x8cf0	; 0x8cf0 <Crypto1ByteArray>

    	if (Buffer[0] == CMD_READ) {
    6f4e:	f8 01       	movw	r30, r16
    6f50:	80 81       	ld	r24, Z
    6f52:	80 33       	cpi	r24, 0x30	; 48
    6f54:	09 f0       	breq	.+2      	; 0x6f58 <MifareClassicAppProcess+0x30a>
    6f56:	c2 c0       	rjmp	.+388    	; 0x70dc <MifareClassicAppProcess+0x48e>
    		if (ISO14443ACheckCRCA(Buffer, CMD_READ_FRAME_SIZE)) {
    6f58:	62 e0       	ldi	r22, 0x02	; 2
    6f5a:	70 e0       	ldi	r23, 0x00	; 0
    6f5c:	c8 01       	movw	r24, r16
    6f5e:	de d5       	rcall	.+3004   	; 0x7b1c <ISO14443ACheckCRCA>
    6f60:	88 23       	and	r24, r24
    6f62:	09 f4       	brne	.+2      	; 0x6f66 <MifareClassicAppProcess+0x318>
    6f64:	ac c0       	rjmp	.+344    	; 0x70be <MifareClassicAppProcess+0x470>
    			/* Read command. Read data from memory and append CRCA. */
    			/* Sector trailor? Use access conditions! */

    			if ((Buffer[1]<128 && (Buffer[1] & 3) == 3) || ((Buffer[1] & 15) == 15)) {
    6f66:	f8 01       	movw	r30, r16
    6f68:	61 81       	ldd	r22, Z+1	; 0x01
    6f6a:	67 fd       	sbrc	r22, 7
    6f6c:	04 c0       	rjmp	.+8      	; 0x6f76 <MifareClassicAppProcess+0x328>
    6f6e:	86 2f       	mov	r24, r22
    6f70:	83 70       	andi	r24, 0x03	; 3
    6f72:	83 30       	cpi	r24, 0x03	; 3
    6f74:	29 f0       	breq	.+10     	; 0x6f80 <MifareClassicAppProcess+0x332>
    6f76:	86 2f       	mov	r24, r22
    6f78:	8f 70       	andi	r24, 0x0F	; 15
    6f7a:	8f 30       	cpi	r24, 0x0F	; 15
    6f7c:	09 f0       	breq	.+2      	; 0x6f80 <MifareClassicAppProcess+0x332>
    6f7e:	84 c0       	rjmp	.+264    	; 0x7088 <MifareClassicAppProcess+0x43a>
    				uint8_t Acc;
    				CurrentAddress = Buffer[1];
    6f80:	60 93 d5 2c 	sts	0x2CD5, r22
/* decode Access conditions for a block */
INLINE uint8_t GetAccessCondition(uint8_t Block)
{
    uint8_t  InvSAcc0;
    uint8_t  InvSAcc1;
    uint8_t  Acc0 = AccessConditions[0];
    6f84:	80 91 c0 2c 	lds	r24, 0x2CC0
    uint8_t  Acc1 = AccessConditions[1];
    6f88:	90 91 c1 2c 	lds	r25, 0x2CC1
    uint8_t  Acc2 = AccessConditions[2];
    6f8c:	30 91 c2 2c 	lds	r19, 0x2CC2
    uint8_t  ResultForBlock = 0;
    
    InvSAcc0 = ~BYTE_SWAP(Acc0);
    6f90:	28 2f       	mov	r18, r24
    6f92:	22 95       	swap	r18
    6f94:	20 95       	com	r18
    InvSAcc1 = ~BYTE_SWAP(Acc1);

    /* Check */
    if ( ((InvSAcc0 ^ Acc1) & 0xf0) ||   /* C1x */
    6f96:	42 2f       	mov	r20, r18
    6f98:	49 27       	eor	r20, r25
    6f9a:	40 7f       	andi	r20, 0xF0	; 240
    6f9c:	09 f0       	breq	.+2      	; 0x6fa0 <MifareClassicAppProcess+0x352>
    6f9e:	43 c0       	rjmp	.+134    	; 0x7026 <MifareClassicAppProcess+0x3d8>
         ((InvSAcc0 ^ Acc2) & 0x0f) ||   /* C2x */
    6fa0:	23 27       	eor	r18, r19
    6fa2:	2f 70       	andi	r18, 0x0F	; 15
    
    InvSAcc0 = ~BYTE_SWAP(Acc0);
    InvSAcc1 = ~BYTE_SWAP(Acc1);

    /* Check */
    if ( ((InvSAcc0 ^ Acc1) & 0xf0) ||   /* C1x */
    6fa4:	09 f0       	breq	.+2      	; 0x6fa8 <MifareClassicAppProcess+0x35a>
    6fa6:	3f c0       	rjmp	.+126    	; 0x7026 <MifareClassicAppProcess+0x3d8>
    uint8_t  Acc1 = AccessConditions[1];
    uint8_t  Acc2 = AccessConditions[2];
    uint8_t  ResultForBlock = 0;
    
    InvSAcc0 = ~BYTE_SWAP(Acc0);
    InvSAcc1 = ~BYTE_SWAP(Acc1);
    6fa8:	92 95       	swap	r25
    6faa:	90 95       	com	r25

    /* Check */
    if ( ((InvSAcc0 ^ Acc1) & 0xf0) ||   /* C1x */
         ((InvSAcc0 ^ Acc2) & 0x0f) ||   /* C2x */
         ((InvSAcc1 ^ Acc2) & 0xf0))     /* C3x */
    6fac:	93 27       	eor	r25, r19
    6fae:	90 7f       	andi	r25, 0xF0	; 240
    InvSAcc0 = ~BYTE_SWAP(Acc0);
    InvSAcc1 = ~BYTE_SWAP(Acc1);

    /* Check */
    if ( ((InvSAcc0 ^ Acc1) & 0xf0) ||   /* C1x */
         ((InvSAcc0 ^ Acc2) & 0x0f) ||   /* C2x */
    6fb0:	d1 f5       	brne	.+116    	; 0x7026 <MifareClassicAppProcess+0x3d8>
    {
      return(NO_ACCESS);
    }
    /* Fix for MFClassic 4K cards */
    if(Block<128)
    	Block &= 3;
    6fb2:	26 2f       	mov	r18, r22
         ((InvSAcc1 ^ Acc2) & 0xf0))     /* C3x */
    {
      return(NO_ACCESS);
    }
    /* Fix for MFClassic 4K cards */
    if(Block<128)
    6fb4:	67 fd       	sbrc	r22, 7
    6fb6:	02 c0       	rjmp	.+4      	; 0x6fbc <MifareClassicAppProcess+0x36e>
    	Block &= 3;
    6fb8:	23 70       	andi	r18, 0x03	; 3
    6fba:	03 c0       	rjmp	.+6      	; 0x6fc2 <MifareClassicAppProcess+0x374>
    else {
    	Block &= 15;
    6fbc:	2f 70       	andi	r18, 0x0F	; 15
    	if (Block& 15)
    6fbe:	09 f0       	breq	.+2      	; 0x6fc2 <MifareClassicAppProcess+0x374>
    		Block=3;
    6fc0:	23 e0       	ldi	r18, 0x03	; 3
    		Block=1;
    	else
    		Block=2;
    }

    Acc0 = ~Acc0;       /* C1x Bits to bit 0..3 */
    6fc2:	98 2f       	mov	r25, r24
    6fc4:	90 95       	com	r25
    Acc1 =  Acc2;       /* C2x Bits to bit 0..3 */
    Acc2 =  Acc2 >> 4;  /* C3x Bits to bit 0..3 */
    6fc6:	43 2f       	mov	r20, r19
    6fc8:	42 95       	swap	r20
    6fca:	4f 70       	andi	r20, 0x0F	; 15

    if(Block)
    6fcc:	22 23       	and	r18, r18
    6fce:	c1 f0       	breq	.+48     	; 0x7000 <MifareClassicAppProcess+0x3b2>
    {
        Acc0 >>= Block;
    6fd0:	89 2f       	mov	r24, r25
    6fd2:	90 e0       	ldi	r25, 0x00	; 0
    6fd4:	02 2e       	mov	r0, r18
    6fd6:	02 c0       	rjmp	.+4      	; 0x6fdc <MifareClassicAppProcess+0x38e>
    6fd8:	95 95       	asr	r25
    6fda:	87 95       	ror	r24
    6fdc:	0a 94       	dec	r0
    6fde:	e2 f7       	brpl	.-8      	; 0x6fd8 <MifareClassicAppProcess+0x38a>
    6fe0:	98 2f       	mov	r25, r24
        Acc1 >>= Block;
    6fe2:	e3 2f       	mov	r30, r19
    6fe4:	f0 e0       	ldi	r31, 0x00	; 0
    6fe6:	02 2e       	mov	r0, r18
    6fe8:	02 c0       	rjmp	.+4      	; 0x6fee <MifareClassicAppProcess+0x3a0>
    6fea:	f5 95       	asr	r31
    6fec:	e7 95       	ror	r30
    6fee:	0a 94       	dec	r0
    6ff0:	e2 f7       	brpl	.-8      	; 0x6fea <MifareClassicAppProcess+0x39c>
    6ff2:	3e 2f       	mov	r19, r30
        Acc2 >>= Block;
    6ff4:	50 e0       	ldi	r21, 0x00	; 0
    6ff6:	02 c0       	rjmp	.+4      	; 0x6ffc <MifareClassicAppProcess+0x3ae>
    6ff8:	55 95       	asr	r21
    6ffa:	47 95       	ror	r20
    6ffc:	2a 95       	dec	r18
    6ffe:	e2 f7       	brpl	.-8      	; 0x6ff8 <MifareClassicAppProcess+0x3aa>
    }
    /* combine the bits */
    ResultForBlock = ((Acc2 & 1) << 2) |
    7000:	40 fb       	bst	r20, 0
    7002:	cc 24       	eor	r12, r12
    7004:	c0 f8       	bld	r12, 0
    7006:	d1 2c       	mov	r13, r1
    7008:	cc 0c       	add	r12, r12
    700a:	dd 1c       	adc	r13, r13
    700c:	cc 0c       	add	r12, r12
    700e:	dd 1c       	adc	r13, r13
                     ((Acc1 & 1) << 1) |
    7010:	30 fb       	bst	r19, 0
    7012:	ee 24       	eor	r14, r14
    7014:	e0 f8       	bld	r14, 0
    7016:	f1 2c       	mov	r15, r1
    7018:	ee 0c       	add	r14, r14
    701a:	ff 1c       	adc	r15, r15
        Acc0 >>= Block;
        Acc1 >>= Block;
        Acc2 >>= Block;
    }
    /* combine the bits */
    ResultForBlock = ((Acc2 & 1) << 2) |
    701c:	ec 28       	or	r14, r12
    701e:	89 2f       	mov	r24, r25
    7020:	81 70       	andi	r24, 0x01	; 1
    7022:	8e 29       	or	r24, r14
    7024:	01 c0       	rjmp	.+2      	; 0x7028 <MifareClassicAppProcess+0x3da>
    /* Check */
    if ( ((InvSAcc0 ^ Acc1) & 0xf0) ||   /* C1x */
         ((InvSAcc0 ^ Acc2) & 0x0f) ||   /* C2x */
         ((InvSAcc1 ^ Acc2) & 0xf0))     /* C3x */
    {
      return(NO_ACCESS);
    7026:	87 e0       	ldi	r24, 0x07	; 7

    			if ((Buffer[1]<128 && (Buffer[1] & 3) == 3) || ((Buffer[1] & 15) == 15)) {
    				uint8_t Acc;
    				CurrentAddress = Buffer[1];
    				/* Decode the access conditions */
    				Acc = abTrailorAccessConditions[ GetAccessCondition(CurrentAddress) ][ KeyInUse ];
    7028:	20 91 d4 2c 	lds	r18, 0x2CD4
    702c:	30 e0       	ldi	r19, 0x00	; 0
    702e:	28 0f       	add	r18, r24
    7030:	31 1d       	adc	r19, r1
    7032:	28 0f       	add	r18, r24
    7034:	31 1d       	adc	r19, r1
    7036:	f9 01       	movw	r30, r18
    7038:	e8 5b       	subi	r30, 0xB8	; 184
    703a:	ff 4d       	sbci	r31, 0xDF	; 223
    703c:	80 81       	ld	r24, Z
    703e:	f8 01       	movw	r30, r16
    7040:	98 01       	movw	r18, r16
    7042:	20 5f       	subi	r18, 0xF0	; 240
    7044:	3f 4f       	sbci	r19, 0xFF	; 255

    				/* Prepare empty Block */
    				for (uint8_t i=0; i<MEM_BYTES_PER_BLOCK; i++)
    					Buffer[i] = 0;
    7046:	11 92       	st	Z+, r1
    				CurrentAddress = Buffer[1];
    				/* Decode the access conditions */
    				Acc = abTrailorAccessConditions[ GetAccessCondition(CurrentAddress) ][ KeyInUse ];

    				/* Prepare empty Block */
    				for (uint8_t i=0; i<MEM_BYTES_PER_BLOCK; i++)
    7048:	e2 17       	cp	r30, r18
    704a:	f3 07       	cpc	r31, r19
    704c:	e1 f7       	brne	.-8      	; 0x7046 <MifareClassicAppProcess+0x3f8>
    					Buffer[i] = 0;

    				/* Allways copy the GPB */
    				/* Key A can never be read! */
    				/* Access conditions were already read during authentication! */
    				Buffer[MEM_KEY_SIZE+MEM_ACC_GPB_SIZE-1] = AccessConditions[MEM_ACC_GPB_SIZE-1];
    704e:	90 91 c3 2c 	lds	r25, 0x2CC3
    7052:	f8 01       	movw	r30, r16
    7054:	91 87       	std	Z+9, r25	; 0x09

    				/* Access conditions are already known */
    				if (Acc & ACC_TRAILOR_READ_ACC) {
    7056:	82 ff       	sbrs	r24, 2
    7058:	09 c0       	rjmp	.+18     	; 0x706c <MifareClassicAppProcess+0x41e>
    					Buffer[MEM_KEY_SIZE]   = AccessConditions[0];
    705a:	90 91 c0 2c 	lds	r25, 0x2CC0
    705e:	96 83       	std	Z+6, r25	; 0x06
    					Buffer[MEM_KEY_SIZE+1] = AccessConditions[1];
    7060:	90 91 c1 2c 	lds	r25, 0x2CC1
    7064:	97 83       	std	Z+7, r25	; 0x07
    					Buffer[MEM_KEY_SIZE+2] = AccessConditions[2];
    7066:	90 91 c2 2c 	lds	r25, 0x2CC2
    706a:	90 87       	std	Z+8, r25	; 0x08
    				}
    				/* Key B is readable in some rare cases */
    				if (Acc & ACC_TRAILOR_READ_KEYB) {
    706c:	84 ff       	sbrs	r24, 4
    706e:	15 c0       	rjmp	.+42     	; 0x709a <MifareClassicAppProcess+0x44c>
    					MemoryReadBlock(Buffer + MEM_BYTES_PER_BLOCK - MEM_KEY_SIZE,
    							(uint16_t)(CurrentAddress | 3) * MEM_BYTES_PER_BLOCK + MEM_BYTES_PER_BLOCK - MEM_KEY_SIZE,
    7070:	63 60       	ori	r22, 0x03	; 3
    7072:	f0 e1       	ldi	r31, 0x10	; 16
    7074:	6f 9f       	mul	r22, r31
    7076:	b0 01       	movw	r22, r0
    7078:	11 24       	eor	r1, r1
    					Buffer[MEM_KEY_SIZE+1] = AccessConditions[1];
    					Buffer[MEM_KEY_SIZE+2] = AccessConditions[2];
    				}
    				/* Key B is readable in some rare cases */
    				if (Acc & ACC_TRAILOR_READ_KEYB) {
    					MemoryReadBlock(Buffer + MEM_BYTES_PER_BLOCK - MEM_KEY_SIZE,
    707a:	66 5f       	subi	r22, 0xF6	; 246
    707c:	7f 4f       	sbci	r23, 0xFF	; 255
    707e:	46 e0       	ldi	r20, 0x06	; 6
    7080:	50 e0       	ldi	r21, 0x00	; 0
    7082:	c8 01       	movw	r24, r16
    7084:	0a 96       	adiw	r24, 0x0a	; 10
    7086:	07 c0       	rjmp	.+14     	; 0x7096 <MifareClassicAppProcess+0x448>
    							(uint16_t)(CurrentAddress | 3) * MEM_BYTES_PER_BLOCK + MEM_BYTES_PER_BLOCK - MEM_KEY_SIZE,
								MEM_KEY_SIZE);
    				}
    			} else {
    				MemoryReadBlock(Buffer, (uint16_t) Buffer[1] * MEM_BYTES_PER_BLOCK, MEM_BYTES_PER_BLOCK);
    7088:	80 e1       	ldi	r24, 0x10	; 16
    708a:	68 9f       	mul	r22, r24
    708c:	b0 01       	movw	r22, r0
    708e:	11 24       	eor	r1, r1
    7090:	40 e1       	ldi	r20, 0x10	; 16
    7092:	50 e0       	ldi	r21, 0x00	; 0
    7094:	c8 01       	movw	r24, r16
    7096:	0e 94 a1 0f 	call	0x1f42	; 0x1f42 <MemoryReadBlock>
    			}
    			ISO14443AAppendCRCA(Buffer, MEM_BYTES_PER_BLOCK);
    709a:	60 e1       	ldi	r22, 0x10	; 16
    709c:	70 e0       	ldi	r23, 0x00	; 0
    709e:	c8 01       	movw	r24, r16
    70a0:	12 d5       	rcall	.+2596   	; 0x7ac6 <ISO14443AAppendCRCA>
    70a2:	e0 91 6e 2f 	lds	r30, 0x2F6E
    70a6:	f0 91 6f 2f 	lds	r31, 0x2F6F
    70aa:	42 e1       	ldi	r20, 0x12	; 18
    70ac:	b8 01       	movw	r22, r16
    70ae:	80 e8       	ldi	r24, 0x80	; 128
    70b0:	19 95       	eicall

    			LogEntry(LOG_INFO_APP_CMD_READ, Buffer, MEM_BYTES_PER_BLOCK + ISO14443A_CRCA_SIZE);

    			/* Encrypt and calculate parity bits. */
    			Crypto1ByteArrayWithParity(Buffer, ISO14443A_CRCA_SIZE + MEM_BYTES_PER_BLOCK);
    70b2:	62 e1       	ldi	r22, 0x12	; 18
    70b4:	c8 01       	movw	r24, r16
    70b6:	0e 94 6a 48 	call	0x90d4	; 0x90d4 <Crypto1ByteArrayWithParity>

    			return ( (CMD_READ_RESPONSE_FRAME_SIZE + ISO14443A_CRCA_SIZE )
    70ba:	80 e9       	ldi	r24, 0x90	; 144
    70bc:	39 c1       	rjmp	.+626    	; 0x7330 <MifareClassicAppProcess+0x6e2>
    					* BITS_PER_BYTE) | ISO14443A_APP_CUSTOM_PARITY;
    		} else {
    			Buffer[0] = NAK_CRC_ERROR ^ Crypto1Nibble();
    70be:	0e 94 83 45 	call	0x8b06	; 0x8b06 <Crypto1Nibble>
    70c2:	91 e0       	ldi	r25, 0x01	; 1
    70c4:	89 27       	eor	r24, r25
    70c6:	f8 01       	movw	r30, r16
    70c8:	80 83       	st	Z, r24
    70ca:	e0 91 6e 2f 	lds	r30, 0x2F6E
    70ce:	f0 91 6f 2f 	lds	r31, 0x2F6F
    70d2:	44 e0       	ldi	r20, 0x04	; 4
    70d4:	b8 01       	movw	r22, r16
    70d6:	81 ec       	ldi	r24, 0xC1	; 193
    70d8:	19 95       	eicall
    70da:	9c c1       	rjmp	.+824    	; 0x7414 <MifareClassicAppProcess+0x7c6>

    			LogEntry(LOG_ERR_APP_CHECKSUM_FAIL, Buffer, 4);

    			return ACK_NAK_FRAME_SIZE;
    		}
    	} else if (Buffer[0] == CMD_WRITE) {
    70dc:	80 3a       	cpi	r24, 0xA0	; 160
    70de:	61 f4       	brne	.+24     	; 0x70f8 <MifareClassicAppProcess+0x4aa>
    		if (ISO14443ACheckCRCA(Buffer, CMD_WRITE_FRAME_SIZE)) {
    70e0:	62 e0       	ldi	r22, 0x02	; 2
    70e2:	70 e0       	ldi	r23, 0x00	; 0
    70e4:	c8 01       	movw	r24, r16
    70e6:	1a d5       	rcall	.+2612   	; 0x7b1c <ISO14443ACheckCRCA>
    70e8:	88 23       	and	r24, r24
    70ea:	d9 f1       	breq	.+118    	; 0x7162 <MifareClassicAppProcess+0x514>
    			/* Write command. Store the address and prepare for the upcoming data.
    			 * Respond with ACK. */
    			CurrentAddress = Buffer[1];
    70ec:	f8 01       	movw	r30, r16
    70ee:	81 81       	ldd	r24, Z+1	; 0x01
    70f0:	80 93 d5 2c 	sts	0x2CD5, r24
    			State = STATE_WRITE;
    70f4:	89 e0       	ldi	r24, 0x09	; 9
    70f6:	0d c0       	rjmp	.+26     	; 0x7112 <MifareClassicAppProcess+0x4c4>
    		} else {
    			LogEntry(LOG_ERR_APP_CHECKSUM_FAIL, Buffer, 4);
    			Buffer[0] = NAK_CRC_ERROR ^ Crypto1Nibble();
    		}
    		return ACK_NAK_FRAME_SIZE;
    	} else if (Buffer[0] == CMD_DECREMENT) {
    70f8:	80 3c       	cpi	r24, 0xC0	; 192
    70fa:	89 f4       	brne	.+34     	; 0x711e <MifareClassicAppProcess+0x4d0>
    		if (ISO14443ACheckCRCA(Buffer, CMD_DECREMENT_FRAME_SIZE)) {
    70fc:	62 e0       	ldi	r22, 0x02	; 2
    70fe:	70 e0       	ldi	r23, 0x00	; 0
    7100:	c8 01       	movw	r24, r16
    7102:	0c d5       	rcall	.+2584   	; 0x7b1c <ISO14443ACheckCRCA>
    7104:	88 23       	and	r24, r24
    7106:	69 f1       	breq	.+90     	; 0x7162 <MifareClassicAppProcess+0x514>
    			CurrentAddress = Buffer[1];
    7108:	f8 01       	movw	r30, r16
    710a:	81 81       	ldd	r24, Z+1	; 0x01
    710c:	80 93 d5 2c 	sts	0x2CD5, r24
    			State = STATE_DECREMENT;
    7110:	8b e0       	ldi	r24, 0x0B	; 11
    7112:	80 93 de 2c 	sts	0x2CDE, r24
    			Buffer[0] = ACK_VALUE ^ Crypto1Nibble();
    7116:	0e 94 83 45 	call	0x8b06	; 0x8b06 <Crypto1Nibble>
    711a:	9a e0       	ldi	r25, 0x0A	; 10
    711c:	0e c1       	rjmp	.+540    	; 0x733a <MifareClassicAppProcess+0x6ec>
    		} else {
    			LogEntry(LOG_ERR_APP_CHECKSUM_FAIL, Buffer, 4);
    			Buffer[0] = NAK_CRC_ERROR ^ Crypto1Nibble();
    		}
    		return ACK_NAK_FRAME_SIZE;
    	} else if (Buffer[0] == CMD_INCREMENT) {
    711e:	81 3c       	cpi	r24, 0xC1	; 193
    7120:	91 f4       	brne	.+36     	; 0x7146 <MifareClassicAppProcess+0x4f8>
    		if (ISO14443ACheckCRCA(Buffer, CMD_DECREMENT_FRAME_SIZE)) {
    7122:	62 e0       	ldi	r22, 0x02	; 2
    7124:	70 e0       	ldi	r23, 0x00	; 0
    7126:	c8 01       	movw	r24, r16
    7128:	f9 d4       	rcall	.+2546   	; 0x7b1c <ISO14443ACheckCRCA>
    712a:	88 23       	and	r24, r24
    712c:	d1 f0       	breq	.+52     	; 0x7162 <MifareClassicAppProcess+0x514>
    			CurrentAddress = Buffer[1];
    712e:	f8 01       	movw	r30, r16
    7130:	81 81       	ldd	r24, Z+1	; 0x01
    7132:	80 93 d5 2c 	sts	0x2CD5, r24
    			State = STATE_INCREMENT;
    7136:	4a e0       	ldi	r20, 0x0A	; 10
    7138:	f4 2e       	mov	r15, r20
    713a:	f0 92 de 2c 	sts	0x2CDE, r15
    			Buffer[0] = ACK_VALUE ^ Crypto1Nibble();
    713e:	0e 94 83 45 	call	0x8b06	; 0x8b06 <Crypto1Nibble>
    7142:	8f 25       	eor	r24, r15
    7144:	fb c0       	rjmp	.+502    	; 0x733c <MifareClassicAppProcess+0x6ee>
    		} else {
    			LogEntry(LOG_ERR_APP_CHECKSUM_FAIL, Buffer, 4);
    			Buffer[0] = NAK_CRC_ERROR ^ Crypto1Nibble();
    		}
    		return ACK_NAK_FRAME_SIZE;
    	} else if (Buffer[0] == CMD_RESTORE) {
    7146:	82 3c       	cpi	r24, 0xC2	; 194
    7148:	99 f4       	brne	.+38     	; 0x7170 <MifareClassicAppProcess+0x522>
    		if (ISO14443ACheckCRCA(Buffer, CMD_DECREMENT_FRAME_SIZE)) {
    714a:	62 e0       	ldi	r22, 0x02	; 2
    714c:	70 e0       	ldi	r23, 0x00	; 0
    714e:	c8 01       	movw	r24, r16
    7150:	e5 d4       	rcall	.+2506   	; 0x7b1c <ISO14443ACheckCRCA>
    7152:	88 23       	and	r24, r24
    7154:	31 f0       	breq	.+12     	; 0x7162 <MifareClassicAppProcess+0x514>
    			CurrentAddress = Buffer[1];
    7156:	f8 01       	movw	r30, r16
    7158:	81 81       	ldd	r24, Z+1	; 0x01
    715a:	80 93 d5 2c 	sts	0x2CD5, r24
    			State = STATE_RESTORE;
    715e:	8c e0       	ldi	r24, 0x0C	; 12
    7160:	d8 cf       	rjmp	.-80     	; 0x7112 <MifareClassicAppProcess+0x4c4>
    7162:	e0 91 6e 2f 	lds	r30, 0x2F6E
    7166:	f0 91 6f 2f 	lds	r31, 0x2F6F
    716a:	44 e0       	ldi	r20, 0x04	; 4
    716c:	b8 01       	movw	r22, r16
    716e:	21 c0       	rjmp	.+66     	; 0x71b2 <MifareClassicAppProcess+0x564>
    		} else {
    			LogEntry(LOG_ERR_APP_CHECKSUM_FAIL, Buffer, 4);
    			Buffer[0] = NAK_CRC_ERROR ^ Crypto1Nibble();
    		}
    		return ACK_NAK_FRAME_SIZE;
    	} else if (Buffer[0] == CMD_TRANSFER) {
    7170:	80 3b       	cpi	r24, 0xB0	; 176
    7172:	11 f5       	brne	.+68     	; 0x71b8 <MifareClassicAppProcess+0x56a>
    		/* Write back the global block buffer to the desired block address */
			if (ISO14443ACheckCRCA(Buffer, CMD_TRANSFER_FRAME_SIZE)) {
    7174:	62 e0       	ldi	r22, 0x02	; 2
    7176:	70 e0       	ldi	r23, 0x00	; 0
    7178:	c8 01       	movw	r24, r16
    717a:	d0 d4       	rcall	.+2464   	; 0x7b1c <ISO14443ACheckCRCA>
    717c:	e0 91 6e 2f 	lds	r30, 0x2F6E
    7180:	f0 91 6f 2f 	lds	r31, 0x2F6F
    7184:	44 e0       	ldi	r20, 0x04	; 4
    7186:	b8 01       	movw	r22, r16
    7188:	88 23       	and	r24, r24
    718a:	99 f0       	breq	.+38     	; 0x71b2 <MifareClassicAppProcess+0x564>
    718c:	86 e8       	ldi	r24, 0x86	; 134
    718e:	19 95       	eicall
				LogEntry(LOG_INFO_APP_CMD_TRANSFER, Buffer, 4);

				if (!ActiveConfiguration.ReadOnly) {
    7190:	80 91 6d 2f 	lds	r24, 0x2F6D
    7194:	81 11       	cpse	r24, r1
    7196:	bf cf       	rjmp	.-130    	; 0x7116 <MifareClassicAppProcess+0x4c8>
					MemoryWriteBlock(BlockBuffer, (uint16_t) Buffer[1] * MEM_BYTES_PER_BLOCK, MEM_BYTES_PER_BLOCK );
    7198:	f8 01       	movw	r30, r16
    719a:	61 81       	ldd	r22, Z+1	; 0x01
    719c:	f0 e1       	ldi	r31, 0x10	; 16
    719e:	6f 9f       	mul	r22, r31
    71a0:	b0 01       	movw	r22, r0
    71a2:	11 24       	eor	r1, r1
    71a4:	40 e1       	ldi	r20, 0x10	; 16
    71a6:	50 e0       	ldi	r21, 0x00	; 0
    71a8:	84 ec       	ldi	r24, 0xC4	; 196
    71aa:	9c e2       	ldi	r25, 0x2C	; 44
    71ac:	0e 94 ef 0f 	call	0x1fde	; 0x1fde <MemoryWriteBlock>
    71b0:	b2 cf       	rjmp	.-156    	; 0x7116 <MifareClassicAppProcess+0x4c8>
    71b2:	81 ec       	ldi	r24, 0xC1	; 193
    71b4:	19 95       	eicall
    71b6:	be c0       	rjmp	.+380    	; 0x7334 <MifareClassicAppProcess+0x6e6>
				LogEntry(LOG_ERR_APP_CHECKSUM_FAIL, Buffer, 4);
				Buffer[0] = NAK_CRC_ERROR ^ Crypto1Nibble();
			}

			return ACK_NAK_FRAME_SIZE;
    	} else if ( (Buffer[0] == CMD_AUTH_A) || (Buffer[0] == CMD_AUTH_B) ) {
    71b8:	90 ea       	ldi	r25, 0xA0	; 160
    71ba:	98 0f       	add	r25, r24
    71bc:	92 30       	cpi	r25, 0x02	; 2
    71be:	08 f0       	brcs	.+2      	; 0x71c2 <MifareClassicAppProcess+0x574>
    71c0:	bf c0       	rjmp	.+382    	; 0x7340 <MifareClassicAppProcess+0x6f2>
    		if (ISO14443ACheckCRCA(Buffer, CMD_AUTH_FRAME_SIZE))
    71c2:	62 e0       	ldi	r22, 0x02	; 2
    71c4:	70 e0       	ldi	r23, 0x00	; 0
    71c6:	c8 01       	movw	r24, r16
    71c8:	a9 d4       	rcall	.+2386   	; 0x7b1c <ISO14443ACheckCRCA>
    71ca:	88 23       	and	r24, r24
    71cc:	09 f4       	brne	.+2      	; 0x71d0 <MifareClassicAppProcess+0x582>
    71ce:	b2 c0       	rjmp	.+356    	; 0x7334 <MifareClassicAppProcess+0x6e6>
    		{
    			/* Nested authentication. */
    			//uint16_t SectorAddress = Buffer[1] & MEM_SECTOR_ADDR_MASK;
    			uint16_t KeyOffset = (Buffer[0] == CMD_AUTH_A ? MEM_KEY_A_OFFSET : MEM_KEY_B_OFFSET);
    71d0:	f8 01       	movw	r30, r16
    71d2:	80 81       	ld	r24, Z
    71d4:	80 36       	cpi	r24, 0x60	; 96
    71d6:	21 f0       	breq	.+8      	; 0x71e0 <MifareClassicAppProcess+0x592>
    71d8:	3a e3       	ldi	r19, 0x3A	; 58
    71da:	c3 2e       	mov	r12, r19
    71dc:	d1 2c       	mov	r13, r1
    71de:	03 c0       	rjmp	.+6      	; 0x71e6 <MifareClassicAppProcess+0x598>
    71e0:	20 e3       	ldi	r18, 0x30	; 48
    71e2:	c2 2e       	mov	r12, r18
    71e4:	d1 2c       	mov	r13, r1
    			uint8_t Key[6];
    			uint8_t Uid[4];
    			uint8_t CardNonce[8];

    			/* Fix for MFClassic 4k cards */
    			if(Buffer[1] >= 128) {
    71e6:	f8 01       	movw	r30, r16
    71e8:	81 81       	ldd	r24, Z+1	; 0x01
    71ea:	87 ff       	sbrs	r24, 7
    71ec:	0c c0       	rjmp	.+24     	; 0x7206 <MifareClassicAppProcess+0x5b8>
    				SectorStartAddress = (Buffer[1] & MEM_BIGSECTOR_ADDR_MASK) * MEM_BYTES_PER_BLOCK ;
    71ee:	80 7f       	andi	r24, 0xF0	; 240
    71f0:	f0 e1       	ldi	r31, 0x10	; 16
    71f2:	8f 9f       	mul	r24, r31
    71f4:	70 01       	movw	r14, r0
    71f6:	11 24       	eor	r1, r1
    				KeyOffset += MEM_KEY_BIGSECTOR_OFFSET;
    71f8:	80 ec       	ldi	r24, 0xC0	; 192
    71fa:	c8 0e       	add	r12, r24
    71fc:	d1 1c       	adc	r13, r1
    				AccOffset += MEM_KEY_BIGSECTOR_OFFSET;
    71fe:	96 ef       	ldi	r25, 0xF6	; 246
    7200:	a9 2e       	mov	r10, r25
    7202:	b1 2c       	mov	r11, r1
    7204:	08 c0       	rjmp	.+16     	; 0x7216 <MifareClassicAppProcess+0x5c8>
    			} else {
    				SectorStartAddress = (Buffer[1] & MEM_SECTOR_ADDR_MASK) * MEM_BYTES_PER_BLOCK ;
    7206:	8c 7f       	andi	r24, 0xFC	; 252
    7208:	90 e1       	ldi	r25, 0x10	; 16
    720a:	89 9f       	mul	r24, r25
    720c:	70 01       	movw	r14, r0
    720e:	11 24       	eor	r1, r1
    		if (ISO14443ACheckCRCA(Buffer, CMD_AUTH_FRAME_SIZE))
    		{
    			/* Nested authentication. */
    			//uint16_t SectorAddress = Buffer[1] & MEM_SECTOR_ADDR_MASK;
    			uint16_t KeyOffset = (Buffer[0] == CMD_AUTH_A ? MEM_KEY_A_OFFSET : MEM_KEY_B_OFFSET);
    			uint16_t AccOffset = MEM_KEY_A_OFFSET + MEM_KEY_SIZE;
    7210:	86 e3       	ldi	r24, 0x36	; 54
    7212:	a8 2e       	mov	r10, r24
    7214:	b1 2c       	mov	r11, r1
    7216:	e0 91 6e 2f 	lds	r30, 0x2F6E
    721a:	f0 91 6f 2f 	lds	r31, 0x2F6F
    721e:	42 e0       	ldi	r20, 0x02	; 2
    7220:	b8 01       	movw	r22, r16
    7222:	80 e9       	ldi	r24, 0x90	; 144
    7224:	19 95       	eicall
    				SectorStartAddress = (Buffer[1] & MEM_SECTOR_ADDR_MASK) * MEM_BYTES_PER_BLOCK ;
    			}

    			LogEntry(LOG_INFO_APP_CMD_AUTH, Buffer, 2);
    			/* set KeyInUse for global use to keep info about authentication */
    			KeyInUse = Buffer[0] & 1;
    7226:	f8 01       	movw	r30, r16
    7228:	80 81       	ld	r24, Z
    722a:	81 70       	andi	r24, 0x01	; 1
    722c:	80 93 d4 2c 	sts	0x2CD4, r24
    			CurrentAddress = SectorStartAddress / MEM_BYTES_PER_BLOCK;
    7230:	c7 01       	movw	r24, r14
    7232:	b4 e0       	ldi	r27, 0x04	; 4
    7234:	96 95       	lsr	r25
    7236:	87 95       	ror	r24
    7238:	ba 95       	dec	r27
    723a:	e1 f7       	brne	.-8      	; 0x7234 <MifareClassicAppProcess+0x5e6>
    723c:	80 93 d5 2c 	sts	0x2CD5, r24
    			if (CurrentAddress != AccessAddress) {
    7240:	90 91 bf 2c 	lds	r25, 0x2CBF
    7244:	98 17       	cp	r25, r24
    7246:	69 f0       	breq	.+26     	; 0x7262 <MifareClassicAppProcess+0x614>
    				/* Get access conditions from the sector trailor */
    				MemoryReadBlock(AccessConditions, SectorStartAddress + AccOffset, MEM_ACC_GPB_SIZE);
    7248:	b7 01       	movw	r22, r14
    724a:	6a 0d       	add	r22, r10
    724c:	7b 1d       	adc	r23, r11
    724e:	44 e0       	ldi	r20, 0x04	; 4
    7250:	50 e0       	ldi	r21, 0x00	; 0
    7252:	80 ec       	ldi	r24, 0xC0	; 192
    7254:	9c e2       	ldi	r25, 0x2C	; 44
    7256:	0e 94 a1 0f 	call	0x1f42	; 0x1f42 <MemoryReadBlock>
    				AccessAddress = CurrentAddress;
    725a:	80 91 d5 2c 	lds	r24, 0x2CD5
    725e:	80 93 bf 2c 	sts	0x2CBF, r24
    			}

    			/* Generate a random nonce and read UID and key from memory */
    			RandomGetBuffer(CardNonce, sizeof(CardNonce));
    7262:	68 e0       	ldi	r22, 0x08	; 8
    7264:	ce 01       	movw	r24, r28
    7266:	01 96       	adiw	r24, 0x01	; 1
    7268:	0e 94 df 0e 	call	0x1dbe	; 0x1dbe <RandomGetBuffer>
    			if (ActiveConfiguration.UidSize == 7)
    726c:	80 91 6c 2f 	lds	r24, 0x2F6C
    				MemoryReadBlock(Uid, MEM_UID_CL2_ADDRESS, MEM_UID_CL2_SIZE);
    7270:	44 e0       	ldi	r20, 0x04	; 4
    7272:	50 e0       	ldi	r21, 0x00	; 0
    				AccessAddress = CurrentAddress;
    			}

    			/* Generate a random nonce and read UID and key from memory */
    			RandomGetBuffer(CardNonce, sizeof(CardNonce));
    			if (ActiveConfiguration.UidSize == 7)
    7274:	87 30       	cpi	r24, 0x07	; 7
    7276:	19 f4       	brne	.+6      	; 0x727e <MifareClassicAppProcess+0x630>
    				MemoryReadBlock(Uid, MEM_UID_CL2_ADDRESS, MEM_UID_CL2_SIZE);
    7278:	63 e0       	ldi	r22, 0x03	; 3
    727a:	70 e0       	ldi	r23, 0x00	; 0
    727c:	02 c0       	rjmp	.+4      	; 0x7282 <MifareClassicAppProcess+0x634>
    			else
    				MemoryReadBlock(Uid, MEM_UID_CL1_ADDRESS, MEM_UID_CL1_SIZE);
    727e:	60 e0       	ldi	r22, 0x00	; 0
    7280:	70 e0       	ldi	r23, 0x00	; 0
    7282:	ce 01       	movw	r24, r28
    7284:	0f 96       	adiw	r24, 0x0f	; 15
    7286:	0e 94 a1 0f 	call	0x1f42	; 0x1f42 <MemoryReadBlock>
    			MemoryReadBlock(Key, SectorStartAddress + KeyOffset, MEM_KEY_SIZE);
    728a:	b7 01       	movw	r22, r14
    728c:	6c 0d       	add	r22, r12
    728e:	7d 1d       	adc	r23, r13
    7290:	46 e0       	ldi	r20, 0x06	; 6
    7292:	50 e0       	ldi	r21, 0x00	; 0
    7294:	ce 01       	movw	r24, r28
    7296:	09 96       	adiw	r24, 0x09	; 9
    7298:	0e 94 a1 0f 	call	0x1f42	; 0x1f42 <MemoryReadBlock>

    			/* Precalculate the reader response from card-nonce */
    			for (uint8_t i=0; i<sizeof(ReaderResponse); i++)
    				ReaderResponse[i] = CardNonce[i];
    729c:	89 81       	ldd	r24, Y+1	; 0x01
    729e:	80 93 d6 2c 	sts	0x2CD6, r24
    72a2:	8a 81       	ldd	r24, Y+2	; 0x02
    72a4:	80 93 d7 2c 	sts	0x2CD7, r24
    72a8:	8b 81       	ldd	r24, Y+3	; 0x03
    72aa:	80 93 d8 2c 	sts	0x2CD8, r24
    72ae:	8c 81       	ldd	r24, Y+4	; 0x04
    72b0:	80 93 d9 2c 	sts	0x2CD9, r24

    			Crypto1PRNG(ReaderResponse, 64);
    72b4:	60 e4       	ldi	r22, 0x40	; 64
    72b6:	86 ed       	ldi	r24, 0xD6	; 214
    72b8:	9c e2       	ldi	r25, 0x2C	; 44
    72ba:	0e 94 b0 4a 	call	0x9560	; 0x9560 <Crypto1PRNG>

    			/* Precalculate our response from the reader response */
    			for (uint8_t i=0; i<sizeof(CardResponse); i++)
    				CardResponse[i] = ReaderResponse[i];
    72be:	80 91 d6 2c 	lds	r24, 0x2CD6
    72c2:	80 93 da 2c 	sts	0x2CDA, r24
    72c6:	80 91 d7 2c 	lds	r24, 0x2CD7
    72ca:	80 93 db 2c 	sts	0x2CDB, r24
    72ce:	80 91 d8 2c 	lds	r24, 0x2CD8
    72d2:	80 93 dc 2c 	sts	0x2CDC, r24
    72d6:	80 91 d9 2c 	lds	r24, 0x2CD9
    72da:	80 93 dd 2c 	sts	0x2CDD, r24

    			Crypto1PRNG(CardResponse, 32);
    72de:	60 e2       	ldi	r22, 0x20	; 32
    72e0:	8a ed       	ldi	r24, 0xDA	; 218
    72e2:	9c e2       	ldi	r25, 0x2C	; 44
    72e4:	0e 94 b0 4a 	call	0x9560	; 0x9560 <Crypto1PRNG>

    			/* Setup crypto1 cipher. */
    			Crypto1SetupNested(Key, Uid, CardNonce, false);
    72e8:	20 e0       	ldi	r18, 0x00	; 0
    72ea:	ae 01       	movw	r20, r28
    72ec:	4f 5f       	subi	r20, 0xFF	; 255
    72ee:	5f 4f       	sbci	r21, 0xFF	; 255
    72f0:	be 01       	movw	r22, r28
    72f2:	61 5f       	subi	r22, 0xF1	; 241
    72f4:	7f 4f       	sbci	r23, 0xFF	; 255
    72f6:	ce 01       	movw	r24, r28
    72f8:	09 96       	adiw	r24, 0x09	; 9
    72fa:	f7 d6       	rcall	.+3566   	; 0x80ea <Crypto1SetupNested>

    			/* Respond with the encrypted random card nonce and expect further authentication
    			 * form the reader in the next frame. */
    			Buffer[0] = CardNonce[0];
    72fc:	89 81       	ldd	r24, Y+1	; 0x01
    72fe:	f8 01       	movw	r30, r16
    7300:	80 83       	st	Z, r24
    			Buffer[1] = CardNonce[1];
    7302:	8a 81       	ldd	r24, Y+2	; 0x02
    7304:	81 83       	std	Z+1, r24	; 0x01
    			Buffer[2] = CardNonce[2];
    7306:	8b 81       	ldd	r24, Y+3	; 0x03
    7308:	82 83       	std	Z+2, r24	; 0x02
    			Buffer[3] = CardNonce[3];
    730a:	8c 81       	ldd	r24, Y+4	; 0x04
    730c:	83 83       	std	Z+3, r24	; 0x03
    			/* Encryption is on, so we have also to encrypt the pariy */
    			Buffer[ ISO14443A_BUFFER_PARITY_OFFSET + 0] =  CardNonce[4];
    730e:	e0 58       	subi	r30, 0x80	; 128
    7310:	ff 4f       	sbci	r31, 0xFF	; 255
    7312:	8d 81       	ldd	r24, Y+5	; 0x05
    7314:	80 83       	st	Z, r24
    			Buffer[ ISO14443A_BUFFER_PARITY_OFFSET + 1] =  CardNonce[5];
    7316:	31 96       	adiw	r30, 0x01	; 1
    7318:	8e 81       	ldd	r24, Y+6	; 0x06
    731a:	80 83       	st	Z, r24
    			Buffer[ ISO14443A_BUFFER_PARITY_OFFSET + 2] =  CardNonce[6];
    731c:	31 96       	adiw	r30, 0x01	; 1
    731e:	8f 81       	ldd	r24, Y+7	; 0x07
    7320:	80 83       	st	Z, r24
    			Buffer[ ISO14443A_BUFFER_PARITY_OFFSET + 3] =  CardNonce[7];
    7322:	31 96       	adiw	r30, 0x01	; 1
    7324:	88 85       	ldd	r24, Y+8	; 0x08
    7326:	80 83       	st	Z, r24
    			State = STATE_AUTHING;
    7328:	87 e0       	ldi	r24, 0x07	; 7
    732a:	80 93 de 2c 	sts	0x2CDE, r24

    			return CMD_AUTH_RB_FRAME_SIZE * BITS_PER_BYTE | ISO14443A_APP_CUSTOM_PARITY;
    732e:	80 e2       	ldi	r24, 0x20	; 32
    7330:	90 e1       	ldi	r25, 0x10	; 16
    7332:	74 c3       	rjmp	.+1768   	; 0x7a1c <MifareClassicAppProcess+0xdce>
    		} else {
    			Buffer[0] = NAK_CRC_ERROR ^ Crypto1Nibble();
    7334:	0e 94 83 45 	call	0x8b06	; 0x8b06 <Crypto1Nibble>
    7338:	91 e0       	ldi	r25, 0x01	; 1
    733a:	89 27       	eor	r24, r25
    733c:	f8 01       	movw	r30, r16
    733e:	01 cd       	rjmp	.-1534   	; 0x6d42 <MifareClassicAppProcess+0xf4>
    			return ACK_NAK_FRAME_SIZE;
    		}
    	} else if (Buffer[0] == CMD_HALT) {
    7340:	80 35       	cpi	r24, 0x50	; 80
    7342:	b9 f4       	brne	.+46     	; 0x7372 <MifareClassicAppProcess+0x724>
    		/* Halts the tag. According to the ISO14443, the second
    		 * byte is supposed to be 0. */
    		if (Buffer[1] == 0) {
    7344:	f8 01       	movw	r30, r16
    7346:	81 81       	ldd	r24, Z+1	; 0x01
    7348:	81 11       	cpse	r24, r1
    734a:	82 cd       	rjmp	.-1276   	; 0x6e50 <MifareClassicAppProcess+0x202>
    			if (ISO14443ACheckCRCA(Buffer, CMD_HALT_FRAME_SIZE)) {
    734c:	62 e0       	ldi	r22, 0x02	; 2
    734e:	70 e0       	ldi	r23, 0x00	; 0
    7350:	c8 01       	movw	r24, r16
    7352:	e4 d3       	rcall	.+1992   	; 0x7b1c <ISO14443ACheckCRCA>
    7354:	88 23       	and	r24, r24
    7356:	09 f4       	brne	.+2      	; 0x735a <MifareClassicAppProcess+0x70c>
    7358:	9b cd       	rjmp	.-1226   	; 0x6e90 <MifareClassicAppProcess+0x242>
    				/* According to ISO14443, we must not send anything
    				 * in order to acknowledge the HALT command. */
    				State = STATE_HALT;
    735a:	10 92 de 2c 	sts	0x2CDE, r1
    735e:	e0 91 6e 2f 	lds	r30, 0x2F6E
    7362:	f0 91 6f 2f 	lds	r31, 0x2F6F
    7366:	40 e0       	ldi	r20, 0x00	; 0
    7368:	60 e0       	ldi	r22, 0x00	; 0
    736a:	70 e0       	ldi	r23, 0x00	; 0
    736c:	81 e9       	ldi	r24, 0x91	; 145
    736e:	19 95       	eicall
    7370:	76 c2       	rjmp	.+1260   	; 0x785e <MifareClassicAppProcess+0xc10>
    			Buffer[0] = NAK_INVALID_ARG;
    			return ACK_NAK_FRAME_SIZE;
    		}
    	} else {
    		/* Unknown command. Enter HALT state */
    		LogEntry(LOG_INFO_APP_CMD_UNKNOWN, Buffer, (BitCount+7)/8);
    7372:	a5 01       	movw	r20, r10
    7374:	49 5f       	subi	r20, 0xF9	; 249
    7376:	5f 4f       	sbci	r21, 0xFF	; 255
    7378:	a3 e0       	ldi	r26, 0x03	; 3
    737a:	56 95       	lsr	r21
    737c:	47 95       	ror	r20
    737e:	aa 95       	dec	r26
    7380:	e1 f7       	brne	.-8      	; 0x737a <MifareClassicAppProcess+0x72c>
    7382:	e0 91 6e 2f 	lds	r30, 0x2F6E
    7386:	f0 91 6f 2f 	lds	r31, 0x2F6F
    738a:	b8 01       	movw	r22, r16
    738c:	82 e9       	ldi	r24, 0x92	; 146
    738e:	19 95       	eicall
    		State = STATE_IDLE;
    7390:	81 e0       	ldi	r24, 0x01	; 1
    7392:	de c0       	rjmp	.+444    	; 0x7550 <MifareClassicAppProcess+0x902>
         * sending the data to be written. Decrypt the data first and
         * check for CRC. Then write the data when ReadOnly mode is not
         * activated. */

        /* We receive 16 bytes of data to be written and 2 bytes CRCA. Decrypt */
        Crypto1ByteArray(Buffer, MEM_BYTES_PER_BLOCK + ISO14443A_CRCA_SIZE);
    7394:	62 e1       	ldi	r22, 0x12	; 18
    7396:	c8 01       	movw	r24, r16
    7398:	0e 94 78 46 	call	0x8cf0	; 0x8cf0 <Crypto1ByteArray>

        if (ISO14443ACheckCRCA(Buffer, MEM_BYTES_PER_BLOCK)) {
    739c:	60 e1       	ldi	r22, 0x10	; 16
    739e:	70 e0       	ldi	r23, 0x00	; 0
    73a0:	c8 01       	movw	r24, r16
    73a2:	bc d3       	rcall	.+1912   	; 0x7b1c <ISO14443ACheckCRCA>
    73a4:	e0 91 6e 2f 	lds	r30, 0x2F6E
    73a8:	f0 91 6f 2f 	lds	r31, 0x2F6F
    73ac:	88 23       	and	r24, r24
    73ae:	29 f1       	breq	.+74     	; 0x73fa <MifareClassicAppProcess+0x7ac>
    73b0:	42 e1       	ldi	r20, 0x12	; 18
    73b2:	b8 01       	movw	r22, r16
    73b4:	81 e8       	ldi	r24, 0x81	; 129
    73b6:	19 95       	eicall
        	LogEntry(LOG_INFO_APP_CMD_WRITE, Buffer, MEM_BYTES_PER_BLOCK + ISO14443A_CRCA_SIZE);

            if (!ActiveConfiguration.ReadOnly) {
    73b8:	80 91 6d 2f 	lds	r24, 0x2F6D
    73bc:	81 11       	cpse	r24, r1
    73be:	0b c0       	rjmp	.+22     	; 0x73d6 <MifareClassicAppProcess+0x788>
                MemoryWriteBlock(Buffer, CurrentAddress * MEM_BYTES_PER_BLOCK, MEM_BYTES_PER_BLOCK);
    73c0:	60 91 d5 2c 	lds	r22, 0x2CD5
    73c4:	f0 e1       	ldi	r31, 0x10	; 16
    73c6:	6f 9f       	mul	r22, r31
    73c8:	b0 01       	movw	r22, r0
    73ca:	11 24       	eor	r1, r1
    73cc:	40 e1       	ldi	r20, 0x10	; 16
    73ce:	50 e0       	ldi	r21, 0x00	; 0
    73d0:	c8 01       	movw	r24, r16
    73d2:	0e 94 ef 0f 	call	0x1fde	; 0x1fde <MemoryWriteBlock>
            } else {
                /* Silently ignore in ReadOnly mode */
            }

            Buffer[0] = ACK_VALUE ^ Crypto1Nibble();
    73d6:	0e 94 83 45 	call	0x8b06	; 0x8b06 <Crypto1Nibble>
    73da:	9a e0       	ldi	r25, 0x0A	; 10
    73dc:	15 c0       	rjmp	.+42     	; 0x7408 <MifareClassicAppProcess+0x7ba>
         * been issued earlier and the reader is now sending the data. First,
         * decrypt the data and check CRC. Read data from the requested block
         * address into the global block buffer and check for integrity. Then
         * add or subtract according to issued command if necessary and store
         * the block back into the global block buffer. */
        Crypto1ByteArray(Buffer, MEM_VALUE_SIZE + ISO14443A_CRCA_SIZE);
    73de:	66 e0       	ldi	r22, 0x06	; 6
    73e0:	c8 01       	movw	r24, r16
    73e2:	0e 94 78 46 	call	0x8cf0	; 0x8cf0 <Crypto1ByteArray>

        if (ISO14443ACheckCRCA(Buffer, MEM_VALUE_SIZE )) {
    73e6:	64 e0       	ldi	r22, 0x04	; 4
    73e8:	70 e0       	ldi	r23, 0x00	; 0
    73ea:	c8 01       	movw	r24, r16
    73ec:	97 d3       	rcall	.+1838   	; 0x7b1c <ISO14443ACheckCRCA>
    73ee:	81 11       	cpse	r24, r1
    73f0:	13 c0       	rjmp	.+38     	; 0x7418 <MifareClassicAppProcess+0x7ca>
    73f2:	e0 91 6e 2f 	lds	r30, 0x2F6E
    73f6:	f0 91 6f 2f 	lds	r31, 0x2F6F
    73fa:	44 e0       	ldi	r20, 0x04	; 4
    73fc:	b8 01       	movw	r22, r16
    73fe:	81 ec       	ldi	r24, 0xC1	; 193
    7400:	19 95       	eicall
            }

            Buffer[0] = ACK_VALUE ^ Crypto1Nibble();
        } else {
        	LogEntry(LOG_ERR_APP_CHECKSUM_FAIL, Buffer, 4);
            Buffer[0] = NAK_CRC_ERROR ^ Crypto1Nibble();
    7402:	0e 94 83 45 	call	0x8b06	; 0x8b06 <Crypto1Nibble>
    7406:	91 e0       	ldi	r25, 0x01	; 1
    7408:	89 27       	eor	r24, r25
    740a:	f8 01       	movw	r30, r16
    740c:	80 83       	st	Z, r24
        }

        State = STATE_AUTHED_IDLE;
    740e:	88 e0       	ldi	r24, 0x08	; 8
    7410:	80 93 de 2c 	sts	0x2CDE, r24
        return ACK_NAK_FRAME_SIZE;
    7414:	84 e0       	ldi	r24, 0x04	; 4
    7416:	24 c2       	rjmp	.+1096   	; 0x7860 <MifareClassicAppProcess+0xc12>
         * add or subtract according to issued command if necessary and store
         * the block back into the global block buffer. */
        Crypto1ByteArray(Buffer, MEM_VALUE_SIZE + ISO14443A_CRCA_SIZE);

        if (ISO14443ACheckCRCA(Buffer, MEM_VALUE_SIZE )) {
            MemoryReadBlock(BlockBuffer, (uint16_t) CurrentAddress * MEM_BYTES_PER_BLOCK, MEM_BYTES_PER_BLOCK);
    7418:	60 91 d5 2c 	lds	r22, 0x2CD5
    741c:	f0 e1       	ldi	r31, 0x10	; 16
    741e:	6f 9f       	mul	r22, r31
    7420:	b0 01       	movw	r22, r0
    7422:	11 24       	eor	r1, r1
    7424:	40 e1       	ldi	r20, 0x10	; 16
    7426:	50 e0       	ldi	r21, 0x00	; 0
    7428:	84 ec       	ldi	r24, 0xC4	; 196
    742a:	9c e2       	ldi	r25, 0x2C	; 44
    742c:	0e 94 a1 0f 	call	0x1f42	; 0x1f42 <MemoryReadBlock>

INLINE bool CheckValueIntegrity(uint8_t* Block)
{
    /* Value Blocks contain a value stored three times, with
     * the middle portion inverted. */
    if (    (Block[0] == (uint8_t) ~Block[4]) && (Block[0] == Block[8])
    7430:	90 91 c4 2c 	lds	r25, 0x2CC4
    7434:	80 91 c8 2c 	lds	r24, 0x2CC8
    7438:	80 95       	com	r24
    743a:	98 13       	cpse	r25, r24
    743c:	eb c2       	rjmp	.+1494   	; 0x7a14 <MifareClassicAppProcess+0xdc6>
    743e:	80 91 cc 2c 	lds	r24, 0x2CCC
    7442:	98 13       	cpse	r25, r24
    7444:	e7 c2       	rjmp	.+1486   	; 0x7a14 <MifareClassicAppProcess+0xdc6>
         && (Block[1] == (uint8_t) ~Block[5]) && (Block[1] == Block[9])
    7446:	20 91 c5 2c 	lds	r18, 0x2CC5
    744a:	80 91 c9 2c 	lds	r24, 0x2CC9
    744e:	80 95       	com	r24
    7450:	28 13       	cpse	r18, r24
    7452:	e0 c2       	rjmp	.+1472   	; 0x7a14 <MifareClassicAppProcess+0xdc6>
    7454:	80 91 cd 2c 	lds	r24, 0x2CCD
    7458:	28 13       	cpse	r18, r24
    745a:	dc c2       	rjmp	.+1464   	; 0x7a14 <MifareClassicAppProcess+0xdc6>
         && (Block[2] == (uint8_t) ~Block[6]) && (Block[2] == Block[10])
    745c:	c0 90 c6 2c 	lds	r12, 0x2CC6
    7460:	80 91 ca 2c 	lds	r24, 0x2CCA
    7464:	80 95       	com	r24
    7466:	c8 12       	cpse	r12, r24
    7468:	d5 c2       	rjmp	.+1450   	; 0x7a14 <MifareClassicAppProcess+0xdc6>
    746a:	80 91 ce 2c 	lds	r24, 0x2CCE
    746e:	c8 12       	cpse	r12, r24
    7470:	d1 c2       	rjmp	.+1442   	; 0x7a14 <MifareClassicAppProcess+0xdc6>
         && (Block[3] == (uint8_t) ~Block[7]) && (Block[3] == Block[11])
    7472:	80 91 c7 2c 	lds	r24, 0x2CC7
    7476:	30 91 cb 2c 	lds	r19, 0x2CCB
    747a:	30 95       	com	r19
    747c:	83 13       	cpse	r24, r19
    747e:	ca c2       	rjmp	.+1428   	; 0x7a14 <MifareClassicAppProcess+0xdc6>
    7480:	30 91 cf 2c 	lds	r19, 0x2CCF
    7484:	83 13       	cpse	r24, r19
    7486:	c6 c2       	rjmp	.+1420   	; 0x7a14 <MifareClassicAppProcess+0xdc6>
         && (Block[12] == (uint8_t) ~Block[13])
    7488:	40 91 d0 2c 	lds	r20, 0x2CD0
    748c:	30 91 d1 2c 	lds	r19, 0x2CD1
    7490:	30 95       	com	r19
    7492:	43 13       	cpse	r20, r19
    7494:	bf c2       	rjmp	.+1406   	; 0x7a14 <MifareClassicAppProcess+0xdc6>
         && (Block[12] == Block[14])
    7496:	30 91 d2 2c 	lds	r19, 0x2CD2
    749a:	43 13       	cpse	r20, r19
    749c:	bb c2       	rjmp	.+1398   	; 0x7a14 <MifareClassicAppProcess+0xdc6>
         && (Block[14] == (uint8_t) ~Block[15])) {
    749e:	30 91 d3 2c 	lds	r19, 0x2CD3
    74a2:	30 95       	com	r19
    74a4:	43 13       	cpse	r20, r19
    74a6:	b6 c2       	rjmp	.+1388   	; 0x7a14 <MifareClassicAppProcess+0xdc6>
}

INLINE void ValueFromBlock(uint32_t* Value, uint8_t* Block)
{
    *Value = 0;
    *Value |= ((uint32_t) Block[0] << 0);
    74a8:	f8 01       	movw	r30, r16
    74aa:	30 81       	ld	r19, Z
    *Value |= ((uint32_t) Block[1] << 8);
    74ac:	41 81       	ldd	r20, Z+1	; 0x01
    *Value |= ((uint32_t) Block[2] << 16);
    74ae:	82 80       	ldd	r8, Z+2	; 0x02
    74b0:	91 2c       	mov	r9, r1
    74b2:	a1 2c       	mov	r10, r1
    74b4:	b1 2c       	mov	r11, r1
    74b6:	54 01       	movw	r10, r8
    74b8:	99 24       	eor	r9, r9
    74ba:	88 24       	eor	r8, r8
    74bc:	94 2a       	or	r9, r20
    74be:	83 2a       	or	r8, r19
    *Value |= ((uint32_t) Block[3] << 24);
    74c0:	33 81       	ldd	r19, Z+3	; 0x03
    74c2:	b3 2a       	or	r11, r19
INLINE void ValueFromBlock(uint32_t* Value, uint8_t* Block)
{
    *Value = 0;
    *Value |= ((uint32_t) Block[0] << 0);
    *Value |= ((uint32_t) Block[1] << 8);
    *Value |= ((uint32_t) Block[2] << 16);
    74c4:	d1 2c       	mov	r13, r1
    74c6:	e1 2c       	mov	r14, r1
    74c8:	f1 2c       	mov	r15, r1
    74ca:	76 01       	movw	r14, r12
    74cc:	dd 24       	eor	r13, r13
    74ce:	cc 24       	eor	r12, r12
    74d0:	d2 2a       	or	r13, r18
    74d2:	c9 2a       	or	r12, r25
    *Value |= ((uint32_t) Block[3] << 24);
    74d4:	f8 2a       	or	r15, r24
                uint32_t BlockValue;

                ValueFromBlock(&ParamValue, Buffer);
                ValueFromBlock(&BlockValue, BlockBuffer);

                if (State == STATE_DECREMENT) {
    74d6:	80 91 de 2c 	lds	r24, 0x2CDE
    74da:	8b 30       	cpi	r24, 0x0B	; 11
    74dc:	09 f0       	breq	.+2      	; 0x74e0 <MifareClassicAppProcess+0x892>
    74de:	7f c2       	rjmp	.+1278   	; 0x79de <MifareClassicAppProcess+0xd90>
    74e0:	e0 91 6e 2f 	lds	r30, 0x2F6E
    74e4:	f0 91 6f 2f 	lds	r31, 0x2F6F
    74e8:	46 e0       	ldi	r20, 0x06	; 6
    74ea:	b8 01       	movw	r22, r16
    74ec:	85 e8       	ldi	r24, 0x85	; 133
    74ee:	19 95       	eicall
                	LogEntry(LOG_INFO_APP_CMD_DEC, Buffer, MEM_VALUE_SIZE + ISO14443A_CRCA_SIZE);
                    BlockValue -= ParamValue;
    74f0:	c8 18       	sub	r12, r8
    74f2:	d9 08       	sbc	r13, r9
    74f4:	ea 08       	sbc	r14, r10
    74f6:	fb 08       	sbc	r15, r11
    *Value |= ((uint32_t) Block[3] << 24);
}

INLINE void ValueToBlock(uint8_t* Block, uint32_t Value)
{
    Block[0] = (uint8_t) (Value >> 0);
    74f8:	c0 92 c4 2c 	sts	0x2CC4, r12
    Block[1] = (uint8_t) (Value >> 8);
    74fc:	33 27       	eor	r19, r19
    74fe:	2f 2d       	mov	r18, r15
    7500:	1e 2d       	mov	r17, r14
    7502:	0d 2d       	mov	r16, r13
    7504:	00 93 c5 2c 	sts	0x2CC5, r16
    Block[2] = (uint8_t) (Value >> 16);
    7508:	a7 01       	movw	r20, r14
    750a:	66 27       	eor	r22, r22
    750c:	77 27       	eor	r23, r23
    750e:	40 93 c6 2c 	sts	0x2CC6, r20
    Block[3] = (uint8_t) (Value >> 24);
    7512:	8f 2d       	mov	r24, r15
    7514:	99 27       	eor	r25, r25
    7516:	aa 27       	eor	r26, r26
    7518:	bb 27       	eor	r27, r27
    751a:	80 93 c7 2c 	sts	0x2CC7, r24
    Block[4] = ~Block[0];
    751e:	ec 2d       	mov	r30, r12
    7520:	e0 95       	com	r30
    7522:	e0 93 c8 2c 	sts	0x2CC8, r30
    Block[5] = ~Block[1];
    7526:	e0 2f       	mov	r30, r16
    7528:	e0 95       	com	r30
    752a:	e0 93 c9 2c 	sts	0x2CC9, r30
    Block[6] = ~Block[2];
    752e:	e4 2f       	mov	r30, r20
    7530:	e0 95       	com	r30
    7532:	e0 93 ca 2c 	sts	0x2CCA, r30
    Block[7] = ~Block[3];
    7536:	e8 2f       	mov	r30, r24
    7538:	e0 95       	com	r30
    753a:	e0 93 cb 2c 	sts	0x2CCB, r30
    Block[8] = Block[0];
    753e:	c0 92 cc 2c 	sts	0x2CCC, r12
    Block[9] = Block[1];
    7542:	00 93 cd 2c 	sts	0x2CCD, r16
    Block[10] = Block[2];
    7546:	40 93 ce 2c 	sts	0x2CCE, r20
    Block[11] = Block[3];
    754a:	80 93 cf 2c 	sts	0x2CCF, r24
                    /* Do nothing */
                }

                ValueToBlock(BlockBuffer, BlockValue);

                State = STATE_AUTHED_IDLE;
    754e:	88 e0       	ldi	r24, 0x08	; 8
    7550:	80 93 de 2c 	sts	0x2CDE, r24
    7554:	84 c1       	rjmp	.+776    	; 0x785e <MifareClassicAppProcess+0xc10>
        if (ISO14443AWakeUp(Buffer, &BitCount, CardATQAValue, FromHalt)) {
            State = STATE_READY1;
            return BitCount;
        }
#ifdef SUPPORT_MF_CLASSIC_MAGIC_MODE
        else if (Buffer[0] == CMD_CHINESE_UNLOCK) {
    7556:	90 34       	cpi	r25, 0x40	; 64
    7558:	09 f0       	breq	.+2      	; 0x755c <MifareClassicAppProcess+0x90e>
    755a:	81 c1       	rjmp	.+770    	; 0x785e <MifareClassicAppProcess+0xc10>
            State = STATE_CHINESE_IDLE;
    755c:	82 e0       	ldi	r24, 0x02	; 2
    755e:	80 93 de 2c 	sts	0x2CDE, r24
            Buffer[0] = ACK_VALUE;
    7562:	8a e0       	ldi	r24, 0x0A	; 10
    7564:	eb ce       	rjmp	.-554    	; 0x733c <MifareClassicAppProcess+0x6ee>

    case STATE_READY1:
        if (ISO14443AWakeUp(Buffer, &BitCount, CardATQAValue, FromHalt)) {
            State = FromHalt ? STATE_HALT : STATE_IDLE;
            return ISO14443A_APP_NO_RESPONSE;
        } else if (Buffer[0] == ISO14443A_CMD_SELECT_CL1) {
    7566:	83 39       	cpi	r24, 0x93	; 147
    7568:	09 f0       	breq	.+2      	; 0x756c <MifareClassicAppProcess+0x91e>
    756a:	84 cc       	rjmp	.-1784   	; 0x6e74 <MifareClassicAppProcess+0x226>
            /* Load UID CL1 and perform anticollision */
            uint8_t UidCL1[ISO14443A_CL_UID_SIZE];
			/* For Longer UIDs indicate that more UID-Bytes follow (-> CL2) */
            if (ActiveConfiguration.UidSize == 7) {
    756c:	80 91 6c 2f 	lds	r24, 0x2F6C
    7570:	87 30       	cpi	r24, 0x07	; 7
    7572:	09 f0       	breq	.+2      	; 0x7576 <MifareClassicAppProcess+0x928>
    7574:	a0 c0       	rjmp	.+320    	; 0x76b6 <MifareClassicAppProcess+0xa68>
	            MemoryReadBlock(&UidCL1[1], MEM_UID_CL1_ADDRESS, MEM_UID_CL1_SIZE-1);
    7576:	43 e0       	ldi	r20, 0x03	; 3
    7578:	50 e0       	ldi	r21, 0x00	; 0
    757a:	60 e0       	ldi	r22, 0x00	; 0
    757c:	70 e0       	ldi	r23, 0x00	; 0
    757e:	ce 01       	movw	r24, r28
    7580:	02 96       	adiw	r24, 0x02	; 2
    7582:	0e 94 a1 0f 	call	0x1f42	; 0x1f42 <MemoryReadBlock>
	            UidCL1[0] = ISO14443A_UID0_CT;
    7586:	88 e8       	ldi	r24, 0x88	; 136
    7588:	89 83       	std	Y+1, r24	; 0x01

INLINE
bool ISO14443ASelect(void* Buffer, uint16_t* BitCount, uint8_t* UidCL, uint8_t SAKValue)
{
    uint8_t* DataPtr = (uint8_t*) Buffer;
    uint8_t NVB = DataPtr[1];
    758a:	f8 01       	movw	r30, r16
    758c:	91 81       	ldd	r25, Z+1	; 0x01
    //uint8_t CollisionByteCount = (NVB >> 4) & 0x0F;
    //uint8_t CollisionBitCount =  (NVB >> 0) & 0x0F;

    switch (NVB) {
    758e:	90 32       	cpi	r25, 0x20	; 32
    7590:	19 f0       	breq	.+6      	; 0x7598 <MifareClassicAppProcess+0x94a>
    7592:	90 37       	cpi	r25, 0x70	; 112
    7594:	61 f0       	breq	.+24     	; 0x75ae <MifareClassicAppProcess+0x960>
    7596:	24 c0       	rjmp	.+72     	; 0x75e0 <MifareClassicAppProcess+0x992>
    case ISO14443A_NVB_AC_START:
        /* Start of anticollision procedure.
        * Send whole UID CLn + BCC */
        DataPtr[0] = UidCL[0];
    7598:	f8 01       	movw	r30, r16
    759a:	80 83       	st	Z, r24
        DataPtr[1] = UidCL[1];
    759c:	3a 81       	ldd	r19, Y+2	; 0x02
    759e:	31 83       	std	Z+1, r19	; 0x01
        DataPtr[2] = UidCL[2];
    75a0:	2b 81       	ldd	r18, Y+3	; 0x03
    75a2:	22 83       	std	Z+2, r18	; 0x02
        DataPtr[3] = UidCL[3];
    75a4:	9c 81       	ldd	r25, Y+4	; 0x04
    75a6:	93 83       	std	Z+3, r25	; 0x03
    75a8:	23 27       	eor	r18, r19
        DataPtr[4] = ISO14443A_CALC_BCC(DataPtr);
    75aa:	82 27       	eor	r24, r18
    75ac:	28 c1       	rjmp	.+592    	; 0x77fe <MifareClassicAppProcess+0xbb0>
        return false;

    case ISO14443A_NVB_AC_END:
        /* End of anticollision procedure.
        * Send SAK CLn if we are selected. */
        if (    (DataPtr[2] == UidCL[0]) &&
    75ae:	f8 01       	movw	r30, r16
    75b0:	82 81       	ldd	r24, Z+2	; 0x02
    75b2:	88 38       	cpi	r24, 0x88	; 136
    75b4:	09 f0       	breq	.+2      	; 0x75b8 <MifareClassicAppProcess+0x96a>
    75b6:	53 c1       	rjmp	.+678    	; 0x785e <MifareClassicAppProcess+0xc10>
    75b8:	93 81       	ldd	r25, Z+3	; 0x03
    75ba:	8a 81       	ldd	r24, Y+2	; 0x02
    75bc:	98 13       	cpse	r25, r24
    75be:	4f c1       	rjmp	.+670    	; 0x785e <MifareClassicAppProcess+0xc10>
                (DataPtr[3] == UidCL[1]) &&
    75c0:	94 81       	ldd	r25, Z+4	; 0x04
    75c2:	8b 81       	ldd	r24, Y+3	; 0x03
    75c4:	98 13       	cpse	r25, r24
    75c6:	4b c1       	rjmp	.+662    	; 0x785e <MifareClassicAppProcess+0xc10>
                (DataPtr[4] == UidCL[2]) &&
    75c8:	95 81       	ldd	r25, Z+5	; 0x05
    75ca:	8c 81       	ldd	r24, Y+4	; 0x04
    75cc:	98 13       	cpse	r25, r24
    75ce:	47 c1       	rjmp	.+654    	; 0x785e <MifareClassicAppProcess+0xc10>
                (DataPtr[5] == UidCL[3]) ) {

            DataPtr[0] = SAKValue;
    75d0:	84 e0       	ldi	r24, 0x04	; 4
    75d2:	80 83       	st	Z, r24
            ISO14443AAppendCRCA(Buffer, 1);
    75d4:	61 e0       	ldi	r22, 0x01	; 1
    75d6:	70 e0       	ldi	r23, 0x00	; 0
    75d8:	c8 01       	movw	r24, r16
    75da:	75 d2       	rcall	.+1258   	; 0x7ac6 <ISO14443AAppendCRCA>
	            if (ISO14443ASelect(Buffer, &BitCount, UidCL1, SAK_UID_NOT_FINISHED))
					State = STATE_READY2;
    75dc:	85 e0       	ldi	r24, 0x05	; 5
    75de:	9e c0       	rjmp	.+316    	; 0x771c <MifareClassicAppProcess+0xace>
            *BitCount = 0;
            return false;
        }
    default:
    {
        uint8_t CollisionByteCount = ((NVB >> 4) & 0x0f) - 2;
    75e0:	e9 2e       	mov	r14, r25
    75e2:	e2 94       	swap	r14
    75e4:	2f e0       	ldi	r18, 0x0F	; 15
    75e6:	e2 22       	and	r14, r18
    75e8:	2e ef       	ldi	r18, 0xFE	; 254
    75ea:	2e 0d       	add	r18, r14
        uint8_t CollisionBitCount  = (NVB >> 0) & 0x0f;
    75ec:	9f 70       	andi	r25, 0x0F	; 15
    75ee:	f9 2e       	mov	r15, r25
        uint8_t mask = 0xFF >> (8 - CollisionBitCount);
    75f0:	88 e0       	ldi	r24, 0x08	; 8
    75f2:	90 e0       	ldi	r25, 0x00	; 0
    75f4:	8f 19       	sub	r24, r15
    75f6:	91 09       	sbc	r25, r1
    75f8:	4f ef       	ldi	r20, 0xFF	; 255
    75fa:	50 e0       	ldi	r21, 0x00	; 0
    75fc:	6a 01       	movw	r12, r20
    75fe:	02 c0       	rjmp	.+4      	; 0x7604 <MifareClassicAppProcess+0x9b6>
    7600:	d5 94       	asr	r13
    7602:	c7 94       	ror	r12
    7604:	8a 95       	dec	r24
    7606:	e2 f7       	brpl	.-8      	; 0x7600 <MifareClassicAppProcess+0x9b2>
        // Since the UidCL does not contain the BCC, we have to distinguish here
        if (
    7608:	25 30       	cpi	r18, 0x05	; 5
    760a:	21 f0       	breq	.+8      	; 0x7614 <MifareClassicAppProcess+0x9c6>
                ((CollisionByteCount == 5 || (CollisionByteCount == 4 && CollisionBitCount > 0)) && memcmp(UidCL, &DataPtr[2], 4) == 0 && (ISO14443A_CALC_BCC(UidCL) & mask) == (DataPtr[6] & mask))
    760c:	24 30       	cpi	r18, 0x04	; 4
    760e:	59 f5       	brne	.+86     	; 0x7666 <MifareClassicAppProcess+0xa18>
    7610:	ff 20       	and	r15, r15
    7612:	e9 f0       	breq	.+58     	; 0x764e <MifareClassicAppProcess+0xa00>
    7614:	44 e0       	ldi	r20, 0x04	; 4
    7616:	50 e0       	ldi	r21, 0x00	; 0
    7618:	b8 01       	movw	r22, r16
    761a:	6e 5f       	subi	r22, 0xFE	; 254
    761c:	7f 4f       	sbci	r23, 0xFF	; 255
    761e:	ce 01       	movw	r24, r28
    7620:	01 96       	adiw	r24, 0x01	; 1
    7622:	2b 8b       	std	Y+19, r18	; 0x13
    7624:	0e 94 da 65 	call	0xcbb4	; 0xcbb4 <memcmp>
    7628:	2b 89       	ldd	r18, Y+19	; 0x13
    762a:	89 2b       	or	r24, r25
    762c:	61 f4       	brne	.+24     	; 0x7646 <MifareClassicAppProcess+0x9f8>
    762e:	9a 81       	ldd	r25, Y+2	; 0x02
    7630:	8b 81       	ldd	r24, Y+3	; 0x03
    7632:	89 27       	eor	r24, r25
    7634:	98 e8       	ldi	r25, 0x88	; 136
    7636:	89 27       	eor	r24, r25
    7638:	9c 81       	ldd	r25, Y+4	; 0x04
    763a:	89 27       	eor	r24, r25
    763c:	f8 01       	movw	r30, r16
    763e:	96 81       	ldd	r25, Z+6	; 0x06
    7640:	89 27       	eor	r24, r25
    7642:	8c 21       	and	r24, r12
    7644:	81 f1       	breq	.+96     	; 0x76a6 <MifareClassicAppProcess+0xa58>
                ||
    7646:	24 30       	cpi	r18, 0x04	; 4
    7648:	71 f4       	brne	.+28     	; 0x7666 <MifareClassicAppProcess+0xa18>
                (CollisionByteCount == 4 && CollisionBitCount == 0 && memcmp(UidCL, &DataPtr[2], 4) == 0)
    764a:	f1 10       	cpse	r15, r1
    764c:	08 c1       	rjmp	.+528    	; 0x785e <MifareClassicAppProcess+0xc10>
    764e:	44 e0       	ldi	r20, 0x04	; 4
    7650:	50 e0       	ldi	r21, 0x00	; 0
    7652:	b8 01       	movw	r22, r16
    7654:	6e 5f       	subi	r22, 0xFE	; 254
    7656:	7f 4f       	sbci	r23, 0xFF	; 255
    7658:	ce 01       	movw	r24, r28
    765a:	01 96       	adiw	r24, 0x01	; 1
    765c:	0e 94 da 65 	call	0xcbb4	; 0xcbb4 <memcmp>
    7660:	89 2b       	or	r24, r25
    7662:	09 f1       	breq	.+66     	; 0x76a6 <MifareClassicAppProcess+0xa58>
    7664:	fc c0       	rjmp	.+504    	; 0x785e <MifareClassicAppProcess+0xc10>
                ||
    7666:	24 30       	cpi	r18, 0x04	; 4
    7668:	08 f0       	brcs	.+2      	; 0x766c <MifareClassicAppProcess+0xa1e>
    766a:	f9 c0       	rjmp	.+498    	; 0x785e <MifareClassicAppProcess+0xc10>
                (CollisionByteCount < 4 && memcmp(UidCL, &DataPtr[2], CollisionByteCount) == 0 && (UidCL[CollisionByteCount] & mask) == (DataPtr[CollisionByteCount + 2] & mask))
    766c:	e2 2e       	mov	r14, r18
    766e:	f1 2c       	mov	r15, r1
    7670:	a7 01       	movw	r20, r14
    7672:	b8 01       	movw	r22, r16
    7674:	6e 5f       	subi	r22, 0xFE	; 254
    7676:	7f 4f       	sbci	r23, 0xFF	; 255
    7678:	ce 01       	movw	r24, r28
    767a:	01 96       	adiw	r24, 0x01	; 1
    767c:	0e 94 da 65 	call	0xcbb4	; 0xcbb4 <memcmp>
    7680:	89 2b       	or	r24, r25
    7682:	09 f0       	breq	.+2      	; 0x7686 <MifareClassicAppProcess+0xa38>
    7684:	ec c0       	rjmp	.+472    	; 0x785e <MifareClassicAppProcess+0xc10>
    7686:	d8 01       	movw	r26, r16
    7688:	ae 0d       	add	r26, r14
    768a:	bf 1d       	adc	r27, r15
    768c:	e1 e0       	ldi	r30, 0x01	; 1
    768e:	f0 e0       	ldi	r31, 0x00	; 0
    7690:	ec 0f       	add	r30, r28
    7692:	fd 1f       	adc	r31, r29
    7694:	ee 0d       	add	r30, r14
    7696:	ff 1d       	adc	r31, r15
    7698:	12 96       	adiw	r26, 0x02	; 2
    769a:	9c 91       	ld	r25, X
    769c:	80 81       	ld	r24, Z
    769e:	89 27       	eor	r24, r25
    76a0:	c8 22       	and	r12, r24
    76a2:	09 f0       	breq	.+2      	; 0x76a6 <MifareClassicAppProcess+0xa58>
    76a4:	dc c0       	rjmp	.+440    	; 0x785e <MifareClassicAppProcess+0xc10>
        )
        {
            DataPtr[0] = UidCL[0];
    76a6:	98 e8       	ldi	r25, 0x88	; 136
    76a8:	f8 01       	movw	r30, r16
    76aa:	90 83       	st	Z, r25
            DataPtr[1] = UidCL[1];
    76ac:	3a 81       	ldd	r19, Y+2	; 0x02
    76ae:	31 83       	std	Z+1, r19	; 0x01
            DataPtr[2] = UidCL[2];
    76b0:	2b 81       	ldd	r18, Y+3	; 0x03
    76b2:	22 83       	std	Z+2, r18	; 0x02
    76b4:	a0 c0       	rjmp	.+320    	; 0x77f6 <MifareClassicAppProcess+0xba8>
            } else {
	            MemoryReadBlock(UidCL1, MEM_UID_CL1_ADDRESS, MEM_UID_CL1_SIZE);
    76b6:	44 e0       	ldi	r20, 0x04	; 4
    76b8:	50 e0       	ldi	r21, 0x00	; 0
    76ba:	60 e0       	ldi	r22, 0x00	; 0
    76bc:	70 e0       	ldi	r23, 0x00	; 0
    76be:	07 c0       	rjmp	.+14     	; 0x76ce <MifareClassicAppProcess+0xa80>

    case STATE_READY2:
    if (ISO14443AWakeUp(Buffer, &BitCount, CardATQAValue, FromHalt)) {
        State = FromHalt ? STATE_HALT : STATE_IDLE;
	    return ISO14443A_APP_NO_RESPONSE;
	    } else if (Buffer[0] == ISO14443A_CMD_SELECT_CL2) {
    76c0:	85 39       	cpi	r24, 0x95	; 149
    76c2:	09 f0       	breq	.+2      	; 0x76c6 <MifareClassicAppProcess+0xa78>
    76c4:	d7 cb       	rjmp	.-2130   	; 0x6e74 <MifareClassicAppProcess+0x226>
	    /* Load UID CL2 and perform anticollision */
	    uint8_t UidCL2[ISO14443A_CL_UID_SIZE];
	    MemoryReadBlock(UidCL2, MEM_UID_CL2_ADDRESS, MEM_UID_CL2_SIZE);
    76c6:	44 e0       	ldi	r20, 0x04	; 4
    76c8:	50 e0       	ldi	r21, 0x00	; 0
    76ca:	63 e0       	ldi	r22, 0x03	; 3
    76cc:	70 e0       	ldi	r23, 0x00	; 0
    76ce:	ce 01       	movw	r24, r28
    76d0:	01 96       	adiw	r24, 0x01	; 1
    76d2:	0e 94 a1 0f 	call	0x1f42	; 0x1f42 <MemoryReadBlock>

	    if (ISO14443ASelect(Buffer, &BitCount, UidCL2, CardSAKValue)) {
    76d6:	90 91 bc 2c 	lds	r25, 0x2CBC

INLINE
bool ISO14443ASelect(void* Buffer, uint16_t* BitCount, uint8_t* UidCL, uint8_t SAKValue)
{
    uint8_t* DataPtr = (uint8_t*) Buffer;
    uint8_t NVB = DataPtr[1];
    76da:	f8 01       	movw	r30, r16
    76dc:	81 81       	ldd	r24, Z+1	; 0x01
    //uint8_t CollisionByteCount = (NVB >> 4) & 0x0F;
    //uint8_t CollisionBitCount =  (NVB >> 0) & 0x0F;

    switch (NVB) {
    76de:	80 32       	cpi	r24, 0x20	; 32
    76e0:	09 f4       	brne	.+2      	; 0x76e4 <MifareClassicAppProcess+0xa96>
    76e2:	82 c0       	rjmp	.+260    	; 0x77e8 <MifareClassicAppProcess+0xb9a>
    76e4:	80 37       	cpi	r24, 0x70	; 112
    76e6:	f1 f4       	brne	.+60     	; 0x7724 <MifareClassicAppProcess+0xad6>
        return false;

    case ISO14443A_NVB_AC_END:
        /* End of anticollision procedure.
        * Send SAK CLn if we are selected. */
        if (    (DataPtr[2] == UidCL[0]) &&
    76e8:	f8 01       	movw	r30, r16
    76ea:	22 81       	ldd	r18, Z+2	; 0x02
    76ec:	89 81       	ldd	r24, Y+1	; 0x01
    76ee:	28 13       	cpse	r18, r24
    76f0:	b6 c0       	rjmp	.+364    	; 0x785e <MifareClassicAppProcess+0xc10>
    76f2:	23 81       	ldd	r18, Z+3	; 0x03
    76f4:	8a 81       	ldd	r24, Y+2	; 0x02
    76f6:	28 13       	cpse	r18, r24
    76f8:	b2 c0       	rjmp	.+356    	; 0x785e <MifareClassicAppProcess+0xc10>
                (DataPtr[3] == UidCL[1]) &&
    76fa:	24 81       	ldd	r18, Z+4	; 0x04
    76fc:	8b 81       	ldd	r24, Y+3	; 0x03
    76fe:	28 13       	cpse	r18, r24
    7700:	ae c0       	rjmp	.+348    	; 0x785e <MifareClassicAppProcess+0xc10>
                (DataPtr[4] == UidCL[2]) &&
    7702:	25 81       	ldd	r18, Z+5	; 0x05
    7704:	8c 81       	ldd	r24, Y+4	; 0x04
    7706:	28 13       	cpse	r18, r24
    7708:	aa c0       	rjmp	.+340    	; 0x785e <MifareClassicAppProcess+0xc10>
                (DataPtr[5] == UidCL[3]) ) {

            DataPtr[0] = SAKValue;
    770a:	90 83       	st	Z, r25
            ISO14443AAppendCRCA(Buffer, 1);
    770c:	61 e0       	ldi	r22, 0x01	; 1
    770e:	70 e0       	ldi	r23, 0x00	; 0
    7710:	c8 01       	movw	r24, r16
    7712:	d9 d1       	rcall	.+946    	; 0x7ac6 <ISO14443AAppendCRCA>
                    AccessAddress = 0xff; /* invalid, force reload */
    7714:	8f ef       	ldi	r24, 0xFF	; 255
    7716:	80 93 bf 2c 	sts	0x2CBF, r24
		    State = STATE_ACTIVE;
    771a:	86 e0       	ldi	r24, 0x06	; 6
    771c:	80 93 de 2c 	sts	0x2CDE, r24
    7720:	88 e1       	ldi	r24, 0x18	; 24
    7722:	9e c0       	rjmp	.+316    	; 0x7860 <MifareClassicAppProcess+0xc12>
            *BitCount = 0;
            return false;
        }
    default:
    {
        uint8_t CollisionByteCount = ((NVB >> 4) & 0x0f) - 2;
    7724:	e8 2e       	mov	r14, r24
    7726:	e2 94       	swap	r14
    7728:	9f e0       	ldi	r25, 0x0F	; 15
    772a:	e9 22       	and	r14, r25
    772c:	2e ef       	ldi	r18, 0xFE	; 254
    772e:	2e 0d       	add	r18, r14
        uint8_t CollisionBitCount  = (NVB >> 0) & 0x0f;
    7730:	8f 70       	andi	r24, 0x0F	; 15
    7732:	f8 2e       	mov	r15, r24
        uint8_t mask = 0xFF >> (8 - CollisionBitCount);
    7734:	88 e0       	ldi	r24, 0x08	; 8
    7736:	90 e0       	ldi	r25, 0x00	; 0
    7738:	8f 19       	sub	r24, r15
    773a:	91 09       	sbc	r25, r1
    773c:	4f ef       	ldi	r20, 0xFF	; 255
    773e:	50 e0       	ldi	r21, 0x00	; 0
    7740:	6a 01       	movw	r12, r20
    7742:	02 c0       	rjmp	.+4      	; 0x7748 <MifareClassicAppProcess+0xafa>
    7744:	d5 94       	asr	r13
    7746:	c7 94       	ror	r12
    7748:	8a 95       	dec	r24
    774a:	e2 f7       	brpl	.-8      	; 0x7744 <MifareClassicAppProcess+0xaf6>
        // Since the UidCL does not contain the BCC, we have to distinguish here
        if (
    774c:	25 30       	cpi	r18, 0x05	; 5
    774e:	21 f0       	breq	.+8      	; 0x7758 <MifareClassicAppProcess+0xb0a>
                ((CollisionByteCount == 5 || (CollisionByteCount == 4 && CollisionBitCount > 0)) && memcmp(UidCL, &DataPtr[2], 4) == 0 && (ISO14443A_CALC_BCC(UidCL) & mask) == (DataPtr[6] & mask))
    7750:	24 30       	cpi	r18, 0x04	; 4
    7752:	59 f5       	brne	.+86     	; 0x77aa <MifareClassicAppProcess+0xb5c>
    7754:	ff 20       	and	r15, r15
    7756:	e9 f0       	breq	.+58     	; 0x7792 <MifareClassicAppProcess+0xb44>
    7758:	44 e0       	ldi	r20, 0x04	; 4
    775a:	50 e0       	ldi	r21, 0x00	; 0
    775c:	b8 01       	movw	r22, r16
    775e:	6e 5f       	subi	r22, 0xFE	; 254
    7760:	7f 4f       	sbci	r23, 0xFF	; 255
    7762:	ce 01       	movw	r24, r28
    7764:	01 96       	adiw	r24, 0x01	; 1
    7766:	2b 8b       	std	Y+19, r18	; 0x13
    7768:	0e 94 da 65 	call	0xcbb4	; 0xcbb4 <memcmp>
    776c:	2b 89       	ldd	r18, Y+19	; 0x13
    776e:	89 2b       	or	r24, r25
    7770:	61 f4       	brne	.+24     	; 0x778a <MifareClassicAppProcess+0xb3c>
    7772:	9a 81       	ldd	r25, Y+2	; 0x02
    7774:	89 81       	ldd	r24, Y+1	; 0x01
    7776:	89 27       	eor	r24, r25
    7778:	9b 81       	ldd	r25, Y+3	; 0x03
    777a:	89 27       	eor	r24, r25
    777c:	9c 81       	ldd	r25, Y+4	; 0x04
    777e:	89 27       	eor	r24, r25
    7780:	f8 01       	movw	r30, r16
    7782:	96 81       	ldd	r25, Z+6	; 0x06
    7784:	89 27       	eor	r24, r25
    7786:	8c 21       	and	r24, r12
    7788:	79 f1       	breq	.+94     	; 0x77e8 <MifareClassicAppProcess+0xb9a>
                ||
    778a:	24 30       	cpi	r18, 0x04	; 4
    778c:	71 f4       	brne	.+28     	; 0x77aa <MifareClassicAppProcess+0xb5c>
                (CollisionByteCount == 4 && CollisionBitCount == 0 && memcmp(UidCL, &DataPtr[2], 4) == 0)
    778e:	f1 10       	cpse	r15, r1
    7790:	66 c0       	rjmp	.+204    	; 0x785e <MifareClassicAppProcess+0xc10>
    7792:	44 e0       	ldi	r20, 0x04	; 4
    7794:	50 e0       	ldi	r21, 0x00	; 0
    7796:	b8 01       	movw	r22, r16
    7798:	6e 5f       	subi	r22, 0xFE	; 254
    779a:	7f 4f       	sbci	r23, 0xFF	; 255
    779c:	ce 01       	movw	r24, r28
    779e:	01 96       	adiw	r24, 0x01	; 1
    77a0:	0e 94 da 65 	call	0xcbb4	; 0xcbb4 <memcmp>
    77a4:	89 2b       	or	r24, r25
    77a6:	01 f1       	breq	.+64     	; 0x77e8 <MifareClassicAppProcess+0xb9a>
    77a8:	5a c0       	rjmp	.+180    	; 0x785e <MifareClassicAppProcess+0xc10>
                ||
    77aa:	24 30       	cpi	r18, 0x04	; 4
    77ac:	08 f0       	brcs	.+2      	; 0x77b0 <MifareClassicAppProcess+0xb62>
    77ae:	57 c0       	rjmp	.+174    	; 0x785e <MifareClassicAppProcess+0xc10>
                (CollisionByteCount < 4 && memcmp(UidCL, &DataPtr[2], CollisionByteCount) == 0 && (UidCL[CollisionByteCount] & mask) == (DataPtr[CollisionByteCount + 2] & mask))
    77b0:	e2 2e       	mov	r14, r18
    77b2:	f1 2c       	mov	r15, r1
    77b4:	a7 01       	movw	r20, r14
    77b6:	b8 01       	movw	r22, r16
    77b8:	6e 5f       	subi	r22, 0xFE	; 254
    77ba:	7f 4f       	sbci	r23, 0xFF	; 255
    77bc:	ce 01       	movw	r24, r28
    77be:	01 96       	adiw	r24, 0x01	; 1
    77c0:	0e 94 da 65 	call	0xcbb4	; 0xcbb4 <memcmp>
    77c4:	89 2b       	or	r24, r25
    77c6:	09 f0       	breq	.+2      	; 0x77ca <MifareClassicAppProcess+0xb7c>
    77c8:	4a c0       	rjmp	.+148    	; 0x785e <MifareClassicAppProcess+0xc10>
    77ca:	d8 01       	movw	r26, r16
    77cc:	ae 0d       	add	r26, r14
    77ce:	bf 1d       	adc	r27, r15
    77d0:	e1 e0       	ldi	r30, 0x01	; 1
    77d2:	f0 e0       	ldi	r31, 0x00	; 0
    77d4:	ec 0f       	add	r30, r28
    77d6:	fd 1f       	adc	r31, r29
    77d8:	ee 0d       	add	r30, r14
    77da:	ff 1d       	adc	r31, r15
    77dc:	12 96       	adiw	r26, 0x02	; 2
    77de:	9c 91       	ld	r25, X
    77e0:	80 81       	ld	r24, Z
    77e2:	89 27       	eor	r24, r25
    77e4:	c8 22       	and	r12, r24
    77e6:	d9 f5       	brne	.+118    	; 0x785e <MifareClassicAppProcess+0xc10>
        )
        {
            DataPtr[0] = UidCL[0];
    77e8:	29 81       	ldd	r18, Y+1	; 0x01
    77ea:	f8 01       	movw	r30, r16
    77ec:	20 83       	st	Z, r18
            DataPtr[1] = UidCL[1];
    77ee:	3a 81       	ldd	r19, Y+2	; 0x02
    77f0:	31 83       	std	Z+1, r19	; 0x01
            DataPtr[2] = UidCL[2];
    77f2:	9b 81       	ldd	r25, Y+3	; 0x03
    77f4:	92 83       	std	Z+2, r25	; 0x02
            DataPtr[3] = UidCL[3];
    77f6:	8c 81       	ldd	r24, Y+4	; 0x04
    77f8:	83 83       	std	Z+3, r24	; 0x03
            DataPtr[4] = ISO14443A_CALC_BCC(DataPtr);
    77fa:	23 27       	eor	r18, r19
    77fc:	92 27       	eor	r25, r18
    77fe:	89 27       	eor	r24, r25
    7800:	84 83       	std	Z+4, r24	; 0x04

            *BitCount = ISO14443A_CL_FRAME_SIZE;
    7802:	88 e2       	ldi	r24, 0x28	; 40
    7804:	2d c0       	rjmp	.+90     	; 0x7860 <MifareClassicAppProcess+0xc12>
        		return ACK_NAK_FRAME_SIZE;
        	}

        	/* EV1 READ_SIG command is */
        	/* same as CMD_RESTORE but has no operand, rely on CRC here! */
      } else if ((Buffer[0] == CMD_SIG_READ) &&
    7806:	82 3c       	cpi	r24, 0xC2	; 194
    7808:	09 f0       	breq	.+2      	; 0x780c <MifareClassicAppProcess+0xbbe>
    780a:	cb c0       	rjmp	.+406    	; 0x79a2 <MifareClassicAppProcess+0xd54>
    780c:	f8 01       	movw	r30, r16
    780e:	91 81       	ldd	r25, Z+1	; 0x01
    7810:	90 3e       	cpi	r25, 0xE0	; 224
    7812:	09 f0       	breq	.+2      	; 0x7816 <MifareClassicAppProcess+0xbc8>
    7814:	c8 c0       	rjmp	.+400    	; 0x79a6 <MifareClassicAppProcess+0xd58>
                 (Buffer[1] == 0xe0) && 
    7816:	92 81       	ldd	r25, Z+2	; 0x02
    7818:	94 3b       	cpi	r25, 0xB4	; 180
    781a:	09 f0       	breq	.+2      	; 0x781e <MifareClassicAppProcess+0xbd0>
    781c:	c4 c0       	rjmp	.+392    	; 0x79a6 <MifareClassicAppProcess+0xd58>
                 (Buffer[2] == 0xb4)) {
            uint8_t Key[6];
	    /* check if Originality check signature data available */
	    /* Signature data is stored in (hidden) blocks 68..71 (0x44..0x47) */
	    /* Signature data is read with key B, check if present */
	    MemoryReadBlock(Key, 
    781e:	46 e0       	ldi	r20, 0x06	; 6
    7820:	50 e0       	ldi	r21, 0x00	; 0
    7822:	6a ea       	ldi	r22, 0xAA	; 170
    7824:	74 e0       	ldi	r23, 0x04	; 4
    7826:	ce 01       	movw	r24, r28
    7828:	01 96       	adiw	r24, 0x01	; 1
    782a:	0e 94 a1 0f 	call	0x1f42	; 0x1f42 <MemoryReadBlock>
	                MEM_EV1_SIGNATURE_TRAILOR + MEM_KEY_B_OFFSET,
	                MEM_KEY_SIZE);
	    /* Key B = 4b791bea7bcc is used to read the data, check if correct key */
	    if (   (Key[0] == 0x4b) && (Key[1] == 0x79) && (Key[2] == 0x1b) 
    782e:	89 81       	ldd	r24, Y+1	; 0x01
    7830:	8b 34       	cpi	r24, 0x4B	; 75
    7832:	09 f0       	breq	.+2      	; 0x7836 <MifareClassicAppProcess+0xbe8>
    7834:	2d cb       	rjmp	.-2470   	; 0x6e90 <MifareClassicAppProcess+0x242>
    7836:	8a 81       	ldd	r24, Y+2	; 0x02
    7838:	89 37       	cpi	r24, 0x79	; 121
    783a:	09 f0       	breq	.+2      	; 0x783e <MifareClassicAppProcess+0xbf0>
    783c:	29 cb       	rjmp	.-2478   	; 0x6e90 <MifareClassicAppProcess+0x242>
    783e:	8b 81       	ldd	r24, Y+3	; 0x03
    7840:	8b 31       	cpi	r24, 0x1B	; 27
    7842:	09 f0       	breq	.+2      	; 0x7846 <MifareClassicAppProcess+0xbf8>
    7844:	25 cb       	rjmp	.-2486   	; 0x6e90 <MifareClassicAppProcess+0x242>
	        && (Key[3] == 0xea) && (Key[4] == 0x7b) && (Key[5] == 0xcc) ) {
    7846:	8c 81       	ldd	r24, Y+4	; 0x04
    7848:	8a 3e       	cpi	r24, 0xEA	; 234
    784a:	09 f0       	breq	.+2      	; 0x784e <MifareClassicAppProcess+0xc00>
    784c:	21 cb       	rjmp	.-2494   	; 0x6e90 <MifareClassicAppProcess+0x242>
    784e:	8d 81       	ldd	r24, Y+5	; 0x05
    7850:	8b 37       	cpi	r24, 0x7B	; 123
    7852:	09 f0       	breq	.+2      	; 0x7856 <MifareClassicAppProcess+0xc08>
    7854:	1d cb       	rjmp	.-2502   	; 0x6e90 <MifareClassicAppProcess+0x242>
    7856:	8e 81       	ldd	r24, Y+6	; 0x06
    7858:	8c 3c       	cpi	r24, 0xCC	; 204
    785a:	09 f0       	breq	.+2      	; 0x785e <MifareClassicAppProcess+0xc10>
    785c:	19 cb       	rjmp	.-2510   	; 0x6e90 <MifareClassicAppProcess+0x242>

            *BitCount = ISO14443A_SAK_FRAME_SIZE;
            return true;
        } else {
            /* We have not been selected. Don't send anything. */
            *BitCount = 0;
    785e:	80 e0       	ldi	r24, 0x00	; 0
    7860:	90 e0       	ldi	r25, 0x00	; 0
    7862:	dc c0       	rjmp	.+440    	; 0x7a1c <MifareClassicAppProcess+0xdce>
            }
        } else if ( (Buffer[0] == CMD_AUTH_A) || (Buffer[0] == CMD_AUTH_B)) {
        	if (ISO14443ACheckCRCA(Buffer, CMD_AUTH_FRAME_SIZE)) {

        		//uint16_t SectorAddress = Buffer[1] & MEM_SECTOR_ADDR_MASK;
        		uint16_t KeyOffset = (Buffer[0] == CMD_AUTH_A ? MEM_KEY_A_OFFSET : MEM_KEY_B_OFFSET);
    7864:	f8 01       	movw	r30, r16
    7866:	80 81       	ld	r24, Z
    7868:	80 36       	cpi	r24, 0x60	; 96
    786a:	21 f0       	breq	.+8      	; 0x7874 <MifareClassicAppProcess+0xc26>
    786c:	8a e3       	ldi	r24, 0x3A	; 58
    786e:	c8 2e       	mov	r12, r24
    7870:	d1 2c       	mov	r13, r1
    7872:	03 c0       	rjmp	.+6      	; 0x787a <MifareClassicAppProcess+0xc2c>
    7874:	b0 e3       	ldi	r27, 0x30	; 48
    7876:	cb 2e       	mov	r12, r27
    7878:	d1 2c       	mov	r13, r1
        		uint8_t Key[6];
        		uint8_t Uid[4];
        		uint8_t CardNonce[8];

        		/* Fix for MFClassic 4k cards */
        		if(Buffer[1] >= 128) {
    787a:	f8 01       	movw	r30, r16
    787c:	81 81       	ldd	r24, Z+1	; 0x01
    787e:	87 ff       	sbrs	r24, 7
    7880:	0c c0       	rjmp	.+24     	; 0x789a <MifareClassicAppProcess+0xc4c>
        			SectorStartAddress = (Buffer[1] & MEM_BIGSECTOR_ADDR_MASK) * MEM_BYTES_PER_BLOCK ;
    7882:	80 7f       	andi	r24, 0xF0	; 240
    7884:	f0 e1       	ldi	r31, 0x10	; 16
    7886:	8f 9f       	mul	r24, r31
    7888:	70 01       	movw	r14, r0
    788a:	11 24       	eor	r1, r1
        			KeyOffset += MEM_KEY_BIGSECTOR_OFFSET;
    788c:	80 ec       	ldi	r24, 0xC0	; 192
    788e:	c8 0e       	add	r12, r24
    7890:	d1 1c       	adc	r13, r1
        			AccessOffset += MEM_KEY_BIGSECTOR_OFFSET;
    7892:	a6 ef       	ldi	r26, 0xF6	; 246
    7894:	aa 2e       	mov	r10, r26
    7896:	b1 2c       	mov	r11, r1
    7898:	08 c0       	rjmp	.+16     	; 0x78aa <MifareClassicAppProcess+0xc5c>
        		} else {
        			SectorStartAddress = (Buffer[1] & MEM_SECTOR_ADDR_MASK) * MEM_BYTES_PER_BLOCK ;
    789a:	8c 7f       	andi	r24, 0xFC	; 252
    789c:	90 e1       	ldi	r25, 0x10	; 16
    789e:	89 9f       	mul	r24, r25
    78a0:	70 01       	movw	r14, r0
    78a2:	11 24       	eor	r1, r1
        } else if ( (Buffer[0] == CMD_AUTH_A) || (Buffer[0] == CMD_AUTH_B)) {
        	if (ISO14443ACheckCRCA(Buffer, CMD_AUTH_FRAME_SIZE)) {

        		//uint16_t SectorAddress = Buffer[1] & MEM_SECTOR_ADDR_MASK;
        		uint16_t KeyOffset = (Buffer[0] == CMD_AUTH_A ? MEM_KEY_A_OFFSET : MEM_KEY_B_OFFSET);
        		uint16_t AccessOffset = MEM_KEY_A_OFFSET + MEM_KEY_SIZE;
    78a4:	f6 e3       	ldi	r31, 0x36	; 54
    78a6:	af 2e       	mov	r10, r31
    78a8:	b1 2c       	mov	r11, r1
    78aa:	e0 91 6e 2f 	lds	r30, 0x2F6E
    78ae:	f0 91 6f 2f 	lds	r31, 0x2F6F
    78b2:	42 e0       	ldi	r20, 0x02	; 2
    78b4:	b8 01       	movw	r22, r16
    78b6:	80 e9       	ldi	r24, 0x90	; 144
    78b8:	19 95       	eicall
        			SectorStartAddress = (Buffer[1] & MEM_SECTOR_ADDR_MASK) * MEM_BYTES_PER_BLOCK ;
        		}

        		LogEntry(LOG_INFO_APP_CMD_AUTH, Buffer, 2);
        		/* set KeyInUse for global use to keep info about authentication */
        		KeyInUse = Buffer[0] & 1;
    78ba:	f8 01       	movw	r30, r16
    78bc:	80 81       	ld	r24, Z
    78be:	81 70       	andi	r24, 0x01	; 1
    78c0:	80 93 d4 2c 	sts	0x2CD4, r24
        		CurrentAddress = SectorStartAddress / MEM_BYTES_PER_BLOCK;
    78c4:	c7 01       	movw	r24, r14
    78c6:	e4 e0       	ldi	r30, 0x04	; 4
    78c8:	96 95       	lsr	r25
    78ca:	87 95       	ror	r24
    78cc:	ea 95       	dec	r30
    78ce:	e1 f7       	brne	.-8      	; 0x78c8 <MifareClassicAppProcess+0xc7a>
    78d0:	80 93 d5 2c 	sts	0x2CD5, r24
        		//if (!AccessConditions[MEM_ACC_GPB_SIZE-1] ||(CurrentAddress != AccessAddress)) {
        		/* Get access conditions from the sector trailor */
        			MemoryReadBlock(AccessConditions, SectorStartAddress + AccessOffset, MEM_ACC_GPB_SIZE);
    78d4:	b7 01       	movw	r22, r14
    78d6:	6a 0d       	add	r22, r10
    78d8:	7b 1d       	adc	r23, r11
    78da:	44 e0       	ldi	r20, 0x04	; 4
    78dc:	50 e0       	ldi	r21, 0x00	; 0
    78de:	80 ec       	ldi	r24, 0xC0	; 192
    78e0:	9c e2       	ldi	r25, 0x2C	; 44
    78e2:	0e 94 a1 0f 	call	0x1f42	; 0x1f42 <MemoryReadBlock>
        			AccessAddress = CurrentAddress;
    78e6:	80 91 d5 2c 	lds	r24, 0x2CD5
    78ea:	80 93 bf 2c 	sts	0x2CBF, r24
        		//}


        		/* Generate a random nonce and read UID and key from memory */
        		RandomGetBuffer(CardNonce, sizeof(CardNonce));
    78ee:	68 e0       	ldi	r22, 0x08	; 8
    78f0:	ce 01       	movw	r24, r28
    78f2:	01 96       	adiw	r24, 0x01	; 1
    78f4:	0e 94 df 0e 	call	0x1dbe	; 0x1dbe <RandomGetBuffer>
        		if (ActiveConfiguration.UidSize == 7)
    78f8:	80 91 6c 2f 	lds	r24, 0x2F6C
        			MemoryReadBlock(Uid, MEM_UID_CL2_ADDRESS, MEM_UID_CL2_SIZE);
    78fc:	44 e0       	ldi	r20, 0x04	; 4
    78fe:	50 e0       	ldi	r21, 0x00	; 0
        		//}


        		/* Generate a random nonce and read UID and key from memory */
        		RandomGetBuffer(CardNonce, sizeof(CardNonce));
        		if (ActiveConfiguration.UidSize == 7)
    7900:	87 30       	cpi	r24, 0x07	; 7
    7902:	19 f4       	brne	.+6      	; 0x790a <MifareClassicAppProcess+0xcbc>
        			MemoryReadBlock(Uid, MEM_UID_CL2_ADDRESS, MEM_UID_CL2_SIZE);
    7904:	63 e0       	ldi	r22, 0x03	; 3
    7906:	70 e0       	ldi	r23, 0x00	; 0
    7908:	02 c0       	rjmp	.+4      	; 0x790e <MifareClassicAppProcess+0xcc0>
        		else
        			MemoryReadBlock(Uid, MEM_UID_CL1_ADDRESS, MEM_UID_CL1_SIZE);
    790a:	60 e0       	ldi	r22, 0x00	; 0
    790c:	70 e0       	ldi	r23, 0x00	; 0
    790e:	ce 01       	movw	r24, r28
    7910:	0f 96       	adiw	r24, 0x0f	; 15
    7912:	0e 94 a1 0f 	call	0x1f42	; 0x1f42 <MemoryReadBlock>
        		MemoryReadBlock(Key, SectorStartAddress + KeyOffset, MEM_KEY_SIZE);
    7916:	b7 01       	movw	r22, r14
    7918:	6c 0d       	add	r22, r12
    791a:	7d 1d       	adc	r23, r13
    791c:	46 e0       	ldi	r20, 0x06	; 6
    791e:	50 e0       	ldi	r21, 0x00	; 0
    7920:	ce 01       	movw	r24, r28
    7922:	09 96       	adiw	r24, 0x09	; 9
    7924:	0e 94 a1 0f 	call	0x1f42	; 0x1f42 <MemoryReadBlock>

        		/* Precalculate the reader response from card-nonce */
        		for (uint8_t i=0; i<sizeof(ReaderResponse); i++)
        			ReaderResponse[i] = CardNonce[i];
    7928:	89 81       	ldd	r24, Y+1	; 0x01
    792a:	80 93 d6 2c 	sts	0x2CD6, r24
    792e:	8a 81       	ldd	r24, Y+2	; 0x02
    7930:	80 93 d7 2c 	sts	0x2CD7, r24
    7934:	8b 81       	ldd	r24, Y+3	; 0x03
    7936:	80 93 d8 2c 	sts	0x2CD8, r24
    793a:	8c 81       	ldd	r24, Y+4	; 0x04
    793c:	80 93 d9 2c 	sts	0x2CD9, r24

        		Crypto1PRNG(ReaderResponse, 64);
    7940:	60 e4       	ldi	r22, 0x40	; 64
    7942:	86 ed       	ldi	r24, 0xD6	; 214
    7944:	9c e2       	ldi	r25, 0x2C	; 44
    7946:	0e 94 b0 4a 	call	0x9560	; 0x9560 <Crypto1PRNG>

        		/* Precalculate our response from the reader response */
        		for (uint8_t i=0; i<sizeof(CardResponse); i++)
        			CardResponse[i] = ReaderResponse[i];
    794a:	80 91 d6 2c 	lds	r24, 0x2CD6
    794e:	80 93 da 2c 	sts	0x2CDA, r24
    7952:	80 91 d7 2c 	lds	r24, 0x2CD7
    7956:	80 93 db 2c 	sts	0x2CDB, r24
    795a:	80 91 d8 2c 	lds	r24, 0x2CD8
    795e:	80 93 dc 2c 	sts	0x2CDC, r24
    7962:	80 91 d9 2c 	lds	r24, 0x2CD9
    7966:	80 93 dd 2c 	sts	0x2CDD, r24

        		Crypto1PRNG(CardResponse, 32);
    796a:	60 e2       	ldi	r22, 0x20	; 32
    796c:	8a ed       	ldi	r24, 0xDA	; 218
    796e:	9c e2       	ldi	r25, 0x2C	; 44
    7970:	0e 94 b0 4a 	call	0x9560	; 0x9560 <Crypto1PRNG>

        		/* Respond with the random card nonce and expect further authentication
        		 * form the reader in the next frame. */
        		State = STATE_AUTHING;
    7974:	87 e0       	ldi	r24, 0x07	; 7
    7976:	80 93 de 2c 	sts	0x2CDE, r24

        		/* use unencrypted card nonce */
        		Buffer[0] = CardNonce[0];
    797a:	89 81       	ldd	r24, Y+1	; 0x01
    797c:	f8 01       	movw	r30, r16
    797e:	80 83       	st	Z, r24
        		Buffer[1] = CardNonce[1];
    7980:	8a 81       	ldd	r24, Y+2	; 0x02
    7982:	81 83       	std	Z+1, r24	; 0x01
        		Buffer[2] = CardNonce[2];
    7984:	8b 81       	ldd	r24, Y+3	; 0x03
    7986:	82 83       	std	Z+2, r24	; 0x02
        		Buffer[3] = CardNonce[3];
    7988:	8c 81       	ldd	r24, Y+4	; 0x04
    798a:	83 83       	std	Z+3, r24	; 0x03

        		/* Setup crypto1 cipher. Discard in-place encrypted CardNonce. */
        		Crypto1Setup(Key, Uid, CardNonce);
    798c:	ae 01       	movw	r20, r28
    798e:	4f 5f       	subi	r20, 0xFF	; 255
    7990:	5f 4f       	sbci	r21, 0xFF	; 255
    7992:	be 01       	movw	r22, r28
    7994:	61 5f       	subi	r22, 0xF1	; 241
    7996:	7f 4f       	sbci	r23, 0xFF	; 255
    7998:	ce 01       	movw	r24, r28
    799a:	09 96       	adiw	r24, 0x09	; 9
    799c:	f0 d0       	rcall	.+480    	; 0x7b7e <Crypto1Setup>

        		return CMD_AUTH_RB_FRAME_SIZE * BITS_PER_BYTE;
    799e:	80 e2       	ldi	r24, 0x20	; 32
    79a0:	5f cf       	rjmp	.-322    	; 0x7860 <MifareClassicAppProcess+0xc12>
	    return ISO14443A_APP_NO_RESPONSE;
            } else {
                Buffer[0] = NAK_CRC_ERROR;
                return ACK_NAK_FRAME_SIZE;
            }
        } else if (  (Buffer[0] == CMD_READ) || (Buffer[0] == CMD_WRITE) || (Buffer[0] == CMD_DECREMENT)
    79a2:	80 33       	cpi	r24, 0x30	; 48
    79a4:	39 f0       	breq	.+14     	; 0x79b4 <MifareClassicAppProcess+0xd66>
    79a6:	98 2f       	mov	r25, r24
    79a8:	9f 7e       	andi	r25, 0xEF	; 239
    79aa:	90 3a       	cpi	r25, 0xA0	; 160
    79ac:	19 f0       	breq	.+6      	; 0x79b4 <MifareClassicAppProcess+0xd66>
    79ae:	80 5c       	subi	r24, 0xC0	; 192
    79b0:	83 30       	cpi	r24, 0x03	; 3
    79b2:	78 f4       	brcc	.+30     	; 0x79d2 <MifareClassicAppProcess+0xd84>
                  || (Buffer[0] == CMD_INCREMENT) || (Buffer[0] == CMD_RESTORE) || (Buffer[0] == CMD_TRANSFER) ) {
            State = STATE_IDLE;
    79b4:	81 e0       	ldi	r24, 0x01	; 1
    79b6:	80 93 de 2c 	sts	0x2CDE, r24
            Buffer[0] = NAK_NOT_AUTHED;
    79ba:	84 e0       	ldi	r24, 0x04	; 4
    79bc:	f8 01       	movw	r30, r16
    79be:	80 83       	st	Z, r24
    79c0:	e0 91 6e 2f 	lds	r30, 0x2F6E
    79c4:	f0 91 6f 2f 	lds	r31, 0x2F6F
    79c8:	40 e0       	ldi	r20, 0x00	; 0
    79ca:	60 e0       	ldi	r22, 0x00	; 0
    79cc:	70 e0       	ldi	r23, 0x00	; 0
    79ce:	82 ec       	ldi	r24, 0xC2	; 194
    79d0:	83 cb       	rjmp	.-2298   	; 0x70d8 <MifareClassicAppProcess+0x48a>
    79d2:	e0 91 6e 2f 	lds	r30, 0x2F6E
    79d6:	f0 91 6f 2f 	lds	r31, 0x2F6F
    79da:	40 e0       	ldi	r20, 0x00	; 0
    79dc:	d6 cc       	rjmp	.-1620   	; 0x738a <MifareClassicAppProcess+0x73c>
                ValueFromBlock(&BlockValue, BlockBuffer);

                if (State == STATE_DECREMENT) {
                	LogEntry(LOG_INFO_APP_CMD_DEC, Buffer, MEM_VALUE_SIZE + ISO14443A_CRCA_SIZE);
                    BlockValue -= ParamValue;
                } else if (State == STATE_INCREMENT) {
    79de:	8a 30       	cpi	r24, 0x0A	; 10
    79e0:	69 f4       	brne	.+26     	; 0x79fc <MifareClassicAppProcess+0xdae>
    79e2:	e0 91 6e 2f 	lds	r30, 0x2F6E
    79e6:	f0 91 6f 2f 	lds	r31, 0x2F6F
    79ea:	46 e0       	ldi	r20, 0x06	; 6
    79ec:	b8 01       	movw	r22, r16
    79ee:	84 e8       	ldi	r24, 0x84	; 132
    79f0:	19 95       	eicall
                	LogEntry(LOG_INFO_APP_CMD_INC, Buffer, MEM_VALUE_SIZE + ISO14443A_CRCA_SIZE);
                    BlockValue += ParamValue;
    79f2:	c8 0c       	add	r12, r8
    79f4:	d9 1c       	adc	r13, r9
    79f6:	ea 1c       	adc	r14, r10
    79f8:	fb 1c       	adc	r15, r11
    79fa:	7e cd       	rjmp	.-1284   	; 0x74f8 <MifareClassicAppProcess+0x8aa>
                } else if (State == STATE_RESTORE) {
    79fc:	8c 30       	cpi	r24, 0x0C	; 12
    79fe:	09 f0       	breq	.+2      	; 0x7a02 <MifareClassicAppProcess+0xdb4>
    7a00:	7b cd       	rjmp	.-1290   	; 0x74f8 <MifareClassicAppProcess+0x8aa>
    7a02:	e0 91 6e 2f 	lds	r30, 0x2F6E
    7a06:	f0 91 6f 2f 	lds	r31, 0x2F6F
    7a0a:	46 e0       	ldi	r20, 0x06	; 6
    7a0c:	b8 01       	movw	r22, r16
    7a0e:	87 e8       	ldi	r24, 0x87	; 135
    7a10:	19 95       	eicall
    7a12:	72 cd       	rjmp	.-1308   	; 0x74f8 <MifareClassicAppProcess+0x8aa>
                State = STATE_AUTHED_IDLE;
                /* No ACK response on value commands part 2 */
                return ISO14443A_APP_NO_RESPONSE;
            } else {
                /* Not sure if this is the correct error code.. */
                Buffer[0] = NAK_OTHER_ERROR ^ Crypto1Nibble();
    7a14:	0e 94 83 45 	call	0x8b06	; 0x8b06 <Crypto1Nibble>
    7a18:	96 e0       	ldi	r25, 0x06	; 6
    7a1a:	f6 cc       	rjmp	.-1556   	; 0x7408 <MifareClassicAppProcess+0x7ba>
        break;
    }

    /* No response has been sent, when we reach here */
    return ISO14443A_APP_NO_RESPONSE;
}
    7a1c:	63 96       	adiw	r28, 0x13	; 19
    7a1e:	cd bf       	out	0x3d, r28	; 61
    7a20:	de bf       	out	0x3e, r29	; 62
    7a22:	df 91       	pop	r29
    7a24:	cf 91       	pop	r28
    7a26:	1f 91       	pop	r17
    7a28:	0f 91       	pop	r16
    7a2a:	ff 90       	pop	r15
    7a2c:	ef 90       	pop	r14
    7a2e:	df 90       	pop	r13
    7a30:	cf 90       	pop	r12
    7a32:	bf 90       	pop	r11
    7a34:	af 90       	pop	r10
    7a36:	9f 90       	pop	r9
    7a38:	8f 90       	pop	r8
    7a3a:	08 95       	ret

00007a3c <MifareClassicGetUid>:

void MifareClassicGetUid(ConfigurationUidType Uid)
{
    7a3c:	cf 93       	push	r28
    7a3e:	df 93       	push	r29
	if (ActiveConfiguration.UidSize == 7) {
    7a40:	20 91 6c 2f 	lds	r18, 0x2F6C
    7a44:	27 30       	cpi	r18, 0x07	; 7
    7a46:	71 f4       	brne	.+28     	; 0x7a64 <MifareClassicGetUid+0x28>
    7a48:	ec 01       	movw	r28, r24
		//Uid[0]=0x88;
		MemoryReadBlock(&Uid[0], MEM_UID_CL1_ADDRESS, MEM_UID_CL1_SIZE-1);
    7a4a:	43 e0       	ldi	r20, 0x03	; 3
    7a4c:	50 e0       	ldi	r21, 0x00	; 0
    7a4e:	60 e0       	ldi	r22, 0x00	; 0
    7a50:	70 e0       	ldi	r23, 0x00	; 0
    7a52:	0e 94 a1 0f 	call	0x1f42	; 0x1f42 <MemoryReadBlock>
		MemoryReadBlock(&Uid[3], MEM_UID_CL2_ADDRESS, MEM_UID_CL2_SIZE);
    7a56:	44 e0       	ldi	r20, 0x04	; 4
    7a58:	50 e0       	ldi	r21, 0x00	; 0
    7a5a:	63 e0       	ldi	r22, 0x03	; 3
    7a5c:	70 e0       	ldi	r23, 0x00	; 0
    7a5e:	ce 01       	movw	r24, r28
    7a60:	03 96       	adiw	r24, 0x03	; 3
    7a62:	04 c0       	rjmp	.+8      	; 0x7a6c <MifareClassicGetUid+0x30>
	}
	else
	MemoryReadBlock(Uid, MEM_UID_CL1_ADDRESS, MEM_UID_CL1_SIZE);
    7a64:	44 e0       	ldi	r20, 0x04	; 4
    7a66:	50 e0       	ldi	r21, 0x00	; 0
    7a68:	60 e0       	ldi	r22, 0x00	; 0
    7a6a:	70 e0       	ldi	r23, 0x00	; 0
}
    7a6c:	df 91       	pop	r29
    7a6e:	cf 91       	pop	r28
		//Uid[0]=0x88;
		MemoryReadBlock(&Uid[0], MEM_UID_CL1_ADDRESS, MEM_UID_CL1_SIZE-1);
		MemoryReadBlock(&Uid[3], MEM_UID_CL2_ADDRESS, MEM_UID_CL2_SIZE);
	}
	else
	MemoryReadBlock(Uid, MEM_UID_CL1_ADDRESS, MEM_UID_CL1_SIZE);
    7a70:	0c 94 a1 0f 	jmp	0x1f42	; 0x1f42 <MemoryReadBlock>

00007a74 <MifareClassicSetUid>:
}

void MifareClassicSetUid(ConfigurationUidType Uid)
{
    7a74:	cf 93       	push	r28
    7a76:	df 93       	push	r29
    7a78:	1f 92       	push	r1
    7a7a:	cd b7       	in	r28, 0x3d	; 61
    7a7c:	de b7       	in	r29, 0x3e	; 62
    if (ActiveConfiguration.UidSize == 7) {
    7a7e:	20 91 6c 2f 	lds	r18, 0x2F6C
    7a82:	27 30       	cpi	r18, 0x07	; 7
    7a84:	29 f4       	brne	.+10     	; 0x7a90 <MifareClassicSetUid+0x1c>
	    //Uid[0]=0x88;
	    MemoryWriteBlock(Uid, MEM_UID_CL1_ADDRESS, ActiveConfiguration.UidSize);
    7a86:	47 e0       	ldi	r20, 0x07	; 7
    7a88:	50 e0       	ldi	r21, 0x00	; 0
    7a8a:	60 e0       	ldi	r22, 0x00	; 0
    7a8c:	70 e0       	ldi	r23, 0x00	; 0
    7a8e:	15 c0       	rjmp	.+42     	; 0x7aba <MifareClassicSetUid+0x46>
    }
    else {
	    uint8_t BCC =  Uid[0] ^ Uid[1] ^ Uid[2] ^ Uid[3];
    7a90:	fc 01       	movw	r30, r24
    7a92:	31 81       	ldd	r19, Z+1	; 0x01
    7a94:	20 81       	ld	r18, Z
    7a96:	23 27       	eor	r18, r19
    7a98:	32 81       	ldd	r19, Z+2	; 0x02
    7a9a:	23 27       	eor	r18, r19
    7a9c:	33 81       	ldd	r19, Z+3	; 0x03
    7a9e:	23 27       	eor	r18, r19
    7aa0:	29 83       	std	Y+1, r18	; 0x01

	    MemoryWriteBlock(Uid, MEM_UID_CL1_ADDRESS, MEM_UID_CL1_SIZE);
    7aa2:	44 e0       	ldi	r20, 0x04	; 4
    7aa4:	50 e0       	ldi	r21, 0x00	; 0
    7aa6:	60 e0       	ldi	r22, 0x00	; 0
    7aa8:	70 e0       	ldi	r23, 0x00	; 0
    7aaa:	0e 94 ef 0f 	call	0x1fde	; 0x1fde <MemoryWriteBlock>
	    MemoryWriteBlock(&BCC, MEM_UID_BCC1_ADDRESS, ISO14443A_CL_BCC_SIZE);
    7aae:	41 e0       	ldi	r20, 0x01	; 1
    7ab0:	50 e0       	ldi	r21, 0x00	; 0
    7ab2:	64 e0       	ldi	r22, 0x04	; 4
    7ab4:	70 e0       	ldi	r23, 0x00	; 0
    7ab6:	ce 01       	movw	r24, r28
    7ab8:	01 96       	adiw	r24, 0x01	; 1
    7aba:	0e 94 ef 0f 	call	0x1fde	; 0x1fde <MemoryWriteBlock>
    }
}
    7abe:	0f 90       	pop	r0
    7ac0:	df 91       	pop	r29
    7ac2:	cf 91       	pop	r28
    7ac4:	08 95       	ret

00007ac6 <ISO14443AAppendCRCA>:
#ifdef USE_HW_CRC
void ISO14443AAppendCRCA(void* Buffer, uint16_t ByteCount)
{
    uint8_t* DataPtr = (uint8_t*) Buffer;

    CRC.CTRL = CRC_RESET0_bm;
    7ac6:	20 e4       	ldi	r18, 0x40	; 64
    7ac8:	20 93 d0 00 	sts	0x00D0, r18
    CRC.CHECKSUM1 = (CRC_INIT_R >> 8) & 0xFF;
    7acc:	26 ec       	ldi	r18, 0xC6	; 198
    7ace:	20 93 d5 00 	sts	0x00D5, r18
    CRC.CHECKSUM0 = (CRC_INIT_R >> 0) & 0xFF;
    7ad2:	20 93 d4 00 	sts	0x00D4, r18
    CRC.CTRL = CRC_SOURCE_IO_gc;
    7ad6:	21 e0       	ldi	r18, 0x01	; 1
    7ad8:	20 93 d0 00 	sts	0x00D0, r18
    7adc:	dc 01       	movw	r26, r24
    7ade:	68 0f       	add	r22, r24
    7ae0:	79 1f       	adc	r23, r25

    while(ByteCount--) {
    7ae2:	a6 17       	cp	r26, r22
    7ae4:	b7 07       	cpc	r27, r23
    7ae6:	41 f0       	breq	.+16     	; 0x7af8 <ISO14443AAppendCRCA+0x32>
        uint8_t Byte = *DataPtr++;
    7ae8:	ed 91       	ld	r30, X+

INLINE uint8_t BitReverseByte(uint8_t Byte)
{
    extern const uint8_t PROGMEM BitReverseByteTable[];

    return pgm_read_byte(&BitReverseByteTable[Byte]);
    7aea:	f0 e0       	ldi	r31, 0x00	; 0
    7aec:	e6 54       	subi	r30, 0x46	; 70
    7aee:	f9 4f       	sbci	r31, 0xF9	; 249
    7af0:	e4 91       	lpm	r30, Z
        Byte = BitReverseByte(Byte);

        CRC.DATAIN = Byte;
    7af2:	e0 93 d3 00 	sts	0x00D3, r30
    7af6:	f5 cf       	rjmp	.-22     	; 0x7ae2 <ISO14443AAppendCRCA+0x1c>
    }

    DataPtr[0] = BitReverseByte(CRC.CHECKSUM1);
    7af8:	e0 91 d5 00 	lds	r30, 0x00D5
    7afc:	f0 e0       	ldi	r31, 0x00	; 0
    7afe:	e6 54       	subi	r30, 0x46	; 70
    7b00:	f9 4f       	sbci	r31, 0xF9	; 249
    7b02:	e4 91       	lpm	r30, Z
    7b04:	ec 93       	st	X, r30
    DataPtr[1] = BitReverseByte(CRC.CHECKSUM0);
    7b06:	e0 91 d4 00 	lds	r30, 0x00D4
    7b0a:	f0 e0       	ldi	r31, 0x00	; 0
    7b0c:	e6 54       	subi	r30, 0x46	; 70
    7b0e:	f9 4f       	sbci	r31, 0xF9	; 249
    7b10:	e4 91       	lpm	r30, Z
    7b12:	11 96       	adiw	r26, 0x01	; 1
    7b14:	ec 93       	st	X, r30

    CRC.CTRL = CRC_SOURCE_DISABLE_gc;
    7b16:	10 92 d0 00 	sts	0x00D0, r1
    7b1a:	08 95       	ret

00007b1c <ISO14443ACheckCRCA>:
#ifdef USE_HW_CRC
bool ISO14443ACheckCRCA(const void* Buffer, uint16_t ByteCount)
{
    const uint8_t* DataPtr = (const uint8_t*) Buffer;

    CRC.CTRL = CRC_RESET0_bm;
    7b1c:	20 e4       	ldi	r18, 0x40	; 64
    7b1e:	20 93 d0 00 	sts	0x00D0, r18
    CRC.CHECKSUM1 = (CRC_INIT_R >> 8) & 0xFF;
    7b22:	26 ec       	ldi	r18, 0xC6	; 198
    7b24:	20 93 d5 00 	sts	0x00D5, r18
    CRC.CHECKSUM0 = (CRC_INIT_R >> 0) & 0xFF;
    7b28:	20 93 d4 00 	sts	0x00D4, r18
    CRC.CTRL = CRC_SOURCE_IO_gc;
    7b2c:	21 e0       	ldi	r18, 0x01	; 1
    7b2e:	20 93 d0 00 	sts	0x00D0, r18
    7b32:	dc 01       	movw	r26, r24
    7b34:	68 0f       	add	r22, r24
    7b36:	79 1f       	adc	r23, r25

    while(ByteCount--) {
    7b38:	a6 17       	cp	r26, r22
    7b3a:	b7 07       	cpc	r27, r23
    7b3c:	41 f0       	breq	.+16     	; 0x7b4e <ISO14443ACheckCRCA+0x32>
        uint8_t Byte = *DataPtr++;
    7b3e:	ed 91       	ld	r30, X+
    7b40:	f0 e0       	ldi	r31, 0x00	; 0
    7b42:	e6 54       	subi	r30, 0x46	; 70
    7b44:	f9 4f       	sbci	r31, 0xF9	; 249
    7b46:	e4 91       	lpm	r30, Z
        Byte = BitReverseByte(Byte);

        CRC.DATAIN = Byte;
    7b48:	e0 93 d3 00 	sts	0x00D3, r30
    7b4c:	f5 cf       	rjmp	.-22     	; 0x7b38 <ISO14443ACheckCRCA+0x1c>
    }

    bool Result = (DataPtr[0] == BitReverseByte(CRC.CHECKSUM1)) && (DataPtr[1] == BitReverseByte(CRC.CHECKSUM0));
    7b4e:	e0 91 d5 00 	lds	r30, 0x00D5
    7b52:	f0 e0       	ldi	r31, 0x00	; 0
    7b54:	e6 54       	subi	r30, 0x46	; 70
    7b56:	f9 4f       	sbci	r31, 0xF9	; 249
    7b58:	e4 91       	lpm	r30, Z
    7b5a:	8c 91       	ld	r24, X
    7b5c:	8e 13       	cpse	r24, r30
    7b5e:	0a c0       	rjmp	.+20     	; 0x7b74 <ISO14443ACheckCRCA+0x58>
    7b60:	e0 91 d4 00 	lds	r30, 0x00D4
    7b64:	f0 e0       	ldi	r31, 0x00	; 0
    7b66:	e6 54       	subi	r30, 0x46	; 70
    7b68:	f9 4f       	sbci	r31, 0xF9	; 249
    7b6a:	e4 91       	lpm	r30, Z
    7b6c:	81 e0       	ldi	r24, 0x01	; 1
    7b6e:	11 96       	adiw	r26, 0x01	; 1
    7b70:	9c 91       	ld	r25, X
    7b72:	9e 13       	cpse	r25, r30
    7b74:	80 e0       	ldi	r24, 0x00	; 0

    CRC.CTRL = CRC_SOURCE_DISABLE_gc;
    7b76:	10 92 d0 00 	sts	0x00D0, r1

    return Result;
}
    7b7a:	81 70       	andi	r24, 0x01	; 1
    7b7c:	08 95       	ret

00007b7e <Crypto1Setup>:
/* Setup LFSR split into odd and even states, feed in uid ^nonce */
/* Version for first (not nested) authentication.                 */
void Crypto1Setup(uint8_t Key[6], 
              uint8_t Uid[4], 
              uint8_t CardNonce[4])
{
    7b7e:	8f 92       	push	r8
    7b80:	9f 92       	push	r9
    7b82:	af 92       	push	r10
    7b84:	bf 92       	push	r11
    7b86:	cf 92       	push	r12
    7b88:	df 92       	push	r13
    7b8a:	ef 92       	push	r14
    7b8c:	ff 92       	push	r15
    7b8e:	0f 93       	push	r16
    7b90:	1f 93       	push	r17
    7b92:	cf 93       	push	r28
    7b94:	df 93       	push	r29
    7b96:	dc 01       	movw	r26, r24
    uint8_t Feedback;
    uint8_t Out;
    uint8_t In;
    uint8_t ByteCount;

    KeyStream = *Key++;
    7b98:	8c 91       	ld	r24, X
    SPLIT_BYTE(Even0, Odd0, KeyStream);
    7b9a:	10 e0       	ldi	r17, 0x00	; 0
    7b9c:	e0 e0       	ldi	r30, 0x00	; 0
    7b9e:	86 95       	lsr	r24
    7ba0:	17 95       	ror	r17
    7ba2:	86 95       	lsr	r24
    7ba4:	e7 95       	ror	r30
    7ba6:	86 95       	lsr	r24
    7ba8:	17 95       	ror	r17
    7baa:	86 95       	lsr	r24
    7bac:	e7 95       	ror	r30
    7bae:	86 95       	lsr	r24
    7bb0:	17 95       	ror	r17
    7bb2:	86 95       	lsr	r24
    7bb4:	e7 95       	ror	r30
    7bb6:	86 95       	lsr	r24
    7bb8:	17 95       	ror	r17
    7bba:	86 95       	lsr	r24
    7bbc:	e7 95       	ror	r30
    KeyStream = *Key++;
    7bbe:	11 96       	adiw	r26, 0x01	; 1
    7bc0:	8c 91       	ld	r24, X
    7bc2:	11 97       	sbiw	r26, 0x01	; 1
    SPLIT_BYTE(Even0, Odd0, KeyStream);
    7bc4:	86 95       	lsr	r24
    7bc6:	17 95       	ror	r17
    7bc8:	86 95       	lsr	r24
    7bca:	e7 95       	ror	r30
    7bcc:	86 95       	lsr	r24
    7bce:	17 95       	ror	r17
    7bd0:	86 95       	lsr	r24
    7bd2:	e7 95       	ror	r30
    7bd4:	86 95       	lsr	r24
    7bd6:	17 95       	ror	r17
    7bd8:	86 95       	lsr	r24
    7bda:	e7 95       	ror	r30
    7bdc:	86 95       	lsr	r24
    7bde:	17 95       	ror	r17
    7be0:	86 95       	lsr	r24
    7be2:	e7 95       	ror	r30
    KeyStream = *Key++;
    7be4:	12 96       	adiw	r26, 0x02	; 2
    7be6:	8c 91       	ld	r24, X
    7be8:	12 97       	sbiw	r26, 0x02	; 2
    SPLIT_BYTE(Even1, Odd1, KeyStream);
    7bea:	f0 e0       	ldi	r31, 0x00	; 0
    7bec:	30 e0       	ldi	r19, 0x00	; 0
    7bee:	86 95       	lsr	r24
    7bf0:	f7 95       	ror	r31
    7bf2:	86 95       	lsr	r24
    7bf4:	37 95       	ror	r19
    7bf6:	86 95       	lsr	r24
    7bf8:	f7 95       	ror	r31
    7bfa:	86 95       	lsr	r24
    7bfc:	37 95       	ror	r19
    7bfe:	86 95       	lsr	r24
    7c00:	f7 95       	ror	r31
    7c02:	86 95       	lsr	r24
    7c04:	37 95       	ror	r19
    7c06:	86 95       	lsr	r24
    7c08:	f7 95       	ror	r31
    7c0a:	86 95       	lsr	r24
    7c0c:	37 95       	ror	r19
    KeyStream = *Key++;
    7c0e:	13 96       	adiw	r26, 0x03	; 3
    7c10:	8c 91       	ld	r24, X
    7c12:	13 97       	sbiw	r26, 0x03	; 3
    SPLIT_BYTE(Even1, Odd1, KeyStream);
    7c14:	86 95       	lsr	r24
    7c16:	f7 95       	ror	r31
    7c18:	86 95       	lsr	r24
    7c1a:	37 95       	ror	r19
    7c1c:	86 95       	lsr	r24
    7c1e:	f7 95       	ror	r31
    7c20:	86 95       	lsr	r24
    7c22:	37 95       	ror	r19
    7c24:	86 95       	lsr	r24
    7c26:	f7 95       	ror	r31
    7c28:	86 95       	lsr	r24
    7c2a:	37 95       	ror	r19
    7c2c:	86 95       	lsr	r24
    7c2e:	f7 95       	ror	r31
    7c30:	86 95       	lsr	r24
    7c32:	37 95       	ror	r19
    KeyStream = *Key++;
    7c34:	14 96       	adiw	r26, 0x04	; 4
    7c36:	8c 91       	ld	r24, X
    7c38:	14 97       	sbiw	r26, 0x04	; 4
    SPLIT_BYTE(Even2, Odd2, KeyStream);
    7c3a:	90 e0       	ldi	r25, 0x00	; 0
    7c3c:	20 e0       	ldi	r18, 0x00	; 0
    7c3e:	86 95       	lsr	r24
    7c40:	97 95       	ror	r25
    7c42:	86 95       	lsr	r24
    7c44:	27 95       	ror	r18
    7c46:	86 95       	lsr	r24
    7c48:	97 95       	ror	r25
    7c4a:	86 95       	lsr	r24
    7c4c:	27 95       	ror	r18
    7c4e:	86 95       	lsr	r24
    7c50:	97 95       	ror	r25
    7c52:	86 95       	lsr	r24
    7c54:	27 95       	ror	r18
    7c56:	86 95       	lsr	r24
    7c58:	97 95       	ror	r25
    7c5a:	86 95       	lsr	r24
    7c5c:	27 95       	ror	r18
    KeyStream = *Key++;
    7c5e:	15 96       	adiw	r26, 0x05	; 5
    7c60:	8c 91       	ld	r24, X
    SPLIT_BYTE(Even2, Odd2, KeyStream);
    7c62:	86 95       	lsr	r24
    7c64:	97 95       	ror	r25
    7c66:	86 95       	lsr	r24
    7c68:	27 95       	ror	r18
    7c6a:	86 95       	lsr	r24
    7c6c:	97 95       	ror	r25
    7c6e:	86 95       	lsr	r24
    7c70:	27 95       	ror	r18
    7c72:	86 95       	lsr	r24
    7c74:	97 95       	ror	r25
    7c76:	86 95       	lsr	r24
    7c78:	27 95       	ror	r18
    7c7a:	86 95       	lsr	r24
    7c7c:	97 95       	ror	r25
    7c7e:	86 95       	lsr	r24
    7c80:	27 95       	ror	r18
    7c82:	5b 01       	movw	r10, r22
    7c84:	da 01       	movw	r26, r20
    7c86:	4a 01       	movw	r8, r20
    7c88:	44 e0       	ldi	r20, 0x04	; 4
    7c8a:	84 0e       	add	r8, r20
    7c8c:	91 1c       	adc	r9, r1

    for ( ByteCount = 0; ByteCount < NONCE_SIZE; ByteCount++)
    {
        In = *CardNonce ^ *Uid++;
    7c8e:	6c 91       	ld	r22, X
    7c90:	e5 01       	movw	r28, r10
    7c92:	79 91       	ld	r23, Y+
    7c94:	5e 01       	movw	r10, r28
    7c96:	76 27       	eor	r23, r22

        Out = CRYPTO1_FILTER_OUTPUT_B0_24(Odd0, Odd1, Odd2);
    7c98:	c3 2e       	mov	r12, r19
    7c9a:	d1 2c       	mov	r13, r1
    7c9c:	a6 01       	movw	r20, r12
    7c9e:	48 54       	subi	r20, 0x48	; 72
    7ca0:	5e 4d       	sbci	r21, 0xDE	; 222
    7ca2:	ee 2e       	mov	r14, r30
    7ca4:	f1 2c       	mov	r15, r1
    7ca6:	e7 01       	movw	r28, r14
    7ca8:	c8 54       	subi	r28, 0x48	; 72
    7caa:	df 4d       	sbci	r29, 0xDF	; 223
    7cac:	7e 01       	movw	r14, r28
    7cae:	ea 01       	movw	r28, r20
    7cb0:	d8 80       	ld	r13, Y
    7cb2:	e7 01       	movw	r28, r14
    7cb4:	08 81       	ld	r16, Y
    7cb6:	ed 2c       	mov	r14, r13
    7cb8:	e0 2a       	or	r14, r16
    7cba:	c2 2e       	mov	r12, r18
    7cbc:	d1 2c       	mov	r13, r1
    7cbe:	a6 01       	movw	r20, r12
    7cc0:	48 54       	subi	r20, 0x48	; 72
    7cc2:	5d 4d       	sbci	r21, 0xDD	; 221
    7cc4:	ea 01       	movw	r28, r20
    7cc6:	08 81       	ld	r16, Y
    7cc8:	e0 2a       	or	r14, r16
    7cca:	f1 2c       	mov	r15, r1
    7ccc:	a7 01       	movw	r20, r14
    7cce:	48 56       	subi	r20, 0x68	; 104
    7cd0:	5f 4d       	sbci	r21, 0xDF	; 223
    7cd2:	ea 01       	movw	r28, r20
    7cd4:	08 81       	ld	r16, Y
        SHIFT8(KeyStream, Out);
    7cd6:	06 95       	lsr	r16
    7cd8:	87 95       	ror	r24
    uint8_t Feedback;

    /* Calculate feedback according to LFSR taps. XOR all state bytes
     * into a single bit. */
    Feedback  = E0 & (uint8_t) (LFSR_MASK_EVEN );
    Feedback ^= E1 & (uint8_t) (LFSR_MASK_EVEN >> 8);
    7cda:	df 2f       	mov	r29, r31
    7cdc:	d0 71       	andi	r29, 0x10	; 16
    7cde:	fd 2e       	mov	r15, r29
{
    uint8_t Feedback;

    /* Calculate feedback according to LFSR taps. XOR all state bytes
     * into a single bit. */
    Feedback  = E0 & (uint8_t) (LFSR_MASK_EVEN );
    7ce0:	01 2f       	mov	r16, r17
    7ce2:	01 7e       	andi	r16, 0xE1	; 225
    Feedback ^= E1 & (uint8_t) (LFSR_MASK_EVEN >> 8);
    7ce4:	f0 26       	eor	r15, r16
    Feedback ^= E2 & (uint8_t) (LFSR_MASK_EVEN >> 16);
    7ce6:	09 2f       	mov	r16, r25
    7ce8:	00 72       	andi	r16, 0x20	; 32
    7cea:	f0 26       	eor	r15, r16

    Feedback ^= O0 & (uint8_t) (LFSR_MASK_ODD );
    7cec:	0e 2f       	mov	r16, r30
    7cee:	04 79       	andi	r16, 0x94	; 148
    7cf0:	f0 26       	eor	r15, r16
    Feedback ^= O1 & (uint8_t) (LFSR_MASK_ODD >> 8);
    7cf2:	03 2f       	mov	r16, r19
    7cf4:	03 77       	andi	r16, 0x73	; 115
    7cf6:	f0 26       	eor	r15, r16
    Feedback ^= O2 & (uint8_t) (LFSR_MASK_ODD >> 16);
    7cf8:	02 2f       	mov	r16, r18
    7cfa:	0a 73       	andi	r16, 0x3A	; 58
    7cfc:	f0 26       	eor	r15, r16

    /* fold 8 into 1 bit */
    Feedback ^= ((Feedback >> 4)|(Feedback << 4)); /* Compiler uses a swap for this (fast!) */
    7cfe:	0f 2d       	mov	r16, r15
    7d00:	02 95       	swap	r16
    7d02:	f0 26       	eor	r15, r16
    Feedback ^= Feedback >> 2;
    7d04:	0f 2d       	mov	r16, r15
    7d06:	06 95       	lsr	r16
    7d08:	06 95       	lsr	r16
    7d0a:	f0 26       	eor	r15, r16
    7d0c:	0f 2d       	mov	r16, r15
    7d0e:	07 27       	eor	r16, r23
    Feedback ^= Feedback >> 1;
    7d10:	f6 94       	lsr	r15
        In = *CardNonce ^ *Uid++;

        Out = CRYPTO1_FILTER_OUTPUT_B0_24(Odd0, Odd1, Odd2);
        SHIFT8(KeyStream, Out);
        Feedback  = Crypto1LFSRbyteFeedback(Even0,Even1,Even2,Odd0,Odd1,Odd2);
        Feedback ^= In;
    7d12:	0f 25       	eor	r16, r15
        SHIFT24(Even0,Even1,Even2, Feedback);
    7d14:	06 95       	lsr	r16
    7d16:	97 95       	ror	r25
    7d18:	f7 95       	ror	r31
    7d1a:	17 95       	ror	r17

        /* Bit 1 */
        In >>= 1;
    7d1c:	76 95       	lsr	r23
        /* remember Odd/Even swap has been omitted! */
        Out = CRYPTO1_FILTER_OUTPUT_B0_24(Even0,Even1,Even2);
    7d1e:	cf 2e       	mov	r12, r31
    7d20:	d1 2c       	mov	r13, r1
    7d22:	a6 01       	movw	r20, r12
    7d24:	48 54       	subi	r20, 0x48	; 72
    7d26:	5e 4d       	sbci	r21, 0xDE	; 222
    7d28:	e1 2e       	mov	r14, r17
    7d2a:	f1 2c       	mov	r15, r1
    7d2c:	e7 01       	movw	r28, r14
    7d2e:	c8 54       	subi	r28, 0x48	; 72
    7d30:	df 4d       	sbci	r29, 0xDF	; 223
    7d32:	7e 01       	movw	r14, r28
    7d34:	ea 01       	movw	r28, r20
    7d36:	d8 80       	ld	r13, Y
    7d38:	e7 01       	movw	r28, r14
    7d3a:	08 81       	ld	r16, Y
    7d3c:	ed 2c       	mov	r14, r13
    7d3e:	e0 2a       	or	r14, r16
    7d40:	c9 2e       	mov	r12, r25
    7d42:	d1 2c       	mov	r13, r1
    7d44:	a6 01       	movw	r20, r12
    7d46:	48 54       	subi	r20, 0x48	; 72
    7d48:	5d 4d       	sbci	r21, 0xDD	; 221
    7d4a:	ea 01       	movw	r28, r20
    7d4c:	08 81       	ld	r16, Y
    7d4e:	e0 2a       	or	r14, r16
    7d50:	f1 2c       	mov	r15, r1
    7d52:	a7 01       	movw	r20, r14
    7d54:	48 56       	subi	r20, 0x68	; 104
    7d56:	5f 4d       	sbci	r21, 0xDF	; 223
    7d58:	ea 01       	movw	r28, r20
    7d5a:	08 81       	ld	r16, Y
        SHIFT8(KeyStream, Out);
    7d5c:	06 95       	lsr	r16
    7d5e:	87 95       	ror	r24
    uint8_t Feedback;

    /* Calculate feedback according to LFSR taps. XOR all state bytes
     * into a single bit. */
    Feedback  = E0 & (uint8_t) (LFSR_MASK_EVEN );
    Feedback ^= E1 & (uint8_t) (LFSR_MASK_EVEN >> 8);
    7d60:	d3 2f       	mov	r29, r19
    7d62:	d0 71       	andi	r29, 0x10	; 16
    7d64:	fd 2e       	mov	r15, r29
{
    uint8_t Feedback;

    /* Calculate feedback according to LFSR taps. XOR all state bytes
     * into a single bit. */
    Feedback  = E0 & (uint8_t) (LFSR_MASK_EVEN );
    7d66:	0e 2f       	mov	r16, r30
    7d68:	01 7e       	andi	r16, 0xE1	; 225
    Feedback ^= E1 & (uint8_t) (LFSR_MASK_EVEN >> 8);
    7d6a:	f0 26       	eor	r15, r16
    Feedback ^= E2 & (uint8_t) (LFSR_MASK_EVEN >> 16);
    7d6c:	02 2f       	mov	r16, r18
    7d6e:	00 72       	andi	r16, 0x20	; 32
    7d70:	f0 26       	eor	r15, r16

    Feedback ^= O0 & (uint8_t) (LFSR_MASK_ODD );
    7d72:	01 2f       	mov	r16, r17
    7d74:	04 79       	andi	r16, 0x94	; 148
    7d76:	f0 26       	eor	r15, r16
    Feedback ^= O1 & (uint8_t) (LFSR_MASK_ODD >> 8);
    7d78:	0f 2f       	mov	r16, r31
    7d7a:	03 77       	andi	r16, 0x73	; 115
    7d7c:	f0 26       	eor	r15, r16
    Feedback ^= O2 & (uint8_t) (LFSR_MASK_ODD >> 16);
    7d7e:	09 2f       	mov	r16, r25
    7d80:	0a 73       	andi	r16, 0x3A	; 58
    7d82:	f0 26       	eor	r15, r16

    /* fold 8 into 1 bit */
    Feedback ^= ((Feedback >> 4)|(Feedback << 4)); /* Compiler uses a swap for this (fast!) */
    7d84:	0f 2d       	mov	r16, r15
    7d86:	02 95       	swap	r16
    7d88:	f0 26       	eor	r15, r16
    Feedback ^= Feedback >> 2;
    7d8a:	0f 2d       	mov	r16, r15
    7d8c:	06 95       	lsr	r16
    7d8e:	06 95       	lsr	r16
    7d90:	f0 26       	eor	r15, r16
    7d92:	0f 2d       	mov	r16, r15
    7d94:	07 27       	eor	r16, r23
    Feedback ^= Feedback >> 1;
    7d96:	f6 94       	lsr	r15
        In >>= 1;
        /* remember Odd/Even swap has been omitted! */
        Out = CRYPTO1_FILTER_OUTPUT_B0_24(Even0,Even1,Even2);
        SHIFT8(KeyStream, Out);
        Feedback = Crypto1LFSRbyteFeedback(Odd0,Odd1,Odd2,Even0,Even1,Even2);
        Feedback ^= In;
    7d98:	0f 25       	eor	r16, r15
        SHIFT24(Odd0,Odd1,Odd2, Feedback);
    7d9a:	06 95       	lsr	r16
    7d9c:	27 95       	ror	r18
    7d9e:	37 95       	ror	r19
    7da0:	e7 95       	ror	r30

        /* Bit 2 */
        In >>= 1;
    7da2:	76 95       	lsr	r23
        Out = CRYPTO1_FILTER_OUTPUT_B0_24(Odd0, Odd1, Odd2);
    7da4:	c3 2e       	mov	r12, r19
    7da6:	d1 2c       	mov	r13, r1
    7da8:	a6 01       	movw	r20, r12
    7daa:	48 54       	subi	r20, 0x48	; 72
    7dac:	5e 4d       	sbci	r21, 0xDE	; 222
    7dae:	ee 2e       	mov	r14, r30
    7db0:	f1 2c       	mov	r15, r1
    7db2:	e7 01       	movw	r28, r14
    7db4:	c8 54       	subi	r28, 0x48	; 72
    7db6:	df 4d       	sbci	r29, 0xDF	; 223
    7db8:	7e 01       	movw	r14, r28
    7dba:	ea 01       	movw	r28, r20
    7dbc:	d8 80       	ld	r13, Y
    7dbe:	e7 01       	movw	r28, r14
    7dc0:	08 81       	ld	r16, Y
    7dc2:	ed 2c       	mov	r14, r13
    7dc4:	e0 2a       	or	r14, r16
    7dc6:	c2 2e       	mov	r12, r18
    7dc8:	d1 2c       	mov	r13, r1
    7dca:	a6 01       	movw	r20, r12
    7dcc:	48 54       	subi	r20, 0x48	; 72
    7dce:	5d 4d       	sbci	r21, 0xDD	; 221
    7dd0:	ea 01       	movw	r28, r20
    7dd2:	08 81       	ld	r16, Y
    7dd4:	e0 2a       	or	r14, r16
    7dd6:	f1 2c       	mov	r15, r1
    7dd8:	a7 01       	movw	r20, r14
    7dda:	48 56       	subi	r20, 0x68	; 104
    7ddc:	5f 4d       	sbci	r21, 0xDF	; 223
    7dde:	ea 01       	movw	r28, r20
    7de0:	08 81       	ld	r16, Y
        SHIFT8(KeyStream, Out);
    7de2:	06 95       	lsr	r16
    7de4:	87 95       	ror	r24
    uint8_t Feedback;

    /* Calculate feedback according to LFSR taps. XOR all state bytes
     * into a single bit. */
    Feedback  = E0 & (uint8_t) (LFSR_MASK_EVEN );
    Feedback ^= E1 & (uint8_t) (LFSR_MASK_EVEN >> 8);
    7de6:	df 2f       	mov	r29, r31
    7de8:	d0 71       	andi	r29, 0x10	; 16
    7dea:	fd 2e       	mov	r15, r29
{
    uint8_t Feedback;

    /* Calculate feedback according to LFSR taps. XOR all state bytes
     * into a single bit. */
    Feedback  = E0 & (uint8_t) (LFSR_MASK_EVEN );
    7dec:	01 2f       	mov	r16, r17
    7dee:	01 7e       	andi	r16, 0xE1	; 225
    Feedback ^= E1 & (uint8_t) (LFSR_MASK_EVEN >> 8);
    7df0:	f0 26       	eor	r15, r16
    Feedback ^= E2 & (uint8_t) (LFSR_MASK_EVEN >> 16);
    7df2:	09 2f       	mov	r16, r25
    7df4:	00 72       	andi	r16, 0x20	; 32
    7df6:	f0 26       	eor	r15, r16

    Feedback ^= O0 & (uint8_t) (LFSR_MASK_ODD );
    7df8:	0e 2f       	mov	r16, r30
    7dfa:	04 79       	andi	r16, 0x94	; 148
    7dfc:	f0 26       	eor	r15, r16
    Feedback ^= O1 & (uint8_t) (LFSR_MASK_ODD >> 8);
    7dfe:	03 2f       	mov	r16, r19
    7e00:	03 77       	andi	r16, 0x73	; 115
    7e02:	f0 26       	eor	r15, r16
    Feedback ^= O2 & (uint8_t) (LFSR_MASK_ODD >> 16);
    7e04:	02 2f       	mov	r16, r18
    7e06:	0a 73       	andi	r16, 0x3A	; 58
    7e08:	0f 25       	eor	r16, r15

    /* fold 8 into 1 bit */
    Feedback ^= ((Feedback >> 4)|(Feedback << 4)); /* Compiler uses a swap for this (fast!) */
    7e0a:	f0 2e       	mov	r15, r16
    7e0c:	f2 94       	swap	r15
    7e0e:	0f 25       	eor	r16, r15
    Feedback ^= Feedback >> 2;
    7e10:	f0 2e       	mov	r15, r16
    7e12:	f6 94       	lsr	r15
    7e14:	f6 94       	lsr	r15
    7e16:	0f 25       	eor	r16, r15
    7e18:	f0 2e       	mov	r15, r16
    7e1a:	f7 26       	eor	r15, r23
    Feedback ^= Feedback >> 1;
    7e1c:	06 95       	lsr	r16
        /* Bit 2 */
        In >>= 1;
        Out = CRYPTO1_FILTER_OUTPUT_B0_24(Odd0, Odd1, Odd2);
        SHIFT8(KeyStream, Out);
        Feedback  = Crypto1LFSRbyteFeedback(Even0,Even1,Even2,Odd0,Odd1,Odd2);
        Feedback ^= In;
    7e1e:	0f 25       	eor	r16, r15
        SHIFT24(Even0,Even1,Even2, Feedback);
    7e20:	d1 2e       	mov	r13, r17
    7e22:	10 2f       	mov	r17, r16
    7e24:	16 95       	lsr	r17
    7e26:	97 95       	ror	r25
    7e28:	f7 95       	ror	r31
    7e2a:	d7 94       	ror	r13

        /* Bit 3 */
        In >>= 1;
    7e2c:	76 95       	lsr	r23
        Out = CRYPTO1_FILTER_OUTPUT_B0_24(Even0,Even1,Even2);
    7e2e:	0f 2f       	mov	r16, r31
    7e30:	10 e0       	ldi	r17, 0x00	; 0
    7e32:	a8 01       	movw	r20, r16
    7e34:	48 54       	subi	r20, 0x48	; 72
    7e36:	5e 4d       	sbci	r21, 0xDE	; 222
    7e38:	0d 2d       	mov	r16, r13
    7e3a:	10 e0       	ldi	r17, 0x00	; 0
    7e3c:	08 54       	subi	r16, 0x48	; 72
    7e3e:	1f 4d       	sbci	r17, 0xDF	; 223
    7e40:	ea 01       	movw	r28, r20
    7e42:	f8 80       	ld	r15, Y
    7e44:	e8 01       	movw	r28, r16
    7e46:	18 81       	ld	r17, Y
    7e48:	0f 2d       	mov	r16, r15
    7e4a:	01 2b       	or	r16, r17
    7e4c:	e9 2e       	mov	r14, r25
    7e4e:	f1 2c       	mov	r15, r1
    7e50:	a7 01       	movw	r20, r14
    7e52:	48 54       	subi	r20, 0x48	; 72
    7e54:	5d 4d       	sbci	r21, 0xDD	; 221
    7e56:	ea 01       	movw	r28, r20
    7e58:	18 81       	ld	r17, Y
    7e5a:	01 2b       	or	r16, r17
    7e5c:	10 e0       	ldi	r17, 0x00	; 0
    7e5e:	08 56       	subi	r16, 0x68	; 104
    7e60:	1f 4d       	sbci	r17, 0xDF	; 223
    7e62:	e8 01       	movw	r28, r16
    7e64:	18 81       	ld	r17, Y
        SHIFT8(KeyStream, Out);
    7e66:	16 95       	lsr	r17
    7e68:	87 95       	ror	r24
    uint8_t Feedback;

    /* Calculate feedback according to LFSR taps. XOR all state bytes
     * into a single bit. */
    Feedback  = E0 & (uint8_t) (LFSR_MASK_EVEN );
    Feedback ^= E1 & (uint8_t) (LFSR_MASK_EVEN >> 8);
    7e6a:	03 2f       	mov	r16, r19
    7e6c:	00 71       	andi	r16, 0x10	; 16
{
    uint8_t Feedback;

    /* Calculate feedback according to LFSR taps. XOR all state bytes
     * into a single bit. */
    Feedback  = E0 & (uint8_t) (LFSR_MASK_EVEN );
    7e6e:	1e 2f       	mov	r17, r30
    7e70:	11 7e       	andi	r17, 0xE1	; 225
    Feedback ^= E1 & (uint8_t) (LFSR_MASK_EVEN >> 8);
    7e72:	01 27       	eor	r16, r17
    Feedback ^= E2 & (uint8_t) (LFSR_MASK_EVEN >> 16);
    7e74:	12 2f       	mov	r17, r18
    7e76:	10 72       	andi	r17, 0x20	; 32
    7e78:	01 27       	eor	r16, r17

    Feedback ^= O0 & (uint8_t) (LFSR_MASK_ODD );
    7e7a:	1d 2d       	mov	r17, r13
    7e7c:	14 79       	andi	r17, 0x94	; 148
    7e7e:	01 27       	eor	r16, r17
    Feedback ^= O1 & (uint8_t) (LFSR_MASK_ODD >> 8);
    7e80:	1f 2f       	mov	r17, r31
    7e82:	13 77       	andi	r17, 0x73	; 115
    7e84:	01 27       	eor	r16, r17
    Feedback ^= O2 & (uint8_t) (LFSR_MASK_ODD >> 16);
    7e86:	19 2f       	mov	r17, r25
    7e88:	1a 73       	andi	r17, 0x3A	; 58
    7e8a:	01 27       	eor	r16, r17

    /* fold 8 into 1 bit */
    Feedback ^= ((Feedback >> 4)|(Feedback << 4)); /* Compiler uses a swap for this (fast!) */
    7e8c:	10 2f       	mov	r17, r16
    7e8e:	12 95       	swap	r17
    7e90:	01 27       	eor	r16, r17
    Feedback ^= Feedback >> 2;
    7e92:	10 2f       	mov	r17, r16
    7e94:	16 95       	lsr	r17
    7e96:	16 95       	lsr	r17
    7e98:	01 27       	eor	r16, r17
    7e9a:	10 2f       	mov	r17, r16
    7e9c:	17 27       	eor	r17, r23
    Feedback ^= Feedback >> 1;
    7e9e:	06 95       	lsr	r16
        /* Bit 3 */
        In >>= 1;
        Out = CRYPTO1_FILTER_OUTPUT_B0_24(Even0,Even1,Even2);
        SHIFT8(KeyStream, Out);
        Feedback = Crypto1LFSRbyteFeedback(Odd0,Odd1,Odd2,Even0,Even1,Even2);
        Feedback ^= In;
    7ea0:	10 27       	eor	r17, r16
        SHIFT24(Odd0,Odd1,Odd2, Feedback);
    7ea2:	16 95       	lsr	r17
    7ea4:	27 95       	ror	r18
    7ea6:	37 95       	ror	r19
    7ea8:	e7 95       	ror	r30

        /* Bit 4 */
        In >>= 1;
    7eaa:	76 95       	lsr	r23
        Out = CRYPTO1_FILTER_OUTPUT_B0_24(Odd0, Odd1, Odd2);
    7eac:	03 2f       	mov	r16, r19
    7eae:	10 e0       	ldi	r17, 0x00	; 0
    7eb0:	a8 01       	movw	r20, r16
    7eb2:	48 54       	subi	r20, 0x48	; 72
    7eb4:	5e 4d       	sbci	r21, 0xDE	; 222
    7eb6:	0e 2f       	mov	r16, r30
    7eb8:	10 e0       	ldi	r17, 0x00	; 0
    7eba:	08 54       	subi	r16, 0x48	; 72
    7ebc:	1f 4d       	sbci	r17, 0xDF	; 223
    7ebe:	ea 01       	movw	r28, r20
    7ec0:	f8 80       	ld	r15, Y
    7ec2:	e8 01       	movw	r28, r16
    7ec4:	18 81       	ld	r17, Y
    7ec6:	0f 2d       	mov	r16, r15
    7ec8:	01 2b       	or	r16, r17
    7eca:	e2 2e       	mov	r14, r18
    7ecc:	f1 2c       	mov	r15, r1
    7ece:	a7 01       	movw	r20, r14
    7ed0:	48 54       	subi	r20, 0x48	; 72
    7ed2:	5d 4d       	sbci	r21, 0xDD	; 221
    7ed4:	ea 01       	movw	r28, r20
    7ed6:	18 81       	ld	r17, Y
    7ed8:	01 2b       	or	r16, r17
    7eda:	10 e0       	ldi	r17, 0x00	; 0
    7edc:	08 56       	subi	r16, 0x68	; 104
    7ede:	1f 4d       	sbci	r17, 0xDF	; 223
    7ee0:	e8 01       	movw	r28, r16
    7ee2:	18 81       	ld	r17, Y
        SHIFT8(KeyStream, Out);
    7ee4:	16 95       	lsr	r17
    7ee6:	87 95       	ror	r24
    uint8_t Feedback;

    /* Calculate feedback according to LFSR taps. XOR all state bytes
     * into a single bit. */
    Feedback  = E0 & (uint8_t) (LFSR_MASK_EVEN );
    Feedback ^= E1 & (uint8_t) (LFSR_MASK_EVEN >> 8);
    7ee8:	0f 2f       	mov	r16, r31
    7eea:	00 71       	andi	r16, 0x10	; 16
{
    uint8_t Feedback;

    /* Calculate feedback according to LFSR taps. XOR all state bytes
     * into a single bit. */
    Feedback  = E0 & (uint8_t) (LFSR_MASK_EVEN );
    7eec:	1d 2d       	mov	r17, r13
    7eee:	11 7e       	andi	r17, 0xE1	; 225
    Feedback ^= E1 & (uint8_t) (LFSR_MASK_EVEN >> 8);
    7ef0:	01 27       	eor	r16, r17
    Feedback ^= E2 & (uint8_t) (LFSR_MASK_EVEN >> 16);
    7ef2:	19 2f       	mov	r17, r25
    7ef4:	10 72       	andi	r17, 0x20	; 32
    7ef6:	01 27       	eor	r16, r17

    Feedback ^= O0 & (uint8_t) (LFSR_MASK_ODD );
    7ef8:	1e 2f       	mov	r17, r30
    7efa:	14 79       	andi	r17, 0x94	; 148
    7efc:	01 27       	eor	r16, r17
    Feedback ^= O1 & (uint8_t) (LFSR_MASK_ODD >> 8);
    7efe:	13 2f       	mov	r17, r19
    7f00:	13 77       	andi	r17, 0x73	; 115
    7f02:	01 27       	eor	r16, r17
    Feedback ^= O2 & (uint8_t) (LFSR_MASK_ODD >> 16);
    7f04:	12 2f       	mov	r17, r18
    7f06:	1a 73       	andi	r17, 0x3A	; 58
    7f08:	01 27       	eor	r16, r17

    /* fold 8 into 1 bit */
    Feedback ^= ((Feedback >> 4)|(Feedback << 4)); /* Compiler uses a swap for this (fast!) */
    7f0a:	10 2f       	mov	r17, r16
    7f0c:	12 95       	swap	r17
    7f0e:	01 27       	eor	r16, r17
    Feedback ^= Feedback >> 2;
    7f10:	10 2f       	mov	r17, r16
    7f12:	16 95       	lsr	r17
    7f14:	16 95       	lsr	r17
    7f16:	01 27       	eor	r16, r17
    7f18:	10 2f       	mov	r17, r16
    7f1a:	17 27       	eor	r17, r23
    Feedback ^= Feedback >> 1;
    7f1c:	06 95       	lsr	r16
        /* Bit 4 */
        In >>= 1;
        Out = CRYPTO1_FILTER_OUTPUT_B0_24(Odd0, Odd1, Odd2);
        SHIFT8(KeyStream, Out);
        Feedback  = Crypto1LFSRbyteFeedback(Even0,Even1,Even2,Odd0,Odd1,Odd2);
        Feedback ^= In;
    7f1e:	01 27       	eor	r16, r17
        SHIFT24(Even0,Even1,Even2, Feedback);
    7f20:	10 2f       	mov	r17, r16
    7f22:	16 95       	lsr	r17
    7f24:	97 95       	ror	r25
    7f26:	f7 95       	ror	r31
    7f28:	d7 94       	ror	r13

        /* Bit 5 */
        In >>= 1;
    7f2a:	76 95       	lsr	r23
        Out = CRYPTO1_FILTER_OUTPUT_B0_24(Even0,Even1,Even2);
    7f2c:	0f 2f       	mov	r16, r31
    7f2e:	10 e0       	ldi	r17, 0x00	; 0
    7f30:	a8 01       	movw	r20, r16
    7f32:	48 54       	subi	r20, 0x48	; 72
    7f34:	5e 4d       	sbci	r21, 0xDE	; 222
    7f36:	0d 2d       	mov	r16, r13
    7f38:	10 e0       	ldi	r17, 0x00	; 0
    7f3a:	08 54       	subi	r16, 0x48	; 72
    7f3c:	1f 4d       	sbci	r17, 0xDF	; 223
    7f3e:	ea 01       	movw	r28, r20
    7f40:	f8 80       	ld	r15, Y
    7f42:	e8 01       	movw	r28, r16
    7f44:	18 81       	ld	r17, Y
    7f46:	0f 2d       	mov	r16, r15
    7f48:	01 2b       	or	r16, r17
    7f4a:	e9 2e       	mov	r14, r25
    7f4c:	f1 2c       	mov	r15, r1
    7f4e:	a7 01       	movw	r20, r14
    7f50:	48 54       	subi	r20, 0x48	; 72
    7f52:	5d 4d       	sbci	r21, 0xDD	; 221
    7f54:	ea 01       	movw	r28, r20
    7f56:	18 81       	ld	r17, Y
    7f58:	01 2b       	or	r16, r17
    7f5a:	10 e0       	ldi	r17, 0x00	; 0
    7f5c:	08 56       	subi	r16, 0x68	; 104
    7f5e:	1f 4d       	sbci	r17, 0xDF	; 223
    7f60:	e8 01       	movw	r28, r16
    7f62:	18 81       	ld	r17, Y
        SHIFT8(KeyStream, Out);
    7f64:	16 95       	lsr	r17
    7f66:	87 95       	ror	r24
    uint8_t Feedback;

    /* Calculate feedback according to LFSR taps. XOR all state bytes
     * into a single bit. */
    Feedback  = E0 & (uint8_t) (LFSR_MASK_EVEN );
    Feedback ^= E1 & (uint8_t) (LFSR_MASK_EVEN >> 8);
    7f68:	03 2f       	mov	r16, r19
    7f6a:	00 71       	andi	r16, 0x10	; 16
{
    uint8_t Feedback;

    /* Calculate feedback according to LFSR taps. XOR all state bytes
     * into a single bit. */
    Feedback  = E0 & (uint8_t) (LFSR_MASK_EVEN );
    7f6c:	1e 2f       	mov	r17, r30
    7f6e:	11 7e       	andi	r17, 0xE1	; 225
    Feedback ^= E1 & (uint8_t) (LFSR_MASK_EVEN >> 8);
    7f70:	01 27       	eor	r16, r17
    Feedback ^= E2 & (uint8_t) (LFSR_MASK_EVEN >> 16);
    7f72:	12 2f       	mov	r17, r18
    7f74:	10 72       	andi	r17, 0x20	; 32
    7f76:	01 27       	eor	r16, r17

    Feedback ^= O0 & (uint8_t) (LFSR_MASK_ODD );
    7f78:	1d 2d       	mov	r17, r13
    7f7a:	14 79       	andi	r17, 0x94	; 148
    7f7c:	01 27       	eor	r16, r17
    Feedback ^= O1 & (uint8_t) (LFSR_MASK_ODD >> 8);
    7f7e:	1f 2f       	mov	r17, r31
    7f80:	13 77       	andi	r17, 0x73	; 115
    7f82:	01 27       	eor	r16, r17
    Feedback ^= O2 & (uint8_t) (LFSR_MASK_ODD >> 16);
    7f84:	19 2f       	mov	r17, r25
    7f86:	1a 73       	andi	r17, 0x3A	; 58
    7f88:	01 27       	eor	r16, r17

    /* fold 8 into 1 bit */
    Feedback ^= ((Feedback >> 4)|(Feedback << 4)); /* Compiler uses a swap for this (fast!) */
    7f8a:	10 2f       	mov	r17, r16
    7f8c:	12 95       	swap	r17
    7f8e:	01 27       	eor	r16, r17
    Feedback ^= Feedback >> 2;
    7f90:	10 2f       	mov	r17, r16
    7f92:	16 95       	lsr	r17
    7f94:	16 95       	lsr	r17
    7f96:	01 27       	eor	r16, r17
    7f98:	10 2f       	mov	r17, r16
    7f9a:	17 27       	eor	r17, r23
    Feedback ^= Feedback >> 1;
    7f9c:	06 95       	lsr	r16
        /* Bit 5 */
        In >>= 1;
        Out = CRYPTO1_FILTER_OUTPUT_B0_24(Even0,Even1,Even2);
        SHIFT8(KeyStream, Out);
        Feedback = Crypto1LFSRbyteFeedback(Odd0,Odd1,Odd2,Even0,Even1,Even2);
        Feedback ^= In;
    7f9e:	10 27       	eor	r17, r16
        SHIFT24(Odd0,Odd1,Odd2, Feedback);
    7fa0:	16 95       	lsr	r17
    7fa2:	27 95       	ror	r18
    7fa4:	37 95       	ror	r19
    7fa6:	e7 95       	ror	r30

        /* Bit 6 */
        In >>= 1;
    7fa8:	76 95       	lsr	r23
        Out = CRYPTO1_FILTER_OUTPUT_B0_24(Odd0, Odd1, Odd2);
    7faa:	03 2f       	mov	r16, r19
    7fac:	10 e0       	ldi	r17, 0x00	; 0
    7fae:	a8 01       	movw	r20, r16
    7fb0:	48 54       	subi	r20, 0x48	; 72
    7fb2:	5e 4d       	sbci	r21, 0xDE	; 222
    7fb4:	0e 2f       	mov	r16, r30
    7fb6:	10 e0       	ldi	r17, 0x00	; 0
    7fb8:	08 54       	subi	r16, 0x48	; 72
    7fba:	1f 4d       	sbci	r17, 0xDF	; 223
    7fbc:	ea 01       	movw	r28, r20
    7fbe:	f8 80       	ld	r15, Y
    7fc0:	e8 01       	movw	r28, r16
    7fc2:	18 81       	ld	r17, Y
    7fc4:	0f 2d       	mov	r16, r15
    7fc6:	01 2b       	or	r16, r17
    7fc8:	e2 2e       	mov	r14, r18
    7fca:	f1 2c       	mov	r15, r1
    7fcc:	a7 01       	movw	r20, r14
    7fce:	48 54       	subi	r20, 0x48	; 72
    7fd0:	5d 4d       	sbci	r21, 0xDD	; 221
    7fd2:	ea 01       	movw	r28, r20
    7fd4:	18 81       	ld	r17, Y
    7fd6:	01 2b       	or	r16, r17
    7fd8:	10 e0       	ldi	r17, 0x00	; 0
    7fda:	08 56       	subi	r16, 0x68	; 104
    7fdc:	1f 4d       	sbci	r17, 0xDF	; 223
    7fde:	e8 01       	movw	r28, r16
    7fe0:	18 81       	ld	r17, Y
        SHIFT8(KeyStream, Out);
    7fe2:	16 95       	lsr	r17
    7fe4:	87 95       	ror	r24
    uint8_t Feedback;

    /* Calculate feedback according to LFSR taps. XOR all state bytes
     * into a single bit. */
    Feedback  = E0 & (uint8_t) (LFSR_MASK_EVEN );
    Feedback ^= E1 & (uint8_t) (LFSR_MASK_EVEN >> 8);
    7fe6:	0f 2f       	mov	r16, r31
    7fe8:	00 71       	andi	r16, 0x10	; 16
{
    uint8_t Feedback;

    /* Calculate feedback according to LFSR taps. XOR all state bytes
     * into a single bit. */
    Feedback  = E0 & (uint8_t) (LFSR_MASK_EVEN );
    7fea:	1d 2d       	mov	r17, r13
    7fec:	11 7e       	andi	r17, 0xE1	; 225
    Feedback ^= E1 & (uint8_t) (LFSR_MASK_EVEN >> 8);
    7fee:	10 27       	eor	r17, r16
    Feedback ^= E2 & (uint8_t) (LFSR_MASK_EVEN >> 16);
    7ff0:	09 2f       	mov	r16, r25
    7ff2:	00 72       	andi	r16, 0x20	; 32
    7ff4:	10 27       	eor	r17, r16

    Feedback ^= O0 & (uint8_t) (LFSR_MASK_ODD );
    7ff6:	0e 2f       	mov	r16, r30
    7ff8:	04 79       	andi	r16, 0x94	; 148
    7ffa:	10 27       	eor	r17, r16
    Feedback ^= O1 & (uint8_t) (LFSR_MASK_ODD >> 8);
    7ffc:	03 2f       	mov	r16, r19
    7ffe:	03 77       	andi	r16, 0x73	; 115
    8000:	10 27       	eor	r17, r16
    Feedback ^= O2 & (uint8_t) (LFSR_MASK_ODD >> 16);
    8002:	02 2f       	mov	r16, r18
    8004:	0a 73       	andi	r16, 0x3A	; 58
    8006:	10 27       	eor	r17, r16

    /* fold 8 into 1 bit */
    Feedback ^= ((Feedback >> 4)|(Feedback << 4)); /* Compiler uses a swap for this (fast!) */
    8008:	01 2f       	mov	r16, r17
    800a:	02 95       	swap	r16
    800c:	10 27       	eor	r17, r16
    Feedback ^= Feedback >> 2;
    800e:	01 2f       	mov	r16, r17
    8010:	06 95       	lsr	r16
    8012:	06 95       	lsr	r16
    8014:	10 27       	eor	r17, r16
    8016:	01 2f       	mov	r16, r17
    8018:	07 27       	eor	r16, r23
    Feedback ^= Feedback >> 1;
    801a:	16 95       	lsr	r17
        /* Bit 6 */
        In >>= 1;
        Out = CRYPTO1_FILTER_OUTPUT_B0_24(Odd0, Odd1, Odd2);
        SHIFT8(KeyStream, Out);
        Feedback  = Crypto1LFSRbyteFeedback(Even0,Even1,Even2,Odd0,Odd1,Odd2);
        Feedback ^= In;
    801c:	01 27       	eor	r16, r17
        SHIFT24(Even0,Even1,Even2, Feedback);
    801e:	1d 2d       	mov	r17, r13
    8020:	06 95       	lsr	r16
    8022:	97 95       	ror	r25
    8024:	f7 95       	ror	r31
    8026:	17 95       	ror	r17

        /* Bit 7 */
        In >>= 1;
        Out = CRYPTO1_FILTER_OUTPUT_B0_24(Even0,Even1,Even2);
    8028:	cf 2e       	mov	r12, r31
    802a:	d1 2c       	mov	r13, r1
    802c:	a6 01       	movw	r20, r12
    802e:	48 54       	subi	r20, 0x48	; 72
    8030:	5e 4d       	sbci	r21, 0xDE	; 222
    8032:	e1 2e       	mov	r14, r17
    8034:	f1 2c       	mov	r15, r1
    8036:	e7 01       	movw	r28, r14
    8038:	c8 54       	subi	r28, 0x48	; 72
    803a:	df 4d       	sbci	r29, 0xDF	; 223
    803c:	7e 01       	movw	r14, r28
    803e:	ea 01       	movw	r28, r20
    8040:	d8 80       	ld	r13, Y
    8042:	e7 01       	movw	r28, r14
    8044:	08 81       	ld	r16, Y
    8046:	ed 2c       	mov	r14, r13
    8048:	e0 2a       	or	r14, r16
    804a:	c9 2e       	mov	r12, r25
    804c:	d1 2c       	mov	r13, r1
    804e:	a6 01       	movw	r20, r12
    8050:	48 54       	subi	r20, 0x48	; 72
    8052:	5d 4d       	sbci	r21, 0xDD	; 221
    8054:	ea 01       	movw	r28, r20
    8056:	08 81       	ld	r16, Y
    8058:	e0 2a       	or	r14, r16
    805a:	f1 2c       	mov	r15, r1
    805c:	a7 01       	movw	r20, r14
    805e:	48 56       	subi	r20, 0x68	; 104
    8060:	5f 4d       	sbci	r21, 0xDF	; 223
    8062:	ea 01       	movw	r28, r20
    8064:	08 81       	ld	r16, Y
        SHIFT8(KeyStream, Out);
    8066:	06 95       	lsr	r16
    8068:	87 95       	ror	r24
    uint8_t Feedback;

    /* Calculate feedback according to LFSR taps. XOR all state bytes
     * into a single bit. */
    Feedback  = E0 & (uint8_t) (LFSR_MASK_EVEN );
    Feedback ^= E1 & (uint8_t) (LFSR_MASK_EVEN >> 8);
    806a:	d3 2f       	mov	r29, r19
    806c:	d0 71       	andi	r29, 0x10	; 16
    806e:	fd 2e       	mov	r15, r29
{
    uint8_t Feedback;

    /* Calculate feedback according to LFSR taps. XOR all state bytes
     * into a single bit. */
    Feedback  = E0 & (uint8_t) (LFSR_MASK_EVEN );
    8070:	0e 2f       	mov	r16, r30
    8072:	01 7e       	andi	r16, 0xE1	; 225
    Feedback ^= E1 & (uint8_t) (LFSR_MASK_EVEN >> 8);
    8074:	f0 26       	eor	r15, r16
    Feedback ^= E2 & (uint8_t) (LFSR_MASK_EVEN >> 16);
    8076:	02 2f       	mov	r16, r18
    8078:	00 72       	andi	r16, 0x20	; 32
    807a:	f0 26       	eor	r15, r16

    Feedback ^= O0 & (uint8_t) (LFSR_MASK_ODD );
    807c:	01 2f       	mov	r16, r17
    807e:	04 79       	andi	r16, 0x94	; 148
    8080:	f0 26       	eor	r15, r16
    Feedback ^= O1 & (uint8_t) (LFSR_MASK_ODD >> 8);
    8082:	0f 2f       	mov	r16, r31
    8084:	03 77       	andi	r16, 0x73	; 115
    8086:	f0 26       	eor	r15, r16
    Feedback ^= O2 & (uint8_t) (LFSR_MASK_ODD >> 16);
    8088:	09 2f       	mov	r16, r25
    808a:	0a 73       	andi	r16, 0x3A	; 58
    808c:	0f 25       	eor	r16, r15

    /* fold 8 into 1 bit */
    Feedback ^= ((Feedback >> 4)|(Feedback << 4)); /* Compiler uses a swap for this (fast!) */
    808e:	f0 2e       	mov	r15, r16
    8090:	f2 94       	swap	r15
    8092:	0f 25       	eor	r16, r15
    Feedback ^= Feedback >> 2;
    8094:	f0 2e       	mov	r15, r16
    8096:	f6 94       	lsr	r15
    8098:	f6 94       	lsr	r15
    809a:	0f 25       	eor	r16, r15
        Feedback  = Crypto1LFSRbyteFeedback(Even0,Even1,Even2,Odd0,Odd1,Odd2);
        Feedback ^= In;
        SHIFT24(Even0,Even1,Even2, Feedback);

        /* Bit 7 */
        In >>= 1;
    809c:	76 95       	lsr	r23
    809e:	70 27       	eor	r23, r16
    Feedback ^= O2 & (uint8_t) (LFSR_MASK_ODD >> 16);

    /* fold 8 into 1 bit */
    Feedback ^= ((Feedback >> 4)|(Feedback << 4)); /* Compiler uses a swap for this (fast!) */
    Feedback ^= Feedback >> 2;
    Feedback ^= Feedback >> 1;
    80a0:	06 95       	lsr	r16
        /* Bit 7 */
        In >>= 1;
        Out = CRYPTO1_FILTER_OUTPUT_B0_24(Even0,Even1,Even2);
        SHIFT8(KeyStream, Out);
        Feedback = Crypto1LFSRbyteFeedback(Odd0,Odd1,Odd2,Even0,Even1,Even2);
        Feedback ^= In;
    80a2:	70 27       	eor	r23, r16
        SHIFT24(Odd0,Odd1,Odd2, Feedback);
    80a4:	76 95       	lsr	r23
    80a6:	27 95       	ror	r18
    80a8:	37 95       	ror	r19
    80aa:	e7 95       	ror	r30

        /* Encrypt Nonce */
        *CardNonce++ ^= KeyStream; /* Encrypt byte   */
    80ac:	68 27       	eor	r22, r24
    80ae:	6d 93       	st	X+, r22
    KeyStream = *Key++;
    SPLIT_BYTE(Even2, Odd2, KeyStream);
    KeyStream = *Key++;
    SPLIT_BYTE(Even2, Odd2, KeyStream);

    for ( ByteCount = 0; ByteCount < NONCE_SIZE; ByteCount++)
    80b0:	a8 15       	cp	r26, r8
    80b2:	b9 05       	cpc	r27, r9
    80b4:	09 f0       	breq	.+2      	; 0x80b8 <Crypto1Setup+0x53a>
    80b6:	eb cd       	rjmp	.-1066   	; 0x7c8e <Crypto1Setup+0x110>

        /* Encrypt Nonce */
        *CardNonce++ ^= KeyStream; /* Encrypt byte   */
    }
    /* save state */
    State.Even[0] = Even0;
    80b8:	10 93 df 2c 	sts	0x2CDF, r17
    State.Even[1] = Even1;
    80bc:	f0 93 e0 2c 	sts	0x2CE0, r31
    State.Even[2] = Even2;
    80c0:	90 93 e1 2c 	sts	0x2CE1, r25
    State.Odd[0]  = Odd0;
    80c4:	e0 93 e2 2c 	sts	0x2CE2, r30
    State.Odd[1]  = Odd1;
    80c8:	30 93 e3 2c 	sts	0x2CE3, r19
    State.Odd[2]  = Odd2;
    80cc:	20 93 e4 2c 	sts	0x2CE4, r18
}
    80d0:	df 91       	pop	r29
    80d2:	cf 91       	pop	r28
    80d4:	1f 91       	pop	r17
    80d6:	0f 91       	pop	r16
    80d8:	ff 90       	pop	r15
    80da:	ef 90       	pop	r14
    80dc:	df 90       	pop	r13
    80de:	cf 90       	pop	r12
    80e0:	bf 90       	pop	r11
    80e2:	af 90       	pop	r10
    80e4:	9f 90       	pop	r9
    80e6:	8f 90       	pop	r8
    80e8:	08 95       	ret

000080ea <Crypto1SetupNested>:
/* Setup LFSR split into odd and even states, feed in uid ^nonce    */
/* Vesion for nested authentication.                                */
/* Also generates encrypted parity bits at CardNonce[4]..[7]        */
/* Use: Decrypt = false for the tag, Decrypt = true for the reader  */
void Crypto1SetupNested(uint8_t Key[6], uint8_t Uid[4], uint8_t CardNonce[8], bool Decrypt)
{
    80ea:	4f 92       	push	r4
    80ec:	5f 92       	push	r5
    80ee:	6f 92       	push	r6
    80f0:	7f 92       	push	r7
    80f2:	9f 92       	push	r9
    80f4:	af 92       	push	r10
    80f6:	bf 92       	push	r11
    80f8:	cf 92       	push	r12
    80fa:	df 92       	push	r13
    80fc:	ef 92       	push	r14
    80fe:	ff 92       	push	r15
    8100:	0f 93       	push	r16
    8102:	1f 93       	push	r17
    8104:	cf 93       	push	r28
    8106:	df 93       	push	r29
    8108:	dc 01       	movw	r26, r24
    uint8_t Feedback;
    uint8_t Out;
    uint8_t In;
    uint8_t ByteCount;

    KeyStream = *Key++;
    810a:	8c 91       	ld	r24, X
    SPLIT_BYTE(Even0, Odd0, KeyStream);
    810c:	10 e0       	ldi	r17, 0x00	; 0
    810e:	b1 2c       	mov	r11, r1
    8110:	eb 2d       	mov	r30, r11
    8112:	86 95       	lsr	r24
    8114:	e7 95       	ror	r30
    8116:	86 95       	lsr	r24
    8118:	17 95       	ror	r17
    811a:	86 95       	lsr	r24
    811c:	e7 95       	ror	r30
    811e:	86 95       	lsr	r24
    8120:	17 95       	ror	r17
    8122:	86 95       	lsr	r24
    8124:	e7 95       	ror	r30
    8126:	86 95       	lsr	r24
    8128:	17 95       	ror	r17
    812a:	86 95       	lsr	r24
    812c:	e7 95       	ror	r30
    812e:	86 95       	lsr	r24
    8130:	17 95       	ror	r17
    KeyStream = *Key++;
    8132:	11 96       	adiw	r26, 0x01	; 1
    8134:	8c 91       	ld	r24, X
    8136:	11 97       	sbiw	r26, 0x01	; 1
    SPLIT_BYTE(Even0, Odd0, KeyStream);
    8138:	be 2e       	mov	r11, r30
    813a:	86 95       	lsr	r24
    813c:	b7 94       	ror	r11
    813e:	86 95       	lsr	r24
    8140:	17 95       	ror	r17
    8142:	86 95       	lsr	r24
    8144:	b7 94       	ror	r11
    8146:	86 95       	lsr	r24
    8148:	17 95       	ror	r17
    814a:	86 95       	lsr	r24
    814c:	b7 94       	ror	r11
    814e:	86 95       	lsr	r24
    8150:	17 95       	ror	r17
    8152:	86 95       	lsr	r24
    8154:	b7 94       	ror	r11
    8156:	86 95       	lsr	r24
    8158:	17 95       	ror	r17
    KeyStream = *Key++;
    815a:	12 96       	adiw	r26, 0x02	; 2
    815c:	9c 91       	ld	r25, X
    815e:	12 97       	sbiw	r26, 0x02	; 2
    SPLIT_BYTE(Even1, Odd1, KeyStream);
    8160:	30 e0       	ldi	r19, 0x00	; 0
    8162:	80 e0       	ldi	r24, 0x00	; 0
    8164:	96 95       	lsr	r25
    8166:	87 95       	ror	r24
    8168:	96 95       	lsr	r25
    816a:	37 95       	ror	r19
    816c:	96 95       	lsr	r25
    816e:	87 95       	ror	r24
    8170:	96 95       	lsr	r25
    8172:	37 95       	ror	r19
    8174:	96 95       	lsr	r25
    8176:	87 95       	ror	r24
    8178:	96 95       	lsr	r25
    817a:	37 95       	ror	r19
    817c:	96 95       	lsr	r25
    817e:	87 95       	ror	r24
    8180:	96 95       	lsr	r25
    8182:	37 95       	ror	r19
    KeyStream = *Key++;
    8184:	13 96       	adiw	r26, 0x03	; 3
    8186:	9c 91       	ld	r25, X
    8188:	13 97       	sbiw	r26, 0x03	; 3
    SPLIT_BYTE(Even1, Odd1, KeyStream);
    818a:	96 95       	lsr	r25
    818c:	87 95       	ror	r24
    818e:	96 95       	lsr	r25
    8190:	37 95       	ror	r19
    8192:	96 95       	lsr	r25
    8194:	87 95       	ror	r24
    8196:	96 95       	lsr	r25
    8198:	37 95       	ror	r19
    819a:	96 95       	lsr	r25
    819c:	87 95       	ror	r24
    819e:	96 95       	lsr	r25
    81a0:	37 95       	ror	r19
    81a2:	96 95       	lsr	r25
    81a4:	87 95       	ror	r24
    81a6:	96 95       	lsr	r25
    81a8:	37 95       	ror	r19
    KeyStream = *Key++;
    81aa:	14 96       	adiw	r26, 0x04	; 4
    81ac:	ec 91       	ld	r30, X
    81ae:	14 97       	sbiw	r26, 0x04	; 4
    SPLIT_BYTE(Even2, Odd2, KeyStream);
    81b0:	90 e0       	ldi	r25, 0x00	; 0
    81b2:	00 e0       	ldi	r16, 0x00	; 0
    81b4:	e6 95       	lsr	r30
    81b6:	07 95       	ror	r16
    81b8:	e6 95       	lsr	r30
    81ba:	97 95       	ror	r25
    81bc:	e6 95       	lsr	r30
    81be:	07 95       	ror	r16
    81c0:	e6 95       	lsr	r30
    81c2:	97 95       	ror	r25
    81c4:	e6 95       	lsr	r30
    81c6:	07 95       	ror	r16
    81c8:	e6 95       	lsr	r30
    81ca:	97 95       	ror	r25
    81cc:	e6 95       	lsr	r30
    81ce:	07 95       	ror	r16
    81d0:	e6 95       	lsr	r30
    81d2:	97 95       	ror	r25
    KeyStream = *Key++;
    81d4:	15 96       	adiw	r26, 0x05	; 5
    81d6:	dc 90       	ld	r13, X
    SPLIT_BYTE(Even2, Odd2, KeyStream);
    81d8:	d6 94       	lsr	r13
    81da:	07 95       	ror	r16
    81dc:	d6 94       	lsr	r13
    81de:	97 95       	ror	r25
    81e0:	d6 94       	lsr	r13
    81e2:	07 95       	ror	r16
    81e4:	d6 94       	lsr	r13
    81e6:	97 95       	ror	r25
    81e8:	d6 94       	lsr	r13
    81ea:	07 95       	ror	r16
    81ec:	d6 94       	lsr	r13
    81ee:	97 95       	ror	r25
    81f0:	d6 94       	lsr	r13
    81f2:	07 95       	ror	r16
    81f4:	d6 94       	lsr	r13
    81f6:	97 95       	ror	r25

    /* Get first filter output */
    Out = CRYPTO1_FILTER_OUTPUT_B0_24(Odd0, Odd1, Odd2);
    81f8:	e3 2f       	mov	r30, r19
    81fa:	f0 e0       	ldi	r31, 0x00	; 0
    81fc:	e8 54       	subi	r30, 0x48	; 72
    81fe:	fe 4d       	sbci	r31, 0xDE	; 222
    8200:	a1 2f       	mov	r26, r17
    8202:	b0 e0       	ldi	r27, 0x00	; 0
    8204:	a8 54       	subi	r26, 0x48	; 72
    8206:	bf 4d       	sbci	r27, 0xDF	; 223
    8208:	f0 81       	ld	r31, Z
    820a:	ec 91       	ld	r30, X
    820c:	ef 2b       	or	r30, r31
    820e:	a9 2f       	mov	r26, r25
    8210:	b0 e0       	ldi	r27, 0x00	; 0
    8212:	a8 54       	subi	r26, 0x48	; 72
    8214:	bd 4d       	sbci	r27, 0xDD	; 221
    8216:	fc 91       	ld	r31, X
    8218:	ef 2b       	or	r30, r31
    821a:	f0 e0       	ldi	r31, 0x00	; 0
    821c:	e8 56       	subi	r30, 0x68	; 104
    821e:	ff 4d       	sbci	r31, 0xDF	; 223
    8220:	e0 80       	ld	r14, Z
    8222:	2b 01       	movw	r4, r22
    8224:	ba 01       	movw	r22, r20
    8226:	6c 5f       	subi	r22, 0xFC	; 252
    8228:	7f 4f       	sbci	r23, 0xFF	; 255
    822a:	da 01       	movw	r26, r20
    822c:	3b 01       	movw	r6, r22

    for ( ByteCount = 0; ByteCount < NONCE_SIZE; ByteCount++)
    {
        In = *CardNonce ^ *Uid++;
    822e:	ac 90       	ld	r10, X
    8230:	e2 01       	movw	r28, r4
    8232:	c9 90       	ld	r12, Y+
    8234:	2e 01       	movw	r4, r28
    8236:	ca 24       	eor	r12, r10

        /* we can reuse the filter output used to decrypt the parity bit! */
        SHIFT8(KeyStream, Out);
    8238:	fd 2d       	mov	r31, r13
    823a:	e6 94       	lsr	r14
    823c:	f7 95       	ror	r31
    uint8_t Feedback;

    /* Calculate feedback according to LFSR taps. XOR all state bytes
     * into a single bit. */
    Feedback  = E0 & (uint8_t) (LFSR_MASK_EVEN );
    Feedback ^= E1 & (uint8_t) (LFSR_MASK_EVEN >> 8);
    823e:	d8 2f       	mov	r29, r24
    8240:	d0 71       	andi	r29, 0x10	; 16
    8242:	fd 2e       	mov	r15, r29
{
    uint8_t Feedback;

    /* Calculate feedback according to LFSR taps. XOR all state bytes
     * into a single bit. */
    Feedback  = E0 & (uint8_t) (LFSR_MASK_EVEN );
    8244:	eb 2d       	mov	r30, r11
    8246:	e1 7e       	andi	r30, 0xE1	; 225
    Feedback ^= E1 & (uint8_t) (LFSR_MASK_EVEN >> 8);
    8248:	fe 26       	eor	r15, r30
    Feedback ^= E2 & (uint8_t) (LFSR_MASK_EVEN >> 16);
    824a:	e0 2f       	mov	r30, r16
    824c:	e0 72       	andi	r30, 0x20	; 32
    824e:	fe 26       	eor	r15, r30

    Feedback ^= O0 & (uint8_t) (LFSR_MASK_ODD );
    8250:	e1 2f       	mov	r30, r17
    8252:	e4 79       	andi	r30, 0x94	; 148
    8254:	fe 26       	eor	r15, r30
    Feedback ^= O1 & (uint8_t) (LFSR_MASK_ODD >> 8);
    8256:	e3 2f       	mov	r30, r19
    8258:	e3 77       	andi	r30, 0x73	; 115
    825a:	fe 26       	eor	r15, r30
    Feedback ^= O2 & (uint8_t) (LFSR_MASK_ODD >> 16);
    825c:	e9 2f       	mov	r30, r25
    825e:	ea 73       	andi	r30, 0x3A	; 58
    8260:	ef 25       	eor	r30, r15

    /* fold 8 into 1 bit */
    Feedback ^= ((Feedback >> 4)|(Feedback << 4)); /* Compiler uses a swap for this (fast!) */
    8262:	fe 2e       	mov	r15, r30
    8264:	f2 94       	swap	r15
    8266:	ef 25       	eor	r30, r15
    Feedback ^= Feedback >> 2;
    8268:	fe 2e       	mov	r15, r30
    826a:	f6 94       	lsr	r15
    826c:	f6 94       	lsr	r15
    826e:	ef 25       	eor	r30, r15
    8270:	fe 2e       	mov	r15, r30
    8272:	fc 24       	eor	r15, r12
    Feedback ^= Feedback >> 1;
    8274:	e6 95       	lsr	r30
        In = *CardNonce ^ *Uid++;

        /* we can reuse the filter output used to decrypt the parity bit! */
        SHIFT8(KeyStream, Out);
        Feedback  = Crypto1LFSRbyteFeedback(Even0,Even1,Even2,Odd0,Odd1,Odd2);
        Feedback ^= In;
    8276:	fe 26       	eor	r15, r30
        SHIFT24_COND_DECRYPT(Even0,Even1,Even2, Feedback, Out, Decrypt);
    8278:	eb 2d       	mov	r30, r11
    827a:	20 fd       	sbrc	r18, 0
    827c:	fe 24       	eor	r15, r14
    827e:	f6 94       	lsr	r15
    8280:	07 95       	ror	r16
    8282:	87 95       	ror	r24
    8284:	e7 95       	ror	r30

        /* Bit 1 */
        In >>= 1;
    8286:	bc 2c       	mov	r11, r12
    8288:	b6 94       	lsr	r11
        /* remember Odd/Even swap has been omitted! */
        Out = CRYPTO1_FILTER_OUTPUT_B0_24(Even0,Even1,Even2);
    828a:	c8 2e       	mov	r12, r24
    828c:	d1 2c       	mov	r13, r1
    828e:	a6 01       	movw	r20, r12
    8290:	48 54       	subi	r20, 0x48	; 72
    8292:	5e 4d       	sbci	r21, 0xDE	; 222
    8294:	ee 2e       	mov	r14, r30
    8296:	f1 2c       	mov	r15, r1
    8298:	e7 01       	movw	r28, r14
    829a:	c8 54       	subi	r28, 0x48	; 72
    829c:	df 4d       	sbci	r29, 0xDF	; 223
    829e:	7e 01       	movw	r14, r28
    82a0:	ea 01       	movw	r28, r20
    82a2:	d8 80       	ld	r13, Y
    82a4:	e7 01       	movw	r28, r14
    82a6:	f8 80       	ld	r15, Y
    82a8:	ed 2c       	mov	r14, r13
    82aa:	ef 28       	or	r14, r15
    82ac:	c0 2e       	mov	r12, r16
    82ae:	d1 2c       	mov	r13, r1
    82b0:	a6 01       	movw	r20, r12
    82b2:	48 54       	subi	r20, 0x48	; 72
    82b4:	5d 4d       	sbci	r21, 0xDD	; 221
    82b6:	ea 01       	movw	r28, r20
    82b8:	f8 80       	ld	r15, Y
    82ba:	ef 28       	or	r14, r15
    82bc:	f1 2c       	mov	r15, r1
    82be:	a7 01       	movw	r20, r14
    82c0:	48 56       	subi	r20, 0x68	; 104
    82c2:	5f 4d       	sbci	r21, 0xDF	; 223
    82c4:	ea 01       	movw	r28, r20
    82c6:	d8 80       	ld	r13, Y
        SHIFT8(KeyStream, Out);
    82c8:	d6 94       	lsr	r13
    82ca:	f7 95       	ror	r31
    uint8_t Feedback;

    /* Calculate feedback according to LFSR taps. XOR all state bytes
     * into a single bit. */
    Feedback  = E0 & (uint8_t) (LFSR_MASK_EVEN );
    Feedback ^= E1 & (uint8_t) (LFSR_MASK_EVEN >> 8);
    82cc:	d3 2f       	mov	r29, r19
    82ce:	d0 71       	andi	r29, 0x10	; 16
    82d0:	ed 2e       	mov	r14, r29
{
    uint8_t Feedback;

    /* Calculate feedback according to LFSR taps. XOR all state bytes
     * into a single bit. */
    Feedback  = E0 & (uint8_t) (LFSR_MASK_EVEN );
    82d2:	41 2f       	mov	r20, r17
    82d4:	41 7e       	andi	r20, 0xE1	; 225
    Feedback ^= E1 & (uint8_t) (LFSR_MASK_EVEN >> 8);
    82d6:	e4 26       	eor	r14, r20
    Feedback ^= E2 & (uint8_t) (LFSR_MASK_EVEN >> 16);
    82d8:	59 2f       	mov	r21, r25
    82da:	50 72       	andi	r21, 0x20	; 32
    82dc:	e5 26       	eor	r14, r21

    Feedback ^= O0 & (uint8_t) (LFSR_MASK_ODD );
    82de:	ce 2f       	mov	r28, r30
    82e0:	c4 79       	andi	r28, 0x94	; 148
    82e2:	ec 26       	eor	r14, r28
    Feedback ^= O1 & (uint8_t) (LFSR_MASK_ODD >> 8);
    82e4:	d8 2f       	mov	r29, r24
    82e6:	d3 77       	andi	r29, 0x73	; 115
    82e8:	ed 26       	eor	r14, r29
    Feedback ^= O2 & (uint8_t) (LFSR_MASK_ODD >> 16);
    82ea:	40 2f       	mov	r20, r16
    82ec:	4a 73       	andi	r20, 0x3A	; 58
    82ee:	e4 26       	eor	r14, r20

    /* fold 8 into 1 bit */
    Feedback ^= ((Feedback >> 4)|(Feedback << 4)); /* Compiler uses a swap for this (fast!) */
    82f0:	fe 2c       	mov	r15, r14
    82f2:	f2 94       	swap	r15
    82f4:	ef 24       	eor	r14, r15
    Feedback ^= Feedback >> 2;
    82f6:	fe 2c       	mov	r15, r14
    82f8:	f6 94       	lsr	r15
    82fa:	f6 94       	lsr	r15
    82fc:	ef 24       	eor	r14, r15
    82fe:	fe 2c       	mov	r15, r14
    8300:	fb 24       	eor	r15, r11
    Feedback ^= Feedback >> 1;
    8302:	e6 94       	lsr	r14
        In >>= 1;
        /* remember Odd/Even swap has been omitted! */
        Out = CRYPTO1_FILTER_OUTPUT_B0_24(Even0,Even1,Even2);
        SHIFT8(KeyStream, Out);
        Feedback = Crypto1LFSRbyteFeedback(Odd0,Odd1,Odd2,Even0,Even1,Even2);
        Feedback ^= In;
    8304:	fe 24       	eor	r15, r14
        SHIFT24_COND_DECRYPT(Odd0,Odd1,Odd2, Feedback, Out, Decrypt);
    8306:	20 fd       	sbrc	r18, 0
    8308:	fd 24       	eor	r15, r13
    830a:	f6 94       	lsr	r15
    830c:	97 95       	ror	r25
    830e:	37 95       	ror	r19
    8310:	17 95       	ror	r17

        /* Bit 2 */
        In >>= 1;
    8312:	b6 94       	lsr	r11
        Out = CRYPTO1_FILTER_OUTPUT_B0_24(Odd0, Odd1, Odd2);
    8314:	c3 2e       	mov	r12, r19
    8316:	d1 2c       	mov	r13, r1
    8318:	e6 01       	movw	r28, r12
    831a:	c8 54       	subi	r28, 0x48	; 72
    831c:	de 4d       	sbci	r29, 0xDE	; 222
    831e:	e1 2e       	mov	r14, r17
    8320:	f1 2c       	mov	r15, r1
    8322:	a7 01       	movw	r20, r14
    8324:	48 54       	subi	r20, 0x48	; 72
    8326:	5f 4d       	sbci	r21, 0xDF	; 223
    8328:	d8 80       	ld	r13, Y
    832a:	ea 01       	movw	r28, r20
    832c:	f8 80       	ld	r15, Y
    832e:	ed 2c       	mov	r14, r13
    8330:	ef 28       	or	r14, r15
    8332:	c9 2e       	mov	r12, r25
    8334:	d1 2c       	mov	r13, r1
    8336:	a6 01       	movw	r20, r12
    8338:	48 54       	subi	r20, 0x48	; 72
    833a:	5d 4d       	sbci	r21, 0xDD	; 221
    833c:	ea 01       	movw	r28, r20
    833e:	f8 80       	ld	r15, Y
    8340:	ef 28       	or	r14, r15
    8342:	f1 2c       	mov	r15, r1
    8344:	a7 01       	movw	r20, r14
    8346:	48 56       	subi	r20, 0x68	; 104
    8348:	5f 4d       	sbci	r21, 0xDF	; 223
    834a:	ea 01       	movw	r28, r20
    834c:	d8 80       	ld	r13, Y
        SHIFT8(KeyStream, Out);
    834e:	d6 94       	lsr	r13
    8350:	f7 95       	ror	r31
    uint8_t Feedback;

    /* Calculate feedback according to LFSR taps. XOR all state bytes
     * into a single bit. */
    Feedback  = E0 & (uint8_t) (LFSR_MASK_EVEN );
    Feedback ^= E1 & (uint8_t) (LFSR_MASK_EVEN >> 8);
    8352:	d8 2f       	mov	r29, r24
    8354:	d0 71       	andi	r29, 0x10	; 16
    8356:	ed 2e       	mov	r14, r29
{
    uint8_t Feedback;

    /* Calculate feedback according to LFSR taps. XOR all state bytes
     * into a single bit. */
    Feedback  = E0 & (uint8_t) (LFSR_MASK_EVEN );
    8358:	4e 2f       	mov	r20, r30
    835a:	41 7e       	andi	r20, 0xE1	; 225
    Feedback ^= E1 & (uint8_t) (LFSR_MASK_EVEN >> 8);
    835c:	e4 26       	eor	r14, r20
    Feedback ^= E2 & (uint8_t) (LFSR_MASK_EVEN >> 16);
    835e:	50 2f       	mov	r21, r16
    8360:	50 72       	andi	r21, 0x20	; 32
    8362:	e5 26       	eor	r14, r21

    Feedback ^= O0 & (uint8_t) (LFSR_MASK_ODD );
    8364:	c1 2f       	mov	r28, r17
    8366:	c4 79       	andi	r28, 0x94	; 148
    8368:	ec 26       	eor	r14, r28
    Feedback ^= O1 & (uint8_t) (LFSR_MASK_ODD >> 8);
    836a:	d3 2f       	mov	r29, r19
    836c:	d3 77       	andi	r29, 0x73	; 115
    836e:	ed 26       	eor	r14, r29
    Feedback ^= O2 & (uint8_t) (LFSR_MASK_ODD >> 16);
    8370:	49 2f       	mov	r20, r25
    8372:	4a 73       	andi	r20, 0x3A	; 58
    8374:	e4 26       	eor	r14, r20

    /* fold 8 into 1 bit */
    Feedback ^= ((Feedback >> 4)|(Feedback << 4)); /* Compiler uses a swap for this (fast!) */
    8376:	fe 2c       	mov	r15, r14
    8378:	f2 94       	swap	r15
    837a:	ef 24       	eor	r14, r15
    Feedback ^= Feedback >> 2;
    837c:	fe 2c       	mov	r15, r14
    837e:	f6 94       	lsr	r15
    8380:	f6 94       	lsr	r15
    8382:	ef 24       	eor	r14, r15
    8384:	fe 2c       	mov	r15, r14
    8386:	fb 24       	eor	r15, r11
    Feedback ^= Feedback >> 1;
    8388:	e6 94       	lsr	r14
        /* Bit 2 */
        In >>= 1;
        Out = CRYPTO1_FILTER_OUTPUT_B0_24(Odd0, Odd1, Odd2);
        SHIFT8(KeyStream, Out);
        Feedback  = Crypto1LFSRbyteFeedback(Even0,Even1,Even2,Odd0,Odd1,Odd2);
        Feedback ^= In;
    838a:	fe 24       	eor	r15, r14
        SHIFT24_COND_DECRYPT(Even0,Even1,Even2, Feedback, Out, Decrypt);
    838c:	20 fd       	sbrc	r18, 0
    838e:	fd 24       	eor	r15, r13
    8390:	f6 94       	lsr	r15
    8392:	07 95       	ror	r16
    8394:	87 95       	ror	r24
    8396:	e7 95       	ror	r30

        /* Bit 3 */
        In >>= 1;
    8398:	b6 94       	lsr	r11
        Out = CRYPTO1_FILTER_OUTPUT_B0_24(Even0,Even1,Even2);
    839a:	c8 2e       	mov	r12, r24
    839c:	d1 2c       	mov	r13, r1
    839e:	e6 01       	movw	r28, r12
    83a0:	c8 54       	subi	r28, 0x48	; 72
    83a2:	de 4d       	sbci	r29, 0xDE	; 222
    83a4:	ee 2e       	mov	r14, r30
    83a6:	f1 2c       	mov	r15, r1
    83a8:	a7 01       	movw	r20, r14
    83aa:	48 54       	subi	r20, 0x48	; 72
    83ac:	5f 4d       	sbci	r21, 0xDF	; 223
    83ae:	d8 80       	ld	r13, Y
    83b0:	ea 01       	movw	r28, r20
    83b2:	f8 80       	ld	r15, Y
    83b4:	ed 2c       	mov	r14, r13
    83b6:	ef 28       	or	r14, r15
    83b8:	c0 2e       	mov	r12, r16
    83ba:	d1 2c       	mov	r13, r1
    83bc:	a6 01       	movw	r20, r12
    83be:	48 54       	subi	r20, 0x48	; 72
    83c0:	5d 4d       	sbci	r21, 0xDD	; 221
    83c2:	ea 01       	movw	r28, r20
    83c4:	f8 80       	ld	r15, Y
    83c6:	ef 28       	or	r14, r15
    83c8:	f1 2c       	mov	r15, r1
    83ca:	a7 01       	movw	r20, r14
    83cc:	48 56       	subi	r20, 0x68	; 104
    83ce:	5f 4d       	sbci	r21, 0xDF	; 223
    83d0:	ea 01       	movw	r28, r20
    83d2:	d8 80       	ld	r13, Y
        SHIFT8(KeyStream, Out);
    83d4:	d6 94       	lsr	r13
    83d6:	f7 95       	ror	r31
    uint8_t Feedback;

    /* Calculate feedback according to LFSR taps. XOR all state bytes
     * into a single bit. */
    Feedback  = E0 & (uint8_t) (LFSR_MASK_EVEN );
    Feedback ^= E1 & (uint8_t) (LFSR_MASK_EVEN >> 8);
    83d8:	d3 2f       	mov	r29, r19
    83da:	d0 71       	andi	r29, 0x10	; 16
    83dc:	ed 2e       	mov	r14, r29
{
    uint8_t Feedback;

    /* Calculate feedback according to LFSR taps. XOR all state bytes
     * into a single bit. */
    Feedback  = E0 & (uint8_t) (LFSR_MASK_EVEN );
    83de:	41 2f       	mov	r20, r17
    83e0:	41 7e       	andi	r20, 0xE1	; 225
    Feedback ^= E1 & (uint8_t) (LFSR_MASK_EVEN >> 8);
    83e2:	e4 26       	eor	r14, r20
    Feedback ^= E2 & (uint8_t) (LFSR_MASK_EVEN >> 16);
    83e4:	59 2f       	mov	r21, r25
    83e6:	50 72       	andi	r21, 0x20	; 32
    83e8:	e5 26       	eor	r14, r21

    Feedback ^= O0 & (uint8_t) (LFSR_MASK_ODD );
    83ea:	ce 2f       	mov	r28, r30
    83ec:	c4 79       	andi	r28, 0x94	; 148
    83ee:	ec 26       	eor	r14, r28
    Feedback ^= O1 & (uint8_t) (LFSR_MASK_ODD >> 8);
    83f0:	d8 2f       	mov	r29, r24
    83f2:	d3 77       	andi	r29, 0x73	; 115
    83f4:	ed 26       	eor	r14, r29
    Feedback ^= O2 & (uint8_t) (LFSR_MASK_ODD >> 16);
    83f6:	40 2f       	mov	r20, r16
    83f8:	4a 73       	andi	r20, 0x3A	; 58
    83fa:	e4 26       	eor	r14, r20

    /* fold 8 into 1 bit */
    Feedback ^= ((Feedback >> 4)|(Feedback << 4)); /* Compiler uses a swap for this (fast!) */
    83fc:	fe 2c       	mov	r15, r14
    83fe:	f2 94       	swap	r15
    8400:	ef 24       	eor	r14, r15
    Feedback ^= Feedback >> 2;
    8402:	fe 2c       	mov	r15, r14
    8404:	f6 94       	lsr	r15
    8406:	f6 94       	lsr	r15
    8408:	ef 24       	eor	r14, r15
    840a:	fe 2c       	mov	r15, r14
    840c:	fb 24       	eor	r15, r11
    Feedback ^= Feedback >> 1;
    840e:	e6 94       	lsr	r14
        /* Bit 3 */
        In >>= 1;
        Out = CRYPTO1_FILTER_OUTPUT_B0_24(Even0,Even1,Even2);
        SHIFT8(KeyStream, Out);
        Feedback = Crypto1LFSRbyteFeedback(Odd0,Odd1,Odd2,Even0,Even1,Even2);
        Feedback ^= In;
    8410:	fe 24       	eor	r15, r14
        SHIFT24_COND_DECRYPT(Odd0,Odd1,Odd2, Feedback, Out, Decrypt);
    8412:	20 fd       	sbrc	r18, 0
    8414:	fd 24       	eor	r15, r13
    8416:	f6 94       	lsr	r15
    8418:	97 95       	ror	r25
    841a:	37 95       	ror	r19
    841c:	17 95       	ror	r17

        /* Bit 4 */
        In >>= 1;
    841e:	b6 94       	lsr	r11
        Out = CRYPTO1_FILTER_OUTPUT_B0_24(Odd0, Odd1, Odd2);
    8420:	c3 2e       	mov	r12, r19
    8422:	d1 2c       	mov	r13, r1
    8424:	e6 01       	movw	r28, r12
    8426:	c8 54       	subi	r28, 0x48	; 72
    8428:	de 4d       	sbci	r29, 0xDE	; 222
    842a:	e1 2e       	mov	r14, r17
    842c:	f1 2c       	mov	r15, r1
    842e:	a7 01       	movw	r20, r14
    8430:	48 54       	subi	r20, 0x48	; 72
    8432:	5f 4d       	sbci	r21, 0xDF	; 223
    8434:	d8 80       	ld	r13, Y
    8436:	ea 01       	movw	r28, r20
    8438:	f8 80       	ld	r15, Y
    843a:	ed 2c       	mov	r14, r13
    843c:	ef 28       	or	r14, r15
    843e:	c9 2e       	mov	r12, r25
    8440:	d1 2c       	mov	r13, r1
    8442:	a6 01       	movw	r20, r12
    8444:	48 54       	subi	r20, 0x48	; 72
    8446:	5d 4d       	sbci	r21, 0xDD	; 221
    8448:	ea 01       	movw	r28, r20
    844a:	f8 80       	ld	r15, Y
    844c:	ef 28       	or	r14, r15
    844e:	f1 2c       	mov	r15, r1
    8450:	a7 01       	movw	r20, r14
    8452:	48 56       	subi	r20, 0x68	; 104
    8454:	5f 4d       	sbci	r21, 0xDF	; 223
    8456:	ea 01       	movw	r28, r20
    8458:	d8 80       	ld	r13, Y
        SHIFT8(KeyStream, Out);
    845a:	d6 94       	lsr	r13
    845c:	f7 95       	ror	r31
    uint8_t Feedback;

    /* Calculate feedback according to LFSR taps. XOR all state bytes
     * into a single bit. */
    Feedback  = E0 & (uint8_t) (LFSR_MASK_EVEN );
    Feedback ^= E1 & (uint8_t) (LFSR_MASK_EVEN >> 8);
    845e:	d8 2f       	mov	r29, r24
    8460:	d0 71       	andi	r29, 0x10	; 16
    8462:	ed 2e       	mov	r14, r29
{
    uint8_t Feedback;

    /* Calculate feedback according to LFSR taps. XOR all state bytes
     * into a single bit. */
    Feedback  = E0 & (uint8_t) (LFSR_MASK_EVEN );
    8464:	4e 2f       	mov	r20, r30
    8466:	41 7e       	andi	r20, 0xE1	; 225
    Feedback ^= E1 & (uint8_t) (LFSR_MASK_EVEN >> 8);
    8468:	e4 26       	eor	r14, r20
    Feedback ^= E2 & (uint8_t) (LFSR_MASK_EVEN >> 16);
    846a:	50 2f       	mov	r21, r16
    846c:	50 72       	andi	r21, 0x20	; 32
    846e:	e5 26       	eor	r14, r21

    Feedback ^= O0 & (uint8_t) (LFSR_MASK_ODD );
    8470:	c1 2f       	mov	r28, r17
    8472:	c4 79       	andi	r28, 0x94	; 148
    8474:	ec 26       	eor	r14, r28
    Feedback ^= O1 & (uint8_t) (LFSR_MASK_ODD >> 8);
    8476:	d3 2f       	mov	r29, r19
    8478:	d3 77       	andi	r29, 0x73	; 115
    847a:	ed 26       	eor	r14, r29
    Feedback ^= O2 & (uint8_t) (LFSR_MASK_ODD >> 16);
    847c:	49 2f       	mov	r20, r25
    847e:	4a 73       	andi	r20, 0x3A	; 58
    8480:	e4 26       	eor	r14, r20

    /* fold 8 into 1 bit */
    Feedback ^= ((Feedback >> 4)|(Feedback << 4)); /* Compiler uses a swap for this (fast!) */
    8482:	fe 2c       	mov	r15, r14
    8484:	f2 94       	swap	r15
    8486:	ef 24       	eor	r14, r15
    Feedback ^= Feedback >> 2;
    8488:	fe 2c       	mov	r15, r14
    848a:	f6 94       	lsr	r15
    848c:	f6 94       	lsr	r15
    848e:	ef 24       	eor	r14, r15
    8490:	fe 2c       	mov	r15, r14
    8492:	fb 24       	eor	r15, r11
    Feedback ^= Feedback >> 1;
    8494:	e6 94       	lsr	r14
        /* Bit 4 */
        In >>= 1;
        Out = CRYPTO1_FILTER_OUTPUT_B0_24(Odd0, Odd1, Odd2);
        SHIFT8(KeyStream, Out);
        Feedback  = Crypto1LFSRbyteFeedback(Even0,Even1,Even2,Odd0,Odd1,Odd2);
        Feedback ^= In;
    8496:	fe 24       	eor	r15, r14
        SHIFT24_COND_DECRYPT(Even0,Even1,Even2, Feedback, Out, Decrypt);
    8498:	20 fd       	sbrc	r18, 0
    849a:	fd 24       	eor	r15, r13
    849c:	f6 94       	lsr	r15
    849e:	07 95       	ror	r16
    84a0:	87 95       	ror	r24
    84a2:	e7 95       	ror	r30

        /* Bit 5 */
        In >>= 1;
    84a4:	b6 94       	lsr	r11
        Out = CRYPTO1_FILTER_OUTPUT_B0_24(Even0,Even1,Even2);
    84a6:	c8 2e       	mov	r12, r24
    84a8:	d1 2c       	mov	r13, r1
    84aa:	e6 01       	movw	r28, r12
    84ac:	c8 54       	subi	r28, 0x48	; 72
    84ae:	de 4d       	sbci	r29, 0xDE	; 222
    84b0:	ee 2e       	mov	r14, r30
    84b2:	f1 2c       	mov	r15, r1
    84b4:	a7 01       	movw	r20, r14
    84b6:	48 54       	subi	r20, 0x48	; 72
    84b8:	5f 4d       	sbci	r21, 0xDF	; 223
    84ba:	d8 80       	ld	r13, Y
    84bc:	ea 01       	movw	r28, r20
    84be:	f8 80       	ld	r15, Y
    84c0:	ed 2c       	mov	r14, r13
    84c2:	ef 28       	or	r14, r15
    84c4:	c0 2e       	mov	r12, r16
    84c6:	d1 2c       	mov	r13, r1
    84c8:	a6 01       	movw	r20, r12
    84ca:	48 54       	subi	r20, 0x48	; 72
    84cc:	5d 4d       	sbci	r21, 0xDD	; 221
    84ce:	ea 01       	movw	r28, r20
    84d0:	f8 80       	ld	r15, Y
    84d2:	ef 28       	or	r14, r15
    84d4:	f1 2c       	mov	r15, r1
    84d6:	a7 01       	movw	r20, r14
    84d8:	48 56       	subi	r20, 0x68	; 104
    84da:	5f 4d       	sbci	r21, 0xDF	; 223
    84dc:	ea 01       	movw	r28, r20
    84de:	d8 80       	ld	r13, Y
        SHIFT8(KeyStream, Out);
    84e0:	d6 94       	lsr	r13
    84e2:	f7 95       	ror	r31
    uint8_t Feedback;

    /* Calculate feedback according to LFSR taps. XOR all state bytes
     * into a single bit. */
    Feedback  = E0 & (uint8_t) (LFSR_MASK_EVEN );
    Feedback ^= E1 & (uint8_t) (LFSR_MASK_EVEN >> 8);
    84e4:	d3 2f       	mov	r29, r19
    84e6:	d0 71       	andi	r29, 0x10	; 16
    84e8:	ed 2e       	mov	r14, r29
{
    uint8_t Feedback;

    /* Calculate feedback according to LFSR taps. XOR all state bytes
     * into a single bit. */
    Feedback  = E0 & (uint8_t) (LFSR_MASK_EVEN );
    84ea:	41 2f       	mov	r20, r17
    84ec:	41 7e       	andi	r20, 0xE1	; 225
    Feedback ^= E1 & (uint8_t) (LFSR_MASK_EVEN >> 8);
    84ee:	e4 26       	eor	r14, r20
    Feedback ^= E2 & (uint8_t) (LFSR_MASK_EVEN >> 16);
    84f0:	59 2f       	mov	r21, r25
    84f2:	50 72       	andi	r21, 0x20	; 32
    84f4:	e5 26       	eor	r14, r21

    Feedback ^= O0 & (uint8_t) (LFSR_MASK_ODD );
    84f6:	ce 2f       	mov	r28, r30
    84f8:	c4 79       	andi	r28, 0x94	; 148
    84fa:	ec 26       	eor	r14, r28
    Feedback ^= O1 & (uint8_t) (LFSR_MASK_ODD >> 8);
    84fc:	d8 2f       	mov	r29, r24
    84fe:	d3 77       	andi	r29, 0x73	; 115
    8500:	ed 26       	eor	r14, r29
    Feedback ^= O2 & (uint8_t) (LFSR_MASK_ODD >> 16);
    8502:	40 2f       	mov	r20, r16
    8504:	4a 73       	andi	r20, 0x3A	; 58
    8506:	e4 26       	eor	r14, r20

    /* fold 8 into 1 bit */
    Feedback ^= ((Feedback >> 4)|(Feedback << 4)); /* Compiler uses a swap for this (fast!) */
    8508:	fe 2c       	mov	r15, r14
    850a:	f2 94       	swap	r15
    850c:	ef 24       	eor	r14, r15
    Feedback ^= Feedback >> 2;
    850e:	fe 2c       	mov	r15, r14
    8510:	f6 94       	lsr	r15
    8512:	f6 94       	lsr	r15
    8514:	ef 24       	eor	r14, r15
    8516:	fe 2c       	mov	r15, r14
    8518:	fb 24       	eor	r15, r11
    Feedback ^= Feedback >> 1;
    851a:	e6 94       	lsr	r14
        /* Bit 5 */
        In >>= 1;
        Out = CRYPTO1_FILTER_OUTPUT_B0_24(Even0,Even1,Even2);
        SHIFT8(KeyStream, Out);
        Feedback = Crypto1LFSRbyteFeedback(Odd0,Odd1,Odd2,Even0,Even1,Even2);
        Feedback ^= In;
    851c:	fe 24       	eor	r15, r14
        SHIFT24_COND_DECRYPT(Odd0,Odd1,Odd2, Feedback, Out, Decrypt);
    851e:	20 fd       	sbrc	r18, 0
    8520:	fd 24       	eor	r15, r13
    8522:	f6 94       	lsr	r15
    8524:	97 95       	ror	r25
    8526:	37 95       	ror	r19
    8528:	17 95       	ror	r17

        /* Bit 6 */
        In >>= 1;
    852a:	9b 2c       	mov	r9, r11
    852c:	96 94       	lsr	r9
        Out = CRYPTO1_FILTER_OUTPUT_B0_24(Odd0, Odd1, Odd2);
    852e:	c3 2e       	mov	r12, r19
    8530:	d1 2c       	mov	r13, r1
    8532:	e6 01       	movw	r28, r12
    8534:	c8 54       	subi	r28, 0x48	; 72
    8536:	de 4d       	sbci	r29, 0xDE	; 222
    8538:	e1 2e       	mov	r14, r17
    853a:	f1 2c       	mov	r15, r1
    853c:	a7 01       	movw	r20, r14
    853e:	48 54       	subi	r20, 0x48	; 72
    8540:	5f 4d       	sbci	r21, 0xDF	; 223
    8542:	d8 80       	ld	r13, Y
    8544:	ea 01       	movw	r28, r20
    8546:	f8 80       	ld	r15, Y
    8548:	ed 2c       	mov	r14, r13
    854a:	ef 28       	or	r14, r15
    854c:	c9 2e       	mov	r12, r25
    854e:	d1 2c       	mov	r13, r1
    8550:	a6 01       	movw	r20, r12
    8552:	48 54       	subi	r20, 0x48	; 72
    8554:	5d 4d       	sbci	r21, 0xDD	; 221
    8556:	ea 01       	movw	r28, r20
    8558:	f8 80       	ld	r15, Y
    855a:	ef 28       	or	r14, r15
    855c:	f1 2c       	mov	r15, r1
    855e:	a7 01       	movw	r20, r14
    8560:	48 56       	subi	r20, 0x68	; 104
    8562:	5f 4d       	sbci	r21, 0xDF	; 223
    8564:	ea 01       	movw	r28, r20
    8566:	d8 80       	ld	r13, Y
        SHIFT8(KeyStream, Out);
    8568:	d6 94       	lsr	r13
    856a:	f7 95       	ror	r31
    uint8_t Feedback;

    /* Calculate feedback according to LFSR taps. XOR all state bytes
     * into a single bit. */
    Feedback  = E0 & (uint8_t) (LFSR_MASK_EVEN );
    Feedback ^= E1 & (uint8_t) (LFSR_MASK_EVEN >> 8);
    856c:	d8 2f       	mov	r29, r24
    856e:	d0 71       	andi	r29, 0x10	; 16
{
    uint8_t Feedback;

    /* Calculate feedback according to LFSR taps. XOR all state bytes
     * into a single bit. */
    Feedback  = E0 & (uint8_t) (LFSR_MASK_EVEN );
    8570:	4e 2f       	mov	r20, r30
    8572:	41 7e       	andi	r20, 0xE1	; 225
    8574:	f4 2e       	mov	r15, r20
    Feedback ^= E1 & (uint8_t) (LFSR_MASK_EVEN >> 8);
    8576:	fd 26       	eor	r15, r29
    Feedback ^= E2 & (uint8_t) (LFSR_MASK_EVEN >> 16);
    8578:	50 2f       	mov	r21, r16
    857a:	50 72       	andi	r21, 0x20	; 32
    857c:	f5 26       	eor	r15, r21

    Feedback ^= O0 & (uint8_t) (LFSR_MASK_ODD );
    857e:	c1 2f       	mov	r28, r17
    8580:	c4 79       	andi	r28, 0x94	; 148
    8582:	fc 26       	eor	r15, r28
    Feedback ^= O1 & (uint8_t) (LFSR_MASK_ODD >> 8);
    8584:	d3 2f       	mov	r29, r19
    8586:	d3 77       	andi	r29, 0x73	; 115
    8588:	fd 26       	eor	r15, r29
    Feedback ^= O2 & (uint8_t) (LFSR_MASK_ODD >> 16);
    858a:	49 2f       	mov	r20, r25
    858c:	4a 73       	andi	r20, 0x3A	; 58
    858e:	f4 26       	eor	r15, r20

    /* fold 8 into 1 bit */
    Feedback ^= ((Feedback >> 4)|(Feedback << 4)); /* Compiler uses a swap for this (fast!) */
    8590:	ef 2c       	mov	r14, r15
    8592:	e2 94       	swap	r14
    8594:	fe 24       	eor	r15, r14
    Feedback ^= Feedback >> 2;
    8596:	ef 2c       	mov	r14, r15
    8598:	e6 94       	lsr	r14
    859a:	e6 94       	lsr	r14
    859c:	fe 24       	eor	r15, r14
    859e:	ef 2c       	mov	r14, r15
    85a0:	e9 24       	eor	r14, r9
    Feedback ^= Feedback >> 1;
    85a2:	f6 94       	lsr	r15
        /* Bit 6 */
        In >>= 1;
        Out = CRYPTO1_FILTER_OUTPUT_B0_24(Odd0, Odd1, Odd2);
        SHIFT8(KeyStream, Out);
        Feedback  = Crypto1LFSRbyteFeedback(Even0,Even1,Even2,Odd0,Odd1,Odd2);
        Feedback ^= In;
    85a4:	fe 24       	eor	r15, r14
        SHIFT24_COND_DECRYPT(Even0,Even1,Even2, Feedback, Out, Decrypt);
    85a6:	be 2e       	mov	r11, r30
    85a8:	ef 2d       	mov	r30, r15
    85aa:	20 fd       	sbrc	r18, 0
    85ac:	ed 25       	eor	r30, r13
    85ae:	e6 95       	lsr	r30
    85b0:	07 95       	ror	r16
    85b2:	87 95       	ror	r24
    85b4:	b7 94       	ror	r11

        /* Bit 7 */
        In >>= 1;
        Out = CRYPTO1_FILTER_OUTPUT_B0_24(Even0,Even1,Even2);
    85b6:	c8 2e       	mov	r12, r24
    85b8:	d1 2c       	mov	r13, r1
    85ba:	e6 01       	movw	r28, r12
    85bc:	c8 54       	subi	r28, 0x48	; 72
    85be:	de 4d       	sbci	r29, 0xDE	; 222
    85c0:	eb 2c       	mov	r14, r11
    85c2:	f1 2c       	mov	r15, r1
    85c4:	a7 01       	movw	r20, r14
    85c6:	48 54       	subi	r20, 0x48	; 72
    85c8:	5f 4d       	sbci	r21, 0xDF	; 223
    85ca:	d8 80       	ld	r13, Y
    85cc:	ea 01       	movw	r28, r20
    85ce:	e8 81       	ld	r30, Y
    85d0:	ed 2c       	mov	r14, r13
    85d2:	ee 2a       	or	r14, r30
    85d4:	c0 2e       	mov	r12, r16
    85d6:	d1 2c       	mov	r13, r1
    85d8:	a6 01       	movw	r20, r12
    85da:	48 54       	subi	r20, 0x48	; 72
    85dc:	5d 4d       	sbci	r21, 0xDD	; 221
    85de:	ea 01       	movw	r28, r20
    85e0:	e8 81       	ld	r30, Y
    85e2:	ee 2a       	or	r14, r30
    85e4:	f1 2c       	mov	r15, r1
    85e6:	a7 01       	movw	r20, r14
    85e8:	48 56       	subi	r20, 0x68	; 104
    85ea:	5f 4d       	sbci	r21, 0xDF	; 223
    85ec:	ea 01       	movw	r28, r20
    85ee:	f8 80       	ld	r15, Y
        SHIFT8(KeyStream, Out);
    85f0:	df 2e       	mov	r13, r31
    85f2:	f6 94       	lsr	r15
    85f4:	d7 94       	ror	r13
    uint8_t Feedback;

    /* Calculate feedback according to LFSR taps. XOR all state bytes
     * into a single bit. */
    Feedback  = E0 & (uint8_t) (LFSR_MASK_EVEN );
    Feedback ^= E1 & (uint8_t) (LFSR_MASK_EVEN >> 8);
    85f6:	f3 2f       	mov	r31, r19
    85f8:	f0 71       	andi	r31, 0x10	; 16
{
    uint8_t Feedback;

    /* Calculate feedback according to LFSR taps. XOR all state bytes
     * into a single bit. */
    Feedback  = E0 & (uint8_t) (LFSR_MASK_EVEN );
    85fa:	e1 2f       	mov	r30, r17
    85fc:	e1 7e       	andi	r30, 0xE1	; 225
    Feedback ^= E1 & (uint8_t) (LFSR_MASK_EVEN >> 8);
    85fe:	ef 27       	eor	r30, r31
    Feedback ^= E2 & (uint8_t) (LFSR_MASK_EVEN >> 16);
    8600:	f9 2f       	mov	r31, r25
    8602:	f0 72       	andi	r31, 0x20	; 32
    8604:	ef 27       	eor	r30, r31

    Feedback ^= O0 & (uint8_t) (LFSR_MASK_ODD );
    8606:	fb 2d       	mov	r31, r11
    8608:	f4 79       	andi	r31, 0x94	; 148
    860a:	ef 27       	eor	r30, r31
    Feedback ^= O1 & (uint8_t) (LFSR_MASK_ODD >> 8);
    860c:	f8 2f       	mov	r31, r24
    860e:	f3 77       	andi	r31, 0x73	; 115
    8610:	ef 27       	eor	r30, r31
    Feedback ^= O2 & (uint8_t) (LFSR_MASK_ODD >> 16);
    8612:	f0 2f       	mov	r31, r16
    8614:	fa 73       	andi	r31, 0x3A	; 58
    8616:	ef 27       	eor	r30, r31

    /* fold 8 into 1 bit */
    Feedback ^= ((Feedback >> 4)|(Feedback << 4)); /* Compiler uses a swap for this (fast!) */
    8618:	fe 2f       	mov	r31, r30
    861a:	f2 95       	swap	r31
    861c:	ef 27       	eor	r30, r31
    Feedback ^= Feedback >> 2;
    861e:	fe 2f       	mov	r31, r30
    8620:	f6 95       	lsr	r31
    8622:	f6 95       	lsr	r31
    8624:	ef 27       	eor	r30, r31
        Feedback  = Crypto1LFSRbyteFeedback(Even0,Even1,Even2,Odd0,Odd1,Odd2);
        Feedback ^= In;
        SHIFT24_COND_DECRYPT(Even0,Even1,Even2, Feedback, Out, Decrypt);

        /* Bit 7 */
        In >>= 1;
    8626:	96 94       	lsr	r9
    8628:	9e 26       	eor	r9, r30
    Feedback ^= O2 & (uint8_t) (LFSR_MASK_ODD >> 16);

    /* fold 8 into 1 bit */
    Feedback ^= ((Feedback >> 4)|(Feedback << 4)); /* Compiler uses a swap for this (fast!) */
    Feedback ^= Feedback >> 2;
    Feedback ^= Feedback >> 1;
    862a:	e6 95       	lsr	r30
        /* Bit 7 */
        In >>= 1;
        Out = CRYPTO1_FILTER_OUTPUT_B0_24(Even0,Even1,Even2);
        SHIFT8(KeyStream, Out);
        Feedback = Crypto1LFSRbyteFeedback(Odd0,Odd1,Odd2,Even0,Even1,Even2);
        Feedback ^= In;
    862c:	9e 26       	eor	r9, r30
        SHIFT24_COND_DECRYPT(Odd0,Odd1,Odd2, Feedback, Out, Decrypt);
    862e:	20 fd       	sbrc	r18, 0
    8630:	9f 24       	eor	r9, r15
    8632:	96 94       	lsr	r9
    8634:	97 95       	ror	r25
    8636:	37 95       	ror	r19
    8638:	17 95       	ror	r17

        /* Generate parity bit */
        Out = CRYPTO1_FILTER_OUTPUT_B0_24(Odd0, Odd1, Odd2);
    863a:	e3 2f       	mov	r30, r19
    863c:	f0 e0       	ldi	r31, 0x00	; 0
    863e:	af 01       	movw	r20, r30
    8640:	48 54       	subi	r20, 0x48	; 72
    8642:	5e 4d       	sbci	r21, 0xDE	; 222
    8644:	e1 2f       	mov	r30, r17
    8646:	f0 e0       	ldi	r31, 0x00	; 0
    8648:	e8 54       	subi	r30, 0x48	; 72
    864a:	ff 4d       	sbci	r31, 0xDF	; 223
    864c:	ea 01       	movw	r28, r20
    864e:	f8 80       	ld	r15, Y
    8650:	e0 81       	ld	r30, Z
    8652:	ef 29       	or	r30, r15
    8654:	e9 2e       	mov	r14, r25
    8656:	f1 2c       	mov	r15, r1
    8658:	a7 01       	movw	r20, r14
    865a:	48 54       	subi	r20, 0x48	; 72
    865c:	5d 4d       	sbci	r21, 0xDD	; 221
    865e:	ea 01       	movw	r28, r20
    8660:	f8 81       	ld	r31, Y
    8662:	ef 2b       	or	r30, r31
    8664:	f0 e0       	ldi	r31, 0x00	; 0
    8666:	e8 56       	subi	r30, 0x68	; 104
    8668:	ff 4d       	sbci	r31, 0xDF	; 223
    866a:	e0 80       	ld	r14, Z

INLINE uint8_t OddParityBit(uint8_t Byte)
{
    extern const uint8_t PROGMEM OddParityByteTable[];

    return pgm_read_byte(&OddParityByteTable[Byte]);
    866c:	ea 2d       	mov	r30, r10
    866e:	f0 e0       	ldi	r31, 0x00	; 0
    8670:	e6 54       	subi	r30, 0x46	; 70
    8672:	fa 4f       	sbci	r31, 0xFA	; 250
    8674:	e4 91       	lpm	r30, Z
        In = *CardNonce;
        Feedback = ODD_PARITY(In);
        CardNonce[NONCE_SIZE] = Out ^ Feedback;  /* Encrypted parity at Offset 4*/
    8676:	ee 25       	eor	r30, r14
    8678:	e3 01       	movw	r28, r6
    867a:	e9 93       	st	Y+, r30
    867c:	3e 01       	movw	r6, r28
        
        /* Encrypt byte   */
        *CardNonce++ = In ^ KeyStream; 
    867e:	ad 24       	eor	r10, r13
    8680:	ad 92       	st	X+, r10
    SPLIT_BYTE(Even2, Odd2, KeyStream);

    /* Get first filter output */
    Out = CRYPTO1_FILTER_OUTPUT_B0_24(Odd0, Odd1, Odd2);

    for ( ByteCount = 0; ByteCount < NONCE_SIZE; ByteCount++)
    8682:	a6 17       	cp	r26, r22
    8684:	b7 07       	cpc	r27, r23
    8686:	09 f0       	breq	.+2      	; 0x868a <Crypto1SetupNested+0x5a0>
    8688:	d2 cd       	rjmp	.-1116   	; 0x822e <Crypto1SetupNested+0x144>
        
        /* Encrypt byte   */
        *CardNonce++ = In ^ KeyStream; 
    }
    /* save state */
    State.Even[0] = Even0;
    868a:	b0 92 df 2c 	sts	0x2CDF, r11
    State.Even[1] = Even1;
    868e:	80 93 e0 2c 	sts	0x2CE0, r24
    State.Even[2] = Even2;
    8692:	00 93 e1 2c 	sts	0x2CE1, r16
    State.Odd[0]  = Odd0;
    8696:	10 93 e2 2c 	sts	0x2CE2, r17
    State.Odd[1]  = Odd1;
    869a:	30 93 e3 2c 	sts	0x2CE3, r19
    State.Odd[2]  = Odd2;
    869e:	90 93 e4 2c 	sts	0x2CE4, r25
}
    86a2:	df 91       	pop	r29
    86a4:	cf 91       	pop	r28
    86a6:	1f 91       	pop	r17
    86a8:	0f 91       	pop	r16
    86aa:	ff 90       	pop	r15
    86ac:	ef 90       	pop	r14
    86ae:	df 90       	pop	r13
    86b0:	cf 90       	pop	r12
    86b2:	bf 90       	pop	r11
    86b4:	af 90       	pop	r10
    86b6:	9f 90       	pop	r9
    86b8:	7f 90       	pop	r7
    86ba:	6f 90       	pop	r6
    86bc:	5f 90       	pop	r5
    86be:	4f 90       	pop	r4
    86c0:	08 95       	ret

000086c2 <Crypto1Auth>:

/* Crypto1Auth is similar to Crypto1Byte but */
/* EncryptedReaderNonce is decrypted and fed back */
void Crypto1Auth(uint8_t EncryptedReaderNonce[NONCE_SIZE])
{
    86c2:	af 92       	push	r10
    86c4:	bf 92       	push	r11
    86c6:	cf 92       	push	r12
    86c8:	df 92       	push	r13
    86ca:	ef 92       	push	r14
    86cc:	ff 92       	push	r15
    86ce:	0f 93       	push	r16
    86d0:	1f 93       	push	r17
    86d2:	cf 93       	push	r28
    86d4:	df 93       	push	r29
    uint8_t In;
    uint8_t Feedback;
    uint8_t i;

    /* read state */
    Even0 = State.Even[0];
    86d6:	60 91 df 2c 	lds	r22, 0x2CDF
    Even1 = State.Even[1];
    86da:	50 91 e0 2c 	lds	r21, 0x2CE0
    Even2 = State.Even[2];
    86de:	20 91 e1 2c 	lds	r18, 0x2CE1
    Odd0 = State.Odd[0];
    86e2:	40 91 e2 2c 	lds	r20, 0x2CE2
    Odd1 = State.Odd[1];
    86e6:	30 91 e3 2c 	lds	r19, 0x2CE3
    Odd2 = State.Odd[2];
    86ea:	d0 91 e4 2c 	lds	r29, 0x2CE4
    86ee:	fc 01       	movw	r30, r24
    86f0:	5c 01       	movw	r10, r24
    86f2:	04 e0       	ldi	r16, 0x04	; 4
    86f4:	a0 0e       	add	r10, r16
    86f6:	b1 1c       	adc	r11, r1

    /* 4 Bytes */
    for(i = 0; i < NONCE_SIZE; i++)
    {
        In = EncryptedReaderNonce[i];
    86f8:	81 91       	ld	r24, Z+
    uint8_t Feedback;

    /* Calculate feedback according to LFSR taps. XOR all state bytes
     * into a single bit. */
    Feedback  = E0 & (uint8_t) (LFSR_MASK_EVEN );
    Feedback ^= E1 & (uint8_t) (LFSR_MASK_EVEN >> 8);
    86fa:	c5 2f       	mov	r28, r21
    86fc:	c0 71       	andi	r28, 0x10	; 16
{
    uint8_t Feedback;

    /* Calculate feedback according to LFSR taps. XOR all state bytes
     * into a single bit. */
    Feedback  = E0 & (uint8_t) (LFSR_MASK_EVEN );
    86fe:	96 2f       	mov	r25, r22
    8700:	91 7e       	andi	r25, 0xE1	; 225
    Feedback ^= E1 & (uint8_t) (LFSR_MASK_EVEN >> 8);
    8702:	c9 27       	eor	r28, r25
    Feedback ^= E2 & (uint8_t) (LFSR_MASK_EVEN >> 16);
    8704:	92 2f       	mov	r25, r18
    8706:	90 72       	andi	r25, 0x20	; 32
    8708:	c9 27       	eor	r28, r25

    Feedback ^= O0 & (uint8_t) (LFSR_MASK_ODD );
    870a:	94 2f       	mov	r25, r20
    870c:	94 79       	andi	r25, 0x94	; 148
    870e:	c9 27       	eor	r28, r25
    Feedback ^= O1 & (uint8_t) (LFSR_MASK_ODD >> 8);
    8710:	93 2f       	mov	r25, r19
    8712:	93 77       	andi	r25, 0x73	; 115
    8714:	c9 27       	eor	r28, r25
    Feedback ^= O2 & (uint8_t) (LFSR_MASK_ODD >> 16);
    8716:	9d 2f       	mov	r25, r29
    8718:	9a 73       	andi	r25, 0x3A	; 58
    871a:	c9 27       	eor	r28, r25

    /* fold 8 into 1 bit */
    Feedback ^= ((Feedback >> 4)|(Feedback << 4)); /* Compiler uses a swap for this (fast!) */
    871c:	7c 2f       	mov	r23, r28
    871e:	72 95       	swap	r23
    8720:	c7 27       	eor	r28, r23
    Feedback ^= Feedback >> 2;
    8722:	7c 2f       	mov	r23, r28
    8724:	76 95       	lsr	r23
    8726:	76 95       	lsr	r23
    8728:	c7 27       	eor	r28, r23
    for(i = 0; i < NONCE_SIZE; i++)
    {
        In = EncryptedReaderNonce[i];

        /* Bit 0 */
        Feedback = CRYPTO1_FILTER_OUTPUT_B0_24(Odd0, Odd1, Odd2);
    872a:	a3 2f       	mov	r26, r19
    872c:	b0 e0       	ldi	r27, 0x00	; 0
    872e:	8d 01       	movw	r16, r26
    8730:	08 54       	subi	r16, 0x48	; 72
    8732:	1e 4d       	sbci	r17, 0xDE	; 222
    8734:	68 01       	movw	r12, r16
    8736:	a4 2f       	mov	r26, r20
    8738:	b0 e0       	ldi	r27, 0x00	; 0
    873a:	8d 01       	movw	r16, r26
    873c:	08 54       	subi	r16, 0x48	; 72
    873e:	1f 4d       	sbci	r17, 0xDF	; 223
    8740:	78 01       	movw	r14, r16
    8742:	d6 01       	movw	r26, r12
    8744:	0c 91       	ld	r16, X
    8746:	d7 01       	movw	r26, r14
    8748:	9c 91       	ld	r25, X
    874a:	09 2b       	or	r16, r25
    874c:	ed 2e       	mov	r14, r29
    874e:	f1 2c       	mov	r15, r1
    8750:	d7 01       	movw	r26, r14
    8752:	a8 54       	subi	r26, 0x48	; 72
    8754:	bd 4d       	sbci	r27, 0xDD	; 221
    8756:	9c 91       	ld	r25, X
    8758:	09 2b       	or	r16, r25
    875a:	10 e0       	ldi	r17, 0x00	; 0
    875c:	08 56       	subi	r16, 0x68	; 104
    875e:	1f 4d       	sbci	r17, 0xDF	; 223
    8760:	d8 01       	movw	r26, r16
    8762:	7c 91       	ld	r23, X
    8764:	78 27       	eor	r23, r24
    8766:	7c 27       	eor	r23, r28
    Feedback ^= O2 & (uint8_t) (LFSR_MASK_ODD >> 16);

    /* fold 8 into 1 bit */
    Feedback ^= ((Feedback >> 4)|(Feedback << 4)); /* Compiler uses a swap for this (fast!) */
    Feedback ^= Feedback >> 2;
    Feedback ^= Feedback >> 1;
    8768:	c6 95       	lsr	r28
    {
        In = EncryptedReaderNonce[i];

        /* Bit 0 */
        Feedback = CRYPTO1_FILTER_OUTPUT_B0_24(Odd0, Odd1, Odd2);
        Feedback  = Crypto1LFSRbyteFeedback(Even0,Even1,Even2,Odd0,Odd1,Odd2)
    876a:	7c 27       	eor	r23, r28
                   ^ Feedback
                   ^ In;
        In >>= 1;
    876c:	86 95       	lsr	r24
        SHIFT24(Even0,Even1,Even2, Feedback);
    876e:	76 95       	lsr	r23
    8770:	27 95       	ror	r18
    8772:	57 95       	ror	r21
    8774:	67 95       	ror	r22
    uint8_t Feedback;

    /* Calculate feedback according to LFSR taps. XOR all state bytes
     * into a single bit. */
    Feedback  = E0 & (uint8_t) (LFSR_MASK_EVEN );
    Feedback ^= E1 & (uint8_t) (LFSR_MASK_EVEN >> 8);
    8776:	c3 2f       	mov	r28, r19
    8778:	c0 71       	andi	r28, 0x10	; 16
{
    uint8_t Feedback;

    /* Calculate feedback according to LFSR taps. XOR all state bytes
     * into a single bit. */
    Feedback  = E0 & (uint8_t) (LFSR_MASK_EVEN );
    877a:	94 2f       	mov	r25, r20
    877c:	91 7e       	andi	r25, 0xE1	; 225
    Feedback ^= E1 & (uint8_t) (LFSR_MASK_EVEN >> 8);
    877e:	c9 27       	eor	r28, r25
    Feedback ^= E2 & (uint8_t) (LFSR_MASK_EVEN >> 16);
    8780:	9d 2f       	mov	r25, r29
    8782:	90 72       	andi	r25, 0x20	; 32
    8784:	c9 27       	eor	r28, r25

    Feedback ^= O0 & (uint8_t) (LFSR_MASK_ODD );
    8786:	96 2f       	mov	r25, r22
    8788:	94 79       	andi	r25, 0x94	; 148
    878a:	c9 27       	eor	r28, r25
    Feedback ^= O1 & (uint8_t) (LFSR_MASK_ODD >> 8);
    878c:	95 2f       	mov	r25, r21
    878e:	93 77       	andi	r25, 0x73	; 115
    8790:	c9 27       	eor	r28, r25
    Feedback ^= O2 & (uint8_t) (LFSR_MASK_ODD >> 16);
    8792:	92 2f       	mov	r25, r18
    8794:	9a 73       	andi	r25, 0x3A	; 58
    8796:	c9 27       	eor	r28, r25

    /* fold 8 into 1 bit */
    Feedback ^= ((Feedback >> 4)|(Feedback << 4)); /* Compiler uses a swap for this (fast!) */
    8798:	7c 2f       	mov	r23, r28
    879a:	72 95       	swap	r23
    879c:	c7 27       	eor	r28, r23
    Feedback ^= Feedback >> 2;
    879e:	7c 2f       	mov	r23, r28
    87a0:	76 95       	lsr	r23
    87a2:	76 95       	lsr	r23
    87a4:	c7 27       	eor	r28, r23
        In >>= 1;
        SHIFT24(Even0,Even1,Even2, Feedback);

        /* Bit 1 */
        /* remember Odd/Even swap has been omitted! */
        Feedback = CRYPTO1_FILTER_OUTPUT_B0_24(Even0,Even1,Even2);
    87a6:	05 2f       	mov	r16, r21
    87a8:	10 e0       	ldi	r17, 0x00	; 0
    87aa:	d8 01       	movw	r26, r16
    87ac:	a8 54       	subi	r26, 0x48	; 72
    87ae:	be 4d       	sbci	r27, 0xDE	; 222
    87b0:	6d 01       	movw	r12, r26
    87b2:	06 2f       	mov	r16, r22
    87b4:	10 e0       	ldi	r17, 0x00	; 0
    87b6:	d8 01       	movw	r26, r16
    87b8:	a8 54       	subi	r26, 0x48	; 72
    87ba:	bf 4d       	sbci	r27, 0xDF	; 223
    87bc:	7d 01       	movw	r14, r26
    87be:	d6 01       	movw	r26, r12
    87c0:	0c 91       	ld	r16, X
    87c2:	d7 01       	movw	r26, r14
    87c4:	9c 91       	ld	r25, X
    87c6:	09 2b       	or	r16, r25
    87c8:	e2 2e       	mov	r14, r18
    87ca:	f1 2c       	mov	r15, r1
    87cc:	d7 01       	movw	r26, r14
    87ce:	a8 54       	subi	r26, 0x48	; 72
    87d0:	bd 4d       	sbci	r27, 0xDD	; 221
    87d2:	9c 91       	ld	r25, X
    87d4:	09 2b       	or	r16, r25
    87d6:	10 e0       	ldi	r17, 0x00	; 0
    87d8:	08 56       	subi	r16, 0x68	; 104
    87da:	1f 4d       	sbci	r17, 0xDF	; 223
    87dc:	d8 01       	movw	r26, r16
    87de:	7c 91       	ld	r23, X
    87e0:	78 27       	eor	r23, r24
    87e2:	7c 27       	eor	r23, r28
    Feedback ^= O2 & (uint8_t) (LFSR_MASK_ODD >> 16);

    /* fold 8 into 1 bit */
    Feedback ^= ((Feedback >> 4)|(Feedback << 4)); /* Compiler uses a swap for this (fast!) */
    Feedback ^= Feedback >> 2;
    Feedback ^= Feedback >> 1;
    87e4:	c6 95       	lsr	r28
        SHIFT24(Even0,Even1,Even2, Feedback);

        /* Bit 1 */
        /* remember Odd/Even swap has been omitted! */
        Feedback = CRYPTO1_FILTER_OUTPUT_B0_24(Even0,Even1,Even2);
        Feedback = Crypto1LFSRbyteFeedback(Odd0,Odd1,Odd2,Even0,Even1,Even2)
    87e6:	7c 27       	eor	r23, r28
                   ^ Feedback
                   ^ In;
        In >>= 1;
    87e8:	86 95       	lsr	r24
        SHIFT24(Odd0,Odd1,Odd2, Feedback);
    87ea:	9d 2f       	mov	r25, r29
    87ec:	76 95       	lsr	r23
    87ee:	97 95       	ror	r25
    87f0:	37 95       	ror	r19
    87f2:	47 95       	ror	r20
    uint8_t Feedback;

    /* Calculate feedback according to LFSR taps. XOR all state bytes
     * into a single bit. */
    Feedback  = E0 & (uint8_t) (LFSR_MASK_EVEN );
    Feedback ^= E1 & (uint8_t) (LFSR_MASK_EVEN >> 8);
    87f4:	c5 2f       	mov	r28, r21
    87f6:	c0 71       	andi	r28, 0x10	; 16
{
    uint8_t Feedback;

    /* Calculate feedback according to LFSR taps. XOR all state bytes
     * into a single bit. */
    Feedback  = E0 & (uint8_t) (LFSR_MASK_EVEN );
    87f8:	76 2f       	mov	r23, r22
    87fa:	71 7e       	andi	r23, 0xE1	; 225
    Feedback ^= E1 & (uint8_t) (LFSR_MASK_EVEN >> 8);
    87fc:	c7 27       	eor	r28, r23
    Feedback ^= E2 & (uint8_t) (LFSR_MASK_EVEN >> 16);
    87fe:	72 2f       	mov	r23, r18
    8800:	70 72       	andi	r23, 0x20	; 32
    8802:	c7 27       	eor	r28, r23

    Feedback ^= O0 & (uint8_t) (LFSR_MASK_ODD );
    8804:	74 2f       	mov	r23, r20
    8806:	74 79       	andi	r23, 0x94	; 148
    8808:	c7 27       	eor	r28, r23
    Feedback ^= O1 & (uint8_t) (LFSR_MASK_ODD >> 8);
    880a:	73 2f       	mov	r23, r19
    880c:	73 77       	andi	r23, 0x73	; 115
    880e:	c7 27       	eor	r28, r23
    Feedback ^= O2 & (uint8_t) (LFSR_MASK_ODD >> 16);
    8810:	79 2f       	mov	r23, r25
    8812:	7a 73       	andi	r23, 0x3A	; 58
    8814:	c7 27       	eor	r28, r23

    /* fold 8 into 1 bit */
    Feedback ^= ((Feedback >> 4)|(Feedback << 4)); /* Compiler uses a swap for this (fast!) */
    8816:	7c 2f       	mov	r23, r28
    8818:	72 95       	swap	r23
    881a:	c7 27       	eor	r28, r23
    Feedback ^= Feedback >> 2;
    881c:	7c 2f       	mov	r23, r28
    881e:	76 95       	lsr	r23
    8820:	76 95       	lsr	r23
    8822:	c7 27       	eor	r28, r23
                   ^ In;
        In >>= 1;
        SHIFT24(Odd0,Odd1,Odd2, Feedback);

        /* Bit 2 */
        Feedback = CRYPTO1_FILTER_OUTPUT_B0_24(Odd0, Odd1, Odd2);
    8824:	03 2f       	mov	r16, r19
    8826:	10 e0       	ldi	r17, 0x00	; 0
    8828:	d8 01       	movw	r26, r16
    882a:	a8 54       	subi	r26, 0x48	; 72
    882c:	be 4d       	sbci	r27, 0xDE	; 222
    882e:	6d 01       	movw	r12, r26
    8830:	04 2f       	mov	r16, r20
    8832:	10 e0       	ldi	r17, 0x00	; 0
    8834:	d8 01       	movw	r26, r16
    8836:	a8 54       	subi	r26, 0x48	; 72
    8838:	bf 4d       	sbci	r27, 0xDF	; 223
    883a:	7d 01       	movw	r14, r26
    883c:	d6 01       	movw	r26, r12
    883e:	0c 91       	ld	r16, X
    8840:	d7 01       	movw	r26, r14
    8842:	7c 91       	ld	r23, X
    8844:	07 2b       	or	r16, r23
    8846:	e9 2e       	mov	r14, r25
    8848:	f1 2c       	mov	r15, r1
    884a:	d7 01       	movw	r26, r14
    884c:	a8 54       	subi	r26, 0x48	; 72
    884e:	bd 4d       	sbci	r27, 0xDD	; 221
    8850:	7c 91       	ld	r23, X
    8852:	07 2b       	or	r16, r23
    8854:	10 e0       	ldi	r17, 0x00	; 0
    8856:	08 56       	subi	r16, 0x68	; 104
    8858:	1f 4d       	sbci	r17, 0xDF	; 223
    885a:	d8 01       	movw	r26, r16
    885c:	7c 91       	ld	r23, X
    885e:	78 27       	eor	r23, r24
    8860:	7c 27       	eor	r23, r28
    Feedback ^= O2 & (uint8_t) (LFSR_MASK_ODD >> 16);

    /* fold 8 into 1 bit */
    Feedback ^= ((Feedback >> 4)|(Feedback << 4)); /* Compiler uses a swap for this (fast!) */
    Feedback ^= Feedback >> 2;
    Feedback ^= Feedback >> 1;
    8862:	c6 95       	lsr	r28
        In >>= 1;
        SHIFT24(Odd0,Odd1,Odd2, Feedback);

        /* Bit 2 */
        Feedback = CRYPTO1_FILTER_OUTPUT_B0_24(Odd0, Odd1, Odd2);
        Feedback  = Crypto1LFSRbyteFeedback(Even0,Even1,Even2,Odd0,Odd1,Odd2)
    8864:	7c 27       	eor	r23, r28
                   ^ Feedback
                   ^ In;
        In >>= 1;
    8866:	86 95       	lsr	r24
        SHIFT24(Even0,Even1,Even2, Feedback);
    8868:	76 95       	lsr	r23
    886a:	27 95       	ror	r18
    886c:	57 95       	ror	r21
    886e:	67 95       	ror	r22
    uint8_t Feedback;

    /* Calculate feedback according to LFSR taps. XOR all state bytes
     * into a single bit. */
    Feedback  = E0 & (uint8_t) (LFSR_MASK_EVEN );
    Feedback ^= E1 & (uint8_t) (LFSR_MASK_EVEN >> 8);
    8870:	c3 2f       	mov	r28, r19
    8872:	c0 71       	andi	r28, 0x10	; 16
{
    uint8_t Feedback;

    /* Calculate feedback according to LFSR taps. XOR all state bytes
     * into a single bit. */
    Feedback  = E0 & (uint8_t) (LFSR_MASK_EVEN );
    8874:	74 2f       	mov	r23, r20
    8876:	71 7e       	andi	r23, 0xE1	; 225
    Feedback ^= E1 & (uint8_t) (LFSR_MASK_EVEN >> 8);
    8878:	c7 27       	eor	r28, r23
    Feedback ^= E2 & (uint8_t) (LFSR_MASK_EVEN >> 16);
    887a:	79 2f       	mov	r23, r25
    887c:	70 72       	andi	r23, 0x20	; 32
    887e:	c7 27       	eor	r28, r23

    Feedback ^= O0 & (uint8_t) (LFSR_MASK_ODD );
    8880:	76 2f       	mov	r23, r22
    8882:	74 79       	andi	r23, 0x94	; 148
    8884:	c7 27       	eor	r28, r23
    Feedback ^= O1 & (uint8_t) (LFSR_MASK_ODD >> 8);
    8886:	75 2f       	mov	r23, r21
    8888:	73 77       	andi	r23, 0x73	; 115
    888a:	c7 27       	eor	r28, r23
    Feedback ^= O2 & (uint8_t) (LFSR_MASK_ODD >> 16);
    888c:	72 2f       	mov	r23, r18
    888e:	7a 73       	andi	r23, 0x3A	; 58
    8890:	c7 27       	eor	r28, r23

    /* fold 8 into 1 bit */
    Feedback ^= ((Feedback >> 4)|(Feedback << 4)); /* Compiler uses a swap for this (fast!) */
    8892:	7c 2f       	mov	r23, r28
    8894:	72 95       	swap	r23
    8896:	c7 27       	eor	r28, r23
    Feedback ^= Feedback >> 2;
    8898:	7c 2f       	mov	r23, r28
    889a:	76 95       	lsr	r23
    889c:	76 95       	lsr	r23
    889e:	c7 27       	eor	r28, r23
                   ^ In;
        In >>= 1;
        SHIFT24(Even0,Even1,Even2, Feedback);

        /* Bit 3 */
        Feedback = CRYPTO1_FILTER_OUTPUT_B0_24(Even0,Even1,Even2);
    88a0:	05 2f       	mov	r16, r21
    88a2:	10 e0       	ldi	r17, 0x00	; 0
    88a4:	d8 01       	movw	r26, r16
    88a6:	a8 54       	subi	r26, 0x48	; 72
    88a8:	be 4d       	sbci	r27, 0xDE	; 222
    88aa:	6d 01       	movw	r12, r26
    88ac:	06 2f       	mov	r16, r22
    88ae:	10 e0       	ldi	r17, 0x00	; 0
    88b0:	d8 01       	movw	r26, r16
    88b2:	a8 54       	subi	r26, 0x48	; 72
    88b4:	bf 4d       	sbci	r27, 0xDF	; 223
    88b6:	7d 01       	movw	r14, r26
    88b8:	d6 01       	movw	r26, r12
    88ba:	0c 91       	ld	r16, X
    88bc:	d7 01       	movw	r26, r14
    88be:	7c 91       	ld	r23, X
    88c0:	07 2b       	or	r16, r23
    88c2:	e2 2e       	mov	r14, r18
    88c4:	f1 2c       	mov	r15, r1
    88c6:	d7 01       	movw	r26, r14
    88c8:	a8 54       	subi	r26, 0x48	; 72
    88ca:	bd 4d       	sbci	r27, 0xDD	; 221
    88cc:	7c 91       	ld	r23, X
    88ce:	07 2b       	or	r16, r23
    88d0:	10 e0       	ldi	r17, 0x00	; 0
    88d2:	08 56       	subi	r16, 0x68	; 104
    88d4:	1f 4d       	sbci	r17, 0xDF	; 223
    88d6:	d8 01       	movw	r26, r16
    88d8:	7c 91       	ld	r23, X
    88da:	78 27       	eor	r23, r24
    88dc:	7c 27       	eor	r23, r28
    Feedback ^= O2 & (uint8_t) (LFSR_MASK_ODD >> 16);

    /* fold 8 into 1 bit */
    Feedback ^= ((Feedback >> 4)|(Feedback << 4)); /* Compiler uses a swap for this (fast!) */
    Feedback ^= Feedback >> 2;
    Feedback ^= Feedback >> 1;
    88de:	c6 95       	lsr	r28
        In >>= 1;
        SHIFT24(Even0,Even1,Even2, Feedback);

        /* Bit 3 */
        Feedback = CRYPTO1_FILTER_OUTPUT_B0_24(Even0,Even1,Even2);
        Feedback = Crypto1LFSRbyteFeedback(Odd0,Odd1,Odd2,Even0,Even1,Even2)
    88e0:	7c 27       	eor	r23, r28
                   ^ Feedback
                   ^ In;
        In >>= 1;
    88e2:	86 95       	lsr	r24
        SHIFT24(Odd0,Odd1,Odd2, Feedback);
    88e4:	76 95       	lsr	r23
    88e6:	97 95       	ror	r25
    88e8:	37 95       	ror	r19
    88ea:	47 95       	ror	r20
    uint8_t Feedback;

    /* Calculate feedback according to LFSR taps. XOR all state bytes
     * into a single bit. */
    Feedback  = E0 & (uint8_t) (LFSR_MASK_EVEN );
    Feedback ^= E1 & (uint8_t) (LFSR_MASK_EVEN >> 8);
    88ec:	c5 2f       	mov	r28, r21
    88ee:	c0 71       	andi	r28, 0x10	; 16
{
    uint8_t Feedback;

    /* Calculate feedback according to LFSR taps. XOR all state bytes
     * into a single bit. */
    Feedback  = E0 & (uint8_t) (LFSR_MASK_EVEN );
    88f0:	76 2f       	mov	r23, r22
    88f2:	71 7e       	andi	r23, 0xE1	; 225
    Feedback ^= E1 & (uint8_t) (LFSR_MASK_EVEN >> 8);
    88f4:	c7 27       	eor	r28, r23
    Feedback ^= E2 & (uint8_t) (LFSR_MASK_EVEN >> 16);
    88f6:	72 2f       	mov	r23, r18
    88f8:	70 72       	andi	r23, 0x20	; 32
    88fa:	c7 27       	eor	r28, r23

    Feedback ^= O0 & (uint8_t) (LFSR_MASK_ODD );
    88fc:	74 2f       	mov	r23, r20
    88fe:	74 79       	andi	r23, 0x94	; 148
    8900:	c7 27       	eor	r28, r23
    Feedback ^= O1 & (uint8_t) (LFSR_MASK_ODD >> 8);
    8902:	73 2f       	mov	r23, r19
    8904:	73 77       	andi	r23, 0x73	; 115
    8906:	c7 27       	eor	r28, r23
    Feedback ^= O2 & (uint8_t) (LFSR_MASK_ODD >> 16);
    8908:	79 2f       	mov	r23, r25
    890a:	7a 73       	andi	r23, 0x3A	; 58
    890c:	c7 27       	eor	r28, r23

    /* fold 8 into 1 bit */
    Feedback ^= ((Feedback >> 4)|(Feedback << 4)); /* Compiler uses a swap for this (fast!) */
    890e:	7c 2f       	mov	r23, r28
    8910:	72 95       	swap	r23
    8912:	c7 27       	eor	r28, r23
    Feedback ^= Feedback >> 2;
    8914:	7c 2f       	mov	r23, r28
    8916:	76 95       	lsr	r23
    8918:	76 95       	lsr	r23
    891a:	c7 27       	eor	r28, r23
                   ^ In;
        In >>= 1;
        SHIFT24(Odd0,Odd1,Odd2, Feedback);

        /* Bit 4 */
        Feedback = CRYPTO1_FILTER_OUTPUT_B0_24(Odd0, Odd1, Odd2);
    891c:	03 2f       	mov	r16, r19
    891e:	10 e0       	ldi	r17, 0x00	; 0
    8920:	d8 01       	movw	r26, r16
    8922:	a8 54       	subi	r26, 0x48	; 72
    8924:	be 4d       	sbci	r27, 0xDE	; 222
    8926:	6d 01       	movw	r12, r26
    8928:	04 2f       	mov	r16, r20
    892a:	10 e0       	ldi	r17, 0x00	; 0
    892c:	d8 01       	movw	r26, r16
    892e:	a8 54       	subi	r26, 0x48	; 72
    8930:	bf 4d       	sbci	r27, 0xDF	; 223
    8932:	7d 01       	movw	r14, r26
    8934:	d6 01       	movw	r26, r12
    8936:	0c 91       	ld	r16, X
    8938:	d7 01       	movw	r26, r14
    893a:	7c 91       	ld	r23, X
    893c:	07 2b       	or	r16, r23
    893e:	e9 2e       	mov	r14, r25
    8940:	f1 2c       	mov	r15, r1
    8942:	d7 01       	movw	r26, r14
    8944:	a8 54       	subi	r26, 0x48	; 72
    8946:	bd 4d       	sbci	r27, 0xDD	; 221
    8948:	7c 91       	ld	r23, X
    894a:	07 2b       	or	r16, r23
    894c:	10 e0       	ldi	r17, 0x00	; 0
    894e:	08 56       	subi	r16, 0x68	; 104
    8950:	1f 4d       	sbci	r17, 0xDF	; 223
    8952:	d8 01       	movw	r26, r16
    8954:	7c 91       	ld	r23, X
    8956:	78 27       	eor	r23, r24
    8958:	7c 27       	eor	r23, r28
    Feedback ^= O2 & (uint8_t) (LFSR_MASK_ODD >> 16);

    /* fold 8 into 1 bit */
    Feedback ^= ((Feedback >> 4)|(Feedback << 4)); /* Compiler uses a swap for this (fast!) */
    Feedback ^= Feedback >> 2;
    Feedback ^= Feedback >> 1;
    895a:	c6 95       	lsr	r28
        In >>= 1;
        SHIFT24(Odd0,Odd1,Odd2, Feedback);

        /* Bit 4 */
        Feedback = CRYPTO1_FILTER_OUTPUT_B0_24(Odd0, Odd1, Odd2);
        Feedback  = Crypto1LFSRbyteFeedback(Even0,Even1,Even2,Odd0,Odd1,Odd2)
    895c:	7c 27       	eor	r23, r28
                   ^ Feedback
                   ^ In;
        In >>= 1;
    895e:	86 95       	lsr	r24
        SHIFT24(Even0,Even1,Even2, Feedback);
    8960:	76 95       	lsr	r23
    8962:	27 95       	ror	r18
    8964:	57 95       	ror	r21
    8966:	67 95       	ror	r22
    uint8_t Feedback;

    /* Calculate feedback according to LFSR taps. XOR all state bytes
     * into a single bit. */
    Feedback  = E0 & (uint8_t) (LFSR_MASK_EVEN );
    Feedback ^= E1 & (uint8_t) (LFSR_MASK_EVEN >> 8);
    8968:	c3 2f       	mov	r28, r19
    896a:	c0 71       	andi	r28, 0x10	; 16
{
    uint8_t Feedback;

    /* Calculate feedback according to LFSR taps. XOR all state bytes
     * into a single bit. */
    Feedback  = E0 & (uint8_t) (LFSR_MASK_EVEN );
    896c:	74 2f       	mov	r23, r20
    896e:	71 7e       	andi	r23, 0xE1	; 225
    Feedback ^= E1 & (uint8_t) (LFSR_MASK_EVEN >> 8);
    8970:	c7 27       	eor	r28, r23
    Feedback ^= E2 & (uint8_t) (LFSR_MASK_EVEN >> 16);
    8972:	79 2f       	mov	r23, r25
    8974:	70 72       	andi	r23, 0x20	; 32
    8976:	c7 27       	eor	r28, r23

    Feedback ^= O0 & (uint8_t) (LFSR_MASK_ODD );
    8978:	76 2f       	mov	r23, r22
    897a:	74 79       	andi	r23, 0x94	; 148
    897c:	c7 27       	eor	r28, r23
    Feedback ^= O1 & (uint8_t) (LFSR_MASK_ODD >> 8);
    897e:	75 2f       	mov	r23, r21
    8980:	73 77       	andi	r23, 0x73	; 115
    8982:	c7 27       	eor	r28, r23
    Feedback ^= O2 & (uint8_t) (LFSR_MASK_ODD >> 16);
    8984:	72 2f       	mov	r23, r18
    8986:	7a 73       	andi	r23, 0x3A	; 58
    8988:	c7 27       	eor	r28, r23

    /* fold 8 into 1 bit */
    Feedback ^= ((Feedback >> 4)|(Feedback << 4)); /* Compiler uses a swap for this (fast!) */
    898a:	7c 2f       	mov	r23, r28
    898c:	72 95       	swap	r23
    898e:	c7 27       	eor	r28, r23
    Feedback ^= Feedback >> 2;
    8990:	7c 2f       	mov	r23, r28
    8992:	76 95       	lsr	r23
    8994:	76 95       	lsr	r23
    8996:	c7 27       	eor	r28, r23
                   ^ In;
        In >>= 1;
        SHIFT24(Even0,Even1,Even2, Feedback);

        /* Bit 5 */
        Feedback = CRYPTO1_FILTER_OUTPUT_B0_24(Even0,Even1,Even2);
    8998:	05 2f       	mov	r16, r21
    899a:	10 e0       	ldi	r17, 0x00	; 0
    899c:	d8 01       	movw	r26, r16
    899e:	a8 54       	subi	r26, 0x48	; 72
    89a0:	be 4d       	sbci	r27, 0xDE	; 222
    89a2:	6d 01       	movw	r12, r26
    89a4:	06 2f       	mov	r16, r22
    89a6:	10 e0       	ldi	r17, 0x00	; 0
    89a8:	d8 01       	movw	r26, r16
    89aa:	a8 54       	subi	r26, 0x48	; 72
    89ac:	bf 4d       	sbci	r27, 0xDF	; 223
    89ae:	7d 01       	movw	r14, r26
    89b0:	d6 01       	movw	r26, r12
    89b2:	0c 91       	ld	r16, X
    89b4:	d7 01       	movw	r26, r14
    89b6:	7c 91       	ld	r23, X
    89b8:	07 2b       	or	r16, r23
    89ba:	e2 2e       	mov	r14, r18
    89bc:	f1 2c       	mov	r15, r1
    89be:	d7 01       	movw	r26, r14
    89c0:	a8 54       	subi	r26, 0x48	; 72
    89c2:	bd 4d       	sbci	r27, 0xDD	; 221
    89c4:	7c 91       	ld	r23, X
    89c6:	07 2b       	or	r16, r23
    89c8:	10 e0       	ldi	r17, 0x00	; 0
    89ca:	08 56       	subi	r16, 0x68	; 104
    89cc:	1f 4d       	sbci	r17, 0xDF	; 223
    89ce:	d8 01       	movw	r26, r16
    89d0:	7c 91       	ld	r23, X
    89d2:	78 27       	eor	r23, r24
    89d4:	7c 27       	eor	r23, r28
    Feedback ^= O2 & (uint8_t) (LFSR_MASK_ODD >> 16);

    /* fold 8 into 1 bit */
    Feedback ^= ((Feedback >> 4)|(Feedback << 4)); /* Compiler uses a swap for this (fast!) */
    Feedback ^= Feedback >> 2;
    Feedback ^= Feedback >> 1;
    89d6:	c6 95       	lsr	r28
        In >>= 1;
        SHIFT24(Even0,Even1,Even2, Feedback);

        /* Bit 5 */
        Feedback = CRYPTO1_FILTER_OUTPUT_B0_24(Even0,Even1,Even2);
        Feedback = Crypto1LFSRbyteFeedback(Odd0,Odd1,Odd2,Even0,Even1,Even2)
    89d8:	7c 27       	eor	r23, r28
                   ^ Feedback
                   ^ In;
        In >>= 1;
    89da:	86 95       	lsr	r24
        SHIFT24(Odd0,Odd1,Odd2, Feedback);
    89dc:	76 95       	lsr	r23
    89de:	97 95       	ror	r25
    89e0:	37 95       	ror	r19
    89e2:	47 95       	ror	r20
    uint8_t Feedback;

    /* Calculate feedback according to LFSR taps. XOR all state bytes
     * into a single bit. */
    Feedback  = E0 & (uint8_t) (LFSR_MASK_EVEN );
    Feedback ^= E1 & (uint8_t) (LFSR_MASK_EVEN >> 8);
    89e4:	c5 2f       	mov	r28, r21
    89e6:	c0 71       	andi	r28, 0x10	; 16
{
    uint8_t Feedback;

    /* Calculate feedback according to LFSR taps. XOR all state bytes
     * into a single bit. */
    Feedback  = E0 & (uint8_t) (LFSR_MASK_EVEN );
    89e8:	76 2f       	mov	r23, r22
    89ea:	71 7e       	andi	r23, 0xE1	; 225
    Feedback ^= E1 & (uint8_t) (LFSR_MASK_EVEN >> 8);
    89ec:	c7 27       	eor	r28, r23
    Feedback ^= E2 & (uint8_t) (LFSR_MASK_EVEN >> 16);
    89ee:	72 2f       	mov	r23, r18
    89f0:	70 72       	andi	r23, 0x20	; 32
    89f2:	c7 27       	eor	r28, r23

    Feedback ^= O0 & (uint8_t) (LFSR_MASK_ODD );
    89f4:	74 2f       	mov	r23, r20
    89f6:	74 79       	andi	r23, 0x94	; 148
    89f8:	c7 27       	eor	r28, r23
    Feedback ^= O1 & (uint8_t) (LFSR_MASK_ODD >> 8);
    89fa:	73 2f       	mov	r23, r19
    89fc:	73 77       	andi	r23, 0x73	; 115
    89fe:	c7 27       	eor	r28, r23
    Feedback ^= O2 & (uint8_t) (LFSR_MASK_ODD >> 16);
    8a00:	79 2f       	mov	r23, r25
    8a02:	7a 73       	andi	r23, 0x3A	; 58
    8a04:	c7 27       	eor	r28, r23

    /* fold 8 into 1 bit */
    Feedback ^= ((Feedback >> 4)|(Feedback << 4)); /* Compiler uses a swap for this (fast!) */
    8a06:	7c 2f       	mov	r23, r28
    8a08:	72 95       	swap	r23
    8a0a:	c7 27       	eor	r28, r23
    Feedback ^= Feedback >> 2;
    8a0c:	7c 2f       	mov	r23, r28
    8a0e:	76 95       	lsr	r23
    8a10:	76 95       	lsr	r23
    8a12:	c7 27       	eor	r28, r23
                   ^ In;
        In >>= 1;
        SHIFT24(Odd0,Odd1,Odd2, Feedback);

        /* Bit 6 */
        Feedback = CRYPTO1_FILTER_OUTPUT_B0_24(Odd0, Odd1, Odd2);
    8a14:	03 2f       	mov	r16, r19
    8a16:	10 e0       	ldi	r17, 0x00	; 0
    8a18:	d8 01       	movw	r26, r16
    8a1a:	a8 54       	subi	r26, 0x48	; 72
    8a1c:	be 4d       	sbci	r27, 0xDE	; 222
    8a1e:	6d 01       	movw	r12, r26
    8a20:	04 2f       	mov	r16, r20
    8a22:	10 e0       	ldi	r17, 0x00	; 0
    8a24:	d8 01       	movw	r26, r16
    8a26:	a8 54       	subi	r26, 0x48	; 72
    8a28:	bf 4d       	sbci	r27, 0xDF	; 223
    8a2a:	7d 01       	movw	r14, r26
    8a2c:	d6 01       	movw	r26, r12
    8a2e:	0c 91       	ld	r16, X
    8a30:	d7 01       	movw	r26, r14
    8a32:	7c 91       	ld	r23, X
    8a34:	07 2b       	or	r16, r23
    8a36:	e9 2e       	mov	r14, r25
    8a38:	f1 2c       	mov	r15, r1
    8a3a:	d7 01       	movw	r26, r14
    8a3c:	a8 54       	subi	r26, 0x48	; 72
    8a3e:	bd 4d       	sbci	r27, 0xDD	; 221
    8a40:	7c 91       	ld	r23, X
    8a42:	07 2b       	or	r16, r23
    8a44:	10 e0       	ldi	r17, 0x00	; 0
    8a46:	08 56       	subi	r16, 0x68	; 104
    8a48:	1f 4d       	sbci	r17, 0xDF	; 223
    8a4a:	d8 01       	movw	r26, r16
    8a4c:	7c 91       	ld	r23, X
    8a4e:	78 27       	eor	r23, r24
    8a50:	7c 27       	eor	r23, r28
    Feedback ^= O2 & (uint8_t) (LFSR_MASK_ODD >> 16);

    /* fold 8 into 1 bit */
    Feedback ^= ((Feedback >> 4)|(Feedback << 4)); /* Compiler uses a swap for this (fast!) */
    Feedback ^= Feedback >> 2;
    Feedback ^= Feedback >> 1;
    8a52:	c6 95       	lsr	r28
        In >>= 1;
        SHIFT24(Odd0,Odd1,Odd2, Feedback);

        /* Bit 6 */
        Feedback = CRYPTO1_FILTER_OUTPUT_B0_24(Odd0, Odd1, Odd2);
        Feedback  = Crypto1LFSRbyteFeedback(Even0,Even1,Even2,Odd0,Odd1,Odd2)
    8a54:	7c 27       	eor	r23, r28
                   ^ Feedback
                   ^ In;
        In >>= 1;
        SHIFT24(Even0,Even1,Even2, Feedback);
    8a56:	76 95       	lsr	r23
    8a58:	27 95       	ror	r18
    8a5a:	57 95       	ror	r21
    8a5c:	67 95       	ror	r22
    uint8_t Feedback;

    /* Calculate feedback according to LFSR taps. XOR all state bytes
     * into a single bit. */
    Feedback  = E0 & (uint8_t) (LFSR_MASK_EVEN );
    Feedback ^= E1 & (uint8_t) (LFSR_MASK_EVEN >> 8);
    8a5e:	c3 2f       	mov	r28, r19
    8a60:	c0 71       	andi	r28, 0x10	; 16
{
    uint8_t Feedback;

    /* Calculate feedback according to LFSR taps. XOR all state bytes
     * into a single bit. */
    Feedback  = E0 & (uint8_t) (LFSR_MASK_EVEN );
    8a62:	74 2f       	mov	r23, r20
    8a64:	71 7e       	andi	r23, 0xE1	; 225
    Feedback ^= E1 & (uint8_t) (LFSR_MASK_EVEN >> 8);
    8a66:	7c 27       	eor	r23, r28
    Feedback ^= E2 & (uint8_t) (LFSR_MASK_EVEN >> 16);
    8a68:	c9 2f       	mov	r28, r25
    8a6a:	c0 72       	andi	r28, 0x20	; 32
    8a6c:	7c 27       	eor	r23, r28

    Feedback ^= O0 & (uint8_t) (LFSR_MASK_ODD );
    8a6e:	c6 2f       	mov	r28, r22
    8a70:	c4 79       	andi	r28, 0x94	; 148
    8a72:	7c 27       	eor	r23, r28
    Feedback ^= O1 & (uint8_t) (LFSR_MASK_ODD >> 8);
    8a74:	c5 2f       	mov	r28, r21
    8a76:	c3 77       	andi	r28, 0x73	; 115
    8a78:	7c 27       	eor	r23, r28
    Feedback ^= O2 & (uint8_t) (LFSR_MASK_ODD >> 16);
    8a7a:	c2 2f       	mov	r28, r18
    8a7c:	ca 73       	andi	r28, 0x3A	; 58
    8a7e:	7c 27       	eor	r23, r28

    /* fold 8 into 1 bit */
    Feedback ^= ((Feedback >> 4)|(Feedback << 4)); /* Compiler uses a swap for this (fast!) */
    8a80:	c7 2f       	mov	r28, r23
    8a82:	c2 95       	swap	r28
    8a84:	7c 27       	eor	r23, r28
    Feedback ^= Feedback >> 2;
    8a86:	c7 2f       	mov	r28, r23
    8a88:	c6 95       	lsr	r28
    8a8a:	c6 95       	lsr	r28
    8a8c:	7c 27       	eor	r23, r28
        /* Bit 6 */
        Feedback = CRYPTO1_FILTER_OUTPUT_B0_24(Odd0, Odd1, Odd2);
        Feedback  = Crypto1LFSRbyteFeedback(Even0,Even1,Even2,Odd0,Odd1,Odd2)
                   ^ Feedback
                   ^ In;
        In >>= 1;
    8a8e:	86 95       	lsr	r24
        SHIFT24(Even0,Even1,Even2, Feedback);

        /* Bit 7 */
        Feedback = CRYPTO1_FILTER_OUTPUT_B0_24(Even0,Even1,Even2);
    8a90:	c5 2f       	mov	r28, r21
    8a92:	d0 e0       	ldi	r29, 0x00	; 0
    8a94:	c8 54       	subi	r28, 0x48	; 72
    8a96:	de 4d       	sbci	r29, 0xDE	; 222
    8a98:	06 2f       	mov	r16, r22
    8a9a:	10 e0       	ldi	r17, 0x00	; 0
    8a9c:	08 54       	subi	r16, 0x48	; 72
    8a9e:	1f 4d       	sbci	r17, 0xDF	; 223
    8aa0:	d8 81       	ld	r29, Y
    8aa2:	d8 01       	movw	r26, r16
    8aa4:	cc 91       	ld	r28, X
    8aa6:	cd 2b       	or	r28, r29
    8aa8:	02 2f       	mov	r16, r18
    8aaa:	10 e0       	ldi	r17, 0x00	; 0
    8aac:	08 54       	subi	r16, 0x48	; 72
    8aae:	1d 4d       	sbci	r17, 0xDD	; 221
    8ab0:	d8 01       	movw	r26, r16
    8ab2:	dc 91       	ld	r29, X
    8ab4:	cd 2b       	or	r28, r29
    8ab6:	d0 e0       	ldi	r29, 0x00	; 0
    8ab8:	c8 56       	subi	r28, 0x68	; 104
    8aba:	df 4d       	sbci	r29, 0xDF	; 223
    8abc:	c8 81       	ld	r28, Y
    8abe:	8c 27       	eor	r24, r28
    8ac0:	87 27       	eor	r24, r23
    Feedback ^= O2 & (uint8_t) (LFSR_MASK_ODD >> 16);

    /* fold 8 into 1 bit */
    Feedback ^= ((Feedback >> 4)|(Feedback << 4)); /* Compiler uses a swap for this (fast!) */
    Feedback ^= Feedback >> 2;
    Feedback ^= Feedback >> 1;
    8ac2:	76 95       	lsr	r23
        In >>= 1;
        SHIFT24(Even0,Even1,Even2, Feedback);

        /* Bit 7 */
        Feedback = CRYPTO1_FILTER_OUTPUT_B0_24(Even0,Even1,Even2);
        Feedback = Crypto1LFSRbyteFeedback(Odd0,Odd1,Odd2,Even0,Even1,Even2)
    8ac4:	87 27       	eor	r24, r23
                   ^ Feedback
                   ^ In;
        SHIFT24(Odd0,Odd1,Odd2, Feedback);
    8ac6:	d9 2f       	mov	r29, r25
    8ac8:	86 95       	lsr	r24
    8aca:	d7 95       	ror	r29
    8acc:	37 95       	ror	r19
    8ace:	47 95       	ror	r20
    Odd0 = State.Odd[0];
    Odd1 = State.Odd[1];
    Odd2 = State.Odd[2];

    /* 4 Bytes */
    for(i = 0; i < NONCE_SIZE; i++)
    8ad0:	ea 15       	cp	r30, r10
    8ad2:	fb 05       	cpc	r31, r11
    8ad4:	09 f0       	breq	.+2      	; 0x8ad8 <Crypto1Auth+0x416>
    8ad6:	10 ce       	rjmp	.-992    	; 0x86f8 <Crypto1Auth+0x36>
                   ^ Feedback
                   ^ In;
        SHIFT24(Odd0,Odd1,Odd2, Feedback);
    }
    /* save state */
    State.Even[0] = Even0;
    8ad8:	60 93 df 2c 	sts	0x2CDF, r22
    State.Even[1] = Even1;
    8adc:	50 93 e0 2c 	sts	0x2CE0, r21
    State.Even[2] = Even2;
    8ae0:	20 93 e1 2c 	sts	0x2CE1, r18
    State.Odd[0]  = Odd0;
    8ae4:	40 93 e2 2c 	sts	0x2CE2, r20
    State.Odd[1]  = Odd1;
    8ae8:	30 93 e3 2c 	sts	0x2CE3, r19
    State.Odd[2]  = Odd2;
    8aec:	d0 93 e4 2c 	sts	0x2CE4, r29
}
    8af0:	df 91       	pop	r29
    8af2:	cf 91       	pop	r28
    8af4:	1f 91       	pop	r17
    8af6:	0f 91       	pop	r16
    8af8:	ff 90       	pop	r15
    8afa:	ef 90       	pop	r14
    8afc:	df 90       	pop	r13
    8afe:	cf 90       	pop	r12
    8b00:	bf 90       	pop	r11
    8b02:	af 90       	pop	r10
    8b04:	08 95       	ret

00008b06 <Crypto1Nibble>:

/* Crypto1Nibble generates keystrem for a nibble (4 bit) */
/* no input to the LFSR  */
uint8_t Crypto1Nibble(void)
{
    8b06:	cf 93       	push	r28
    8b08:	df 93       	push	r29
    uint8_t KeyStream;
    uint8_t Feedback;
    uint8_t Out;

    /* read state */
    Even0 = State.Even[0];
    8b0a:	ef ed       	ldi	r30, 0xDF	; 223
    8b0c:	fc e2       	ldi	r31, 0x2C	; 44
    8b0e:	a0 81       	ld	r26, Z
    Even1 = State.Even[1];
    8b10:	71 81       	ldd	r23, Z+1	; 0x01
    Even2 = State.Even[2];
    8b12:	62 81       	ldd	r22, Z+2	; 0x02
    Odd0 = State.Odd[0];
    8b14:	33 81       	ldd	r19, Z+3	; 0x03
    Odd1 = State.Odd[1];
    8b16:	24 81       	ldd	r18, Z+4	; 0x04
    Odd2 = State.Odd[2];
    8b18:	95 81       	ldd	r25, Z+5	; 0x05
    uint8_t Feedback;

    /* Calculate feedback according to LFSR taps. XOR all state bytes
     * into a single bit. */
    Feedback  = E0 & (uint8_t) (LFSR_MASK_EVEN );
    Feedback ^= E1 & (uint8_t) (LFSR_MASK_EVEN >> 8);
    8b1a:	47 2f       	mov	r20, r23
    8b1c:	40 71       	andi	r20, 0x10	; 16
{
    uint8_t Feedback;

    /* Calculate feedback according to LFSR taps. XOR all state bytes
     * into a single bit. */
    Feedback  = E0 & (uint8_t) (LFSR_MASK_EVEN );
    8b1e:	8a 2f       	mov	r24, r26
    8b20:	81 7e       	andi	r24, 0xE1	; 225
    Feedback ^= E1 & (uint8_t) (LFSR_MASK_EVEN >> 8);
    8b22:	84 27       	eor	r24, r20
    Feedback ^= E2 & (uint8_t) (LFSR_MASK_EVEN >> 16);
    8b24:	46 2f       	mov	r20, r22
    8b26:	40 72       	andi	r20, 0x20	; 32
    8b28:	84 27       	eor	r24, r20

    Feedback ^= O0 & (uint8_t) (LFSR_MASK_ODD );
    8b2a:	43 2f       	mov	r20, r19
    8b2c:	44 79       	andi	r20, 0x94	; 148
    8b2e:	84 27       	eor	r24, r20
    Feedback ^= O1 & (uint8_t) (LFSR_MASK_ODD >> 8);
    8b30:	42 2f       	mov	r20, r18
    8b32:	43 77       	andi	r20, 0x73	; 115
    8b34:	84 27       	eor	r24, r20
    Feedback ^= O2 & (uint8_t) (LFSR_MASK_ODD >> 16);
    8b36:	49 2f       	mov	r20, r25
    8b38:	4a 73       	andi	r20, 0x3A	; 58
    8b3a:	84 27       	eor	r24, r20

    /* fold 8 into 1 bit */
    Feedback ^= ((Feedback >> 4)|(Feedback << 4)); /* Compiler uses a swap for this (fast!) */
    8b3c:	48 2f       	mov	r20, r24
    8b3e:	42 95       	swap	r20
    8b40:	84 27       	eor	r24, r20
    Feedback ^= Feedback >> 2;
    8b42:	48 2f       	mov	r20, r24
    8b44:	46 95       	lsr	r20
    8b46:	46 95       	lsr	r20
    8b48:	84 27       	eor	r24, r20
    Feedback ^= Feedback >> 1;
    8b4a:	48 2f       	mov	r20, r24
    8b4c:	46 95       	lsr	r20
    8b4e:	84 27       	eor	r24, r20
    Odd2 = State.Odd[2];

    /* Bit 0, initialise keystream */
    KeyStream = CRYPTO1_FILTER_OUTPUT_B3_24(Odd0, Odd1, Odd2);
    Feedback  = Crypto1LFSRbyteFeedback(Even0,Even1,Even2,Odd0,Odd1,Odd2);
    SHIFT24(Even0,Even1,Even2, Feedback);
    8b50:	86 95       	lsr	r24
    8b52:	67 95       	ror	r22
    8b54:	77 95       	ror	r23
    8b56:	a7 95       	ror	r26
    Odd0 = State.Odd[0];
    Odd1 = State.Odd[1];
    Odd2 = State.Odd[2];

    /* Bit 0, initialise keystream */
    KeyStream = CRYPTO1_FILTER_OUTPUT_B3_24(Odd0, Odd1, Odd2);
    8b58:	c2 2f       	mov	r28, r18
    8b5a:	d0 e0       	ldi	r29, 0x00	; 0
    8b5c:	c8 54       	subi	r28, 0x48	; 72
    8b5e:	de 4d       	sbci	r29, 0xDE	; 222
    8b60:	43 2f       	mov	r20, r19
    8b62:	50 e0       	ldi	r21, 0x00	; 0
    8b64:	48 54       	subi	r20, 0x48	; 72
    8b66:	5f 4d       	sbci	r21, 0xDF	; 223
    8b68:	b8 81       	ld	r27, Y
    8b6a:	ea 01       	movw	r28, r20
    8b6c:	88 81       	ld	r24, Y
    8b6e:	b8 2b       	or	r27, r24
    8b70:	49 2f       	mov	r20, r25
    8b72:	50 e0       	ldi	r21, 0x00	; 0
    8b74:	48 54       	subi	r20, 0x48	; 72
    8b76:	5d 4d       	sbci	r21, 0xDD	; 221
    8b78:	ea 01       	movw	r28, r20
    8b7a:	88 81       	ld	r24, Y
    8b7c:	cb 2f       	mov	r28, r27
    8b7e:	c8 2b       	or	r28, r24
    8b80:	d0 e0       	ldi	r29, 0x00	; 0
    8b82:	c8 5a       	subi	r28, 0xA8	; 168
    8b84:	df 4d       	sbci	r29, 0xDF	; 223
    Feedback  = Crypto1LFSRbyteFeedback(Even0,Even1,Even2,Odd0,Odd1,Odd2);
    SHIFT24(Even0,Even1,Even2, Feedback);

    /* Bit 1 */
    Out = CRYPTO1_FILTER_OUTPUT_B3_24(Even0,Even1,Even2);
    KeyStream = (KeyStream>>1) | Out;
    8b86:	88 81       	ld	r24, Y
    8b88:	86 95       	lsr	r24
    uint8_t Feedback;

    /* Calculate feedback according to LFSR taps. XOR all state bytes
     * into a single bit. */
    Feedback  = E0 & (uint8_t) (LFSR_MASK_EVEN );
    Feedback ^= E1 & (uint8_t) (LFSR_MASK_EVEN >> 8);
    8b8a:	52 2f       	mov	r21, r18
    8b8c:	50 71       	andi	r21, 0x10	; 16
{
    uint8_t Feedback;

    /* Calculate feedback according to LFSR taps. XOR all state bytes
     * into a single bit. */
    Feedback  = E0 & (uint8_t) (LFSR_MASK_EVEN );
    8b8e:	43 2f       	mov	r20, r19
    8b90:	41 7e       	andi	r20, 0xE1	; 225
    Feedback ^= E1 & (uint8_t) (LFSR_MASK_EVEN >> 8);
    8b92:	45 27       	eor	r20, r21
    Feedback ^= E2 & (uint8_t) (LFSR_MASK_EVEN >> 16);
    8b94:	59 2f       	mov	r21, r25
    8b96:	50 72       	andi	r21, 0x20	; 32
    8b98:	45 27       	eor	r20, r21

    Feedback ^= O0 & (uint8_t) (LFSR_MASK_ODD );
    8b9a:	5a 2f       	mov	r21, r26
    8b9c:	54 79       	andi	r21, 0x94	; 148
    8b9e:	45 27       	eor	r20, r21
    Feedback ^= O1 & (uint8_t) (LFSR_MASK_ODD >> 8);
    8ba0:	57 2f       	mov	r21, r23
    8ba2:	53 77       	andi	r21, 0x73	; 115
    8ba4:	45 27       	eor	r20, r21
    Feedback ^= O2 & (uint8_t) (LFSR_MASK_ODD >> 16);
    8ba6:	56 2f       	mov	r21, r22
    8ba8:	5a 73       	andi	r21, 0x3A	; 58
    8baa:	45 27       	eor	r20, r21

    /* fold 8 into 1 bit */
    Feedback ^= ((Feedback >> 4)|(Feedback << 4)); /* Compiler uses a swap for this (fast!) */
    8bac:	54 2f       	mov	r21, r20
    8bae:	52 95       	swap	r21
    8bb0:	45 27       	eor	r20, r21
    Feedback ^= Feedback >> 2;
    8bb2:	54 2f       	mov	r21, r20
    8bb4:	56 95       	lsr	r21
    8bb6:	56 95       	lsr	r21
    8bb8:	45 27       	eor	r20, r21
    Feedback ^= Feedback >> 1;
    8bba:	54 2f       	mov	r21, r20
    8bbc:	56 95       	lsr	r21
    8bbe:	45 27       	eor	r20, r21

    /* Bit 1 */
    Out = CRYPTO1_FILTER_OUTPUT_B3_24(Even0,Even1,Even2);
    KeyStream = (KeyStream>>1) | Out;
    Feedback = Crypto1LFSRbyteFeedback(Odd0,Odd1,Odd2,Even0,Even1,Even2);
    SHIFT24(Odd0,Odd1,Odd2, Feedback);
    8bc0:	46 95       	lsr	r20
    8bc2:	97 95       	ror	r25
    8bc4:	27 95       	ror	r18
    8bc6:	37 95       	ror	r19
    KeyStream = CRYPTO1_FILTER_OUTPUT_B3_24(Odd0, Odd1, Odd2);
    Feedback  = Crypto1LFSRbyteFeedback(Even0,Even1,Even2,Odd0,Odd1,Odd2);
    SHIFT24(Even0,Even1,Even2, Feedback);

    /* Bit 1 */
    Out = CRYPTO1_FILTER_OUTPUT_B3_24(Even0,Even1,Even2);
    8bc8:	c7 2f       	mov	r28, r23
    8bca:	d0 e0       	ldi	r29, 0x00	; 0
    8bcc:	c8 54       	subi	r28, 0x48	; 72
    8bce:	de 4d       	sbci	r29, 0xDE	; 222
    8bd0:	4a 2f       	mov	r20, r26
    8bd2:	50 e0       	ldi	r21, 0x00	; 0
    8bd4:	48 54       	subi	r20, 0x48	; 72
    8bd6:	5f 4d       	sbci	r21, 0xDF	; 223
    8bd8:	b8 81       	ld	r27, Y
    8bda:	ea 01       	movw	r28, r20
    8bdc:	48 81       	ld	r20, Y
    8bde:	b4 2b       	or	r27, r20
    8be0:	46 2f       	mov	r20, r22
    8be2:	50 e0       	ldi	r21, 0x00	; 0
    8be4:	48 54       	subi	r20, 0x48	; 72
    8be6:	5d 4d       	sbci	r21, 0xDD	; 221
    8be8:	ea 01       	movw	r28, r20
    8bea:	48 81       	ld	r20, Y
    8bec:	cb 2f       	mov	r28, r27
    8bee:	c4 2b       	or	r28, r20
    8bf0:	d0 e0       	ldi	r29, 0x00	; 0
    8bf2:	c8 5a       	subi	r28, 0xA8	; 168
    8bf4:	df 4d       	sbci	r29, 0xDF	; 223
    KeyStream = (KeyStream>>1) | Out;
    8bf6:	48 81       	ld	r20, Y
    8bf8:	84 2b       	or	r24, r20
    Feedback = Crypto1LFSRbyteFeedback(Odd0,Odd1,Odd2,Even0,Even1,Even2);
    SHIFT24(Odd0,Odd1,Odd2, Feedback);

    /* Bit 2 */
    Out = CRYPTO1_FILTER_OUTPUT_B3_24(Odd0, Odd1, Odd2);
    KeyStream = (KeyStream>>1) | Out;
    8bfa:	86 95       	lsr	r24
    uint8_t Feedback;

    /* Calculate feedback according to LFSR taps. XOR all state bytes
     * into a single bit. */
    Feedback  = E0 & (uint8_t) (LFSR_MASK_EVEN );
    Feedback ^= E1 & (uint8_t) (LFSR_MASK_EVEN >> 8);
    8bfc:	57 2f       	mov	r21, r23
    8bfe:	50 71       	andi	r21, 0x10	; 16
{
    uint8_t Feedback;

    /* Calculate feedback according to LFSR taps. XOR all state bytes
     * into a single bit. */
    Feedback  = E0 & (uint8_t) (LFSR_MASK_EVEN );
    8c00:	4a 2f       	mov	r20, r26
    8c02:	41 7e       	andi	r20, 0xE1	; 225
    Feedback ^= E1 & (uint8_t) (LFSR_MASK_EVEN >> 8);
    8c04:	45 27       	eor	r20, r21
    Feedback ^= E2 & (uint8_t) (LFSR_MASK_EVEN >> 16);
    8c06:	56 2f       	mov	r21, r22
    8c08:	50 72       	andi	r21, 0x20	; 32
    8c0a:	45 27       	eor	r20, r21

    Feedback ^= O0 & (uint8_t) (LFSR_MASK_ODD );
    8c0c:	53 2f       	mov	r21, r19
    8c0e:	54 79       	andi	r21, 0x94	; 148
    8c10:	45 27       	eor	r20, r21
    Feedback ^= O1 & (uint8_t) (LFSR_MASK_ODD >> 8);
    8c12:	52 2f       	mov	r21, r18
    8c14:	53 77       	andi	r21, 0x73	; 115
    8c16:	45 27       	eor	r20, r21
    Feedback ^= O2 & (uint8_t) (LFSR_MASK_ODD >> 16);
    8c18:	59 2f       	mov	r21, r25
    8c1a:	5a 73       	andi	r21, 0x3A	; 58
    8c1c:	45 27       	eor	r20, r21

    /* fold 8 into 1 bit */
    Feedback ^= ((Feedback >> 4)|(Feedback << 4)); /* Compiler uses a swap for this (fast!) */
    8c1e:	54 2f       	mov	r21, r20
    8c20:	52 95       	swap	r21
    8c22:	45 27       	eor	r20, r21
    Feedback ^= Feedback >> 2;
    8c24:	54 2f       	mov	r21, r20
    8c26:	56 95       	lsr	r21
    8c28:	56 95       	lsr	r21
    8c2a:	45 27       	eor	r20, r21
    Feedback ^= Feedback >> 1;
    8c2c:	54 2f       	mov	r21, r20
    8c2e:	56 95       	lsr	r21
    8c30:	45 27       	eor	r20, r21

    /* Bit 2 */
    Out = CRYPTO1_FILTER_OUTPUT_B3_24(Odd0, Odd1, Odd2);
    KeyStream = (KeyStream>>1) | Out;
    Feedback  = Crypto1LFSRbyteFeedback(Even0,Even1,Even2,Odd0,Odd1,Odd2);
    SHIFT24(Even0,Even1,Even2, Feedback);
    8c32:	46 95       	lsr	r20
    8c34:	67 95       	ror	r22
    8c36:	77 95       	ror	r23
    8c38:	a7 95       	ror	r26
    KeyStream = (KeyStream>>1) | Out;
    Feedback = Crypto1LFSRbyteFeedback(Odd0,Odd1,Odd2,Even0,Even1,Even2);
    SHIFT24(Odd0,Odd1,Odd2, Feedback);

    /* Bit 2 */
    Out = CRYPTO1_FILTER_OUTPUT_B3_24(Odd0, Odd1, Odd2);
    8c3a:	c2 2f       	mov	r28, r18
    8c3c:	d0 e0       	ldi	r29, 0x00	; 0
    8c3e:	c8 54       	subi	r28, 0x48	; 72
    8c40:	de 4d       	sbci	r29, 0xDE	; 222
    8c42:	43 2f       	mov	r20, r19
    8c44:	50 e0       	ldi	r21, 0x00	; 0
    8c46:	48 54       	subi	r20, 0x48	; 72
    8c48:	5f 4d       	sbci	r21, 0xDF	; 223
    8c4a:	b8 81       	ld	r27, Y
    8c4c:	ea 01       	movw	r28, r20
    8c4e:	48 81       	ld	r20, Y
    8c50:	b4 2b       	or	r27, r20
    8c52:	49 2f       	mov	r20, r25
    8c54:	50 e0       	ldi	r21, 0x00	; 0
    8c56:	48 54       	subi	r20, 0x48	; 72
    8c58:	5d 4d       	sbci	r21, 0xDD	; 221
    8c5a:	ea 01       	movw	r28, r20
    8c5c:	48 81       	ld	r20, Y
    8c5e:	cb 2f       	mov	r28, r27
    8c60:	c4 2b       	or	r28, r20
    8c62:	d0 e0       	ldi	r29, 0x00	; 0
    8c64:	c8 5a       	subi	r28, 0xA8	; 168
    8c66:	df 4d       	sbci	r29, 0xDF	; 223
    KeyStream = (KeyStream>>1) | Out;
    8c68:	48 81       	ld	r20, Y
    8c6a:	84 2b       	or	r24, r20
    Feedback  = Crypto1LFSRbyteFeedback(Even0,Even1,Even2,Odd0,Odd1,Odd2);
    SHIFT24(Even0,Even1,Even2, Feedback);

    /* Bit 3 */
    Out = CRYPTO1_FILTER_OUTPUT_B3_24(Even0,Even1,Even2);
    KeyStream = (KeyStream>>1) | Out;
    8c6c:	86 95       	lsr	r24
    KeyStream = (KeyStream>>1) | Out;
    Feedback  = Crypto1LFSRbyteFeedback(Even0,Even1,Even2,Odd0,Odd1,Odd2);
    SHIFT24(Even0,Even1,Even2, Feedback);

    /* Bit 3 */
    Out = CRYPTO1_FILTER_OUTPUT_B3_24(Even0,Even1,Even2);
    8c6e:	c7 2f       	mov	r28, r23
    8c70:	d0 e0       	ldi	r29, 0x00	; 0
    8c72:	c8 54       	subi	r28, 0x48	; 72
    8c74:	de 4d       	sbci	r29, 0xDE	; 222
    8c76:	4a 2f       	mov	r20, r26
    8c78:	50 e0       	ldi	r21, 0x00	; 0
    8c7a:	48 54       	subi	r20, 0x48	; 72
    8c7c:	5f 4d       	sbci	r21, 0xDF	; 223
    8c7e:	b8 81       	ld	r27, Y
    8c80:	ea 01       	movw	r28, r20
    8c82:	48 81       	ld	r20, Y
    8c84:	b4 2b       	or	r27, r20
    8c86:	46 2f       	mov	r20, r22
    8c88:	50 e0       	ldi	r21, 0x00	; 0
    8c8a:	48 54       	subi	r20, 0x48	; 72
    8c8c:	5d 4d       	sbci	r21, 0xDD	; 221
    8c8e:	ea 01       	movw	r28, r20
    8c90:	48 81       	ld	r20, Y
    8c92:	cb 2f       	mov	r28, r27
    8c94:	c4 2b       	or	r28, r20
    8c96:	d0 e0       	ldi	r29, 0x00	; 0
    8c98:	c8 5a       	subi	r28, 0xA8	; 168
    8c9a:	df 4d       	sbci	r29, 0xDF	; 223
    KeyStream = (KeyStream>>1) | Out;
    8c9c:	48 81       	ld	r20, Y
    8c9e:	84 2b       	or	r24, r20
    uint8_t Feedback;

    /* Calculate feedback according to LFSR taps. XOR all state bytes
     * into a single bit. */
    Feedback  = E0 & (uint8_t) (LFSR_MASK_EVEN );
    Feedback ^= E1 & (uint8_t) (LFSR_MASK_EVEN >> 8);
    8ca0:	52 2f       	mov	r21, r18
    8ca2:	50 71       	andi	r21, 0x10	; 16
{
    uint8_t Feedback;

    /* Calculate feedback according to LFSR taps. XOR all state bytes
     * into a single bit. */
    Feedback  = E0 & (uint8_t) (LFSR_MASK_EVEN );
    8ca4:	43 2f       	mov	r20, r19
    8ca6:	41 7e       	andi	r20, 0xE1	; 225
    Feedback ^= E1 & (uint8_t) (LFSR_MASK_EVEN >> 8);
    8ca8:	45 27       	eor	r20, r21
    Feedback ^= E2 & (uint8_t) (LFSR_MASK_EVEN >> 16);
    8caa:	59 2f       	mov	r21, r25
    8cac:	50 72       	andi	r21, 0x20	; 32
    8cae:	45 27       	eor	r20, r21

    Feedback ^= O0 & (uint8_t) (LFSR_MASK_ODD );
    8cb0:	5a 2f       	mov	r21, r26
    8cb2:	54 79       	andi	r21, 0x94	; 148
    8cb4:	45 27       	eor	r20, r21
    Feedback ^= O1 & (uint8_t) (LFSR_MASK_ODD >> 8);
    8cb6:	57 2f       	mov	r21, r23
    8cb8:	53 77       	andi	r21, 0x73	; 115
    8cba:	45 27       	eor	r20, r21
    Feedback ^= O2 & (uint8_t) (LFSR_MASK_ODD >> 16);
    8cbc:	56 2f       	mov	r21, r22
    8cbe:	5a 73       	andi	r21, 0x3A	; 58
    8cc0:	45 27       	eor	r20, r21

    /* fold 8 into 1 bit */
    Feedback ^= ((Feedback >> 4)|(Feedback << 4)); /* Compiler uses a swap for this (fast!) */
    8cc2:	54 2f       	mov	r21, r20
    8cc4:	52 95       	swap	r21
    8cc6:	45 27       	eor	r20, r21
    Feedback ^= Feedback >> 2;
    8cc8:	54 2f       	mov	r21, r20
    8cca:	56 95       	lsr	r21
    8ccc:	56 95       	lsr	r21
    8cce:	45 27       	eor	r20, r21
    Feedback ^= Feedback >> 1;
    8cd0:	54 2f       	mov	r21, r20
    8cd2:	56 95       	lsr	r21
    8cd4:	45 27       	eor	r20, r21

    /* Bit 3 */
    Out = CRYPTO1_FILTER_OUTPUT_B3_24(Even0,Even1,Even2);
    KeyStream = (KeyStream>>1) | Out;
    Feedback = Crypto1LFSRbyteFeedback(Odd0,Odd1,Odd2,Even0,Even1,Even2);
    SHIFT24(Odd0,Odd1,Odd2, Feedback);
    8cd6:	46 95       	lsr	r20
    8cd8:	97 95       	ror	r25
    8cda:	27 95       	ror	r18
    8cdc:	37 95       	ror	r19

    /* save state */
    State.Even[0] = Even0;
    8cde:	a0 83       	st	Z, r26
    State.Even[1] = Even1;
    8ce0:	71 83       	std	Z+1, r23	; 0x01
    State.Even[2] = Even2;
    8ce2:	62 83       	std	Z+2, r22	; 0x02
    State.Odd[0]  = Odd0;
    8ce4:	33 83       	std	Z+3, r19	; 0x03
    State.Odd[1]  = Odd1;
    8ce6:	24 83       	std	Z+4, r18	; 0x04
    State.Odd[2]  = Odd2;
    8ce8:	95 83       	std	Z+5, r25	; 0x05

    return(KeyStream);
}
    8cea:	df 91       	pop	r29
    8cec:	cf 91       	pop	r28
    8cee:	08 95       	ret

00008cf0 <Crypto1ByteArray>:
/* Crypto1ByteArray transcrypts array of bytes        */
/* No input to the LFSR                               */
/* Avoids load/store of the LFSR-state for each byte! */
/* Enhacement for the original function Crypto1Byte() */
void Crypto1ByteArray(uint8_t* Buffer, uint8_t Count)
{
    8cf0:	0f 93       	push	r16
    8cf2:	1f 93       	push	r17
    8cf4:	cf 93       	push	r28
    8cf6:	df 93       	push	r29
    uint8_t KeyStream = 0;
    uint8_t Feedback;
    uint8_t Out;
    
    /* read state */
    Even0 = State.Even[0];
    8cf8:	a0 91 df 2c 	lds	r26, 0x2CDF
    Even1 = State.Even[1];
    8cfc:	70 91 e0 2c 	lds	r23, 0x2CE0
    Even2 = State.Even[2];
    8d00:	20 91 e1 2c 	lds	r18, 0x2CE1
    Odd0 = State.Odd[0];
    8d04:	50 91 e2 2c 	lds	r21, 0x2CE2
    Odd1 = State.Odd[1];
    8d08:	40 91 e3 2c 	lds	r20, 0x2CE3
    Odd2 = State.Odd[2];
    8d0c:	30 91 e4 2c 	lds	r19, 0x2CE4
    8d10:	fc 01       	movw	r30, r24

    while(Count--)
    8d12:	61 50       	subi	r22, 0x01	; 1
    8d14:	08 f4       	brcc	.+2      	; 0x8d18 <Crypto1ByteArray+0x28>
    8d16:	cd c1       	rjmp	.+922    	; 0x90b2 <Crypto1ByteArray+0x3c2>
    uint8_t Feedback;

    /* Calculate feedback according to LFSR taps. XOR all state bytes
     * into a single bit. */
    Feedback  = E0 & (uint8_t) (LFSR_MASK_EVEN );
    Feedback ^= E1 & (uint8_t) (LFSR_MASK_EVEN >> 8);
    8d18:	97 2f       	mov	r25, r23
    8d1a:	90 71       	andi	r25, 0x10	; 16
{
    uint8_t Feedback;

    /* Calculate feedback according to LFSR taps. XOR all state bytes
     * into a single bit. */
    Feedback  = E0 & (uint8_t) (LFSR_MASK_EVEN );
    8d1c:	8a 2f       	mov	r24, r26
    8d1e:	81 7e       	andi	r24, 0xE1	; 225
    Feedback ^= E1 & (uint8_t) (LFSR_MASK_EVEN >> 8);
    8d20:	89 27       	eor	r24, r25
    Feedback ^= E2 & (uint8_t) (LFSR_MASK_EVEN >> 16);
    8d22:	92 2f       	mov	r25, r18
    8d24:	90 72       	andi	r25, 0x20	; 32
    8d26:	89 27       	eor	r24, r25

    Feedback ^= O0 & (uint8_t) (LFSR_MASK_ODD );
    8d28:	95 2f       	mov	r25, r21
    8d2a:	94 79       	andi	r25, 0x94	; 148
    8d2c:	89 27       	eor	r24, r25
    Feedback ^= O1 & (uint8_t) (LFSR_MASK_ODD >> 8);
    8d2e:	94 2f       	mov	r25, r20
    8d30:	93 77       	andi	r25, 0x73	; 115
    8d32:	89 27       	eor	r24, r25
    Feedback ^= O2 & (uint8_t) (LFSR_MASK_ODD >> 16);
    8d34:	93 2f       	mov	r25, r19
    8d36:	9a 73       	andi	r25, 0x3A	; 58
    8d38:	89 27       	eor	r24, r25

    /* fold 8 into 1 bit */
    Feedback ^= ((Feedback >> 4)|(Feedback << 4)); /* Compiler uses a swap for this (fast!) */
    8d3a:	98 2f       	mov	r25, r24
    8d3c:	92 95       	swap	r25
    8d3e:	89 27       	eor	r24, r25
    Feedback ^= Feedback >> 2;
    8d40:	98 2f       	mov	r25, r24
    8d42:	96 95       	lsr	r25
    8d44:	96 95       	lsr	r25
    8d46:	89 27       	eor	r24, r25
    Feedback ^= Feedback >> 1;
    8d48:	98 2f       	mov	r25, r24
    8d4a:	96 95       	lsr	r25
    8d4c:	89 27       	eor	r24, r25
    while(Count--)
    {
        /* Bit 0, initialise keystream */
        KeyStream = CRYPTO1_FILTER_OUTPUT_B7_24(Odd0, Odd1, Odd2);
        Feedback  = Crypto1LFSRbyteFeedback(Even0,Even1,Even2,Odd0,Odd1,Odd2);
        SHIFT24(Even0,Even1,Even2, Feedback);
    8d4e:	86 95       	lsr	r24
    8d50:	27 95       	ror	r18
    8d52:	77 95       	ror	r23
    8d54:	a7 95       	ror	r26
    Odd2 = State.Odd[2];

    while(Count--)
    {
        /* Bit 0, initialise keystream */
        KeyStream = CRYPTO1_FILTER_OUTPUT_B7_24(Odd0, Odd1, Odd2);
    8d56:	c4 2f       	mov	r28, r20
    8d58:	d0 e0       	ldi	r29, 0x00	; 0
    8d5a:	c8 54       	subi	r28, 0x48	; 72
    8d5c:	de 4d       	sbci	r29, 0xDE	; 222
    8d5e:	85 2f       	mov	r24, r21
    8d60:	90 e0       	ldi	r25, 0x00	; 0
    8d62:	88 54       	subi	r24, 0x48	; 72
    8d64:	9f 4d       	sbci	r25, 0xDF	; 223
    8d66:	b8 81       	ld	r27, Y
    8d68:	ec 01       	movw	r28, r24
    8d6a:	88 81       	ld	r24, Y
    8d6c:	b8 2b       	or	r27, r24
    8d6e:	83 2f       	mov	r24, r19
    8d70:	90 e0       	ldi	r25, 0x00	; 0
    8d72:	88 54       	subi	r24, 0x48	; 72
    8d74:	9d 4d       	sbci	r25, 0xDD	; 221
    8d76:	ec 01       	movw	r28, r24
    8d78:	88 81       	ld	r24, Y
    8d7a:	cb 2f       	mov	r28, r27
    8d7c:	c8 2b       	or	r28, r24
    8d7e:	d0 e0       	ldi	r29, 0x00	; 0
    8d80:	c8 58       	subi	r28, 0x88	; 136
    8d82:	df 4d       	sbci	r29, 0xDF	; 223
        SHIFT24(Even0,Even1,Even2, Feedback);

        /* Bit 1 */
        /* remember Odd/Even swap has been omitted! */
        Out = CRYPTO1_FILTER_OUTPUT_B7_24(Even0,Even1,Even2);
        KeyStream = (KeyStream>>1) | Out;
    8d84:	b8 81       	ld	r27, Y
    8d86:	b6 95       	lsr	r27
    uint8_t Feedback;

    /* Calculate feedback according to LFSR taps. XOR all state bytes
     * into a single bit. */
    Feedback  = E0 & (uint8_t) (LFSR_MASK_EVEN );
    Feedback ^= E1 & (uint8_t) (LFSR_MASK_EVEN >> 8);
    8d88:	94 2f       	mov	r25, r20
    8d8a:	90 71       	andi	r25, 0x10	; 16
{
    uint8_t Feedback;

    /* Calculate feedback according to LFSR taps. XOR all state bytes
     * into a single bit. */
    Feedback  = E0 & (uint8_t) (LFSR_MASK_EVEN );
    8d8c:	85 2f       	mov	r24, r21
    8d8e:	81 7e       	andi	r24, 0xE1	; 225
    Feedback ^= E1 & (uint8_t) (LFSR_MASK_EVEN >> 8);
    8d90:	89 27       	eor	r24, r25
    Feedback ^= E2 & (uint8_t) (LFSR_MASK_EVEN >> 16);
    8d92:	93 2f       	mov	r25, r19
    8d94:	90 72       	andi	r25, 0x20	; 32
    8d96:	89 27       	eor	r24, r25

    Feedback ^= O0 & (uint8_t) (LFSR_MASK_ODD );
    8d98:	9a 2f       	mov	r25, r26
    8d9a:	94 79       	andi	r25, 0x94	; 148
    8d9c:	89 27       	eor	r24, r25
    Feedback ^= O1 & (uint8_t) (LFSR_MASK_ODD >> 8);
    8d9e:	97 2f       	mov	r25, r23
    8da0:	93 77       	andi	r25, 0x73	; 115
    8da2:	89 27       	eor	r24, r25
    Feedback ^= O2 & (uint8_t) (LFSR_MASK_ODD >> 16);
    8da4:	92 2f       	mov	r25, r18
    8da6:	9a 73       	andi	r25, 0x3A	; 58
    8da8:	89 27       	eor	r24, r25

    /* fold 8 into 1 bit */
    Feedback ^= ((Feedback >> 4)|(Feedback << 4)); /* Compiler uses a swap for this (fast!) */
    8daa:	98 2f       	mov	r25, r24
    8dac:	92 95       	swap	r25
    8dae:	89 27       	eor	r24, r25
    Feedback ^= Feedback >> 2;
    8db0:	98 2f       	mov	r25, r24
    8db2:	96 95       	lsr	r25
    8db4:	96 95       	lsr	r25
    8db6:	89 27       	eor	r24, r25
    Feedback ^= Feedback >> 1;
    8db8:	98 2f       	mov	r25, r24
    8dba:	96 95       	lsr	r25
    8dbc:	89 27       	eor	r24, r25
        /* Bit 1 */
        /* remember Odd/Even swap has been omitted! */
        Out = CRYPTO1_FILTER_OUTPUT_B7_24(Even0,Even1,Even2);
        KeyStream = (KeyStream>>1) | Out;
        Feedback = Crypto1LFSRbyteFeedback(Odd0,Odd1,Odd2,Even0,Even1,Even2);
        SHIFT24(Odd0,Odd1,Odd2, Feedback);
    8dbe:	86 95       	lsr	r24
    8dc0:	37 95       	ror	r19
    8dc2:	47 95       	ror	r20
    8dc4:	57 95       	ror	r21
        Feedback  = Crypto1LFSRbyteFeedback(Even0,Even1,Even2,Odd0,Odd1,Odd2);
        SHIFT24(Even0,Even1,Even2, Feedback);

        /* Bit 1 */
        /* remember Odd/Even swap has been omitted! */
        Out = CRYPTO1_FILTER_OUTPUT_B7_24(Even0,Even1,Even2);
    8dc6:	c7 2f       	mov	r28, r23
    8dc8:	d0 e0       	ldi	r29, 0x00	; 0
    8dca:	c8 54       	subi	r28, 0x48	; 72
    8dcc:	de 4d       	sbci	r29, 0xDE	; 222
    8dce:	8a 2f       	mov	r24, r26
    8dd0:	90 e0       	ldi	r25, 0x00	; 0
    8dd2:	88 54       	subi	r24, 0x48	; 72
    8dd4:	9f 4d       	sbci	r25, 0xDF	; 223
    8dd6:	18 81       	ld	r17, Y
    8dd8:	ec 01       	movw	r28, r24
    8dda:	88 81       	ld	r24, Y
    8ddc:	18 2b       	or	r17, r24
    8dde:	82 2f       	mov	r24, r18
    8de0:	90 e0       	ldi	r25, 0x00	; 0
    8de2:	88 54       	subi	r24, 0x48	; 72
    8de4:	9d 4d       	sbci	r25, 0xDD	; 221
    8de6:	ec 01       	movw	r28, r24
    8de8:	88 81       	ld	r24, Y
    8dea:	c1 2f       	mov	r28, r17
    8dec:	c8 2b       	or	r28, r24
    8dee:	d0 e0       	ldi	r29, 0x00	; 0
    8df0:	c8 58       	subi	r28, 0x88	; 136
    8df2:	df 4d       	sbci	r29, 0xDF	; 223
        KeyStream = (KeyStream>>1) | Out;
    8df4:	88 81       	ld	r24, Y
    8df6:	b8 2b       	or	r27, r24
        Feedback = Crypto1LFSRbyteFeedback(Odd0,Odd1,Odd2,Even0,Even1,Even2);
        SHIFT24(Odd0,Odd1,Odd2, Feedback);

        /* Bit 2 */
        Out = CRYPTO1_FILTER_OUTPUT_B7_24(Odd0, Odd1, Odd2);
        KeyStream = (KeyStream>>1) | Out;
    8df8:	b6 95       	lsr	r27
    uint8_t Feedback;

    /* Calculate feedback according to LFSR taps. XOR all state bytes
     * into a single bit. */
    Feedback  = E0 & (uint8_t) (LFSR_MASK_EVEN );
    Feedback ^= E1 & (uint8_t) (LFSR_MASK_EVEN >> 8);
    8dfa:	97 2f       	mov	r25, r23
    8dfc:	90 71       	andi	r25, 0x10	; 16
{
    uint8_t Feedback;

    /* Calculate feedback according to LFSR taps. XOR all state bytes
     * into a single bit. */
    Feedback  = E0 & (uint8_t) (LFSR_MASK_EVEN );
    8dfe:	8a 2f       	mov	r24, r26
    8e00:	81 7e       	andi	r24, 0xE1	; 225
    Feedback ^= E1 & (uint8_t) (LFSR_MASK_EVEN >> 8);
    8e02:	89 27       	eor	r24, r25
    Feedback ^= E2 & (uint8_t) (LFSR_MASK_EVEN >> 16);
    8e04:	92 2f       	mov	r25, r18
    8e06:	90 72       	andi	r25, 0x20	; 32
    8e08:	89 27       	eor	r24, r25

    Feedback ^= O0 & (uint8_t) (LFSR_MASK_ODD );
    8e0a:	95 2f       	mov	r25, r21
    8e0c:	94 79       	andi	r25, 0x94	; 148
    8e0e:	89 27       	eor	r24, r25
    Feedback ^= O1 & (uint8_t) (LFSR_MASK_ODD >> 8);
    8e10:	94 2f       	mov	r25, r20
    8e12:	93 77       	andi	r25, 0x73	; 115
    8e14:	89 27       	eor	r24, r25
    Feedback ^= O2 & (uint8_t) (LFSR_MASK_ODD >> 16);
    8e16:	93 2f       	mov	r25, r19
    8e18:	9a 73       	andi	r25, 0x3A	; 58
    8e1a:	89 27       	eor	r24, r25

    /* fold 8 into 1 bit */
    Feedback ^= ((Feedback >> 4)|(Feedback << 4)); /* Compiler uses a swap for this (fast!) */
    8e1c:	98 2f       	mov	r25, r24
    8e1e:	92 95       	swap	r25
    8e20:	89 27       	eor	r24, r25
    Feedback ^= Feedback >> 2;
    8e22:	98 2f       	mov	r25, r24
    8e24:	96 95       	lsr	r25
    8e26:	96 95       	lsr	r25
    8e28:	89 27       	eor	r24, r25
    Feedback ^= Feedback >> 1;
    8e2a:	98 2f       	mov	r25, r24
    8e2c:	96 95       	lsr	r25
    8e2e:	89 27       	eor	r24, r25

        /* Bit 2 */
        Out = CRYPTO1_FILTER_OUTPUT_B7_24(Odd0, Odd1, Odd2);
        KeyStream = (KeyStream>>1) | Out;
        Feedback  = Crypto1LFSRbyteFeedback(Even0,Even1,Even2,Odd0,Odd1,Odd2);
        SHIFT24(Even0,Even1,Even2, Feedback);
    8e30:	86 95       	lsr	r24
    8e32:	27 95       	ror	r18
    8e34:	77 95       	ror	r23
    8e36:	a7 95       	ror	r26
        KeyStream = (KeyStream>>1) | Out;
        Feedback = Crypto1LFSRbyteFeedback(Odd0,Odd1,Odd2,Even0,Even1,Even2);
        SHIFT24(Odd0,Odd1,Odd2, Feedback);

        /* Bit 2 */
        Out = CRYPTO1_FILTER_OUTPUT_B7_24(Odd0, Odd1, Odd2);
    8e38:	c4 2f       	mov	r28, r20
    8e3a:	d0 e0       	ldi	r29, 0x00	; 0
    8e3c:	c8 54       	subi	r28, 0x48	; 72
    8e3e:	de 4d       	sbci	r29, 0xDE	; 222
    8e40:	85 2f       	mov	r24, r21
    8e42:	90 e0       	ldi	r25, 0x00	; 0
    8e44:	88 54       	subi	r24, 0x48	; 72
    8e46:	9f 4d       	sbci	r25, 0xDF	; 223
    8e48:	18 81       	ld	r17, Y
    8e4a:	ec 01       	movw	r28, r24
    8e4c:	88 81       	ld	r24, Y
    8e4e:	18 2b       	or	r17, r24
    8e50:	83 2f       	mov	r24, r19
    8e52:	90 e0       	ldi	r25, 0x00	; 0
    8e54:	88 54       	subi	r24, 0x48	; 72
    8e56:	9d 4d       	sbci	r25, 0xDD	; 221
    8e58:	ec 01       	movw	r28, r24
    8e5a:	88 81       	ld	r24, Y
    8e5c:	c1 2f       	mov	r28, r17
    8e5e:	c8 2b       	or	r28, r24
    8e60:	d0 e0       	ldi	r29, 0x00	; 0
    8e62:	c8 58       	subi	r28, 0x88	; 136
    8e64:	df 4d       	sbci	r29, 0xDF	; 223
        KeyStream = (KeyStream>>1) | Out;
    8e66:	88 81       	ld	r24, Y
    8e68:	b8 2b       	or	r27, r24
        SHIFT24(Even0,Even1,Even2, Feedback);

        /* Bit 3 */
        /* remember Odd/Even swap has been omitted! */
        Out = CRYPTO1_FILTER_OUTPUT_B7_24(Even0,Even1,Even2);
        KeyStream = (KeyStream>>1) | Out;
    8e6a:	b6 95       	lsr	r27
    uint8_t Feedback;

    /* Calculate feedback according to LFSR taps. XOR all state bytes
     * into a single bit. */
    Feedback  = E0 & (uint8_t) (LFSR_MASK_EVEN );
    Feedback ^= E1 & (uint8_t) (LFSR_MASK_EVEN >> 8);
    8e6c:	94 2f       	mov	r25, r20
    8e6e:	90 71       	andi	r25, 0x10	; 16
{
    uint8_t Feedback;

    /* Calculate feedback according to LFSR taps. XOR all state bytes
     * into a single bit. */
    Feedback  = E0 & (uint8_t) (LFSR_MASK_EVEN );
    8e70:	85 2f       	mov	r24, r21
    8e72:	81 7e       	andi	r24, 0xE1	; 225
    Feedback ^= E1 & (uint8_t) (LFSR_MASK_EVEN >> 8);
    8e74:	89 27       	eor	r24, r25
    Feedback ^= E2 & (uint8_t) (LFSR_MASK_EVEN >> 16);
    8e76:	93 2f       	mov	r25, r19
    8e78:	90 72       	andi	r25, 0x20	; 32
    8e7a:	89 27       	eor	r24, r25

    Feedback ^= O0 & (uint8_t) (LFSR_MASK_ODD );
    8e7c:	9a 2f       	mov	r25, r26
    8e7e:	94 79       	andi	r25, 0x94	; 148
    8e80:	89 27       	eor	r24, r25
    Feedback ^= O1 & (uint8_t) (LFSR_MASK_ODD >> 8);
    8e82:	97 2f       	mov	r25, r23
    8e84:	93 77       	andi	r25, 0x73	; 115
    8e86:	89 27       	eor	r24, r25
    Feedback ^= O2 & (uint8_t) (LFSR_MASK_ODD >> 16);
    8e88:	92 2f       	mov	r25, r18
    8e8a:	9a 73       	andi	r25, 0x3A	; 58
    8e8c:	89 27       	eor	r24, r25

    /* fold 8 into 1 bit */
    Feedback ^= ((Feedback >> 4)|(Feedback << 4)); /* Compiler uses a swap for this (fast!) */
    8e8e:	98 2f       	mov	r25, r24
    8e90:	92 95       	swap	r25
    8e92:	89 27       	eor	r24, r25
    Feedback ^= Feedback >> 2;
    8e94:	98 2f       	mov	r25, r24
    8e96:	96 95       	lsr	r25
    8e98:	96 95       	lsr	r25
    8e9a:	89 27       	eor	r24, r25
    Feedback ^= Feedback >> 1;
    8e9c:	98 2f       	mov	r25, r24
    8e9e:	96 95       	lsr	r25
    8ea0:	89 27       	eor	r24, r25
        /* Bit 3 */
        /* remember Odd/Even swap has been omitted! */
        Out = CRYPTO1_FILTER_OUTPUT_B7_24(Even0,Even1,Even2);
        KeyStream = (KeyStream>>1) | Out;
        Feedback = Crypto1LFSRbyteFeedback(Odd0,Odd1,Odd2,Even0,Even1,Even2);
        SHIFT24(Odd0,Odd1,Odd2, Feedback);
    8ea2:	86 95       	lsr	r24
    8ea4:	37 95       	ror	r19
    8ea6:	47 95       	ror	r20
    8ea8:	57 95       	ror	r21
        Feedback  = Crypto1LFSRbyteFeedback(Even0,Even1,Even2,Odd0,Odd1,Odd2);
        SHIFT24(Even0,Even1,Even2, Feedback);

        /* Bit 3 */
        /* remember Odd/Even swap has been omitted! */
        Out = CRYPTO1_FILTER_OUTPUT_B7_24(Even0,Even1,Even2);
    8eaa:	c7 2f       	mov	r28, r23
    8eac:	d0 e0       	ldi	r29, 0x00	; 0
    8eae:	c8 54       	subi	r28, 0x48	; 72
    8eb0:	de 4d       	sbci	r29, 0xDE	; 222
    8eb2:	8a 2f       	mov	r24, r26
    8eb4:	90 e0       	ldi	r25, 0x00	; 0
    8eb6:	88 54       	subi	r24, 0x48	; 72
    8eb8:	9f 4d       	sbci	r25, 0xDF	; 223
    8eba:	18 81       	ld	r17, Y
    8ebc:	ec 01       	movw	r28, r24
    8ebe:	88 81       	ld	r24, Y
    8ec0:	18 2b       	or	r17, r24
    8ec2:	82 2f       	mov	r24, r18
    8ec4:	90 e0       	ldi	r25, 0x00	; 0
    8ec6:	88 54       	subi	r24, 0x48	; 72
    8ec8:	9d 4d       	sbci	r25, 0xDD	; 221
    8eca:	ec 01       	movw	r28, r24
    8ecc:	88 81       	ld	r24, Y
    8ece:	c1 2f       	mov	r28, r17
    8ed0:	c8 2b       	or	r28, r24
    8ed2:	d0 e0       	ldi	r29, 0x00	; 0
    8ed4:	c8 58       	subi	r28, 0x88	; 136
    8ed6:	df 4d       	sbci	r29, 0xDF	; 223
        KeyStream = (KeyStream>>1) | Out;
    8ed8:	88 81       	ld	r24, Y
    8eda:	b8 2b       	or	r27, r24
        Feedback = Crypto1LFSRbyteFeedback(Odd0,Odd1,Odd2,Even0,Even1,Even2);
        SHIFT24(Odd0,Odd1,Odd2, Feedback);

        /* Bit 4 */
        Out = CRYPTO1_FILTER_OUTPUT_B7_24(Odd0, Odd1, Odd2);
        KeyStream = (KeyStream>>1) | Out;
    8edc:	b6 95       	lsr	r27
    uint8_t Feedback;

    /* Calculate feedback according to LFSR taps. XOR all state bytes
     * into a single bit. */
    Feedback  = E0 & (uint8_t) (LFSR_MASK_EVEN );
    Feedback ^= E1 & (uint8_t) (LFSR_MASK_EVEN >> 8);
    8ede:	97 2f       	mov	r25, r23
    8ee0:	90 71       	andi	r25, 0x10	; 16
{
    uint8_t Feedback;

    /* Calculate feedback according to LFSR taps. XOR all state bytes
     * into a single bit. */
    Feedback  = E0 & (uint8_t) (LFSR_MASK_EVEN );
    8ee2:	8a 2f       	mov	r24, r26
    8ee4:	81 7e       	andi	r24, 0xE1	; 225
    Feedback ^= E1 & (uint8_t) (LFSR_MASK_EVEN >> 8);
    8ee6:	89 27       	eor	r24, r25
    Feedback ^= E2 & (uint8_t) (LFSR_MASK_EVEN >> 16);
    8ee8:	92 2f       	mov	r25, r18
    8eea:	90 72       	andi	r25, 0x20	; 32
    8eec:	89 27       	eor	r24, r25

    Feedback ^= O0 & (uint8_t) (LFSR_MASK_ODD );
    8eee:	95 2f       	mov	r25, r21
    8ef0:	94 79       	andi	r25, 0x94	; 148
    8ef2:	89 27       	eor	r24, r25
    Feedback ^= O1 & (uint8_t) (LFSR_MASK_ODD >> 8);
    8ef4:	94 2f       	mov	r25, r20
    8ef6:	93 77       	andi	r25, 0x73	; 115
    8ef8:	89 27       	eor	r24, r25
    Feedback ^= O2 & (uint8_t) (LFSR_MASK_ODD >> 16);
    8efa:	93 2f       	mov	r25, r19
    8efc:	9a 73       	andi	r25, 0x3A	; 58
    8efe:	89 27       	eor	r24, r25

    /* fold 8 into 1 bit */
    Feedback ^= ((Feedback >> 4)|(Feedback << 4)); /* Compiler uses a swap for this (fast!) */
    8f00:	98 2f       	mov	r25, r24
    8f02:	92 95       	swap	r25
    8f04:	89 27       	eor	r24, r25
    Feedback ^= Feedback >> 2;
    8f06:	98 2f       	mov	r25, r24
    8f08:	96 95       	lsr	r25
    8f0a:	96 95       	lsr	r25
    8f0c:	89 27       	eor	r24, r25
    Feedback ^= Feedback >> 1;
    8f0e:	98 2f       	mov	r25, r24
    8f10:	96 95       	lsr	r25
    8f12:	89 27       	eor	r24, r25

        /* Bit 4 */
        Out = CRYPTO1_FILTER_OUTPUT_B7_24(Odd0, Odd1, Odd2);
        KeyStream = (KeyStream>>1) | Out;
        Feedback  = Crypto1LFSRbyteFeedback(Even0,Even1,Even2,Odd0,Odd1,Odd2);
        SHIFT24(Even0,Even1,Even2, Feedback);
    8f14:	86 95       	lsr	r24
    8f16:	27 95       	ror	r18
    8f18:	77 95       	ror	r23
    8f1a:	a7 95       	ror	r26
        KeyStream = (KeyStream>>1) | Out;
        Feedback = Crypto1LFSRbyteFeedback(Odd0,Odd1,Odd2,Even0,Even1,Even2);
        SHIFT24(Odd0,Odd1,Odd2, Feedback);

        /* Bit 4 */
        Out = CRYPTO1_FILTER_OUTPUT_B7_24(Odd0, Odd1, Odd2);
    8f1c:	c4 2f       	mov	r28, r20
    8f1e:	d0 e0       	ldi	r29, 0x00	; 0
    8f20:	c8 54       	subi	r28, 0x48	; 72
    8f22:	de 4d       	sbci	r29, 0xDE	; 222
    8f24:	85 2f       	mov	r24, r21
    8f26:	90 e0       	ldi	r25, 0x00	; 0
    8f28:	88 54       	subi	r24, 0x48	; 72
    8f2a:	9f 4d       	sbci	r25, 0xDF	; 223
    8f2c:	18 81       	ld	r17, Y
    8f2e:	ec 01       	movw	r28, r24
    8f30:	88 81       	ld	r24, Y
    8f32:	18 2b       	or	r17, r24
    8f34:	83 2f       	mov	r24, r19
    8f36:	90 e0       	ldi	r25, 0x00	; 0
    8f38:	88 54       	subi	r24, 0x48	; 72
    8f3a:	9d 4d       	sbci	r25, 0xDD	; 221
    8f3c:	ec 01       	movw	r28, r24
    8f3e:	88 81       	ld	r24, Y
    8f40:	c1 2f       	mov	r28, r17
    8f42:	c8 2b       	or	r28, r24
    8f44:	d0 e0       	ldi	r29, 0x00	; 0
    8f46:	c8 58       	subi	r28, 0x88	; 136
    8f48:	df 4d       	sbci	r29, 0xDF	; 223
        KeyStream = (KeyStream>>1) | Out;
    8f4a:	88 81       	ld	r24, Y
    8f4c:	b8 2b       	or	r27, r24
        SHIFT24(Even0,Even1,Even2, Feedback);

        /* Bit 5 */
        /* remember Odd/Even swap has been omitted! */
        Out = CRYPTO1_FILTER_OUTPUT_B7_24(Even0,Even1,Even2);
        KeyStream = (KeyStream>>1) | Out;
    8f4e:	b6 95       	lsr	r27
    uint8_t Feedback;

    /* Calculate feedback according to LFSR taps. XOR all state bytes
     * into a single bit. */
    Feedback  = E0 & (uint8_t) (LFSR_MASK_EVEN );
    Feedback ^= E1 & (uint8_t) (LFSR_MASK_EVEN >> 8);
    8f50:	94 2f       	mov	r25, r20
    8f52:	90 71       	andi	r25, 0x10	; 16
{
    uint8_t Feedback;

    /* Calculate feedback according to LFSR taps. XOR all state bytes
     * into a single bit. */
    Feedback  = E0 & (uint8_t) (LFSR_MASK_EVEN );
    8f54:	85 2f       	mov	r24, r21
    8f56:	81 7e       	andi	r24, 0xE1	; 225
    Feedback ^= E1 & (uint8_t) (LFSR_MASK_EVEN >> 8);
    8f58:	98 27       	eor	r25, r24
    Feedback ^= E2 & (uint8_t) (LFSR_MASK_EVEN >> 16);
    8f5a:	83 2f       	mov	r24, r19
    8f5c:	80 72       	andi	r24, 0x20	; 32
    8f5e:	98 27       	eor	r25, r24

    Feedback ^= O0 & (uint8_t) (LFSR_MASK_ODD );
    8f60:	8a 2f       	mov	r24, r26
    8f62:	84 79       	andi	r24, 0x94	; 148
    8f64:	98 27       	eor	r25, r24
    Feedback ^= O1 & (uint8_t) (LFSR_MASK_ODD >> 8);
    8f66:	87 2f       	mov	r24, r23
    8f68:	83 77       	andi	r24, 0x73	; 115
    8f6a:	98 27       	eor	r25, r24
    Feedback ^= O2 & (uint8_t) (LFSR_MASK_ODD >> 16);
    8f6c:	82 2f       	mov	r24, r18
    8f6e:	8a 73       	andi	r24, 0x3A	; 58
    8f70:	98 27       	eor	r25, r24

    /* fold 8 into 1 bit */
    Feedback ^= ((Feedback >> 4)|(Feedback << 4)); /* Compiler uses a swap for this (fast!) */
    8f72:	89 2f       	mov	r24, r25
    8f74:	82 95       	swap	r24
    8f76:	98 27       	eor	r25, r24
    Feedback ^= Feedback >> 2;
    8f78:	89 2f       	mov	r24, r25
    8f7a:	86 95       	lsr	r24
    8f7c:	86 95       	lsr	r24
    8f7e:	98 27       	eor	r25, r24
    Feedback ^= Feedback >> 1;
    8f80:	89 2f       	mov	r24, r25
    8f82:	86 95       	lsr	r24
    8f84:	98 27       	eor	r25, r24
        /* Bit 5 */
        /* remember Odd/Even swap has been omitted! */
        Out = CRYPTO1_FILTER_OUTPUT_B7_24(Even0,Even1,Even2);
        KeyStream = (KeyStream>>1) | Out;
        Feedback = Crypto1LFSRbyteFeedback(Odd0,Odd1,Odd2,Even0,Even1,Even2);
        SHIFT24(Odd0,Odd1,Odd2, Feedback);
    8f86:	83 2f       	mov	r24, r19
    8f88:	96 95       	lsr	r25
    8f8a:	87 95       	ror	r24
    8f8c:	47 95       	ror	r20
    8f8e:	57 95       	ror	r21
        Feedback  = Crypto1LFSRbyteFeedback(Even0,Even1,Even2,Odd0,Odd1,Odd2);
        SHIFT24(Even0,Even1,Even2, Feedback);

        /* Bit 5 */
        /* remember Odd/Even swap has been omitted! */
        Out = CRYPTO1_FILTER_OUTPUT_B7_24(Even0,Even1,Even2);
    8f90:	c7 2f       	mov	r28, r23
    8f92:	d0 e0       	ldi	r29, 0x00	; 0
    8f94:	c8 54       	subi	r28, 0x48	; 72
    8f96:	de 4d       	sbci	r29, 0xDE	; 222
    8f98:	0a 2f       	mov	r16, r26
    8f9a:	10 e0       	ldi	r17, 0x00	; 0
    8f9c:	08 54       	subi	r16, 0x48	; 72
    8f9e:	1f 4d       	sbci	r17, 0xDF	; 223
    8fa0:	38 81       	ld	r19, Y
    8fa2:	e8 01       	movw	r28, r16
    8fa4:	98 81       	ld	r25, Y
    8fa6:	39 2b       	or	r19, r25
    8fa8:	02 2f       	mov	r16, r18
    8faa:	10 e0       	ldi	r17, 0x00	; 0
    8fac:	08 54       	subi	r16, 0x48	; 72
    8fae:	1d 4d       	sbci	r17, 0xDD	; 221
    8fb0:	e8 01       	movw	r28, r16
    8fb2:	98 81       	ld	r25, Y
    8fb4:	c3 2f       	mov	r28, r19
    8fb6:	c9 2b       	or	r28, r25
    8fb8:	d0 e0       	ldi	r29, 0x00	; 0
    8fba:	c8 58       	subi	r28, 0x88	; 136
    8fbc:	df 4d       	sbci	r29, 0xDF	; 223
        KeyStream = (KeyStream>>1) | Out;
    8fbe:	38 81       	ld	r19, Y
    8fc0:	b3 2b       	or	r27, r19
        Feedback = Crypto1LFSRbyteFeedback(Odd0,Odd1,Odd2,Even0,Even1,Even2);
        SHIFT24(Odd0,Odd1,Odd2, Feedback);

        /* Bit 6 */
        Out = CRYPTO1_FILTER_OUTPUT_B7_24(Odd0, Odd1, Odd2);
        KeyStream = (KeyStream>>1) | Out;
    8fc2:	b6 95       	lsr	r27
    uint8_t Feedback;

    /* Calculate feedback according to LFSR taps. XOR all state bytes
     * into a single bit. */
    Feedback  = E0 & (uint8_t) (LFSR_MASK_EVEN );
    Feedback ^= E1 & (uint8_t) (LFSR_MASK_EVEN >> 8);
    8fc4:	37 2f       	mov	r19, r23
    8fc6:	30 71       	andi	r19, 0x10	; 16
{
    uint8_t Feedback;

    /* Calculate feedback according to LFSR taps. XOR all state bytes
     * into a single bit. */
    Feedback  = E0 & (uint8_t) (LFSR_MASK_EVEN );
    8fc8:	9a 2f       	mov	r25, r26
    8fca:	91 7e       	andi	r25, 0xE1	; 225
    Feedback ^= E1 & (uint8_t) (LFSR_MASK_EVEN >> 8);
    8fcc:	93 27       	eor	r25, r19
    Feedback ^= E2 & (uint8_t) (LFSR_MASK_EVEN >> 16);
    8fce:	32 2f       	mov	r19, r18
    8fd0:	30 72       	andi	r19, 0x20	; 32
    8fd2:	93 27       	eor	r25, r19

    Feedback ^= O0 & (uint8_t) (LFSR_MASK_ODD );
    8fd4:	35 2f       	mov	r19, r21
    8fd6:	34 79       	andi	r19, 0x94	; 148
    8fd8:	93 27       	eor	r25, r19
    Feedback ^= O1 & (uint8_t) (LFSR_MASK_ODD >> 8);
    8fda:	34 2f       	mov	r19, r20
    8fdc:	33 77       	andi	r19, 0x73	; 115
    8fde:	93 27       	eor	r25, r19
    Feedback ^= O2 & (uint8_t) (LFSR_MASK_ODD >> 16);
    8fe0:	38 2f       	mov	r19, r24
    8fe2:	3a 73       	andi	r19, 0x3A	; 58
    8fe4:	93 27       	eor	r25, r19

    /* fold 8 into 1 bit */
    Feedback ^= ((Feedback >> 4)|(Feedback << 4)); /* Compiler uses a swap for this (fast!) */
    8fe6:	39 2f       	mov	r19, r25
    8fe8:	32 95       	swap	r19
    8fea:	93 27       	eor	r25, r19
    Feedback ^= Feedback >> 2;
    8fec:	39 2f       	mov	r19, r25
    8fee:	36 95       	lsr	r19
    8ff0:	36 95       	lsr	r19
    8ff2:	93 27       	eor	r25, r19
    Feedback ^= Feedback >> 1;
    8ff4:	39 2f       	mov	r19, r25
    8ff6:	36 95       	lsr	r19
    8ff8:	93 27       	eor	r25, r19

        /* Bit 6 */
        Out = CRYPTO1_FILTER_OUTPUT_B7_24(Odd0, Odd1, Odd2);
        KeyStream = (KeyStream>>1) | Out;
        Feedback  = Crypto1LFSRbyteFeedback(Even0,Even1,Even2,Odd0,Odd1,Odd2);
        SHIFT24(Even0,Even1,Even2, Feedback);
    8ffa:	96 95       	lsr	r25
    8ffc:	27 95       	ror	r18
    8ffe:	77 95       	ror	r23
    9000:	a7 95       	ror	r26
        KeyStream = (KeyStream>>1) | Out;
        Feedback = Crypto1LFSRbyteFeedback(Odd0,Odd1,Odd2,Even0,Even1,Even2);
        SHIFT24(Odd0,Odd1,Odd2, Feedback);

        /* Bit 6 */
        Out = CRYPTO1_FILTER_OUTPUT_B7_24(Odd0, Odd1, Odd2);
    9002:	c4 2f       	mov	r28, r20
    9004:	d0 e0       	ldi	r29, 0x00	; 0
    9006:	c8 54       	subi	r28, 0x48	; 72
    9008:	de 4d       	sbci	r29, 0xDE	; 222
    900a:	05 2f       	mov	r16, r21
    900c:	10 e0       	ldi	r17, 0x00	; 0
    900e:	08 54       	subi	r16, 0x48	; 72
    9010:	1f 4d       	sbci	r17, 0xDF	; 223
    9012:	38 81       	ld	r19, Y
    9014:	e8 01       	movw	r28, r16
    9016:	98 81       	ld	r25, Y
    9018:	39 2b       	or	r19, r25
    901a:	08 2f       	mov	r16, r24
    901c:	10 e0       	ldi	r17, 0x00	; 0
    901e:	08 54       	subi	r16, 0x48	; 72
    9020:	1d 4d       	sbci	r17, 0xDD	; 221
    9022:	e8 01       	movw	r28, r16
    9024:	98 81       	ld	r25, Y
    9026:	c3 2f       	mov	r28, r19
    9028:	c9 2b       	or	r28, r25
    902a:	d0 e0       	ldi	r29, 0x00	; 0
    902c:	c8 58       	subi	r28, 0x88	; 136
    902e:	df 4d       	sbci	r29, 0xDF	; 223
        KeyStream = (KeyStream>>1) | Out;
    9030:	98 81       	ld	r25, Y
    9032:	3b 2f       	mov	r19, r27
    9034:	39 2b       	or	r19, r25
        SHIFT24(Even0,Even1,Even2, Feedback);

        /* Bit 7 */
        /* remember Odd/Even swap has been omitted! */
        Out = CRYPTO1_FILTER_OUTPUT_B7_24(Even0,Even1,Even2);
        KeyStream = (KeyStream>>1) | Out;
    9036:	36 95       	lsr	r19
        Feedback  = Crypto1LFSRbyteFeedback(Even0,Even1,Even2,Odd0,Odd1,Odd2);
        SHIFT24(Even0,Even1,Even2, Feedback);

        /* Bit 7 */
        /* remember Odd/Even swap has been omitted! */
        Out = CRYPTO1_FILTER_OUTPUT_B7_24(Even0,Even1,Even2);
    9038:	c7 2f       	mov	r28, r23
    903a:	d0 e0       	ldi	r29, 0x00	; 0
    903c:	c8 54       	subi	r28, 0x48	; 72
    903e:	de 4d       	sbci	r29, 0xDE	; 222
    9040:	0a 2f       	mov	r16, r26
    9042:	10 e0       	ldi	r17, 0x00	; 0
    9044:	08 54       	subi	r16, 0x48	; 72
    9046:	1f 4d       	sbci	r17, 0xDF	; 223
    9048:	b8 81       	ld	r27, Y
    904a:	e8 01       	movw	r28, r16
    904c:	98 81       	ld	r25, Y
    904e:	b9 2b       	or	r27, r25
    9050:	02 2f       	mov	r16, r18
    9052:	10 e0       	ldi	r17, 0x00	; 0
    9054:	08 54       	subi	r16, 0x48	; 72
    9056:	1d 4d       	sbci	r17, 0xDD	; 221
    9058:	e8 01       	movw	r28, r16
    905a:	98 81       	ld	r25, Y
    905c:	cb 2f       	mov	r28, r27
    905e:	c9 2b       	or	r28, r25
    9060:	d0 e0       	ldi	r29, 0x00	; 0
    9062:	c8 58       	subi	r28, 0x88	; 136
    9064:	df 4d       	sbci	r29, 0xDF	; 223
        KeyStream = (KeyStream>>1) | Out;
    9066:	b8 81       	ld	r27, Y
    9068:	b3 2b       	or	r27, r19
    uint8_t Feedback;

    /* Calculate feedback according to LFSR taps. XOR all state bytes
     * into a single bit. */
    Feedback  = E0 & (uint8_t) (LFSR_MASK_EVEN );
    Feedback ^= E1 & (uint8_t) (LFSR_MASK_EVEN >> 8);
    906a:	34 2f       	mov	r19, r20
    906c:	30 71       	andi	r19, 0x10	; 16
{
    uint8_t Feedback;

    /* Calculate feedback according to LFSR taps. XOR all state bytes
     * into a single bit. */
    Feedback  = E0 & (uint8_t) (LFSR_MASK_EVEN );
    906e:	95 2f       	mov	r25, r21
    9070:	91 7e       	andi	r25, 0xE1	; 225
    Feedback ^= E1 & (uint8_t) (LFSR_MASK_EVEN >> 8);
    9072:	93 27       	eor	r25, r19
    Feedback ^= E2 & (uint8_t) (LFSR_MASK_EVEN >> 16);
    9074:	38 2f       	mov	r19, r24
    9076:	30 72       	andi	r19, 0x20	; 32
    9078:	93 27       	eor	r25, r19

    Feedback ^= O0 & (uint8_t) (LFSR_MASK_ODD );
    907a:	3a 2f       	mov	r19, r26
    907c:	34 79       	andi	r19, 0x94	; 148
    907e:	93 27       	eor	r25, r19
    Feedback ^= O1 & (uint8_t) (LFSR_MASK_ODD >> 8);
    9080:	37 2f       	mov	r19, r23
    9082:	33 77       	andi	r19, 0x73	; 115
    9084:	93 27       	eor	r25, r19
    Feedback ^= O2 & (uint8_t) (LFSR_MASK_ODD >> 16);
    9086:	32 2f       	mov	r19, r18
    9088:	3a 73       	andi	r19, 0x3A	; 58
    908a:	93 27       	eor	r25, r19

    /* fold 8 into 1 bit */
    Feedback ^= ((Feedback >> 4)|(Feedback << 4)); /* Compiler uses a swap for this (fast!) */
    908c:	39 2f       	mov	r19, r25
    908e:	32 95       	swap	r19
    9090:	93 27       	eor	r25, r19
    Feedback ^= Feedback >> 2;
    9092:	39 2f       	mov	r19, r25
    9094:	36 95       	lsr	r19
    9096:	36 95       	lsr	r19
    9098:	93 27       	eor	r25, r19
    Feedback ^= Feedback >> 1;
    909a:	39 2f       	mov	r19, r25
    909c:	36 95       	lsr	r19
    909e:	93 27       	eor	r25, r19
        /* Bit 7 */
        /* remember Odd/Even swap has been omitted! */
        Out = CRYPTO1_FILTER_OUTPUT_B7_24(Even0,Even1,Even2);
        KeyStream = (KeyStream>>1) | Out;
        Feedback = Crypto1LFSRbyteFeedback(Odd0,Odd1,Odd2,Even0,Even1,Even2);
        SHIFT24(Odd0,Odd1,Odd2, Feedback);
    90a0:	38 2f       	mov	r19, r24
    90a2:	96 95       	lsr	r25
    90a4:	37 95       	ror	r19
    90a6:	47 95       	ror	r20
    90a8:	57 95       	ror	r21

        /* Transcrypt and increment buffer address */
        *Buffer++ ^= KeyStream;
    90aa:	80 81       	ld	r24, Z
    90ac:	8b 27       	eor	r24, r27
    90ae:	81 93       	st	Z+, r24
    90b0:	30 ce       	rjmp	.-928    	; 0x8d12 <Crypto1ByteArray+0x22>
    }

    /* save state */
    State.Even[0] = Even0;
    90b2:	a0 93 df 2c 	sts	0x2CDF, r26
    State.Even[1] = Even1;
    90b6:	70 93 e0 2c 	sts	0x2CE0, r23
    State.Even[2] = Even2;
    90ba:	20 93 e1 2c 	sts	0x2CE1, r18
    State.Odd[0]  = Odd0;
    90be:	50 93 e2 2c 	sts	0x2CE2, r21
    State.Odd[1]  = Odd1;
    90c2:	40 93 e3 2c 	sts	0x2CE3, r20
    State.Odd[2]  = Odd2;
    90c6:	30 93 e4 2c 	sts	0x2CE4, r19
}
    90ca:	df 91       	pop	r29
    90cc:	cf 91       	pop	r28
    90ce:	1f 91       	pop	r17
    90d0:	0f 91       	pop	r16
    90d2:	08 95       	ret

000090d4 <Crypto1ByteArrayWithParity>:
/* No input to the LFSR                                    */
/* Avoids load/store of the LFSR-state for each byte!      */
/* The filter output used to encrypt the parity is         */
/* reused to encrypt bit 0 in the next byte.               */
void Crypto1ByteArrayWithParity(uint8_t* Buffer, uint8_t Count)
{
    90d4:	cf 92       	push	r12
    90d6:	df 92       	push	r13
    90d8:	ef 92       	push	r14
    90da:	ff 92       	push	r15
    90dc:	1f 93       	push	r17
    90de:	cf 93       	push	r28
    90e0:	df 93       	push	r29
    uint8_t KeyStream = 0;
    uint8_t Feedback;
    uint8_t Out;
    
    /* read state */
    Even0 = State.Even[0];
    90e2:	10 91 df 2c 	lds	r17, 0x2CDF
    Even1 = State.Even[1];
    90e6:	d0 91 e0 2c 	lds	r29, 0x2CE0
    Even2 = State.Even[2];
    90ea:	c0 91 e1 2c 	lds	r28, 0x2CE1
    Odd0 = State.Odd[0];
    90ee:	70 91 e2 2c 	lds	r23, 0x2CE2
    Odd1 = State.Odd[1];
    90f2:	40 91 e3 2c 	lds	r20, 0x2CE3
    Odd2 = State.Odd[2];
    90f6:	20 91 e4 2c 	lds	r18, 0x2CE4

    /* First pass needs output, next pass uses parity bit! */
    Out = CRYPTO1_FILTER_OUTPUT_B0_24(Odd0, Odd1, Odd2);
    90fa:	e4 2f       	mov	r30, r20
    90fc:	f0 e0       	ldi	r31, 0x00	; 0
    90fe:	e8 54       	subi	r30, 0x48	; 72
    9100:	fe 4d       	sbci	r31, 0xDE	; 222
    9102:	a7 2f       	mov	r26, r23
    9104:	b0 e0       	ldi	r27, 0x00	; 0
    9106:	a8 54       	subi	r26, 0x48	; 72
    9108:	bf 4d       	sbci	r27, 0xDF	; 223
    910a:	e0 81       	ld	r30, Z
    910c:	3c 91       	ld	r19, X
    910e:	e3 2b       	or	r30, r19
    9110:	a2 2f       	mov	r26, r18
    9112:	b0 e0       	ldi	r27, 0x00	; 0
    9114:	a8 54       	subi	r26, 0x48	; 72
    9116:	bd 4d       	sbci	r27, 0xDD	; 221
    9118:	3c 91       	ld	r19, X
    911a:	e3 2b       	or	r30, r19
    911c:	f0 e0       	ldi	r31, 0x00	; 0
    911e:	e8 56       	subi	r30, 0x68	; 104
    9120:	ff 4d       	sbci	r31, 0xDF	; 223
    9122:	30 81       	ld	r19, Z
    9124:	dc 01       	movw	r26, r24
void Crypto1ByteArrayWithParity(uint8_t* Buffer, uint8_t Count)
{
    /* state registers */
    register uint8_t Even0, Even1, Even2;
    register uint8_t Odd0,  Odd1,  Odd2;
    uint8_t KeyStream = 0;
    9126:	80 e0       	ldi	r24, 0x00	; 0
    Odd2 = State.Odd[2];

    /* First pass needs output, next pass uses parity bit! */
    Out = CRYPTO1_FILTER_OUTPUT_B0_24(Odd0, Odd1, Odd2);

    while(Count--)
    9128:	61 50       	subi	r22, 0x01	; 1
    912a:	08 f4       	brcc	.+2      	; 0x912e <Crypto1ByteArrayWithParity+0x5a>
    912c:	05 c2       	rjmp	.+1034   	; 0x9538 <Crypto1ByteArrayWithParity+0x464>
    {
        /* Bit 0, initialise keystream from parity */
        SHIFT8(KeyStream,Out);
    912e:	58 2f       	mov	r21, r24
    9130:	36 95       	lsr	r19
    9132:	57 95       	ror	r21
    uint8_t Feedback;

    /* Calculate feedback according to LFSR taps. XOR all state bytes
     * into a single bit. */
    Feedback  = E0 & (uint8_t) (LFSR_MASK_EVEN );
    Feedback ^= E1 & (uint8_t) (LFSR_MASK_EVEN >> 8);
    9134:	9d 2f       	mov	r25, r29
    9136:	90 71       	andi	r25, 0x10	; 16
{
    uint8_t Feedback;

    /* Calculate feedback according to LFSR taps. XOR all state bytes
     * into a single bit. */
    Feedback  = E0 & (uint8_t) (LFSR_MASK_EVEN );
    9138:	81 2f       	mov	r24, r17
    913a:	81 7e       	andi	r24, 0xE1	; 225
    Feedback ^= E1 & (uint8_t) (LFSR_MASK_EVEN >> 8);
    913c:	89 27       	eor	r24, r25
    Feedback ^= E2 & (uint8_t) (LFSR_MASK_EVEN >> 16);
    913e:	9c 2f       	mov	r25, r28
    9140:	90 72       	andi	r25, 0x20	; 32
    9142:	89 27       	eor	r24, r25

    Feedback ^= O0 & (uint8_t) (LFSR_MASK_ODD );
    9144:	97 2f       	mov	r25, r23
    9146:	94 79       	andi	r25, 0x94	; 148
    9148:	89 27       	eor	r24, r25
    Feedback ^= O1 & (uint8_t) (LFSR_MASK_ODD >> 8);
    914a:	94 2f       	mov	r25, r20
    914c:	93 77       	andi	r25, 0x73	; 115
    914e:	89 27       	eor	r24, r25
    Feedback ^= O2 & (uint8_t) (LFSR_MASK_ODD >> 16);
    9150:	32 2f       	mov	r19, r18
    9152:	3a 73       	andi	r19, 0x3A	; 58
    9154:	83 27       	eor	r24, r19

    /* fold 8 into 1 bit */
    Feedback ^= ((Feedback >> 4)|(Feedback << 4)); /* Compiler uses a swap for this (fast!) */
    9156:	98 2f       	mov	r25, r24
    9158:	92 95       	swap	r25
    915a:	89 27       	eor	r24, r25
    Feedback ^= Feedback >> 2;
    915c:	98 2f       	mov	r25, r24
    915e:	96 95       	lsr	r25
    9160:	96 95       	lsr	r25
    9162:	89 27       	eor	r24, r25
    Feedback ^= Feedback >> 1;
    9164:	98 2f       	mov	r25, r24
    9166:	96 95       	lsr	r25
    9168:	89 27       	eor	r24, r25
    while(Count--)
    {
        /* Bit 0, initialise keystream from parity */
        SHIFT8(KeyStream,Out);
        Feedback  = Crypto1LFSRbyteFeedback(Even0,Even1,Even2,Odd0,Odd1,Odd2);
        SHIFT24(Even0,Even1,Even2, Feedback);
    916a:	9c 2f       	mov	r25, r28
    916c:	86 95       	lsr	r24
    916e:	97 95       	ror	r25
    9170:	d7 95       	ror	r29
    9172:	17 95       	ror	r17

        /* Bit 1 */
        /* remember Odd/Even swap has been omitted! */
        Out = CRYPTO1_FILTER_OUTPUT_B7_24(Even0,Even1,Even2);
        KeyStream = (KeyStream>>1) | Out;
    9174:	56 95       	lsr	r21
    uint8_t Feedback;

    /* Calculate feedback according to LFSR taps. XOR all state bytes
     * into a single bit. */
    Feedback  = E0 & (uint8_t) (LFSR_MASK_EVEN );
    Feedback ^= E1 & (uint8_t) (LFSR_MASK_EVEN >> 8);
    9176:	34 2f       	mov	r19, r20
    9178:	30 71       	andi	r19, 0x10	; 16
{
    uint8_t Feedback;

    /* Calculate feedback according to LFSR taps. XOR all state bytes
     * into a single bit. */
    Feedback  = E0 & (uint8_t) (LFSR_MASK_EVEN );
    917a:	87 2f       	mov	r24, r23
    917c:	81 7e       	andi	r24, 0xE1	; 225
    Feedback ^= E1 & (uint8_t) (LFSR_MASK_EVEN >> 8);
    917e:	83 27       	eor	r24, r19
    Feedback ^= E2 & (uint8_t) (LFSR_MASK_EVEN >> 16);
    9180:	32 2f       	mov	r19, r18
    9182:	30 72       	andi	r19, 0x20	; 32
    9184:	83 27       	eor	r24, r19

    Feedback ^= O0 & (uint8_t) (LFSR_MASK_ODD );
    9186:	31 2f       	mov	r19, r17
    9188:	34 79       	andi	r19, 0x94	; 148
    918a:	83 27       	eor	r24, r19
    Feedback ^= O1 & (uint8_t) (LFSR_MASK_ODD >> 8);
    918c:	3d 2f       	mov	r19, r29
    918e:	33 77       	andi	r19, 0x73	; 115
    9190:	83 27       	eor	r24, r19
    Feedback ^= O2 & (uint8_t) (LFSR_MASK_ODD >> 16);
    9192:	39 2f       	mov	r19, r25
    9194:	3a 73       	andi	r19, 0x3A	; 58
    9196:	83 27       	eor	r24, r19

    /* fold 8 into 1 bit */
    Feedback ^= ((Feedback >> 4)|(Feedback << 4)); /* Compiler uses a swap for this (fast!) */
    9198:	38 2f       	mov	r19, r24
    919a:	32 95       	swap	r19
    919c:	83 27       	eor	r24, r19
    Feedback ^= Feedback >> 2;
    919e:	38 2f       	mov	r19, r24
    91a0:	36 95       	lsr	r19
    91a2:	36 95       	lsr	r19
    91a4:	83 27       	eor	r24, r19
    Feedback ^= Feedback >> 1;
    91a6:	38 2f       	mov	r19, r24
    91a8:	36 95       	lsr	r19
    91aa:	83 27       	eor	r24, r19
        /* Bit 1 */
        /* remember Odd/Even swap has been omitted! */
        Out = CRYPTO1_FILTER_OUTPUT_B7_24(Even0,Even1,Even2);
        KeyStream = (KeyStream>>1) | Out;
        Feedback = Crypto1LFSRbyteFeedback(Odd0,Odd1,Odd2,Even0,Even1,Even2);
        SHIFT24(Odd0,Odd1,Odd2, Feedback);
    91ac:	86 95       	lsr	r24
    91ae:	27 95       	ror	r18
    91b0:	47 95       	ror	r20
    91b2:	77 95       	ror	r23
        Feedback  = Crypto1LFSRbyteFeedback(Even0,Even1,Even2,Odd0,Odd1,Odd2);
        SHIFT24(Even0,Even1,Even2, Feedback);

        /* Bit 1 */
        /* remember Odd/Even swap has been omitted! */
        Out = CRYPTO1_FILTER_OUTPUT_B7_24(Even0,Even1,Even2);
    91b4:	cd 2e       	mov	r12, r29
    91b6:	d1 2c       	mov	r13, r1
    91b8:	f6 01       	movw	r30, r12
    91ba:	e8 54       	subi	r30, 0x48	; 72
    91bc:	fe 4d       	sbci	r31, 0xDE	; 222
    91be:	6f 01       	movw	r12, r30
    91c0:	e1 2e       	mov	r14, r17
    91c2:	f1 2c       	mov	r15, r1
    91c4:	f7 01       	movw	r30, r14
    91c6:	e8 54       	subi	r30, 0x48	; 72
    91c8:	ff 4d       	sbci	r31, 0xDF	; 223
    91ca:	7f 01       	movw	r14, r30
    91cc:	f6 01       	movw	r30, r12
    91ce:	30 81       	ld	r19, Z
    91d0:	f7 01       	movw	r30, r14
    91d2:	80 81       	ld	r24, Z
    91d4:	83 2b       	or	r24, r19
    91d6:	e9 2e       	mov	r14, r25
    91d8:	f1 2c       	mov	r15, r1
    91da:	f7 01       	movw	r30, r14
    91dc:	e8 54       	subi	r30, 0x48	; 72
    91de:	fd 4d       	sbci	r31, 0xDD	; 221
    91e0:	30 81       	ld	r19, Z
    91e2:	e8 2f       	mov	r30, r24
    91e4:	e3 2b       	or	r30, r19
    91e6:	f0 e0       	ldi	r31, 0x00	; 0
    91e8:	e8 58       	subi	r30, 0x88	; 136
    91ea:	ff 4d       	sbci	r31, 0xDF	; 223
        KeyStream = (KeyStream>>1) | Out;
    91ec:	80 81       	ld	r24, Z
    91ee:	58 2b       	or	r21, r24
        Feedback = Crypto1LFSRbyteFeedback(Odd0,Odd1,Odd2,Even0,Even1,Even2);
        SHIFT24(Odd0,Odd1,Odd2, Feedback);

        /* Bit 2 */
        Out = CRYPTO1_FILTER_OUTPUT_B7_24(Odd0, Odd1, Odd2);
        KeyStream = (KeyStream>>1) | Out;
    91f0:	56 95       	lsr	r21
    uint8_t Feedback;

    /* Calculate feedback according to LFSR taps. XOR all state bytes
     * into a single bit. */
    Feedback  = E0 & (uint8_t) (LFSR_MASK_EVEN );
    Feedback ^= E1 & (uint8_t) (LFSR_MASK_EVEN >> 8);
    91f2:	3d 2f       	mov	r19, r29
    91f4:	30 71       	andi	r19, 0x10	; 16
{
    uint8_t Feedback;

    /* Calculate feedback according to LFSR taps. XOR all state bytes
     * into a single bit. */
    Feedback  = E0 & (uint8_t) (LFSR_MASK_EVEN );
    91f6:	81 2f       	mov	r24, r17
    91f8:	81 7e       	andi	r24, 0xE1	; 225
    Feedback ^= E1 & (uint8_t) (LFSR_MASK_EVEN >> 8);
    91fa:	83 27       	eor	r24, r19
    Feedback ^= E2 & (uint8_t) (LFSR_MASK_EVEN >> 16);
    91fc:	39 2f       	mov	r19, r25
    91fe:	30 72       	andi	r19, 0x20	; 32
    9200:	83 27       	eor	r24, r19

    Feedback ^= O0 & (uint8_t) (LFSR_MASK_ODD );
    9202:	37 2f       	mov	r19, r23
    9204:	34 79       	andi	r19, 0x94	; 148
    9206:	83 27       	eor	r24, r19
    Feedback ^= O1 & (uint8_t) (LFSR_MASK_ODD >> 8);
    9208:	34 2f       	mov	r19, r20
    920a:	33 77       	andi	r19, 0x73	; 115
    920c:	83 27       	eor	r24, r19
    Feedback ^= O2 & (uint8_t) (LFSR_MASK_ODD >> 16);
    920e:	32 2f       	mov	r19, r18
    9210:	3a 73       	andi	r19, 0x3A	; 58
    9212:	83 27       	eor	r24, r19

    /* fold 8 into 1 bit */
    Feedback ^= ((Feedback >> 4)|(Feedback << 4)); /* Compiler uses a swap for this (fast!) */
    9214:	38 2f       	mov	r19, r24
    9216:	32 95       	swap	r19
    9218:	83 27       	eor	r24, r19
    Feedback ^= Feedback >> 2;
    921a:	38 2f       	mov	r19, r24
    921c:	36 95       	lsr	r19
    921e:	36 95       	lsr	r19
    9220:	83 27       	eor	r24, r19
    Feedback ^= Feedback >> 1;
    9222:	38 2f       	mov	r19, r24
    9224:	36 95       	lsr	r19
    9226:	83 27       	eor	r24, r19

        /* Bit 2 */
        Out = CRYPTO1_FILTER_OUTPUT_B7_24(Odd0, Odd1, Odd2);
        KeyStream = (KeyStream>>1) | Out;
        Feedback  = Crypto1LFSRbyteFeedback(Even0,Even1,Even2,Odd0,Odd1,Odd2);
        SHIFT24(Even0,Even1,Even2, Feedback);
    9228:	86 95       	lsr	r24
    922a:	97 95       	ror	r25
    922c:	d7 95       	ror	r29
    922e:	17 95       	ror	r17
        KeyStream = (KeyStream>>1) | Out;
        Feedback = Crypto1LFSRbyteFeedback(Odd0,Odd1,Odd2,Even0,Even1,Even2);
        SHIFT24(Odd0,Odd1,Odd2, Feedback);

        /* Bit 2 */
        Out = CRYPTO1_FILTER_OUTPUT_B7_24(Odd0, Odd1, Odd2);
    9230:	c4 2e       	mov	r12, r20
    9232:	d1 2c       	mov	r13, r1
    9234:	f6 01       	movw	r30, r12
    9236:	e8 54       	subi	r30, 0x48	; 72
    9238:	fe 4d       	sbci	r31, 0xDE	; 222
    923a:	6f 01       	movw	r12, r30
    923c:	e7 2e       	mov	r14, r23
    923e:	f1 2c       	mov	r15, r1
    9240:	f7 01       	movw	r30, r14
    9242:	e8 54       	subi	r30, 0x48	; 72
    9244:	ff 4d       	sbci	r31, 0xDF	; 223
    9246:	7f 01       	movw	r14, r30
    9248:	f6 01       	movw	r30, r12
    924a:	30 81       	ld	r19, Z
    924c:	f7 01       	movw	r30, r14
    924e:	80 81       	ld	r24, Z
    9250:	83 2b       	or	r24, r19
    9252:	e2 2e       	mov	r14, r18
    9254:	f1 2c       	mov	r15, r1
    9256:	f7 01       	movw	r30, r14
    9258:	e8 54       	subi	r30, 0x48	; 72
    925a:	fd 4d       	sbci	r31, 0xDD	; 221
    925c:	30 81       	ld	r19, Z
    925e:	e8 2f       	mov	r30, r24
    9260:	e3 2b       	or	r30, r19
    9262:	f0 e0       	ldi	r31, 0x00	; 0
    9264:	e8 58       	subi	r30, 0x88	; 136
    9266:	ff 4d       	sbci	r31, 0xDF	; 223
        KeyStream = (KeyStream>>1) | Out;
    9268:	c0 81       	ld	r28, Z
    926a:	5c 2b       	or	r21, r28
        SHIFT24(Even0,Even1,Even2, Feedback);

        /* Bit 3 */
        /* remember Odd/Even swap has been omitted! */
        Out = CRYPTO1_FILTER_OUTPUT_B7_24(Even0,Even1,Even2);
        KeyStream = (KeyStream>>1) | Out;
    926c:	56 95       	lsr	r21
    uint8_t Feedback;

    /* Calculate feedback according to LFSR taps. XOR all state bytes
     * into a single bit. */
    Feedback  = E0 & (uint8_t) (LFSR_MASK_EVEN );
    Feedback ^= E1 & (uint8_t) (LFSR_MASK_EVEN >> 8);
    926e:	34 2f       	mov	r19, r20
    9270:	30 71       	andi	r19, 0x10	; 16
{
    uint8_t Feedback;

    /* Calculate feedback according to LFSR taps. XOR all state bytes
     * into a single bit. */
    Feedback  = E0 & (uint8_t) (LFSR_MASK_EVEN );
    9272:	87 2f       	mov	r24, r23
    9274:	81 7e       	andi	r24, 0xE1	; 225
    Feedback ^= E1 & (uint8_t) (LFSR_MASK_EVEN >> 8);
    9276:	83 27       	eor	r24, r19
    Feedback ^= E2 & (uint8_t) (LFSR_MASK_EVEN >> 16);
    9278:	32 2f       	mov	r19, r18
    927a:	30 72       	andi	r19, 0x20	; 32
    927c:	83 27       	eor	r24, r19

    Feedback ^= O0 & (uint8_t) (LFSR_MASK_ODD );
    927e:	31 2f       	mov	r19, r17
    9280:	34 79       	andi	r19, 0x94	; 148
    9282:	83 27       	eor	r24, r19
    Feedback ^= O1 & (uint8_t) (LFSR_MASK_ODD >> 8);
    9284:	3d 2f       	mov	r19, r29
    9286:	33 77       	andi	r19, 0x73	; 115
    9288:	83 27       	eor	r24, r19
    Feedback ^= O2 & (uint8_t) (LFSR_MASK_ODD >> 16);
    928a:	39 2f       	mov	r19, r25
    928c:	3a 73       	andi	r19, 0x3A	; 58
    928e:	83 27       	eor	r24, r19

    /* fold 8 into 1 bit */
    Feedback ^= ((Feedback >> 4)|(Feedback << 4)); /* Compiler uses a swap for this (fast!) */
    9290:	38 2f       	mov	r19, r24
    9292:	32 95       	swap	r19
    9294:	83 27       	eor	r24, r19
    Feedback ^= Feedback >> 2;
    9296:	38 2f       	mov	r19, r24
    9298:	36 95       	lsr	r19
    929a:	36 95       	lsr	r19
    929c:	83 27       	eor	r24, r19
    Feedback ^= Feedback >> 1;
    929e:	38 2f       	mov	r19, r24
    92a0:	36 95       	lsr	r19
    92a2:	83 27       	eor	r24, r19
        /* Bit 3 */
        /* remember Odd/Even swap has been omitted! */
        Out = CRYPTO1_FILTER_OUTPUT_B7_24(Even0,Even1,Even2);
        KeyStream = (KeyStream>>1) | Out;
        Feedback = Crypto1LFSRbyteFeedback(Odd0,Odd1,Odd2,Even0,Even1,Even2);
        SHIFT24(Odd0,Odd1,Odd2, Feedback);
    92a4:	86 95       	lsr	r24
    92a6:	27 95       	ror	r18
    92a8:	47 95       	ror	r20
    92aa:	77 95       	ror	r23
        Feedback  = Crypto1LFSRbyteFeedback(Even0,Even1,Even2,Odd0,Odd1,Odd2);
        SHIFT24(Even0,Even1,Even2, Feedback);

        /* Bit 3 */
        /* remember Odd/Even swap has been omitted! */
        Out = CRYPTO1_FILTER_OUTPUT_B7_24(Even0,Even1,Even2);
    92ac:	cd 2e       	mov	r12, r29
    92ae:	d1 2c       	mov	r13, r1
    92b0:	f6 01       	movw	r30, r12
    92b2:	e8 54       	subi	r30, 0x48	; 72
    92b4:	fe 4d       	sbci	r31, 0xDE	; 222
    92b6:	6f 01       	movw	r12, r30
    92b8:	e1 2e       	mov	r14, r17
    92ba:	f1 2c       	mov	r15, r1
    92bc:	f7 01       	movw	r30, r14
    92be:	e8 54       	subi	r30, 0x48	; 72
    92c0:	ff 4d       	sbci	r31, 0xDF	; 223
    92c2:	7f 01       	movw	r14, r30
    92c4:	f6 01       	movw	r30, r12
    92c6:	30 81       	ld	r19, Z
    92c8:	f7 01       	movw	r30, r14
    92ca:	80 81       	ld	r24, Z
    92cc:	83 2b       	or	r24, r19
    92ce:	e9 2e       	mov	r14, r25
    92d0:	f1 2c       	mov	r15, r1
    92d2:	f7 01       	movw	r30, r14
    92d4:	e8 54       	subi	r30, 0x48	; 72
    92d6:	fd 4d       	sbci	r31, 0xDD	; 221
    92d8:	30 81       	ld	r19, Z
    92da:	e8 2f       	mov	r30, r24
    92dc:	e3 2b       	or	r30, r19
    92de:	f0 e0       	ldi	r31, 0x00	; 0
    92e0:	e8 58       	subi	r30, 0x88	; 136
    92e2:	ff 4d       	sbci	r31, 0xDF	; 223
        KeyStream = (KeyStream>>1) | Out;
    92e4:	c0 81       	ld	r28, Z
    92e6:	c5 2b       	or	r28, r21
        Feedback = Crypto1LFSRbyteFeedback(Odd0,Odd1,Odd2,Even0,Even1,Even2);
        SHIFT24(Odd0,Odd1,Odd2, Feedback);

        /* Bit 4 */
        Out = CRYPTO1_FILTER_OUTPUT_B7_24(Odd0, Odd1, Odd2);
        KeyStream = (KeyStream>>1) | Out;
    92e8:	c6 95       	lsr	r28
    uint8_t Feedback;

    /* Calculate feedback according to LFSR taps. XOR all state bytes
     * into a single bit. */
    Feedback  = E0 & (uint8_t) (LFSR_MASK_EVEN );
    Feedback ^= E1 & (uint8_t) (LFSR_MASK_EVEN >> 8);
    92ea:	3d 2f       	mov	r19, r29
    92ec:	30 71       	andi	r19, 0x10	; 16
{
    uint8_t Feedback;

    /* Calculate feedback according to LFSR taps. XOR all state bytes
     * into a single bit. */
    Feedback  = E0 & (uint8_t) (LFSR_MASK_EVEN );
    92ee:	81 2f       	mov	r24, r17
    92f0:	81 7e       	andi	r24, 0xE1	; 225
    Feedback ^= E1 & (uint8_t) (LFSR_MASK_EVEN >> 8);
    92f2:	83 27       	eor	r24, r19
    Feedback ^= E2 & (uint8_t) (LFSR_MASK_EVEN >> 16);
    92f4:	39 2f       	mov	r19, r25
    92f6:	30 72       	andi	r19, 0x20	; 32
    92f8:	83 27       	eor	r24, r19

    Feedback ^= O0 & (uint8_t) (LFSR_MASK_ODD );
    92fa:	37 2f       	mov	r19, r23
    92fc:	34 79       	andi	r19, 0x94	; 148
    92fe:	83 27       	eor	r24, r19
    Feedback ^= O1 & (uint8_t) (LFSR_MASK_ODD >> 8);
    9300:	34 2f       	mov	r19, r20
    9302:	33 77       	andi	r19, 0x73	; 115
    9304:	83 27       	eor	r24, r19
    Feedback ^= O2 & (uint8_t) (LFSR_MASK_ODD >> 16);
    9306:	32 2f       	mov	r19, r18
    9308:	3a 73       	andi	r19, 0x3A	; 58
    930a:	83 27       	eor	r24, r19

    /* fold 8 into 1 bit */
    Feedback ^= ((Feedback >> 4)|(Feedback << 4)); /* Compiler uses a swap for this (fast!) */
    930c:	38 2f       	mov	r19, r24
    930e:	32 95       	swap	r19
    9310:	83 27       	eor	r24, r19
    Feedback ^= Feedback >> 2;
    9312:	38 2f       	mov	r19, r24
    9314:	36 95       	lsr	r19
    9316:	36 95       	lsr	r19
    9318:	83 27       	eor	r24, r19
    Feedback ^= Feedback >> 1;
    931a:	38 2f       	mov	r19, r24
    931c:	36 95       	lsr	r19
    931e:	83 27       	eor	r24, r19

        /* Bit 4 */
        Out = CRYPTO1_FILTER_OUTPUT_B7_24(Odd0, Odd1, Odd2);
        KeyStream = (KeyStream>>1) | Out;
        Feedback  = Crypto1LFSRbyteFeedback(Even0,Even1,Even2,Odd0,Odd1,Odd2);
        SHIFT24(Even0,Even1,Even2, Feedback);
    9320:	86 95       	lsr	r24
    9322:	97 95       	ror	r25
    9324:	d7 95       	ror	r29
    9326:	17 95       	ror	r17
        KeyStream = (KeyStream>>1) | Out;
        Feedback = Crypto1LFSRbyteFeedback(Odd0,Odd1,Odd2,Even0,Even1,Even2);
        SHIFT24(Odd0,Odd1,Odd2, Feedback);

        /* Bit 4 */
        Out = CRYPTO1_FILTER_OUTPUT_B7_24(Odd0, Odd1, Odd2);
    9328:	c4 2e       	mov	r12, r20
    932a:	d1 2c       	mov	r13, r1
    932c:	f6 01       	movw	r30, r12
    932e:	e8 54       	subi	r30, 0x48	; 72
    9330:	fe 4d       	sbci	r31, 0xDE	; 222
    9332:	6f 01       	movw	r12, r30
    9334:	e7 2e       	mov	r14, r23
    9336:	f1 2c       	mov	r15, r1
    9338:	f7 01       	movw	r30, r14
    933a:	e8 54       	subi	r30, 0x48	; 72
    933c:	ff 4d       	sbci	r31, 0xDF	; 223
    933e:	7f 01       	movw	r14, r30
    9340:	f6 01       	movw	r30, r12
    9342:	30 81       	ld	r19, Z
    9344:	f7 01       	movw	r30, r14
    9346:	80 81       	ld	r24, Z
    9348:	38 2b       	or	r19, r24
    934a:	e2 2e       	mov	r14, r18
    934c:	f1 2c       	mov	r15, r1
    934e:	f7 01       	movw	r30, r14
    9350:	e8 54       	subi	r30, 0x48	; 72
    9352:	fd 4d       	sbci	r31, 0xDD	; 221
    9354:	80 81       	ld	r24, Z
    9356:	e3 2f       	mov	r30, r19
    9358:	e8 2b       	or	r30, r24
    935a:	f0 e0       	ldi	r31, 0x00	; 0
    935c:	e8 58       	subi	r30, 0x88	; 136
    935e:	ff 4d       	sbci	r31, 0xDF	; 223
        KeyStream = (KeyStream>>1) | Out;
    9360:	80 81       	ld	r24, Z
    9362:	c8 2b       	or	r28, r24
        SHIFT24(Even0,Even1,Even2, Feedback);

        /* Bit 5 */
        /* remember Odd/Even swap has been omitted! */
        Out = CRYPTO1_FILTER_OUTPUT_B7_24(Even0,Even1,Even2);
        KeyStream = (KeyStream>>1) | Out;
    9364:	c6 95       	lsr	r28
    uint8_t Feedback;

    /* Calculate feedback according to LFSR taps. XOR all state bytes
     * into a single bit. */
    Feedback  = E0 & (uint8_t) (LFSR_MASK_EVEN );
    Feedback ^= E1 & (uint8_t) (LFSR_MASK_EVEN >> 8);
    9366:	34 2f       	mov	r19, r20
    9368:	30 71       	andi	r19, 0x10	; 16
{
    uint8_t Feedback;

    /* Calculate feedback according to LFSR taps. XOR all state bytes
     * into a single bit. */
    Feedback  = E0 & (uint8_t) (LFSR_MASK_EVEN );
    936a:	87 2f       	mov	r24, r23
    936c:	81 7e       	andi	r24, 0xE1	; 225
    Feedback ^= E1 & (uint8_t) (LFSR_MASK_EVEN >> 8);
    936e:	83 27       	eor	r24, r19
    Feedback ^= E2 & (uint8_t) (LFSR_MASK_EVEN >> 16);
    9370:	32 2f       	mov	r19, r18
    9372:	30 72       	andi	r19, 0x20	; 32
    9374:	83 27       	eor	r24, r19

    Feedback ^= O0 & (uint8_t) (LFSR_MASK_ODD );
    9376:	31 2f       	mov	r19, r17
    9378:	34 79       	andi	r19, 0x94	; 148
    937a:	83 27       	eor	r24, r19
    Feedback ^= O1 & (uint8_t) (LFSR_MASK_ODD >> 8);
    937c:	3d 2f       	mov	r19, r29
    937e:	33 77       	andi	r19, 0x73	; 115
    9380:	83 27       	eor	r24, r19
    Feedback ^= O2 & (uint8_t) (LFSR_MASK_ODD >> 16);
    9382:	39 2f       	mov	r19, r25
    9384:	3a 73       	andi	r19, 0x3A	; 58
    9386:	83 27       	eor	r24, r19

    /* fold 8 into 1 bit */
    Feedback ^= ((Feedback >> 4)|(Feedback << 4)); /* Compiler uses a swap for this (fast!) */
    9388:	38 2f       	mov	r19, r24
    938a:	32 95       	swap	r19
    938c:	83 27       	eor	r24, r19
    Feedback ^= Feedback >> 2;
    938e:	38 2f       	mov	r19, r24
    9390:	36 95       	lsr	r19
    9392:	36 95       	lsr	r19
    9394:	83 27       	eor	r24, r19
    Feedback ^= Feedback >> 1;
    9396:	38 2f       	mov	r19, r24
    9398:	36 95       	lsr	r19
    939a:	83 27       	eor	r24, r19
        /* Bit 5 */
        /* remember Odd/Even swap has been omitted! */
        Out = CRYPTO1_FILTER_OUTPUT_B7_24(Even0,Even1,Even2);
        KeyStream = (KeyStream>>1) | Out;
        Feedback = Crypto1LFSRbyteFeedback(Odd0,Odd1,Odd2,Even0,Even1,Even2);
        SHIFT24(Odd0,Odd1,Odd2, Feedback);
    939c:	54 2f       	mov	r21, r20
    939e:	86 95       	lsr	r24
    93a0:	27 95       	ror	r18
    93a2:	57 95       	ror	r21
    93a4:	77 95       	ror	r23
        Feedback  = Crypto1LFSRbyteFeedback(Even0,Even1,Even2,Odd0,Odd1,Odd2);
        SHIFT24(Even0,Even1,Even2, Feedback);

        /* Bit 5 */
        /* remember Odd/Even swap has been omitted! */
        Out = CRYPTO1_FILTER_OUTPUT_B7_24(Even0,Even1,Even2);
    93a6:	cd 2e       	mov	r12, r29
    93a8:	d1 2c       	mov	r13, r1
    93aa:	f6 01       	movw	r30, r12
    93ac:	e8 54       	subi	r30, 0x48	; 72
    93ae:	fe 4d       	sbci	r31, 0xDE	; 222
    93b0:	6f 01       	movw	r12, r30
    93b2:	e1 2e       	mov	r14, r17
    93b4:	f1 2c       	mov	r15, r1
    93b6:	f7 01       	movw	r30, r14
    93b8:	e8 54       	subi	r30, 0x48	; 72
    93ba:	ff 4d       	sbci	r31, 0xDF	; 223
    93bc:	7f 01       	movw	r14, r30
    93be:	f6 01       	movw	r30, r12
    93c0:	30 81       	ld	r19, Z
    93c2:	f7 01       	movw	r30, r14
    93c4:	80 81       	ld	r24, Z
    93c6:	83 2b       	or	r24, r19
    93c8:	e9 2e       	mov	r14, r25
    93ca:	f1 2c       	mov	r15, r1
    93cc:	f7 01       	movw	r30, r14
    93ce:	e8 54       	subi	r30, 0x48	; 72
    93d0:	fd 4d       	sbci	r31, 0xDD	; 221
    93d2:	30 81       	ld	r19, Z
    93d4:	e8 2f       	mov	r30, r24
    93d6:	e3 2b       	or	r30, r19
    93d8:	f0 e0       	ldi	r31, 0x00	; 0
    93da:	e8 58       	subi	r30, 0x88	; 136
    93dc:	ff 4d       	sbci	r31, 0xDF	; 223
        KeyStream = (KeyStream>>1) | Out;
    93de:	80 81       	ld	r24, Z
    93e0:	8c 2b       	or	r24, r28
        Feedback = Crypto1LFSRbyteFeedback(Odd0,Odd1,Odd2,Even0,Even1,Even2);
        SHIFT24(Odd0,Odd1,Odd2, Feedback);

        /* Bit 6 */
        Out = CRYPTO1_FILTER_OUTPUT_B7_24(Odd0, Odd1, Odd2);
        KeyStream = (KeyStream>>1) | Out;
    93e2:	48 2f       	mov	r20, r24
    93e4:	46 95       	lsr	r20
    uint8_t Feedback;

    /* Calculate feedback according to LFSR taps. XOR all state bytes
     * into a single bit. */
    Feedback  = E0 & (uint8_t) (LFSR_MASK_EVEN );
    Feedback ^= E1 & (uint8_t) (LFSR_MASK_EVEN >> 8);
    93e6:	3d 2f       	mov	r19, r29
    93e8:	30 71       	andi	r19, 0x10	; 16
{
    uint8_t Feedback;

    /* Calculate feedback according to LFSR taps. XOR all state bytes
     * into a single bit. */
    Feedback  = E0 & (uint8_t) (LFSR_MASK_EVEN );
    93ea:	81 2f       	mov	r24, r17
    93ec:	81 7e       	andi	r24, 0xE1	; 225
    Feedback ^= E1 & (uint8_t) (LFSR_MASK_EVEN >> 8);
    93ee:	38 27       	eor	r19, r24
    Feedback ^= E2 & (uint8_t) (LFSR_MASK_EVEN >> 16);
    93f0:	89 2f       	mov	r24, r25
    93f2:	80 72       	andi	r24, 0x20	; 32
    93f4:	38 27       	eor	r19, r24

    Feedback ^= O0 & (uint8_t) (LFSR_MASK_ODD );
    93f6:	87 2f       	mov	r24, r23
    93f8:	84 79       	andi	r24, 0x94	; 148
    93fa:	38 27       	eor	r19, r24
    Feedback ^= O1 & (uint8_t) (LFSR_MASK_ODD >> 8);
    93fc:	85 2f       	mov	r24, r21
    93fe:	83 77       	andi	r24, 0x73	; 115
    9400:	38 27       	eor	r19, r24
    Feedback ^= O2 & (uint8_t) (LFSR_MASK_ODD >> 16);
    9402:	82 2f       	mov	r24, r18
    9404:	8a 73       	andi	r24, 0x3A	; 58
    9406:	38 27       	eor	r19, r24

    /* fold 8 into 1 bit */
    Feedback ^= ((Feedback >> 4)|(Feedback << 4)); /* Compiler uses a swap for this (fast!) */
    9408:	83 2f       	mov	r24, r19
    940a:	82 95       	swap	r24
    940c:	38 27       	eor	r19, r24
    Feedback ^= Feedback >> 2;
    940e:	83 2f       	mov	r24, r19
    9410:	86 95       	lsr	r24
    9412:	86 95       	lsr	r24
    9414:	38 27       	eor	r19, r24
    Feedback ^= Feedback >> 1;
    9416:	83 2f       	mov	r24, r19
    9418:	86 95       	lsr	r24
    941a:	38 27       	eor	r19, r24

        /* Bit 6 */
        Out = CRYPTO1_FILTER_OUTPUT_B7_24(Odd0, Odd1, Odd2);
        KeyStream = (KeyStream>>1) | Out;
        Feedback  = Crypto1LFSRbyteFeedback(Even0,Even1,Even2,Odd0,Odd1,Odd2);
        SHIFT24(Even0,Even1,Even2, Feedback);
    941c:	c9 2f       	mov	r28, r25
    941e:	36 95       	lsr	r19
    9420:	c7 95       	ror	r28
    9422:	d7 95       	ror	r29
    9424:	17 95       	ror	r17
        KeyStream = (KeyStream>>1) | Out;
        Feedback = Crypto1LFSRbyteFeedback(Odd0,Odd1,Odd2,Even0,Even1,Even2);
        SHIFT24(Odd0,Odd1,Odd2, Feedback);

        /* Bit 6 */
        Out = CRYPTO1_FILTER_OUTPUT_B7_24(Odd0, Odd1, Odd2);
    9426:	e5 2f       	mov	r30, r21
    9428:	f0 e0       	ldi	r31, 0x00	; 0
    942a:	e8 54       	subi	r30, 0x48	; 72
    942c:	fe 4d       	sbci	r31, 0xDE	; 222
    942e:	87 2f       	mov	r24, r23
    9430:	90 e0       	ldi	r25, 0x00	; 0
    9432:	88 54       	subi	r24, 0x48	; 72
    9434:	9f 4d       	sbci	r25, 0xDF	; 223
    9436:	30 81       	ld	r19, Z
    9438:	fc 01       	movw	r30, r24
    943a:	80 81       	ld	r24, Z
    943c:	38 2b       	or	r19, r24
    943e:	82 2f       	mov	r24, r18
    9440:	90 e0       	ldi	r25, 0x00	; 0
    9442:	88 54       	subi	r24, 0x48	; 72
    9444:	9d 4d       	sbci	r25, 0xDD	; 221
    9446:	fc 01       	movw	r30, r24
    9448:	90 81       	ld	r25, Z
    944a:	e3 2f       	mov	r30, r19
    944c:	e9 2b       	or	r30, r25
    944e:	f0 e0       	ldi	r31, 0x00	; 0
    9450:	e8 58       	subi	r30, 0x88	; 136
    9452:	ff 4d       	sbci	r31, 0xDF	; 223
        KeyStream = (KeyStream>>1) | Out;
    9454:	90 81       	ld	r25, Z
    9456:	84 2f       	mov	r24, r20
    9458:	89 2b       	or	r24, r25
        SHIFT24(Even0,Even1,Even2, Feedback);

        /* Bit 7 */
        /* remember Odd/Even swap has been omitted! */
        Out = CRYPTO1_FILTER_OUTPUT_B7_24(Even0,Even1,Even2);
        KeyStream = (KeyStream>>1) | Out;
    945a:	38 2f       	mov	r19, r24
    945c:	36 95       	lsr	r19
        Feedback  = Crypto1LFSRbyteFeedback(Even0,Even1,Even2,Odd0,Odd1,Odd2);
        SHIFT24(Even0,Even1,Even2, Feedback);

        /* Bit 7 */
        /* remember Odd/Even swap has been omitted! */
        Out = CRYPTO1_FILTER_OUTPUT_B7_24(Even0,Even1,Even2);
    945e:	ed 2f       	mov	r30, r29
    9460:	f0 e0       	ldi	r31, 0x00	; 0
    9462:	cf 01       	movw	r24, r30
    9464:	88 54       	subi	r24, 0x48	; 72
    9466:	9e 4d       	sbci	r25, 0xDE	; 222
    9468:	6c 01       	movw	r12, r24
    946a:	e1 2f       	mov	r30, r17
    946c:	f0 e0       	ldi	r31, 0x00	; 0
    946e:	cf 01       	movw	r24, r30
    9470:	88 54       	subi	r24, 0x48	; 72
    9472:	9f 4d       	sbci	r25, 0xDF	; 223
    9474:	f6 01       	movw	r30, r12
    9476:	40 81       	ld	r20, Z
    9478:	fc 01       	movw	r30, r24
    947a:	90 81       	ld	r25, Z
    947c:	49 2b       	or	r20, r25
    947e:	ec 2e       	mov	r14, r28
    9480:	f1 2c       	mov	r15, r1
    9482:	c7 01       	movw	r24, r14
    9484:	88 54       	subi	r24, 0x48	; 72
    9486:	9d 4d       	sbci	r25, 0xDD	; 221
    9488:	fc 01       	movw	r30, r24
    948a:	90 81       	ld	r25, Z
    948c:	e4 2f       	mov	r30, r20
    948e:	e9 2b       	or	r30, r25
    9490:	f0 e0       	ldi	r31, 0x00	; 0
    9492:	e8 58       	subi	r30, 0x88	; 136
    9494:	ff 4d       	sbci	r31, 0xDF	; 223
        KeyStream = (KeyStream>>1) | Out;
    9496:	90 81       	ld	r25, Z
    9498:	83 2f       	mov	r24, r19
    949a:	89 2b       	or	r24, r25
    uint8_t Feedback;

    /* Calculate feedback according to LFSR taps. XOR all state bytes
     * into a single bit. */
    Feedback  = E0 & (uint8_t) (LFSR_MASK_EVEN );
    Feedback ^= E1 & (uint8_t) (LFSR_MASK_EVEN >> 8);
    949c:	35 2f       	mov	r19, r21
    949e:	30 71       	andi	r19, 0x10	; 16
{
    uint8_t Feedback;

    /* Calculate feedback according to LFSR taps. XOR all state bytes
     * into a single bit. */
    Feedback  = E0 & (uint8_t) (LFSR_MASK_EVEN );
    94a0:	97 2f       	mov	r25, r23
    94a2:	91 7e       	andi	r25, 0xE1	; 225
    Feedback ^= E1 & (uint8_t) (LFSR_MASK_EVEN >> 8);
    94a4:	39 27       	eor	r19, r25
    Feedback ^= E2 & (uint8_t) (LFSR_MASK_EVEN >> 16);
    94a6:	92 2f       	mov	r25, r18
    94a8:	90 72       	andi	r25, 0x20	; 32
    94aa:	39 27       	eor	r19, r25

    Feedback ^= O0 & (uint8_t) (LFSR_MASK_ODD );
    94ac:	91 2f       	mov	r25, r17
    94ae:	94 79       	andi	r25, 0x94	; 148
    94b0:	39 27       	eor	r19, r25
    Feedback ^= O1 & (uint8_t) (LFSR_MASK_ODD >> 8);
    94b2:	9d 2f       	mov	r25, r29
    94b4:	93 77       	andi	r25, 0x73	; 115
    94b6:	39 27       	eor	r19, r25
    Feedback ^= O2 & (uint8_t) (LFSR_MASK_ODD >> 16);
    94b8:	4c 2f       	mov	r20, r28
    94ba:	4a 73       	andi	r20, 0x3A	; 58
    94bc:	34 27       	eor	r19, r20

    /* fold 8 into 1 bit */
    Feedback ^= ((Feedback >> 4)|(Feedback << 4)); /* Compiler uses a swap for this (fast!) */
    94be:	93 2f       	mov	r25, r19
    94c0:	92 95       	swap	r25
    94c2:	39 27       	eor	r19, r25
    Feedback ^= Feedback >> 2;
    94c4:	93 2f       	mov	r25, r19
    94c6:	96 95       	lsr	r25
    94c8:	96 95       	lsr	r25
    94ca:	39 27       	eor	r19, r25
    Feedback ^= Feedback >> 1;
    94cc:	93 2f       	mov	r25, r19
    94ce:	96 95       	lsr	r25
    94d0:	39 27       	eor	r19, r25
        /* Bit 7 */
        /* remember Odd/Even swap has been omitted! */
        Out = CRYPTO1_FILTER_OUTPUT_B7_24(Even0,Even1,Even2);
        KeyStream = (KeyStream>>1) | Out;
        Feedback = Crypto1LFSRbyteFeedback(Odd0,Odd1,Odd2,Even0,Even1,Even2);
        SHIFT24(Odd0,Odd1,Odd2, Feedback);
    94d2:	45 2f       	mov	r20, r21
    94d4:	36 95       	lsr	r19
    94d6:	27 95       	ror	r18
    94d8:	47 95       	ror	r20
    94da:	77 95       	ror	r23

        /* Next bit encodes parity */
        Out = CRYPTO1_FILTER_OUTPUT_B0_24(Odd0, Odd1, Odd2);
    94dc:	c4 2e       	mov	r12, r20
    94de:	d1 2c       	mov	r13, r1
    94e0:	f6 01       	movw	r30, r12
    94e2:	e8 54       	subi	r30, 0x48	; 72
    94e4:	fe 4d       	sbci	r31, 0xDE	; 222
    94e6:	6f 01       	movw	r12, r30
    94e8:	e7 2e       	mov	r14, r23
    94ea:	f1 2c       	mov	r15, r1
    94ec:	f7 01       	movw	r30, r14
    94ee:	e8 54       	subi	r30, 0x48	; 72
    94f0:	ff 4d       	sbci	r31, 0xDF	; 223
    94f2:	7f 01       	movw	r14, r30
    94f4:	f6 01       	movw	r30, r12
    94f6:	30 81       	ld	r19, Z
    94f8:	f7 01       	movw	r30, r14
    94fa:	90 81       	ld	r25, Z
    94fc:	39 2b       	or	r19, r25
    94fe:	e2 2e       	mov	r14, r18
    9500:	f1 2c       	mov	r15, r1
    9502:	f7 01       	movw	r30, r14
    9504:	e8 54       	subi	r30, 0x48	; 72
    9506:	fd 4d       	sbci	r31, 0xDD	; 221
    9508:	90 81       	ld	r25, Z
    950a:	e3 2f       	mov	r30, r19
    950c:	e9 2b       	or	r30, r25
    950e:	f0 e0       	ldi	r31, 0x00	; 0
    9510:	e8 56       	subi	r30, 0x68	; 104
    9512:	ff 4d       	sbci	r31, 0xDF	; 223
    9514:	30 81       	ld	r19, Z
        Buffer[ISO14443A_BUFFER_PARITY_OFFSET] = ODD_PARITY(*Buffer) ^ Out;
    9516:	9c 91       	ld	r25, X
    9518:	e9 2f       	mov	r30, r25
    951a:	f0 e0       	ldi	r31, 0x00	; 0
    951c:	e6 54       	subi	r30, 0x46	; 70
    951e:	fa 4f       	sbci	r31, 0xFA	; 250
    9520:	e4 91       	lpm	r30, Z
    9522:	7d 01       	movw	r14, r26
    9524:	f0 e8       	ldi	r31, 0x80	; 128
    9526:	ef 0e       	add	r14, r31
    9528:	f1 1c       	adc	r15, r1
    952a:	5e 2f       	mov	r21, r30
    952c:	53 27       	eor	r21, r19
    952e:	f7 01       	movw	r30, r14
    9530:	50 83       	st	Z, r21
    
        /* encode Byte */
        *Buffer++ ^= KeyStream;
    9532:	98 27       	eor	r25, r24
    9534:	9d 93       	st	X+, r25
    9536:	f8 cd       	rjmp	.-1040   	; 0x9128 <Crypto1ByteArrayWithParity+0x54>
    }
    /* save state */
    State.Even[0] = Even0;
    9538:	10 93 df 2c 	sts	0x2CDF, r17
    State.Even[1] = Even1;
    953c:	d0 93 e0 2c 	sts	0x2CE0, r29
    State.Even[2] = Even2;
    9540:	c0 93 e1 2c 	sts	0x2CE1, r28
    State.Odd[0]  = Odd0;
    9544:	70 93 e2 2c 	sts	0x2CE2, r23
    State.Odd[1]  = Odd1;
    9548:	40 93 e3 2c 	sts	0x2CE3, r20
    State.Odd[2]  = Odd2;
    954c:	20 93 e4 2c 	sts	0x2CE4, r18
}
    9550:	df 91       	pop	r29
    9552:	cf 91       	pop	r28
    9554:	1f 91       	pop	r17
    9556:	ff 90       	pop	r15
    9558:	ef 90       	pop	r14
    955a:	df 90       	pop	r13
    955c:	cf 90       	pop	r12
    955e:	08 95       	ret

00009560 <Crypto1PRNG>:
/* The ClockCount for the PRNG is always multiple of 32!          */
/* Up tp 11 Bits can be calculated at once                        */
/* Split into chunks of 11+11+10 = 32 bits                        */ 
/* This avoids a calculated number of shifts                      */
void Crypto1PRNG(uint8_t State[4], uint8_t ClockCount)
{
    9560:	0f 93       	push	r16
    9562:	1f 93       	push	r17
    9564:	fc 01       	movw	r30, r24
    9566:	86 2f       	mov	r24, r22
    /* For ease of processing convert the state into a 32 bit integer first */
    uint32_t Temp;
    uint16_t Feedback;
    
    Temp  = (uint32_t) State[0] << 0;
    9568:	90 81       	ld	r25, Z
    Temp |= (uint32_t) State[1] << 8;
    956a:	21 81       	ldd	r18, Z+1	; 0x01
    Temp |= (uint32_t) State[2] << 16;
    956c:	42 81       	ldd	r20, Z+2	; 0x02
    956e:	50 e0       	ldi	r21, 0x00	; 0
    9570:	60 e0       	ldi	r22, 0x00	; 0
    9572:	70 e0       	ldi	r23, 0x00	; 0
    9574:	ba 01       	movw	r22, r20
    9576:	55 27       	eor	r21, r21
    9578:	44 27       	eor	r20, r20
    957a:	52 2b       	or	r21, r18
    957c:	49 2b       	or	r20, r25
    Temp |= (uint32_t) State[3] << 24;
    957e:	93 81       	ldd	r25, Z+3	; 0x03
    9580:	79 2b       	or	r23, r25
    9582:	8b 01       	movw	r16, r22
    9584:	22 27       	eor	r18, r18
    9586:	33 27       	eor	r19, r19

    /* PRNG is always a multiple of 32!        */
    /* Up tp 11 Bits can be calculated at once */
    /* Split into chunks of 11+11+10 = 32 bits */ 
    while(ClockCount >= 32) {
    9588:	80 32       	cpi	r24, 0x20	; 32
    958a:	08 f4       	brcc	.+2      	; 0x958e <Crypto1PRNG+0x2e>
    958c:	71 c0       	rjmp	.+226    	; 0x9670 <Crypto1PRNG+0x110>
        Feedback = (uint16_t)(Temp>>16);
        Feedback ^= Feedback >> 3;   /* 2d = 101101,  fold 101 101 => 101 */
    958e:	d8 01       	movw	r26, r16
    9590:	23 e0       	ldi	r18, 0x03	; 3
    9592:	b6 95       	lsr	r27
    9594:	a7 95       	ror	r26
    9596:	2a 95       	dec	r18
    9598:	e1 f7       	brne	.-8      	; 0x9592 <Crypto1PRNG+0x32>
    959a:	0a 27       	eor	r16, r26
    959c:	1b 27       	eor	r17, r27
        Feedback ^= Feedback >> 2;   /* fold 101 => 1 */
    959e:	98 01       	movw	r18, r16
    95a0:	36 95       	lsr	r19
    95a2:	27 95       	ror	r18
    95a4:	36 95       	lsr	r19
    95a6:	27 95       	ror	r18
        /* Cycle LFSR and feed back. */
        Temp = (Temp >> 11) | (((uint32_t)Feedback) << (32-11));
    95a8:	bb e0       	ldi	r27, 0x0B	; 11
    95aa:	76 95       	lsr	r23
    95ac:	67 95       	ror	r22
    95ae:	57 95       	ror	r21
    95b0:	47 95       	ror	r20
    95b2:	ba 95       	dec	r27
    95b4:	d1 f7       	brne	.-12     	; 0x95aa <Crypto1PRNG+0x4a>
    /* Up tp 11 Bits can be calculated at once */
    /* Split into chunks of 11+11+10 = 32 bits */ 
    while(ClockCount >= 32) {
        Feedback = (uint16_t)(Temp>>16);
        Feedback ^= Feedback >> 3;   /* 2d = 101101,  fold 101 101 => 101 */
        Feedback ^= Feedback >> 2;   /* fold 101 => 1 */
    95b6:	02 27       	eor	r16, r18
    95b8:	13 27       	eor	r17, r19
        /* Cycle LFSR and feed back. */
        Temp = (Temp >> 11) | (((uint32_t)Feedback) << (32-11));
    95ba:	20 e0       	ldi	r18, 0x00	; 0
    95bc:	30 e0       	ldi	r19, 0x00	; 0
    95be:	95 e1       	ldi	r25, 0x15	; 21
    95c0:	00 0f       	add	r16, r16
    95c2:	11 1f       	adc	r17, r17
    95c4:	22 1f       	adc	r18, r18
    95c6:	33 1f       	adc	r19, r19
    95c8:	9a 95       	dec	r25
    95ca:	d1 f7       	brne	.-12     	; 0x95c0 <Crypto1PRNG+0x60>
    95cc:	40 2b       	or	r20, r16
    95ce:	51 2b       	or	r21, r17
    95d0:	62 2b       	or	r22, r18
    95d2:	73 2b       	or	r23, r19
 
        /* Same for the next 11 Bits */
        Feedback = (uint16_t)(Temp>>16);
    95d4:	8b 01       	movw	r16, r22
    95d6:	22 27       	eor	r18, r18
    95d8:	33 27       	eor	r19, r19
        Feedback ^= Feedback >> 3;   /* 2d = 101101,  fold 101 101 => 101 */
    95da:	d8 01       	movw	r26, r16
    95dc:	33 e0       	ldi	r19, 0x03	; 3
    95de:	b6 95       	lsr	r27
    95e0:	a7 95       	ror	r26
    95e2:	3a 95       	dec	r19
    95e4:	e1 f7       	brne	.-8      	; 0x95de <Crypto1PRNG+0x7e>
    95e6:	0a 27       	eor	r16, r26
    95e8:	1b 27       	eor	r17, r27
        Feedback ^= Feedback >> 2;   /* fold 101 => 1 */
    95ea:	98 01       	movw	r18, r16
    95ec:	36 95       	lsr	r19
    95ee:	27 95       	ror	r18
    95f0:	36 95       	lsr	r19
    95f2:	27 95       	ror	r18
        Temp = (Temp >> 11) | (((uint32_t)Feedback) << (32-11));
    95f4:	bb e0       	ldi	r27, 0x0B	; 11
    95f6:	76 95       	lsr	r23
    95f8:	67 95       	ror	r22
    95fa:	57 95       	ror	r21
    95fc:	47 95       	ror	r20
    95fe:	ba 95       	dec	r27
    9600:	d1 f7       	brne	.-12     	; 0x95f6 <Crypto1PRNG+0x96>
        Temp = (Temp >> 11) | (((uint32_t)Feedback) << (32-11));
 
        /* Same for the next 11 Bits */
        Feedback = (uint16_t)(Temp>>16);
        Feedback ^= Feedback >> 3;   /* 2d = 101101,  fold 101 101 => 101 */
        Feedback ^= Feedback >> 2;   /* fold 101 => 1 */
    9602:	02 27       	eor	r16, r18
    9604:	13 27       	eor	r17, r19
        Temp = (Temp >> 11) | (((uint32_t)Feedback) << (32-11));
    9606:	20 e0       	ldi	r18, 0x00	; 0
    9608:	30 e0       	ldi	r19, 0x00	; 0
    960a:	95 e1       	ldi	r25, 0x15	; 21
    960c:	00 0f       	add	r16, r16
    960e:	11 1f       	adc	r17, r17
    9610:	22 1f       	adc	r18, r18
    9612:	33 1f       	adc	r19, r19
    9614:	9a 95       	dec	r25
    9616:	d1 f7       	brne	.-12     	; 0x960c <Crypto1PRNG+0xac>
    9618:	40 2b       	or	r20, r16
    961a:	51 2b       	or	r21, r17
    961c:	62 2b       	or	r22, r18
    961e:	73 2b       	or	r23, r19

        /* Remaining 10 bits */
        Feedback = (uint16_t)(Temp>>16);
    9620:	8b 01       	movw	r16, r22
    9622:	22 27       	eor	r18, r18
    9624:	33 27       	eor	r19, r19
        Feedback ^= Feedback >> 3;   /* 2d = 101101,  fold 101 101 => 101 */
    9626:	d8 01       	movw	r26, r16
    9628:	33 e0       	ldi	r19, 0x03	; 3
    962a:	b6 95       	lsr	r27
    962c:	a7 95       	ror	r26
    962e:	3a 95       	dec	r19
    9630:	e1 f7       	brne	.-8      	; 0x962a <Crypto1PRNG+0xca>
    9632:	0a 27       	eor	r16, r26
    9634:	1b 27       	eor	r17, r27
        Feedback ^= Feedback >> 2;   /* fold 101 => 1 */
    9636:	98 01       	movw	r18, r16
    9638:	36 95       	lsr	r19
    963a:	27 95       	ror	r18
    963c:	36 95       	lsr	r19
    963e:	27 95       	ror	r18
        Temp = (Temp >> 10) | (((uint32_t)Feedback) << (32-10));
    9640:	ba e0       	ldi	r27, 0x0A	; 10
    9642:	76 95       	lsr	r23
    9644:	67 95       	ror	r22
    9646:	57 95       	ror	r21
    9648:	47 95       	ror	r20
    964a:	ba 95       	dec	r27
    964c:	d1 f7       	brne	.-12     	; 0x9642 <Crypto1PRNG+0xe2>
        Temp = (Temp >> 11) | (((uint32_t)Feedback) << (32-11));

        /* Remaining 10 bits */
        Feedback = (uint16_t)(Temp>>16);
        Feedback ^= Feedback >> 3;   /* 2d = 101101,  fold 101 101 => 101 */
        Feedback ^= Feedback >> 2;   /* fold 101 => 1 */
    964e:	02 27       	eor	r16, r18
    9650:	13 27       	eor	r17, r19
        Temp = (Temp >> 10) | (((uint32_t)Feedback) << (32-10));
    9652:	20 e0       	ldi	r18, 0x00	; 0
    9654:	30 e0       	ldi	r19, 0x00	; 0
    9656:	96 e1       	ldi	r25, 0x16	; 22
    9658:	00 0f       	add	r16, r16
    965a:	11 1f       	adc	r17, r17
    965c:	22 1f       	adc	r18, r18
    965e:	33 1f       	adc	r19, r19
    9660:	9a 95       	dec	r25
    9662:	d1 f7       	brne	.-12     	; 0x9658 <Crypto1PRNG+0xf8>
    9664:	40 2b       	or	r20, r16
    9666:	51 2b       	or	r21, r17
    9668:	62 2b       	or	r22, r18
    966a:	73 2b       	or	r23, r19
 
        /* Now 32 bits are fed back */
        ClockCount -= 32;
    966c:	80 52       	subi	r24, 0x20	; 32
    966e:	89 cf       	rjmp	.-238    	; 0x9582 <Crypto1PRNG+0x22>
    }

    /* Store back state */
    State[0] = (uint8_t) (Temp >> 0);
    9670:	40 83       	st	Z, r20
    State[1] = (uint8_t) (Temp >> 8);
    9672:	51 83       	std	Z+1, r21	; 0x01
    State[2] = (uint8_t) (Temp >> 16);
    9674:	02 83       	std	Z+2, r16	; 0x02
    State[3] = (uint8_t) (Temp >> 24);
    9676:	73 83       	std	Z+3, r23	; 0x03
}
    9678:	1f 91       	pop	r17
    967a:	0f 91       	pop	r16
    967c:	08 95       	ret

0000967e <addParityBits>:

static CardType CardCandidates[ARRAY_COUNT(CardIdentificationList)];
static uint8_t CardCandidatesIdx = 0;

uint16_t addParityBits(uint8_t * Buffer, uint16_t BitCount)
{
    967e:	af 92       	push	r10
    9680:	bf 92       	push	r11
    9682:	cf 92       	push	r12
    9684:	df 92       	push	r13
    9686:	ef 92       	push	r14
    9688:	ff 92       	push	r15
    968a:	0f 93       	push	r16
    968c:	1f 93       	push	r17
    968e:	cf 93       	push	r28
    9690:	df 93       	push	r29
    if (BitCount == 7)
    9692:	67 30       	cpi	r22, 0x07	; 7
    9694:	71 05       	cpc	r23, r1
    9696:	09 f4       	brne	.+2      	; 0x969a <addParityBits+0x1c>
    9698:	51 c0       	rjmp	.+162    	; 0x973c <addParityBits+0xbe>
        return 7;
    if (BitCount % 8)
    969a:	9b 01       	movw	r18, r22
    969c:	27 70       	andi	r18, 0x07	; 7
    969e:	33 27       	eor	r19, r19
    96a0:	23 2b       	or	r18, r19
    96a2:	09 f0       	breq	.+2      	; 0x96a6 <addParityBits+0x28>
    96a4:	4e c0       	rjmp	.+156    	; 0x9742 <addParityBits+0xc4>
    96a6:	eb 01       	movw	r28, r22
    96a8:	6c 01       	movw	r12, r24
        return BitCount;
    uint8_t * currByte, * tmpByte;
    uint8_t * const lastByte = Buffer + BitCount/8 + BitCount/64; // starting address + number of bytes + number of parity bytes
    96aa:	5b 01       	movw	r10, r22
    96ac:	83 e0       	ldi	r24, 0x03	; 3
    96ae:	b6 94       	lsr	r11
    96b0:	a7 94       	ror	r10
    96b2:	8a 95       	dec	r24
    96b4:	e1 f7       	brne	.-8      	; 0x96ae <addParityBits+0x30>
    96b6:	7b 01       	movw	r14, r22
    96b8:	96 e0       	ldi	r25, 0x06	; 6
    96ba:	f6 94       	lsr	r15
    96bc:	e7 94       	ror	r14
    96be:	9a 95       	dec	r25
    96c0:	e1 f7       	brne	.-8      	; 0x96ba <addParityBits+0x3c>
    96c2:	ea 0c       	add	r14, r10
    96c4:	fb 1c       	adc	r15, r11
    96c6:	ec 0c       	add	r14, r12
    96c8:	fd 1c       	adc	r15, r13
    currByte = Buffer + BitCount/8 - 1;
    96ca:	85 01       	movw	r16, r10
    96cc:	01 50       	subi	r16, 0x01	; 1
    96ce:	11 09       	sbc	r17, r1
    96d0:	0c 0d       	add	r16, r12
    96d2:	1d 1d       	adc	r17, r13
    uint8_t parity;
    memset(currByte+1, 0, lastByte-currByte); // zeroize all bytes used for parity bits
    96d4:	a7 01       	movw	r20, r14
    96d6:	40 1b       	sub	r20, r16
    96d8:	51 0b       	sbc	r21, r17
    96da:	60 e0       	ldi	r22, 0x00	; 0
    96dc:	70 e0       	ldi	r23, 0x00	; 0
    96de:	c8 01       	movw	r24, r16
    96e0:	01 96       	adiw	r24, 0x01	; 1
    96e2:	0e 94 01 66 	call	0xcc02	; 0xcc02 <memset>
    while (currByte >= Buffer) // loop over all input bytes
    96e6:	0c 15       	cp	r16, r12
    96e8:	1d 05       	cpc	r17, r13
    96ea:	20 f1       	brcs	.+72     	; 0x9734 <addParityBits+0xb6>

INLINE uint8_t OddParityBit(uint8_t Byte)
{
    extern const uint8_t PROGMEM OddParityByteTable[];

    return pgm_read_byte(&OddParityByteTable[Byte]);
    96ec:	d8 01       	movw	r26, r16
    96ee:	ec 91       	ld	r30, X
    96f0:	f0 e0       	ldi	r31, 0x00	; 0
    96f2:	e6 54       	subi	r30, 0x46	; 70
    96f4:	fa 4f       	sbci	r31, 0xFA	; 250
    96f6:	44 91       	lpm	r20, Z
    96f8:	97 01       	movw	r18, r14
    {
        parity = OddParityBit(*currByte); // get parity bit
        tmpByte = lastByte;
    96fa:	d7 01       	movw	r26, r14
        while (tmpByte > currByte) // loop over all bytes from the last byte to the current one -- shifts the whole byte string
    96fc:	0a 17       	cp	r16, r26
    96fe:	1b 07       	cpc	r17, r27
    9700:	68 f4       	brcc	.+26     	; 0x971c <addParityBits+0x9e>
        {
            *tmpByte <<= 1; // shift this byte
    9702:	8c 91       	ld	r24, X
    9704:	98 2f       	mov	r25, r24
    9706:	99 0f       	add	r25, r25
            *tmpByte |= (*(tmpByte-1) & 0x80) >> 7; // insert the last bit from the previous byte
    9708:	f9 01       	movw	r30, r18
    970a:	82 91       	ld	r24, -Z
    970c:	9f 01       	movw	r18, r30
    970e:	88 1f       	adc	r24, r24
    9710:	88 27       	eor	r24, r24
    9712:	88 1f       	adc	r24, r24
    9714:	89 2b       	or	r24, r25
    9716:	8c 93       	st	X, r24
            tmpByte--; // go to the previous byte
    9718:	11 97       	sbiw	r26, 0x01	; 1
    971a:	f0 cf       	rjmp	.-32     	; 0x96fc <addParityBits+0x7e>
        }
        *(++tmpByte) &= 0xFE; // zeroize the bit, where we want to put the parity bit
    971c:	11 96       	adiw	r26, 0x01	; 1
    971e:	8c 91       	ld	r24, X
    9720:	11 97       	sbiw	r26, 0x01	; 1
    9722:	8e 7f       	andi	r24, 0xFE	; 254
        *tmpByte |= parity & 1; // add the parity bit
    9724:	e4 2f       	mov	r30, r20
    9726:	e1 70       	andi	r30, 0x01	; 1
    9728:	e8 2b       	or	r30, r24
    972a:	11 96       	adiw	r26, 0x01	; 1
    972c:	ec 93       	st	X, r30
        currByte--; // go to previous input byte
    972e:	01 50       	subi	r16, 0x01	; 1
    9730:	11 09       	sbc	r17, r1
    9732:	d9 cf       	rjmp	.-78     	; 0x96e6 <addParityBits+0x68>
    }
    return BitCount + (BitCount / 8);
    9734:	c5 01       	movw	r24, r10
    9736:	8c 0f       	add	r24, r28
    9738:	9d 1f       	adc	r25, r29
    973a:	04 c0       	rjmp	.+8      	; 0x9744 <addParityBits+0xc6>
static uint8_t CardCandidatesIdx = 0;

uint16_t addParityBits(uint8_t * Buffer, uint16_t BitCount)
{
    if (BitCount == 7)
        return 7;
    973c:	87 e0       	ldi	r24, 0x07	; 7
    973e:	90 e0       	ldi	r25, 0x00	; 0
    9740:	01 c0       	rjmp	.+2      	; 0x9744 <addParityBits+0xc6>
    9742:	cb 01       	movw	r24, r22
        *(++tmpByte) &= 0xFE; // zeroize the bit, where we want to put the parity bit
        *tmpByte |= parity & 1; // add the parity bit
        currByte--; // go to previous input byte
    }
    return BitCount + (BitCount / 8);
}
    9744:	df 91       	pop	r29
    9746:	cf 91       	pop	r28
    9748:	1f 91       	pop	r17
    974a:	0f 91       	pop	r16
    974c:	ff 90       	pop	r15
    974e:	ef 90       	pop	r14
    9750:	df 90       	pop	r13
    9752:	cf 90       	pop	r12
    9754:	bf 90       	pop	r11
    9756:	af 90       	pop	r10
    9758:	08 95       	ret

0000975a <Reader14443A_Deselect>:
{

}

static uint16_t Reader14443A_Deselect(uint8_t* Buffer) // deselects the card because of an error, so we will continue to select the card afterwards
{
    975a:	cf 93       	push	r28
    975c:	df 93       	push	r29
    975e:	ec 01       	movw	r28, r24
    Buffer[0] = 0xC2;
    9760:	82 ec       	ldi	r24, 0xC2	; 194
    9762:	88 83       	st	Y, r24
    ISO14443AAppendCRCA(Buffer, 1);
    9764:	61 e0       	ldi	r22, 0x01	; 1
    9766:	70 e0       	ldi	r23, 0x00	; 0
    9768:	ce 01       	movw	r24, r28
    976a:	0e 94 63 3d 	call	0x7ac6	; 0x7ac6 <ISO14443AAppendCRCA>
    ReaderState = STATE_DESELECT;
    976e:	8a e0       	ldi	r24, 0x0A	; 10
    9770:	80 93 bf 2d 	sts	0x2DBF, r24
    Selected = false;
    9774:	10 92 c0 2d 	sts	0x2DC0, r1
    return addParityBits(Buffer, 24);
    9778:	68 e1       	ldi	r22, 0x18	; 24
    977a:	70 e0       	ldi	r23, 0x00	; 0
    977c:	ce 01       	movw	r24, r28
}
    977e:	df 91       	pop	r29
    9780:	cf 91       	pop	r28
{
    Buffer[0] = 0xC2;
    ISO14443AAppendCRCA(Buffer, 1);
    ReaderState = STATE_DESELECT;
    Selected = false;
    return addParityBits(Buffer, 24);
    9782:	7d cf       	rjmp	.-262    	; 0x967e <addParityBits>

00009784 <removeParityBits>:
    }
    return BitCount + (BitCount / 8);
}

uint16_t removeParityBits(uint8_t * Buffer, uint16_t BitCount)
{
    9784:	ef 92       	push	r14
    9786:	ff 92       	push	r15
    9788:	0f 93       	push	r16
    978a:	1f 93       	push	r17
    978c:	cf 93       	push	r28
    978e:	df 93       	push	r29
    9790:	ec 01       	movw	r28, r24
    9792:	cb 01       	movw	r24, r22
    // Short frame, no parity bit is added
    if (BitCount == 7)
    9794:	67 30       	cpi	r22, 0x07	; 7
    9796:	71 05       	cpc	r23, r1
    9798:	d1 f1       	breq	.+116    	; 0x980e <removeParityBits+0x8a>
        return 7;

    uint16_t i;
    for (i = 0; i < (BitCount / 9); i++)
    979a:	69 e0       	ldi	r22, 0x09	; 9
    979c:	70 e0       	ldi	r23, 0x00	; 0
    979e:	0e 94 31 65 	call	0xca62	; 0xca62 <__udivmodhi4>
    97a2:	de 01       	movw	r26, r28
    97a4:	20 e0       	ldi	r18, 0x00	; 0
    97a6:	30 e0       	ldi	r19, 0x00	; 0
    {
        Buffer[i] = (Buffer[i + i/8] >> (i%8));
        if (i%8)
            Buffer[i] |= (Buffer[i + i/8 + 1] << (8 - (i % 8)));
    97a8:	88 e0       	ldi	r24, 0x08	; 8
    97aa:	90 e0       	ldi	r25, 0x00	; 0
    // Short frame, no parity bit is added
    if (BitCount == 7)
        return 7;

    uint16_t i;
    for (i = 0; i < (BitCount / 9); i++)
    97ac:	26 17       	cp	r18, r22
    97ae:	37 07       	cpc	r19, r23
    97b0:	39 f1       	breq	.+78     	; 0x9800 <removeParityBits+0x7c>
    {
        Buffer[i] = (Buffer[i + i/8] >> (i%8));
    97b2:	f9 01       	movw	r30, r18
    97b4:	43 e0       	ldi	r20, 0x03	; 3
    97b6:	f6 95       	lsr	r31
    97b8:	e7 95       	ror	r30
    97ba:	4a 95       	dec	r20
    97bc:	e1 f7       	brne	.-8      	; 0x97b6 <removeParityBits+0x32>
    97be:	e2 0f       	add	r30, r18
    97c0:	f3 1f       	adc	r31, r19
    97c2:	ec 0f       	add	r30, r28
    97c4:	fd 1f       	adc	r31, r29
    97c6:	40 81       	ld	r20, Z
    97c8:	50 e0       	ldi	r21, 0x00	; 0
    97ca:	89 01       	movw	r16, r18
    97cc:	07 70       	andi	r16, 0x07	; 7
    97ce:	11 27       	eor	r17, r17
    97d0:	00 2e       	mov	r0, r16
    97d2:	02 c0       	rjmp	.+4      	; 0x97d8 <removeParityBits+0x54>
    97d4:	55 95       	asr	r21
    97d6:	47 95       	ror	r20
    97d8:	0a 94       	dec	r0
    97da:	e2 f7       	brpl	.-8      	; 0x97d4 <removeParityBits+0x50>
    97dc:	4c 93       	st	X, r20
        if (i%8)
    97de:	01 15       	cp	r16, r1
    97e0:	11 05       	cpc	r17, r1
    97e2:	51 f0       	breq	.+20     	; 0x97f8 <removeParityBits+0x74>
            Buffer[i] |= (Buffer[i + i/8 + 1] << (8 - (i % 8)));
    97e4:	e1 81       	ldd	r30, Z+1	; 0x01
    97e6:	7c 01       	movw	r14, r24
    97e8:	e0 1a       	sub	r14, r16
    97ea:	f1 0a       	sbc	r15, r17
    97ec:	01 c0       	rjmp	.+2      	; 0x97f0 <removeParityBits+0x6c>
    97ee:	ee 0f       	add	r30, r30
    97f0:	ea 94       	dec	r14
    97f2:	ea f7       	brpl	.-6      	; 0x97ee <removeParityBits+0x6a>
    97f4:	4e 2b       	or	r20, r30
    97f6:	4c 93       	st	X, r20
    // Short frame, no parity bit is added
    if (BitCount == 7)
        return 7;

    uint16_t i;
    for (i = 0; i < (BitCount / 9); i++)
    97f8:	2f 5f       	subi	r18, 0xFF	; 255
    97fa:	3f 4f       	sbci	r19, 0xFF	; 255
    97fc:	11 96       	adiw	r26, 0x01	; 1
    97fe:	d6 cf       	rjmp	.-84     	; 0x97ac <removeParityBits+0x28>
    {
        Buffer[i] = (Buffer[i + i/8] >> (i%8));
        if (i%8)
            Buffer[i] |= (Buffer[i + i/8 + 1] << (8 - (i % 8)));
    }
    return BitCount/9*8;
    9800:	c9 01       	movw	r24, r18
    9802:	23 e0       	ldi	r18, 0x03	; 3
    9804:	88 0f       	add	r24, r24
    9806:	99 1f       	adc	r25, r25
    9808:	2a 95       	dec	r18
    980a:	e1 f7       	brne	.-8      	; 0x9804 <removeParityBits+0x80>
    980c:	02 c0       	rjmp	.+4      	; 0x9812 <removeParityBits+0x8e>

uint16_t removeParityBits(uint8_t * Buffer, uint16_t BitCount)
{
    // Short frame, no parity bit is added
    if (BitCount == 7)
        return 7;
    980e:	87 e0       	ldi	r24, 0x07	; 7
    9810:	90 e0       	ldi	r25, 0x00	; 0
        Buffer[i] = (Buffer[i + i/8] >> (i%8));
        if (i%8)
            Buffer[i] |= (Buffer[i + i/8 + 1] << (8 - (i % 8)));
    }
    return BitCount/9*8;
}
    9812:	df 91       	pop	r29
    9814:	cf 91       	pop	r28
    9816:	1f 91       	pop	r17
    9818:	0f 91       	pop	r16
    981a:	ff 90       	pop	r15
    981c:	ef 90       	pop	r14
    981e:	08 95       	ret

00009820 <checkParityBits>:

bool checkParityBits(uint8_t * Buffer, uint16_t BitCount)
{
    9820:	ef 92       	push	r14
    9822:	ff 92       	push	r15
    9824:	0f 93       	push	r16
    9826:	1f 93       	push	r17
    9828:	cf 93       	push	r28
    982a:	df 93       	push	r29
    982c:	ec 01       	movw	r28, r24
    982e:	cb 01       	movw	r24, r22
    if (BitCount == 7)
    9830:	67 30       	cpi	r22, 0x07	; 7
    9832:	71 05       	cpc	r23, r1
    9834:	09 f4       	brne	.+2      	; 0x9838 <checkParityBits+0x18>
    9836:	42 c0       	rjmp	.+132    	; 0x98bc <checkParityBits+0x9c>
    //if (BitCount % 9 || BitCount == 0)
    //	return false;

    uint16_t i;
    uint8_t currentByte, parity;
    for (i = 0; i < (BitCount / 9); i++)
    9838:	69 e0       	ldi	r22, 0x09	; 9
    983a:	70 e0       	ldi	r23, 0x00	; 0
    983c:	0e 94 31 65 	call	0xca62	; 0xca62 <__udivmodhi4>
    9840:	20 e0       	ldi	r18, 0x00	; 0
    9842:	30 e0       	ldi	r19, 0x00	; 0
    {
        currentByte = (Buffer[i + i/8] >> (i%8));
        if (i%8)
            currentByte |= (Buffer[i + i/8 + 1] << (8 - (i % 8)));
    9844:	88 e0       	ldi	r24, 0x08	; 8
    9846:	90 e0       	ldi	r25, 0x00	; 0
    //if (BitCount % 9 || BitCount == 0)
    //	return false;

    uint16_t i;
    uint8_t currentByte, parity;
    for (i = 0; i < (BitCount / 9); i++)
    9848:	26 17       	cp	r18, r22
    984a:	37 07       	cpc	r19, r23
    984c:	b9 f1       	breq	.+110    	; 0x98bc <checkParityBits+0x9c>
    {
        currentByte = (Buffer[i + i/8] >> (i%8));
    984e:	d9 01       	movw	r26, r18
    9850:	43 e0       	ldi	r20, 0x03	; 3
    9852:	b6 95       	lsr	r27
    9854:	a7 95       	ror	r26
    9856:	4a 95       	dec	r20
    9858:	e1 f7       	brne	.-8      	; 0x9852 <checkParityBits+0x32>
    985a:	a2 0f       	add	r26, r18
    985c:	b3 1f       	adc	r27, r19
    985e:	a9 01       	movw	r20, r18
    9860:	47 70       	andi	r20, 0x07	; 7
    9862:	55 27       	eor	r21, r21
    9864:	ac 0f       	add	r26, r28
    9866:	bd 1f       	adc	r27, r29
    9868:	ec 91       	ld	r30, X
    986a:	f0 e0       	ldi	r31, 0x00	; 0
    986c:	04 2e       	mov	r0, r20
    986e:	02 c0       	rjmp	.+4      	; 0x9874 <checkParityBits+0x54>
    9870:	f5 95       	asr	r31
    9872:	e7 95       	ror	r30
    9874:	0a 94       	dec	r0
    9876:	e2 f7       	brpl	.-8      	; 0x9870 <checkParityBits+0x50>
        if (i%8)
    9878:	41 15       	cp	r20, r1
    987a:	51 05       	cpc	r21, r1
    987c:	59 f0       	breq	.+22     	; 0x9894 <checkParityBits+0x74>
            currentByte |= (Buffer[i + i/8 + 1] << (8 - (i % 8)));
    987e:	11 96       	adiw	r26, 0x01	; 1
    9880:	0c 91       	ld	r16, X
    9882:	11 97       	sbiw	r26, 0x01	; 1
    9884:	7c 01       	movw	r14, r24
    9886:	e4 1a       	sub	r14, r20
    9888:	f5 0a       	sbc	r15, r21
    988a:	01 c0       	rjmp	.+2      	; 0x988e <checkParityBits+0x6e>
    988c:	00 0f       	add	r16, r16
    988e:	ea 94       	dec	r14
    9890:	ea f7       	brpl	.-6      	; 0x988c <checkParityBits+0x6c>
    9892:	e0 2b       	or	r30, r16
    9894:	f0 e0       	ldi	r31, 0x00	; 0
    9896:	e6 54       	subi	r30, 0x46	; 70
    9898:	fa 4f       	sbci	r31, 0xFA	; 250
    989a:	e4 91       	lpm	r30, Z
        parity = OddParityBit(currentByte);
        if (((Buffer[i + i/8 + 1] >> (i % 8)) ^ parity) & 1) {
    989c:	11 96       	adiw	r26, 0x01	; 1
    989e:	ac 91       	ld	r26, X
    98a0:	b0 e0       	ldi	r27, 0x00	; 0
    98a2:	8d 01       	movw	r16, r26
    98a4:	02 c0       	rjmp	.+4      	; 0x98aa <checkParityBits+0x8a>
    98a6:	15 95       	asr	r17
    98a8:	07 95       	ror	r16
    98aa:	4a 95       	dec	r20
    98ac:	e2 f7       	brpl	.-8      	; 0x98a6 <checkParityBits+0x86>
    98ae:	a8 01       	movw	r20, r16
    98b0:	4e 27       	eor	r20, r30
    98b2:	40 fd       	sbrc	r20, 0
    98b4:	05 c0       	rjmp	.+10     	; 0x98c0 <checkParityBits+0xa0>
    //if (BitCount % 9 || BitCount == 0)
    //	return false;

    uint16_t i;
    uint8_t currentByte, parity;
    for (i = 0; i < (BitCount / 9); i++)
    98b6:	2f 5f       	subi	r18, 0xFF	; 255
    98b8:	3f 4f       	sbci	r19, 0xFF	; 255
    98ba:	c6 cf       	rjmp	.-116    	; 0x9848 <checkParityBits+0x28>
}

bool checkParityBits(uint8_t * Buffer, uint16_t BitCount)
{
    if (BitCount == 7)
        return true;
    98bc:	81 e0       	ldi	r24, 0x01	; 1
    98be:	01 c0       	rjmp	.+2      	; 0x98c2 <checkParityBits+0xa2>
        currentByte = (Buffer[i + i/8] >> (i%8));
        if (i%8)
            currentByte |= (Buffer[i + i/8 + 1] << (8 - (i % 8)));
        parity = OddParityBit(currentByte);
        if (((Buffer[i + i/8 + 1] >> (i % 8)) ^ parity) & 1) {
            return false;
    98c0:	80 e0       	ldi	r24, 0x00	; 0
        }
    }
    return true;
}
    98c2:	df 91       	pop	r29
    98c4:	cf 91       	pop	r28
    98c6:	1f 91       	pop	r17
    98c8:	0f 91       	pop	r16
    98ca:	ff 90       	pop	r15
    98cc:	ef 90       	pop	r14
    98ce:	08 95       	ret

000098d0 <Reader14443AAppInit>:
    ReaderState = STATE_IDLE;
}

void Reader14443AAppInit(void)
{
    ReaderState = STATE_IDLE;
    98d0:	10 92 bf 2d 	sts	0x2DBF, r1
    98d4:	08 95       	ret

000098d6 <Reader14443AAppReset>:
}

void Reader14443AAppReset(void)
{
    ReaderState = STATE_IDLE;
    98d6:	10 92 bf 2d 	sts	0x2DBF, r1
    Reader14443CurrentCommand = Reader14443_Do_Nothing;
    98da:	10 92 e5 2c 	sts	0x2CE5, r1
    Selected = false;
    98de:	10 92 c0 2d 	sts	0x2DC0, r1
    98e2:	08 95       	ret

000098e4 <Reader14443AAppTimeout>:
    return true;
}

void Reader14443AAppTimeout(void)
{
    Reader14443AAppReset();
    98e4:	f8 df       	rcall	.-16     	; 0x98d6 <Reader14443AAppReset>
    Reader14443ACodecReset();
    98e6:	0e 94 d4 2c 	call	0x59a8	; 0x59a8 <Reader14443ACodecReset>
    ReaderState = STATE_IDLE;
    98ea:	10 92 bf 2d 	sts	0x2DBF, r1
    98ee:	08 95       	ret

000098f0 <Reader14443AAppTask>:
    Reader14443CurrentCommand = Reader14443_Do_Nothing;
    Selected = false;
}

void Reader14443AAppTask(void)
{
    98f0:	08 95       	ret

000098f2 <Reader14443AAppTick>:

}

void Reader14443AAppTick(void)
{
    98f2:	08 95       	ret

000098f4 <ISO14443_CRCA>:
    }
    return 0;
}

uint16_t ISO14443_CRCA(uint8_t * Buffer, uint8_t ByteCount)
{
    98f4:	dc 01       	movw	r26, r24
    uint8_t * DataPtr = Buffer;
    uint16_t crc = 0x6363;
    98f6:	23 e6       	ldi	r18, 0x63	; 99
    98f8:	33 e6       	ldi	r19, 0x63	; 99
    uint8_t ch;
    while (ByteCount--)
    98fa:	61 50       	subi	r22, 0x01	; 1
    98fc:	e8 f0       	brcs	.+58     	; 0x9938 <ISO14443_CRCA+0x44>
    {
        ch = *DataPtr++ ^ crc;
    98fe:	4d 91       	ld	r20, X+
    9900:	94 2f       	mov	r25, r20
    9902:	92 27       	eor	r25, r18
        ch = ch ^ (ch << 4);
    9904:	80 e1       	ldi	r24, 0x10	; 16
    9906:	98 9f       	mul	r25, r24
    9908:	a0 01       	movw	r20, r0
    990a:	11 24       	eor	r1, r1
    990c:	49 27       	eor	r20, r25
        crc = (crc >> 8) ^ (ch << 8) ^ (ch << 3) ^ (ch >> 4);
    990e:	e4 2f       	mov	r30, r20
    9910:	f0 e0       	ldi	r31, 0x00	; 0
    9912:	42 95       	swap	r20
    9914:	4f 70       	andi	r20, 0x0F	; 15
    9916:	23 2f       	mov	r18, r19
    9918:	33 27       	eor	r19, r19
    991a:	c9 01       	movw	r24, r18
    991c:	84 27       	eor	r24, r20
    991e:	ac 01       	movw	r20, r24
    9920:	3e 2f       	mov	r19, r30
    9922:	22 27       	eor	r18, r18
    9924:	24 27       	eor	r18, r20
    9926:	35 27       	eor	r19, r21
    9928:	43 e0       	ldi	r20, 0x03	; 3
    992a:	ee 0f       	add	r30, r30
    992c:	ff 1f       	adc	r31, r31
    992e:	4a 95       	dec	r20
    9930:	e1 f7       	brne	.-8      	; 0x992a <ISO14443_CRCA+0x36>
    9932:	2e 27       	eor	r18, r30
    9934:	3f 27       	eor	r19, r31
    9936:	e1 cf       	rjmp	.-62     	; 0x98fa <ISO14443_CRCA+0x6>
    }
    return crc;
}
    9938:	c9 01       	movw	r24, r18
    993a:	08 95       	ret

0000993c <Reader14443A_Select>:
    Selected = false;
    return addParityBits(Buffer, 24);
}

static uint16_t Reader14443A_Select(uint8_t * Buffer, uint16_t BitCount)
{
    993c:	ef 92       	push	r14
    993e:	ff 92       	push	r15
    9940:	1f 93       	push	r17
    9942:	cf 93       	push	r28
    9944:	df 93       	push	r29
    9946:	ec 01       	movw	r28, r24
    9948:	7b 01       	movw	r14, r22
    if (Selected)
    994a:	80 91 c0 2d 	lds	r24, 0x2DC0
    994e:	88 23       	and	r24, r24
    9950:	39 f0       	breq	.+14     	; 0x9960 <Reader14443A_Select+0x24>
    {
        if (ReaderState > STATE_HALT)
    9952:	80 91 bf 2d 	lds	r24, 0x2DBF
    9956:	82 30       	cpi	r24, 0x02	; 2
    9958:	08 f0       	brcs	.+2      	; 0x995c <Reader14443A_Select+0x20>
    995a:	ed c0       	rjmp	.+474    	; 0x9b36 <Reader14443A_Select+0x1fa>
            return 0;
        else
            Selected = false;
    995c:	10 92 c0 2d 	sts	0x2DC0, r1
    }

    // general frame handling:
    uint8_t flags = 0;
    if (BitCount > 0 && checkParityBits(Buffer, BitCount))
    9960:	e1 14       	cp	r14, r1
    9962:	f1 04       	cpc	r15, r1
    9964:	61 f0       	breq	.+24     	; 0x997e <Reader14443A_Select+0x42>
    9966:	b7 01       	movw	r22, r14
    9968:	ce 01       	movw	r24, r28
    996a:	5a df       	rcall	.-332    	; 0x9820 <checkParityBits>
    996c:	88 23       	and	r24, r24
    996e:	09 f4       	brne	.+2      	; 0x9972 <Reader14443A_Select+0x36>
    9970:	e5 c0       	rjmp	.+458    	; 0x9b3c <Reader14443A_Select+0x200>
    {
        flags |= FLAGS_PARITY_OK;
        BitCount = removeParityBits(Buffer, BitCount);
    9972:	b7 01       	movw	r22, r14
    9974:	ce 01       	movw	r24, r28
    9976:	06 df       	rcall	.-500    	; 0x9784 <removeParityBits>
    9978:	7c 01       	movw	r14, r24

    // general frame handling:
    uint8_t flags = 0;
    if (BitCount > 0 && checkParityBits(Buffer, BitCount))
    {
        flags |= FLAGS_PARITY_OK;
    997a:	81 e0       	ldi	r24, 0x01	; 1
        BitCount = removeParityBits(Buffer, BitCount);
    997c:	01 c0       	rjmp	.+2      	; 0x9980 <Reader14443A_Select+0x44>
    } else if (BitCount == 0) {
        flags |= FLAGS_NO_DATA;
    997e:	82 e0       	ldi	r24, 0x02	; 2
    } else { // checkParityBits returned false
        LogEntry(LOG_ERR_APP_CHECKSUM_FAIL, Buffer, (BitCount + 7) / 8);
    }


    switch (ReaderState)
    9980:	10 91 bf 2d 	lds	r17, 0x2DBF
    9984:	16 30       	cpi	r17, 0x06	; 6
    9986:	90 f4       	brcc	.+36     	; 0x99ac <Reader14443A_Select+0x70>
    9988:	13 30       	cpi	r17, 0x03	; 3
    998a:	90 f5       	brcc	.+100    	; 0x99f0 <Reader14443A_Select+0xb4>
    998c:	12 30       	cpi	r17, 0x02	; 2
    998e:	a8 f4       	brcc	.+42     	; 0x99ba <Reader14443A_Select+0x7e>
    {
    case STATE_IDLE:
    case STATE_HALT:
        Reader_FWT = 4;
    9990:	84 e0       	ldi	r24, 0x04	; 4
    9992:	90 e0       	ldi	r25, 0x00	; 0
    9994:	80 93 1e 20 	sts	0x201E, r24
    9998:	90 93 1f 20 	sts	0x201F, r25
        /* Send a REQA */
        Buffer[0] = ISO14443A_CMD_WUPA; // whenever REQA works, WUPA also works, so we choose WUPA always
    999c:	82 e5       	ldi	r24, 0x52	; 82
    999e:	88 83       	st	Y, r24
        ReaderState = STATE_READY;
    99a0:	82 e0       	ldi	r24, 0x02	; 2
    99a2:	80 93 bf 2d 	sts	0x2DBF, r24
        return 7;
    99a6:	87 e0       	ldi	r24, 0x07	; 7
    99a8:	90 e0       	ldi	r25, 0x00	; 0
    99aa:	d9 c0       	rjmp	.+434    	; 0x9b5e <Reader14443A_Select+0x222>
    } else { // checkParityBits returned false
        LogEntry(LOG_ERR_APP_CHECKSUM_FAIL, Buffer, (BitCount + 7) / 8);
    }


    switch (ReaderState)
    99ac:	19 30       	cpi	r17, 0x09	; 9
    99ae:	08 f4       	brcc	.+2      	; 0x99b2 <Reader14443A_Select+0x76>
    99b0:	79 c0       	rjmp	.+242    	; 0x9aa4 <Reader14443A_Select+0x168>
    99b2:	1a 30       	cpi	r17, 0x0A	; 10
    99b4:	09 f4       	brne	.+2      	; 0x99b8 <Reader14443A_Select+0x7c>
    99b6:	a8 c0       	rjmp	.+336    	; 0x9b08 <Reader14443A_Select+0x1cc>
    99b8:	be c0       	rjmp	.+380    	; 0x9b36 <Reader14443A_Select+0x1fa>
        Buffer[0] = ISO14443A_CMD_WUPA; // whenever REQA works, WUPA also works, so we choose WUPA always
        ReaderState = STATE_READY;
        return 7;

    case STATE_READY:
        if (BitCount != 16 || (flags & FLAGS_PARITY_OK) == 0)
    99ba:	90 e1       	ldi	r25, 0x10	; 16
    99bc:	e9 16       	cp	r14, r25
    99be:	f1 04       	cpc	r15, r1
    99c0:	11 f4       	brne	.+4      	; 0x99c6 <Reader14443A_Select+0x8a>
    99c2:	80 fd       	sbrc	r24, 0
    99c4:	03 c0       	rjmp	.+6      	; 0x99cc <Reader14443A_Select+0x90>
        {
            ReaderState = STATE_IDLE;
    99c6:	10 92 bf 2d 	sts	0x2DBF, r1
    99ca:	a4 c0       	rjmp	.+328    	; 0x9b14 <Reader14443A_Select+0x1d8>
            Reader14443ACodecStart();
            return 0;
        }
        CardCharacteristics.ATQA = Buffer[1] << 8 | Buffer[0]; // save ATQA for possible later use
    99cc:	89 81       	ldd	r24, Y+1	; 0x01
    99ce:	90 e0       	ldi	r25, 0x00	; 0
    99d0:	98 2f       	mov	r25, r24
    99d2:	88 27       	eor	r24, r24
    99d4:	28 81       	ld	r18, Y
    99d6:	82 2b       	or	r24, r18
    99d8:	80 93 b1 2d 	sts	0x2DB1, r24
    99dc:	90 93 b2 2d 	sts	0x2DB2, r25
        Buffer[0] = ISO14443A_CMD_SELECT_CL1;
    99e0:	83 e9       	ldi	r24, 0x93	; 147
    99e2:	88 83       	st	Y, r24
        Buffer[1] = 0x20; // NVB = 16
    99e4:	80 e2       	ldi	r24, 0x20	; 32
    99e6:	89 83       	std	Y+1, r24	; 0x01
        ReaderState = STATE_ACTIVE_CL1;
    99e8:	83 e0       	ldi	r24, 0x03	; 3
    99ea:	80 93 bf 2d 	sts	0x2DBF, r24
    99ee:	78 c0       	rjmp	.+240    	; 0x9ae0 <Reader14443A_Select+0x1a4>
        return addParityBits(Buffer, 2 * BITS_PER_BYTE);

    case STATE_ACTIVE_CL1 ... STATE_ACTIVE_CL3:
        if ((flags & FLAGS_PARITY_OK) == 0 || BitCount < (5 * BITS_PER_BYTE) || !CHECK_BCC(Buffer))
    99f0:	80 ff       	sbrs	r24, 0
    99f2:	e9 cf       	rjmp	.-46     	; 0x99c6 <Reader14443A_Select+0x8a>
    99f4:	88 e2       	ldi	r24, 0x28	; 40
    99f6:	e8 16       	cp	r14, r24
    99f8:	f1 04       	cpc	r15, r1
    99fa:	28 f3       	brcs	.-54     	; 0x99c6 <Reader14443A_Select+0x8a>
    99fc:	28 81       	ld	r18, Y
    99fe:	89 81       	ldd	r24, Y+1	; 0x01
    9a00:	82 27       	eor	r24, r18
    9a02:	9a 81       	ldd	r25, Y+2	; 0x02
    9a04:	89 27       	eor	r24, r25
    9a06:	9b 81       	ldd	r25, Y+3	; 0x03
    9a08:	89 27       	eor	r24, r25
    9a0a:	9c 81       	ldd	r25, Y+4	; 0x04
    9a0c:	89 13       	cpse	r24, r25
    9a0e:	db cf       	rjmp	.-74     	; 0x99c6 <Reader14443A_Select+0x8a>
    9a10:	81 2f       	mov	r24, r17
    9a12:	90 e0       	ldi	r25, 0x00	; 0
            return 0;
        }

        if (Buffer[0] == ISO14443A_UID0_CT)
        {
            memcpy(CardCharacteristics.UID + (ReaderState - STATE_ACTIVE_CL1) * 3, Buffer + 1, 3);
    9a14:	03 97       	sbiw	r24, 0x03	; 3
            ReaderState = STATE_IDLE;
            Reader14443ACodecStart();
            return 0;
        }

        if (Buffer[0] == ISO14443A_UID0_CT)
    9a16:	28 38       	cpi	r18, 0x88	; 136
    9a18:	79 f4       	brne	.+30     	; 0x9a38 <Reader14443A_Select+0xfc>
        {
            memcpy(CardCharacteristics.UID + (ReaderState - STATE_ACTIVE_CL1) * 3, Buffer + 1, 3);
    9a1a:	9c 01       	movw	r18, r24
    9a1c:	22 0f       	add	r18, r18
    9a1e:	33 1f       	adc	r19, r19
    9a20:	82 0f       	add	r24, r18
    9a22:	93 1f       	adc	r25, r19
    9a24:	fc 01       	movw	r30, r24
    9a26:	ec 54       	subi	r30, 0x4C	; 76
    9a28:	f2 4d       	sbci	r31, 0xD2	; 210
    9a2a:	29 81       	ldd	r18, Y+1	; 0x01
    9a2c:	3a 81       	ldd	r19, Y+2	; 0x02
    9a2e:	4b 81       	ldd	r20, Y+3	; 0x03
    9a30:	20 83       	st	Z, r18
    9a32:	31 83       	std	Z+1, r19	; 0x01
    9a34:	42 83       	std	Z+2, r20	; 0x02
    9a36:	10 c0       	rjmp	.+32     	; 0x9a58 <Reader14443A_Select+0x11c>
        } else {
            memcpy(CardCharacteristics.UID + (ReaderState - STATE_ACTIVE_CL1) * 3, Buffer, 4);
    9a38:	fc 01       	movw	r30, r24
    9a3a:	ee 0f       	add	r30, r30
    9a3c:	ff 1f       	adc	r31, r31
    9a3e:	8e 0f       	add	r24, r30
    9a40:	9f 1f       	adc	r25, r31
    9a42:	fc 01       	movw	r30, r24
    9a44:	ec 54       	subi	r30, 0x4C	; 76
    9a46:	f2 4d       	sbci	r31, 0xD2	; 210
    9a48:	88 81       	ld	r24, Y
    9a4a:	99 81       	ldd	r25, Y+1	; 0x01
    9a4c:	aa 81       	ldd	r26, Y+2	; 0x02
    9a4e:	bb 81       	ldd	r27, Y+3	; 0x03
    9a50:	80 83       	st	Z, r24
    9a52:	91 83       	std	Z+1, r25	; 0x01
    9a54:	a2 83       	std	Z+2, r26	; 0x02
    9a56:	b3 83       	std	Z+3, r27	; 0x03
        }
        // shift received UID two bytes to the right
        memmove(Buffer+2, Buffer, 5);
    9a58:	45 e0       	ldi	r20, 0x05	; 5
    9a5a:	50 e0       	ldi	r21, 0x00	; 0
    9a5c:	be 01       	movw	r22, r28
    9a5e:	ce 01       	movw	r24, r28
    9a60:	02 96       	adiw	r24, 0x02	; 2
    9a62:	0e 94 f0 65 	call	0xcbe0	; 0xcbe0 <memmove>
        Buffer[0] = (ReaderState == STATE_ACTIVE_CL1) ? ISO14443A_CMD_SELECT_CL1 : (ReaderState == STATE_ACTIVE_CL2) ? ISO14443A_CMD_SELECT_CL2 : ISO14443A_CMD_SELECT_CL3;
    9a66:	13 30       	cpi	r17, 0x03	; 3
    9a68:	21 f0       	breq	.+8      	; 0x9a72 <Reader14443A_Select+0x136>
    9a6a:	14 30       	cpi	r17, 0x04	; 4
    9a6c:	21 f0       	breq	.+8      	; 0x9a76 <Reader14443A_Select+0x13a>
    9a6e:	87 e9       	ldi	r24, 0x97	; 151
    9a70:	03 c0       	rjmp	.+6      	; 0x9a78 <Reader14443A_Select+0x13c>
    9a72:	83 e9       	ldi	r24, 0x93	; 147
    9a74:	01 c0       	rjmp	.+2      	; 0x9a78 <Reader14443A_Select+0x13c>
    9a76:	85 e9       	ldi	r24, 0x95	; 149
    9a78:	88 83       	st	Y, r24
        Buffer[1] = 0x70; // NVB = 56
    9a7a:	80 e7       	ldi	r24, 0x70	; 112
    9a7c:	89 83       	std	Y+1, r24	; 0x01
        ISO14443AAppendCRCA(Buffer, 7);
    9a7e:	67 e0       	ldi	r22, 0x07	; 7
    9a80:	70 e0       	ldi	r23, 0x00	; 0
    9a82:	ce 01       	movw	r24, r28
    9a84:	0e 94 63 3d 	call	0x7ac6	; 0x7ac6 <ISO14443AAppendCRCA>
        ReaderState = ReaderState - STATE_ACTIVE_CL1 + STATE_SAK_CL1;
    9a88:	80 91 bf 2d 	lds	r24, 0x2DBF
    9a8c:	8d 5f       	subi	r24, 0xFD	; 253
    9a8e:	80 93 bf 2d 	sts	0x2DBF, r24
        return addParityBits(Buffer, (7 + 2) * BITS_PER_BYTE);
    9a92:	68 e4       	ldi	r22, 0x48	; 72
    9a94:	70 e0       	ldi	r23, 0x00	; 0
    9a96:	ce 01       	movw	r24, r28
        return 0;

    default:
        return 0;
    }
}
    9a98:	df 91       	pop	r29
    9a9a:	cf 91       	pop	r28
    9a9c:	1f 91       	pop	r17
    9a9e:	ff 90       	pop	r15
    9aa0:	ef 90       	pop	r14
        memmove(Buffer+2, Buffer, 5);
        Buffer[0] = (ReaderState == STATE_ACTIVE_CL1) ? ISO14443A_CMD_SELECT_CL1 : (ReaderState == STATE_ACTIVE_CL2) ? ISO14443A_CMD_SELECT_CL2 : ISO14443A_CMD_SELECT_CL3;
        Buffer[1] = 0x70; // NVB = 56
        ISO14443AAppendCRCA(Buffer, 7);
        ReaderState = ReaderState - STATE_ACTIVE_CL1 + STATE_SAK_CL1;
        return addParityBits(Buffer, (7 + 2) * BITS_PER_BYTE);
    9aa2:	ed cd       	rjmp	.-1062   	; 0x967e <addParityBits>

    case STATE_SAK_CL1 ... STATE_SAK_CL3:
        if ((flags & FLAGS_PARITY_OK) == 0 || BitCount != (3 * BITS_PER_BYTE) || ISO14443_CRCA(Buffer, 3) != 0)
    9aa4:	80 ff       	sbrs	r24, 0
    9aa6:	8f cf       	rjmp	.-226    	; 0x99c6 <Reader14443A_Select+0x8a>
    9aa8:	98 e1       	ldi	r25, 0x18	; 24
    9aaa:	e9 16       	cp	r14, r25
    9aac:	f1 04       	cpc	r15, r1
    9aae:	09 f0       	breq	.+2      	; 0x9ab2 <Reader14443A_Select+0x176>
    9ab0:	8a cf       	rjmp	.-236    	; 0x99c6 <Reader14443A_Select+0x8a>
    9ab2:	63 e0       	ldi	r22, 0x03	; 3
    9ab4:	ce 01       	movw	r24, r28
    9ab6:	1e df       	rcall	.-452    	; 0x98f4 <ISO14443_CRCA>
    9ab8:	00 97       	sbiw	r24, 0x00	; 0
    9aba:	09 f0       	breq	.+2      	; 0x9abe <Reader14443A_Select+0x182>
    9abc:	84 cf       	rjmp	.-248    	; 0x99c6 <Reader14443A_Select+0x8a>
            ReaderState = STATE_IDLE;
            Reader14443ACodecStart();
            return 0;
        }

        if (IS_CASCADE_BIT_SET(Buffer) && ReaderState != STATE_SAK_CL3)
    9abe:	28 81       	ld	r18, Y
    9ac0:	22 ff       	sbrs	r18, 2
    9ac2:	11 c0       	rjmp	.+34     	; 0x9ae6 <Reader14443A_Select+0x1aa>
    9ac4:	18 30       	cpi	r17, 0x08	; 8
    9ac6:	79 f0       	breq	.+30     	; 0x9ae6 <Reader14443A_Select+0x1aa>
        {
            Buffer[0] = (ReaderState == STATE_SAK_CL1) ? ISO14443A_CMD_SELECT_CL2 : ISO14443A_CMD_SELECT_CL3;
    9ac8:	16 30       	cpi	r17, 0x06	; 6
    9aca:	11 f0       	breq	.+4      	; 0x9ad0 <Reader14443A_Select+0x194>
    9acc:	87 e9       	ldi	r24, 0x97	; 151
    9ace:	01 c0       	rjmp	.+2      	; 0x9ad2 <Reader14443A_Select+0x196>
    9ad0:	85 e9       	ldi	r24, 0x95	; 149
    9ad2:	88 83       	st	Y, r24
            Buffer[1] = 0x20; // NVB = 16 bit
    9ad4:	80 e2       	ldi	r24, 0x20	; 32
    9ad6:	89 83       	std	Y+1, r24	; 0x01
            ReaderState = ReaderState - STATE_SAK_CL1 + STATE_ACTIVE_CL1 + 1;
    9ad8:	2e ef       	ldi	r18, 0xFE	; 254
    9ada:	21 0f       	add	r18, r17
    9adc:	20 93 bf 2d 	sts	0x2DBF, r18
            return addParityBits(Buffer, 2 * BITS_PER_BYTE);
    9ae0:	60 e1       	ldi	r22, 0x10	; 16
    9ae2:	70 e0       	ldi	r23, 0x00	; 0
    9ae4:	d8 cf       	rjmp	.-80     	; 0x9a96 <Reader14443A_Select+0x15a>
        } else if (IS_CASCADE_BIT_SET(Buffer) && ReaderState == STATE_SAK_CL3) {
            // TODO handle this very strange hopefully not happening error
        }
        Selected = true;
    9ae6:	21 e0       	ldi	r18, 0x01	; 1
    9ae8:	20 93 c0 2d 	sts	0x2DC0, r18
        CardCharacteristics.UIDSize = (ReaderState - STATE_SAK_CL1) * 3 + 4;
    9aec:	21 2f       	mov	r18, r17
    9aee:	30 e0       	ldi	r19, 0x00	; 0
    9af0:	26 50       	subi	r18, 0x06	; 6
    9af2:	31 09       	sbc	r19, r1
    9af4:	32 2f       	mov	r19, r18
    9af6:	33 0f       	add	r19, r19
    9af8:	23 0f       	add	r18, r19
    9afa:	2c 5f       	subi	r18, 0xFC	; 252
    9afc:	20 93 be 2d 	sts	0x2DBE, r18
        CardCharacteristics.SAK = Buffer[0]; // save last SAK for possible later use
    9b00:	28 81       	ld	r18, Y
    9b02:	20 93 b3 2d 	sts	0x2DB3, r18
        return 0;
    9b06:	2b c0       	rjmp	.+86     	; 0x9b5e <Reader14443A_Select+0x222>

    case STATE_DESELECT:
        if ((flags & FLAGS_NO_DATA) != 0) // most likely the card already understood the deselect
    9b08:	98 2f       	mov	r25, r24
    9b0a:	92 70       	andi	r25, 0x02	; 2
    9b0c:	31 f0       	breq	.+12     	; 0x9b1a <Reader14443A_Select+0x1de>
        {
            ReaderState = STATE_HALT;
    9b0e:	81 e0       	ldi	r24, 0x01	; 1
    9b10:	80 93 bf 2d 	sts	0x2DBF, r24
            Reader14443ACodecStart();
    9b14:	0e 94 cd 2c 	call	0x599a	; 0x599a <Reader14443ACodecStart>
    9b18:	0e c0       	rjmp	.+28     	; 0x9b36 <Reader14443A_Select+0x1fa>
            return 0;
        }
        if ((flags & FLAGS_PARITY_OK) == 0 || ISO14443_CRCA(Buffer, 3))
    9b1a:	80 ff       	sbrs	r24, 0
    9b1c:	05 c0       	rjmp	.+10     	; 0x9b28 <Reader14443A_Select+0x1ec>
    9b1e:	63 e0       	ldi	r22, 0x03	; 3
    9b20:	ce 01       	movw	r24, r28
    9b22:	e8 de       	rcall	.-560    	; 0x98f4 <ISO14443_CRCA>
    9b24:	89 2b       	or	r24, r25
    9b26:	99 f3       	breq	.-26     	; 0x9b0e <Reader14443A_Select+0x1d2>
        {
            return Reader14443A_Deselect(Buffer);
    9b28:	ce 01       	movw	r24, r28
        return 0;

    default:
        return 0;
    }
}
    9b2a:	df 91       	pop	r29
    9b2c:	cf 91       	pop	r28
    9b2e:	1f 91       	pop	r17
    9b30:	ff 90       	pop	r15
    9b32:	ef 90       	pop	r14
            Reader14443ACodecStart();
            return 0;
        }
        if ((flags & FLAGS_PARITY_OK) == 0 || ISO14443_CRCA(Buffer, 3))
        {
            return Reader14443A_Deselect(Buffer);
    9b34:	12 ce       	rjmp	.-988    	; 0x975a <Reader14443A_Deselect>
        ReaderState = STATE_HALT;
        Reader14443ACodecStart();
        return 0;

    default:
        return 0;
    9b36:	80 e0       	ldi	r24, 0x00	; 0
    9b38:	90 e0       	ldi	r25, 0x00	; 0
    9b3a:	11 c0       	rjmp	.+34     	; 0x9b5e <Reader14443A_Select+0x222>
        flags |= FLAGS_PARITY_OK;
        BitCount = removeParityBits(Buffer, BitCount);
    } else if (BitCount == 0) {
        flags |= FLAGS_NO_DATA;
    } else { // checkParityBits returned false
        LogEntry(LOG_ERR_APP_CHECKSUM_FAIL, Buffer, (BitCount + 7) / 8);
    9b3c:	a7 01       	movw	r20, r14
    9b3e:	49 5f       	subi	r20, 0xF9	; 249
    9b40:	5f 4f       	sbci	r21, 0xFF	; 255
    9b42:	83 e0       	ldi	r24, 0x03	; 3
    9b44:	56 95       	lsr	r21
    9b46:	47 95       	ror	r20
    9b48:	8a 95       	dec	r24
    9b4a:	e1 f7       	brne	.-8      	; 0x9b44 <Reader14443A_Select+0x208>
    9b4c:	e0 91 6e 2f 	lds	r30, 0x2F6E
    9b50:	f0 91 6f 2f 	lds	r31, 0x2F6F
    9b54:	be 01       	movw	r22, r28
    9b56:	81 ec       	ldi	r24, 0xC1	; 193
    9b58:	19 95       	eicall
        else
            Selected = false;
    }

    // general frame handling:
    uint8_t flags = 0;
    9b5a:	80 e0       	ldi	r24, 0x00	; 0
    9b5c:	11 cf       	rjmp	.-478    	; 0x9980 <Reader14443A_Select+0x44>
        return 0;

    default:
        return 0;
    }
}
    9b5e:	df 91       	pop	r29
    9b60:	cf 91       	pop	r28
    9b62:	1f 91       	pop	r17
    9b64:	ff 90       	pop	r15
    9b66:	ef 90       	pop	r14
    9b68:	08 95       	ret

00009b6a <Identify>:
    ReaderState = STATE_ATS;
    return addParityBits(Buffer, 4 * BITS_PER_BYTE);
}

static bool Identify(uint8_t *Buffer, uint16_t *BitCount)
{
    9b6a:	9f 92       	push	r9
    9b6c:	af 92       	push	r10
    9b6e:	bf 92       	push	r11
    9b70:	cf 92       	push	r12
    9b72:	df 92       	push	r13
    9b74:	ef 92       	push	r14
    9b76:	ff 92       	push	r15
    9b78:	0f 93       	push	r16
    9b7a:	1f 93       	push	r17
    9b7c:	cf 93       	push	r28
    9b7e:	df 93       	push	r29
    9b80:	cd b7       	in	r28, 0x3d	; 61
    9b82:	de b7       	in	r29, 0x3e	; 62
    9b84:	c7 56       	subi	r28, 0x67	; 103
    9b86:	d1 09       	sbc	r29, r1
    9b88:	cd bf       	out	0x3d, r28	; 61
    9b8a:	de bf       	out	0x3e, r29	; 62
    9b8c:	8c 01       	movw	r16, r24
    9b8e:	7b 01       	movw	r14, r22
    uint16_t rVal = Reader14443A_Select(Buffer, *BitCount);
    9b90:	fb 01       	movw	r30, r22
    9b92:	60 81       	ld	r22, Z
    9b94:	71 81       	ldd	r23, Z+1	; 0x01
    9b96:	d2 de       	rcall	.-604    	; 0x993c <Reader14443A_Select>
    if (Selected)
    9b98:	d0 90 c0 2d 	lds	r13, 0x2DC0
    9b9c:	dd 20       	and	r13, r13
    9b9e:	09 f4       	brne	.+2      	; 0x9ba2 <Identify+0x38>
    9ba0:	45 c1       	rjmp	.+650    	; 0x9e2c <Identify+0x2c2>
    {
        if (ReaderState >= STATE_SAK_CL1 && ReaderState <= STATE_SAK_CL3)
    9ba2:	80 91 bf 2d 	lds	r24, 0x2DBF
    9ba6:	9a ef       	ldi	r25, 0xFA	; 250
    9ba8:	98 0f       	add	r25, r24
    9baa:	93 30       	cpi	r25, 0x03	; 3
    9bac:	08 f0       	brcs	.+2      	; 0x9bb0 <Identify+0x46>
    9bae:	58 c0       	rjmp	.+176    	; 0x9c60 <Identify+0xf6>
        {
            bool ISO14443_4A_compliant = IS_ISO14443A_4_COMPLIANT(Buffer);
    9bb0:	f8 01       	movw	r30, r16
    9bb2:	c0 80       	ld	r12, Z
    9bb4:	c5 fa       	bst	r12, 5
    9bb6:	cc 24       	eor	r12, r12
    9bb8:	c0 f8       	bld	r12, 0
            CardCandidatesIdx = 0;
    9bba:	10 92 a1 2d 	sts	0x2DA1, r1
    9bbe:	5c ee       	ldi	r21, 0xEC	; 236
    9bc0:	a5 2e       	mov	r10, r21
    9bc2:	51 e1       	ldi	r21, 0x11	; 17
    9bc4:	b5 2e       	mov	r11, r21

            uint8_t i;
            for (i = 0; i < ARRAY_COUNT(CardIdentificationList); i++)
    9bc6:	91 2c       	mov	r9, r1
            {
                CardIdentificationType card;
                memcpy_P(&card, &CardIdentificationList[i], sizeof(CardIdentificationType));
    9bc8:	47 e6       	ldi	r20, 0x67	; 103
    9bca:	50 e0       	ldi	r21, 0x00	; 0
    9bcc:	b5 01       	movw	r22, r10
    9bce:	ce 01       	movw	r24, r28
    9bd0:	01 96       	adiw	r24, 0x01	; 1
    9bd2:	0e 94 b9 65 	call	0xcb72	; 0xcb72 <memcpy_P>
                if (card.ATQARelevant && card.ATQA != CardCharacteristics.ATQA)
    9bd6:	8b 81       	ldd	r24, Y+3	; 0x03
    9bd8:	88 23       	and	r24, r24
    9bda:	49 f0       	breq	.+18     	; 0x9bee <Identify+0x84>
    9bdc:	29 81       	ldd	r18, Y+1	; 0x01
    9bde:	3a 81       	ldd	r19, Y+2	; 0x02
    9be0:	80 91 b1 2d 	lds	r24, 0x2DB1
    9be4:	90 91 b2 2d 	lds	r25, 0x2DB2
    9be8:	28 17       	cp	r18, r24
    9bea:	39 07       	cpc	r19, r25
    9bec:	b9 f4       	brne	.+46     	; 0x9c1c <Identify+0xb2>
                    continue;
                if (card.SAKRelevant && card.SAK != CardCharacteristics.SAK)
    9bee:	8d 81       	ldd	r24, Y+5	; 0x05
    9bf0:	88 23       	and	r24, r24
    9bf2:	29 f0       	breq	.+10     	; 0x9bfe <Identify+0x94>
    9bf4:	9c 81       	ldd	r25, Y+4	; 0x04
    9bf6:	80 91 b3 2d 	lds	r24, 0x2DB3
    9bfa:	98 13       	cpse	r25, r24
    9bfc:	0f c0       	rjmp	.+30     	; 0x9c1c <Identify+0xb2>
                    continue;
                if (card.ATSRelevant && !ISO14443_4A_compliant)
    9bfe:	8f 89       	ldd	r24, Y+23	; 0x17
    9c00:	88 23       	and	r24, r24
    9c02:	11 f0       	breq	.+4      	; 0x9c08 <Identify+0x9e>
    9c04:	cc 20       	and	r12, r12
    9c06:	51 f0       	breq	.+20     	; 0x9c1c <Identify+0xb2>
                    continue; // for this card type candidate, the ATS is relevant, but the card does not support ISO14443-4A
                CardCandidates[CardCandidatesIdx++] = i;
    9c08:	e0 91 a1 2d 	lds	r30, 0x2DA1
    9c0c:	81 e0       	ldi	r24, 0x01	; 1
    9c0e:	8e 0f       	add	r24, r30
    9c10:	80 93 a1 2d 	sts	0x2DA1, r24
    9c14:	f0 e0       	ldi	r31, 0x00	; 0
    9c16:	ee 55       	subi	r30, 0x5E	; 94
    9c18:	f2 4d       	sbci	r31, 0xD2	; 210
    9c1a:	90 82       	st	Z, r9
        {
            bool ISO14443_4A_compliant = IS_ISO14443A_4_COMPLIANT(Buffer);
            CardCandidatesIdx = 0;

            uint8_t i;
            for (i = 0; i < ARRAY_COUNT(CardIdentificationList); i++)
    9c1c:	93 94       	inc	r9
    9c1e:	f7 e6       	ldi	r31, 0x67	; 103
    9c20:	af 0e       	add	r10, r31
    9c22:	b1 1c       	adc	r11, r1
    9c24:	8f e0       	ldi	r24, 0x0F	; 15
    9c26:	98 12       	cpse	r9, r24
    9c28:	cf cf       	rjmp	.-98     	; 0x9bc8 <Identify+0x5e>
                if (card.ATSRelevant && !ISO14443_4A_compliant)
                    continue; // for this card type candidate, the ATS is relevant, but the card does not support ISO14443-4A
                CardCandidates[CardCandidatesIdx++] = i;
            }

            if (ISO14443_4A_compliant)
    9c2a:	c1 10       	cpse	r12, r1
    9c2c:	0d c0       	rjmp	.+26     	; 0x9c48 <Identify+0xde>

        /*
         * If any cards are not distinguishable with ISO14443A commands only, this is the place to run some proprietary commands.
         */

        if ((ReaderState >= STATE_SAK_CL1 && ReaderState <= STATE_SAK_CL3) || ReaderState == STATE_ATS)
    9c2e:	80 91 bf 2d 	lds	r24, 0x2DBF
    9c32:	9a ef       	ldi	r25, 0xFA	; 250
    9c34:	98 0f       	add	r25, r24
    9c36:	94 30       	cpi	r25, 0x04	; 4
    9c38:	08 f0       	brcs	.+2      	; 0x9c3c <Identify+0xd2>
    9c3a:	ad c0       	rjmp	.+346    	; 0x9d96 <Identify+0x22c>
        {
            uint8_t i;
            for (i = 0; i < CardCandidatesIdx; i++)
    9c3c:	90 91 a1 2d 	lds	r25, 0x2DA1
    9c40:	22 ea       	ldi	r18, 0xA2	; 162
    9c42:	3d e2       	ldi	r19, 0x2D	; 45
    9c44:	f9 01       	movw	r30, r18
    9c46:	8c c0       	rjmp	.+280    	; 0x9d60 <Identify+0x1f6>
    return addParityBits(Buffer, 4 * BITS_PER_BYTE);
}

INLINE uint16_t Reader14443A_RATS(uint8_t* Buffer)
{
    Buffer[0] = 0xE0; // RATS command
    9c48:	80 ee       	ldi	r24, 0xE0	; 224
    9c4a:	f8 01       	movw	r30, r16
    9c4c:	80 83       	st	Z, r24
    Buffer[1] = 0x80;
    9c4e:	80 e8       	ldi	r24, 0x80	; 128
    9c50:	81 83       	std	Z+1, r24	; 0x01
    ISO14443AAppendCRCA(Buffer, 2);
    9c52:	62 e0       	ldi	r22, 0x02	; 2
    9c54:	70 e0       	ldi	r23, 0x00	; 0
    9c56:	c8 01       	movw	r24, r16
    9c58:	0e 94 63 3d 	call	0x7ac6	; 0x7ac6 <ISO14443AAppendCRCA>
    ReaderState = STATE_ATS;
    9c5c:	89 e0       	ldi	r24, 0x09	; 9
    9c5e:	94 c0       	rjmp	.+296    	; 0x9d88 <Identify+0x21e>
                *BitCount = Reader14443A_RATS(Buffer);
                return false;
            }
            // if we don't have to send the RATS, we are finished for distinguishing with ISO 14443A

        } else if (ReaderState == STATE_ATS) { // we have got the ATS
    9c60:	89 30       	cpi	r24, 0x09	; 9
    9c62:	29 f7       	brne	.-54     	; 0x9c2e <Identify+0xc4>
            if (!checkParityBits(Buffer, *BitCount))
    9c64:	f7 01       	movw	r30, r14
    9c66:	60 81       	ld	r22, Z
    9c68:	71 81       	ldd	r23, Z+1	; 0x01
    9c6a:	c8 01       	movw	r24, r16
    9c6c:	d9 dd       	rcall	.-1102   	; 0x9820 <checkParityBits>
    9c6e:	f7 01       	movw	r30, r14
    9c70:	60 81       	ld	r22, Z
    9c72:	71 81       	ldd	r23, Z+1	; 0x01
    9c74:	81 11       	cpse	r24, r1
    9c76:	15 c0       	rjmp	.+42     	; 0x9ca2 <Identify+0x138>
            {
                LogEntry(LOG_ERR_APP_CHECKSUM_FAIL, Buffer, (*BitCount + 8) / 7);
    9c78:	cb 01       	movw	r24, r22
    9c7a:	08 96       	adiw	r24, 0x08	; 8
    9c7c:	67 e0       	ldi	r22, 0x07	; 7
    9c7e:	70 e0       	ldi	r23, 0x00	; 0
    9c80:	0e 94 31 65 	call	0xca62	; 0xca62 <__udivmodhi4>
    9c84:	46 2f       	mov	r20, r22
    9c86:	e0 91 6e 2f 	lds	r30, 0x2F6E
    9c8a:	f0 91 6f 2f 	lds	r31, 0x2F6F
    9c8e:	b8 01       	movw	r22, r16
    9c90:	81 ec       	ldi	r24, 0xC1	; 193
    9c92:	19 95       	eicall
                *BitCount = Reader14443A_Deselect(Buffer);
    9c94:	c8 01       	movw	r24, r16
    9c96:	61 dd       	rcall	.-1342   	; 0x975a <Reader14443A_Deselect>
    9c98:	f7 01       	movw	r30, r14
    9c9a:	80 83       	st	Z, r24
    9c9c:	91 83       	std	Z+1, r25	; 0x01
                return false;
    9c9e:	d1 2c       	mov	r13, r1
    9ca0:	c8 c0       	rjmp	.+400    	; 0x9e32 <Identify+0x2c8>
            }
            *BitCount = removeParityBits(Buffer, *BitCount);
    9ca2:	c8 01       	movw	r24, r16
    9ca4:	6f dd       	rcall	.-1314   	; 0x9784 <removeParityBits>
    9ca6:	f7 01       	movw	r30, r14
    9ca8:	80 83       	st	Z, r24
    9caa:	91 83       	std	Z+1, r25	; 0x01

            if (Buffer[0] != *BitCount / 8 - 2 || ISO14443_CRCA(Buffer, Buffer[0] + 2))
    9cac:	f8 01       	movw	r30, r16
    9cae:	60 81       	ld	r22, Z
    9cb0:	26 2f       	mov	r18, r22
    9cb2:	30 e0       	ldi	r19, 0x00	; 0
    9cb4:	43 e0       	ldi	r20, 0x03	; 3
    9cb6:	96 95       	lsr	r25
    9cb8:	87 95       	ror	r24
    9cba:	4a 95       	dec	r20
    9cbc:	e1 f7       	brne	.-8      	; 0x9cb6 <Identify+0x14c>
    9cbe:	02 97       	sbiw	r24, 0x02	; 2
    9cc0:	28 17       	cp	r18, r24
    9cc2:	39 07       	cpc	r19, r25
    9cc4:	39 f7       	brne	.-50     	; 0x9c94 <Identify+0x12a>
    9cc6:	6e 5f       	subi	r22, 0xFE	; 254
    9cc8:	c8 01       	movw	r24, r16
    9cca:	14 de       	rcall	.-984    	; 0x98f4 <ISO14443_CRCA>
    9ccc:	89 2b       	or	r24, r25
    9cce:	11 f7       	brne	.-60     	; 0x9c94 <Identify+0x12a>
    9cd0:	c1 2c       	mov	r12, r1

            uint8_t i;
            for (i = 0; i < CardCandidatesIdx; i++)
            {
                CardIdentificationType card;
                memcpy_P(&card, &CardIdentificationList[CardCandidates[i]], sizeof(CardIdentificationType));
    9cd2:	97 e6       	ldi	r25, 0x67	; 103
    9cd4:	99 2e       	mov	r9, r25
                if (!card.ATSRelevant || (card.ATSRelevant && card.ATSSize == Buffer[0] - 1 && memcmp(card.ATS, Buffer + 1, card.ATSSize) == 0))
    9cd6:	58 01       	movw	r10, r16
    9cd8:	ff ef       	ldi	r31, 0xFF	; 255
    9cda:	af 1a       	sub	r10, r31
    9cdc:	bf 0a       	sbc	r11, r31
                *BitCount = Reader14443A_Deselect(Buffer);
                return false;
            }

            uint8_t i;
            for (i = 0; i < CardCandidatesIdx; i++)
    9cde:	80 91 a1 2d 	lds	r24, 0x2DA1
    9ce2:	c8 16       	cp	r12, r24
    9ce4:	08 f0       	brcs	.+2      	; 0x9ce8 <Identify+0x17e>
    9ce6:	a3 cf       	rjmp	.-186    	; 0x9c2e <Identify+0xc4>
            {
                CardIdentificationType card;
                memcpy_P(&card, &CardIdentificationList[CardCandidates[i]], sizeof(CardIdentificationType));
    9ce8:	ec 2d       	mov	r30, r12
    9cea:	f0 e0       	ldi	r31, 0x00	; 0
    9cec:	ee 55       	subi	r30, 0x5E	; 94
    9cee:	f2 4d       	sbci	r31, 0xD2	; 210
    9cf0:	60 81       	ld	r22, Z
    9cf2:	96 9e       	mul	r9, r22
    9cf4:	b0 01       	movw	r22, r0
    9cf6:	11 24       	eor	r1, r1
    9cf8:	64 51       	subi	r22, 0x14	; 20
    9cfa:	7e 4e       	sbci	r23, 0xEE	; 238
    9cfc:	47 e6       	ldi	r20, 0x67	; 103
    9cfe:	50 e0       	ldi	r21, 0x00	; 0
    9d00:	ce 01       	movw	r24, r28
    9d02:	01 96       	adiw	r24, 0x01	; 1
    9d04:	0e 94 b9 65 	call	0xcb72	; 0xcb72 <memcpy_P>
                if (!card.ATSRelevant || (card.ATSRelevant && card.ATSSize == Buffer[0] - 1 && memcmp(card.ATS, Buffer + 1, card.ATSSize) == 0))
    9d08:	8f 89       	ldd	r24, Y+23	; 0x17
    9d0a:	88 23       	and	r24, r24
    9d0c:	39 f1       	breq	.+78     	; 0x9d5c <Identify+0x1f2>
    9d0e:	4e 89       	ldd	r20, Y+22	; 0x16
    9d10:	50 e0       	ldi	r21, 0x00	; 0
    9d12:	f8 01       	movw	r30, r16
    9d14:	80 81       	ld	r24, Z
    9d16:	90 e0       	ldi	r25, 0x00	; 0
    9d18:	01 97       	sbiw	r24, 0x01	; 1
    9d1a:	48 17       	cp	r20, r24
    9d1c:	59 07       	cpc	r21, r25
    9d1e:	39 f4       	brne	.+14     	; 0x9d2e <Identify+0x1c4>
    9d20:	b5 01       	movw	r22, r10
    9d22:	ce 01       	movw	r24, r28
    9d24:	06 96       	adiw	r24, 0x06	; 6
    9d26:	0e 94 da 65 	call	0xcbb4	; 0xcbb4 <memcmp>
    9d2a:	89 2b       	or	r24, r25
    9d2c:	b9 f0       	breq	.+46     	; 0x9d5c <Identify+0x1f2>
                     */
                    continue;

                // Else, we have to delete this candidate
                uint8_t j;
                for (j = i; j < CardCandidatesIdx - 1; j++)
    9d2e:	20 91 a1 2d 	lds	r18, 0x2DA1
    9d32:	42 2f       	mov	r20, r18
    9d34:	50 e0       	ldi	r21, 0x00	; 0
    9d36:	41 50       	subi	r20, 0x01	; 1
    9d38:	51 09       	sbc	r21, r1
    9d3a:	3c 2d       	mov	r19, r12
    9d3c:	83 2f       	mov	r24, r19
    9d3e:	90 e0       	ldi	r25, 0x00	; 0
    9d40:	84 17       	cp	r24, r20
    9d42:	95 07       	cpc	r25, r21
    9d44:	3c f4       	brge	.+14     	; 0x9d54 <Identify+0x1ea>
                    CardCandidates[j] = CardCandidates[j+1];
    9d46:	fc 01       	movw	r30, r24
    9d48:	ee 55       	subi	r30, 0x5E	; 94
    9d4a:	f2 4d       	sbci	r31, 0xD2	; 210
    9d4c:	81 81       	ldd	r24, Z+1	; 0x01
    9d4e:	80 83       	st	Z, r24
                     */
                    continue;

                // Else, we have to delete this candidate
                uint8_t j;
                for (j = i; j < CardCandidatesIdx - 1; j++)
    9d50:	3f 5f       	subi	r19, 0xFF	; 255
    9d52:	f4 cf       	rjmp	.-24     	; 0x9d3c <Identify+0x1d2>
                    CardCandidates[j] = CardCandidates[j+1];
                CardCandidatesIdx--;
    9d54:	21 50       	subi	r18, 0x01	; 1
    9d56:	20 93 a1 2d 	sts	0x2DA1, r18
                i--;
    9d5a:	ca 94       	dec	r12
                *BitCount = Reader14443A_Deselect(Buffer);
                return false;
            }

            uint8_t i;
            for (i = 0; i < CardCandidatesIdx; i++)
    9d5c:	c3 94       	inc	r12
    9d5e:	bf cf       	rjmp	.-130    	; 0x9cde <Identify+0x174>
    9d60:	8e 2f       	mov	r24, r30
    9d62:	82 1b       	sub	r24, r18
         */

        if ((ReaderState >= STATE_SAK_CL1 && ReaderState <= STATE_SAK_CL3) || ReaderState == STATE_ATS)
        {
            uint8_t i;
            for (i = 0; i < CardCandidatesIdx; i++)
    9d64:	89 17       	cp	r24, r25
    9d66:	08 f0       	brcs	.+2      	; 0x9d6a <Identify+0x200>
    9d68:	64 c0       	rjmp	.+200    	; 0x9e32 <Identify+0x2c8>
            {
                switch (CardCandidates[i])
    9d6a:	81 91       	ld	r24, Z+
    9d6c:	84 50       	subi	r24, 0x04	; 4
    9d6e:	82 30       	cpi	r24, 0x02	; 2
    9d70:	b8 f7       	brcc	.-18     	; 0x9d60 <Identify+0x1f6>
                {
                case CardType_NXP_MIFARE_DESFire:
                case CardType_NXP_MIFARE_DESFire_EV1:
                    Buffer[0] = 0x02;
    9d72:	82 e0       	ldi	r24, 0x02	; 2
    9d74:	f8 01       	movw	r30, r16
    9d76:	80 83       	st	Z, r24
                    Buffer[1] = 0x60;
    9d78:	80 e6       	ldi	r24, 0x60	; 96
    9d7a:	81 83       	std	Z+1, r24	; 0x01
                    ISO14443AAppendCRCA(Buffer, 2);
    9d7c:	62 e0       	ldi	r22, 0x02	; 2
    9d7e:	70 e0       	ldi	r23, 0x00	; 0
    9d80:	c8 01       	movw	r24, r16
    9d82:	0e 94 63 3d 	call	0x7ac6	; 0x7ac6 <ISO14443AAppendCRCA>
                    ReaderState = STATE_DESFIRE_INFO;
    9d86:	8b e0       	ldi	r24, 0x0B	; 11
    9d88:	80 93 bf 2d 	sts	0x2DBF, r24
                    *BitCount = addParityBits(Buffer, 4 * BITS_PER_BYTE);
    9d8c:	60 e2       	ldi	r22, 0x20	; 32
    9d8e:	70 e0       	ldi	r23, 0x00	; 0
    9d90:	c8 01       	movw	r24, r16
    9d92:	75 dc       	rcall	.-1814   	; 0x967e <addParityBits>
    9d94:	81 cf       	rjmp	.-254    	; 0x9c98 <Identify+0x12e>
                default:
                    break;
                }
            }
        } else {
            switch (ReaderState)
    9d96:	8b 30       	cpi	r24, 0x0B	; 11
    9d98:	09 f0       	breq	.+2      	; 0x9d9c <Identify+0x232>
    9d9a:	4b c0       	rjmp	.+150    	; 0x9e32 <Identify+0x2c8>
            {
            case STATE_DESFIRE_INFO:
                if (*BitCount == 0)
    9d9c:	f7 01       	movw	r30, r14
    9d9e:	60 81       	ld	r22, Z
    9da0:	71 81       	ldd	r23, Z+1	; 0x01
    9da2:	61 15       	cp	r22, r1
    9da4:	71 05       	cpc	r23, r1
    9da6:	09 f4       	brne	.+2      	; 0x9daa <Identify+0x240>
    9da8:	3e c0       	rjmp	.+124    	; 0x9e26 <Identify+0x2bc>
                {
                    CardCandidatesIdx = 0; // this will return that this card is unknown to us
                    break;
                }
                if (!checkParityBits(Buffer, *BitCount))
    9daa:	c8 01       	movw	r24, r16
    9dac:	39 dd       	rcall	.-1422   	; 0x9820 <checkParityBits>
    9dae:	d8 2e       	mov	r13, r24
    9db0:	f7 01       	movw	r30, r14
    9db2:	60 81       	ld	r22, Z
    9db4:	71 81       	ldd	r23, Z+1	; 0x01
    9db6:	81 11       	cpse	r24, r1
    9db8:	13 c0       	rjmp	.+38     	; 0x9de0 <Identify+0x276>
                {
                    LogEntry(LOG_ERR_APP_CHECKSUM_FAIL, Buffer, (*BitCount + 8) / 7);
    9dba:	cb 01       	movw	r24, r22
    9dbc:	08 96       	adiw	r24, 0x08	; 8
    9dbe:	67 e0       	ldi	r22, 0x07	; 7
    9dc0:	70 e0       	ldi	r23, 0x00	; 0
    9dc2:	0e 94 31 65 	call	0xca62	; 0xca62 <__udivmodhi4>
    9dc6:	46 2f       	mov	r20, r22
    9dc8:	e0 91 6e 2f 	lds	r30, 0x2F6E
    9dcc:	f0 91 6f 2f 	lds	r31, 0x2F6F
    9dd0:	b8 01       	movw	r22, r16
    9dd2:	81 ec       	ldi	r24, 0xC1	; 193
    9dd4:	19 95       	eicall
                    CardCandidatesIdx = 0;
    9dd6:	10 92 a1 2d 	sts	0x2DA1, r1
                    *BitCount = Reader14443A_Deselect(Buffer);
    9dda:	c8 01       	movw	r24, r16
    9ddc:	be dc       	rcall	.-1668   	; 0x975a <Reader14443A_Deselect>
    9dde:	26 c0       	rjmp	.+76     	; 0x9e2c <Identify+0x2c2>
                    return false;
                }
                *BitCount = removeParityBits(Buffer, *BitCount);
    9de0:	c8 01       	movw	r24, r16
    9de2:	d0 dc       	rcall	.-1632   	; 0x9784 <removeParityBits>
    9de4:	f7 01       	movw	r30, r14
    9de6:	80 83       	st	Z, r24
    9de8:	91 83       	std	Z+1, r25	; 0x01
                if (ISO14443_CRCA(Buffer, *BitCount / 8))
    9dea:	bc 01       	movw	r22, r24
    9dec:	83 e0       	ldi	r24, 0x03	; 3
    9dee:	76 95       	lsr	r23
    9df0:	67 95       	ror	r22
    9df2:	8a 95       	dec	r24
    9df4:	e1 f7       	brne	.-8      	; 0x9dee <Identify+0x284>
    9df6:	c8 01       	movw	r24, r16
    9df8:	7d dd       	rcall	.-1286   	; 0x98f4 <ISO14443_CRCA>
    9dfa:	89 2b       	or	r24, r25
    9dfc:	19 f0       	breq	.+6      	; 0x9e04 <Identify+0x29a>
                {
                    CardCandidatesIdx = 0;
    9dfe:	10 92 a1 2d 	sts	0x2DA1, r1
    9e02:	48 cf       	rjmp	.-368    	; 0x9c94 <Identify+0x12a>
                    *BitCount = Reader14443A_Deselect(Buffer);
                    return false;
                }
                switch (Buffer[5])
    9e04:	f8 01       	movw	r30, r16
    9e06:	85 81       	ldd	r24, Z+5	; 0x05
    9e08:	88 23       	and	r24, r24
    9e0a:	31 f0       	breq	.+12     	; 0x9e18 <Identify+0x2ae>
    9e0c:	81 30       	cpi	r24, 0x01	; 1
    9e0e:	59 f4       	brne	.+22     	; 0x9e26 <Identify+0x2bc>
                    CardCandidatesIdx = 1;
                    CardCandidates[0] = CardType_NXP_MIFARE_DESFire;
                    break;

                case 0x01:
                    CardCandidatesIdx = 1;
    9e10:	80 93 a1 2d 	sts	0x2DA1, r24
                    CardCandidates[0] = CardType_NXP_MIFARE_DESFire_EV1;
    9e14:	85 e0       	ldi	r24, 0x05	; 5
    9e16:	04 c0       	rjmp	.+8      	; 0x9e20 <Identify+0x2b6>
                    return false;
                }
                switch (Buffer[5])
                {
                case 0x00:
                    CardCandidatesIdx = 1;
    9e18:	81 e0       	ldi	r24, 0x01	; 1
    9e1a:	80 93 a1 2d 	sts	0x2DA1, r24
                    CardCandidates[0] = CardType_NXP_MIFARE_DESFire;
    9e1e:	84 e0       	ldi	r24, 0x04	; 4
                    break;

                case 0x01:
                    CardCandidatesIdx = 1;
                    CardCandidates[0] = CardType_NXP_MIFARE_DESFire_EV1;
    9e20:	80 93 a2 2d 	sts	0x2DA2, r24
                    break;
    9e24:	06 c0       	rjmp	.+12     	; 0x9e32 <Identify+0x2c8>

                default:
                    CardCandidatesIdx = 0;
    9e26:	10 92 a1 2d 	sts	0x2DA1, r1
    9e2a:	03 c0       	rjmp	.+6      	; 0x9e32 <Identify+0x2c8>
                break;
            }
        }
        return true;
    }
    *BitCount = rVal;
    9e2c:	f7 01       	movw	r30, r14
    9e2e:	80 83       	st	Z, r24
    9e30:	91 83       	std	Z+1, r25	; 0x01
    return false;
}
    9e32:	8d 2d       	mov	r24, r13
    9e34:	c9 59       	subi	r28, 0x99	; 153
    9e36:	df 4f       	sbci	r29, 0xFF	; 255
    9e38:	cd bf       	out	0x3d, r28	; 61
    9e3a:	de bf       	out	0x3e, r29	; 62
    9e3c:	df 91       	pop	r29
    9e3e:	cf 91       	pop	r28
    9e40:	1f 91       	pop	r17
    9e42:	0f 91       	pop	r16
    9e44:	ff 90       	pop	r15
    9e46:	ef 90       	pop	r14
    9e48:	df 90       	pop	r13
    9e4a:	cf 90       	pop	r12
    9e4c:	bf 90       	pop	r11
    9e4e:	af 90       	pop	r10
    9e50:	9f 90       	pop	r9
    9e52:	08 95       	ret

00009e54 <Reader14443AAppProcess>:

uint16_t Reader14443AAppProcess(uint8_t* Buffer, uint16_t BitCount)
{
    9e54:	5f 92       	push	r5
    9e56:	6f 92       	push	r6
    9e58:	7f 92       	push	r7
    9e5a:	8f 92       	push	r8
    9e5c:	9f 92       	push	r9
    9e5e:	af 92       	push	r10
    9e60:	bf 92       	push	r11
    9e62:	cf 92       	push	r12
    9e64:	df 92       	push	r13
    9e66:	ef 92       	push	r14
    9e68:	ff 92       	push	r15
    9e6a:	0f 93       	push	r16
    9e6c:	1f 93       	push	r17
    9e6e:	cf 93       	push	r28
    9e70:	df 93       	push	r29
    9e72:	cd b7       	in	r28, 0x3d	; 61
    9e74:	de b7       	in	r29, 0x3e	; 62
    9e76:	c2 54       	subi	r28, 0x42	; 66
    9e78:	d2 40       	sbci	r29, 0x02	; 2
    9e7a:	cd bf       	out	0x3d, r28	; 61
    9e7c:	de bf       	out	0x3e, r29	; 62
    9e7e:	7c 01       	movw	r14, r24
    9e80:	cf 5b       	subi	r28, 0xBF	; 191
    9e82:	dd 4f       	sbci	r29, 0xFD	; 253
    9e84:	68 83       	st	Y, r22
    9e86:	79 83       	std	Y+1, r23	; 0x01
    9e88:	c1 54       	subi	r28, 0x41	; 65
    9e8a:	d2 40       	sbci	r29, 0x02	; 2
    switch (Reader14443CurrentCommand)
    9e8c:	80 91 e5 2c 	lds	r24, 0x2CE5
    9e90:	84 30       	cpi	r24, 0x04	; 4
    9e92:	09 f4       	brne	.+2      	; 0x9e96 <Reader14443AAppProcess+0x42>
    9e94:	8b c1       	rjmp	.+790    	; 0xa1ac <Reader14443AAppProcess+0x358>
    9e96:	40 f4       	brcc	.+16     	; 0x9ea8 <Reader14443AAppProcess+0x54>
    9e98:	82 30       	cpi	r24, 0x02	; 2
    9e9a:	09 f4       	brne	.+2      	; 0x9e9e <Reader14443AAppProcess+0x4a>
    9e9c:	d6 c0       	rjmp	.+428    	; 0xa04a <Reader14443AAppProcess+0x1f6>
    9e9e:	08 f0       	brcs	.+2      	; 0x9ea2 <Reader14443AAppProcess+0x4e>
    9ea0:	60 c1       	rjmp	.+704    	; 0xa162 <Reader14443AAppProcess+0x30e>
    9ea2:	81 30       	cpi	r24, 0x01	; 1
    9ea4:	51 f0       	breq	.+20     	; 0x9eba <Reader14443AAppProcess+0x66>
    9ea6:	8f c4       	rjmp	.+2334   	; 0xa7c6 <Reader14443AAppProcess+0x972>
    9ea8:	86 30       	cpi	r24, 0x06	; 6
    9eaa:	09 f4       	brne	.+2      	; 0x9eae <Reader14443AAppProcess+0x5a>
    9eac:	21 c3       	rjmp	.+1602   	; 0xa4f0 <Reader14443AAppProcess+0x69c>
    9eae:	08 f4       	brcc	.+2      	; 0x9eb2 <Reader14443AAppProcess+0x5e>
    9eb0:	48 c2       	rjmp	.+1168   	; 0xa342 <Reader14443AAppProcess+0x4ee>
    9eb2:	87 30       	cpi	r24, 0x07	; 7
    9eb4:	09 f4       	brne	.+2      	; 0x9eb8 <Reader14443AAppProcess+0x64>
    9eb6:	ca c3       	rjmp	.+1940   	; 0xa64c <Reader14443AAppProcess+0x7f8>
    9eb8:	86 c4       	rjmp	.+2316   	; 0xa7c6 <Reader14443AAppProcess+0x972>
    {
        case Reader14443_Send:
        {
            if (ReaderSendBitCount)
    9eba:	00 91 54 2f 	lds	r16, 0x2F54
    9ebe:	10 91 55 2f 	lds	r17, 0x2F55
    9ec2:	01 15       	cp	r16, r1
    9ec4:	11 05       	cpc	r17, r1
    9ec6:	c1 f0       	breq	.+48     	; 0x9ef8 <Reader14443AAppProcess+0xa4>
            {
                memcpy(Buffer, ReaderSendBuffer, (ReaderSendBitCount + 7) / 8);
    9ec8:	a8 01       	movw	r20, r16
    9eca:	49 5f       	subi	r20, 0xF9	; 249
    9ecc:	5f 4f       	sbci	r21, 0xFF	; 255
    9ece:	e3 e0       	ldi	r30, 0x03	; 3
    9ed0:	56 95       	lsr	r21
    9ed2:	47 95       	ror	r20
    9ed4:	ea 95       	dec	r30
    9ed6:	e1 f7       	brne	.-8      	; 0x9ed0 <Reader14443AAppProcess+0x7c>
    9ed8:	62 e5       	ldi	r22, 0x52	; 82
    9eda:	7e e2       	ldi	r23, 0x2E	; 46
    9edc:	c7 01       	movw	r24, r14
    9ede:	0e 94 e7 65 	call	0xcbce	; 0xcbce <memcpy>
                uint16_t tmp = addParityBits(Buffer, ReaderSendBitCount);
    9ee2:	60 91 54 2f 	lds	r22, 0x2F54
    9ee6:	70 91 55 2f 	lds	r23, 0x2F55
    9eea:	c7 01       	movw	r24, r14
    9eec:	c8 db       	rcall	.-2160   	; 0x967e <addParityBits>
                ReaderSendBitCount = 0;
    9eee:	10 92 54 2f 	sts	0x2F54, r1
    9ef2:	10 92 55 2f 	sts	0x2F55, r1
    9ef6:	23 c2       	rjmp	.+1094   	; 0xa33e <Reader14443AAppProcess+0x4ea>
                return tmp;
            }

            if (BitCount == 0)
    9ef8:	cf 5b       	subi	r28, 0xBF	; 191
    9efa:	dd 4f       	sbci	r29, 0xFD	; 253
    9efc:	68 81       	ld	r22, Y
    9efe:	79 81       	ldd	r23, Y+1	; 0x01
    9f00:	c1 54       	subi	r28, 0x41	; 65
    9f02:	d2 40       	sbci	r29, 0x02	; 2
    9f04:	61 15       	cp	r22, r1
    9f06:	71 05       	cpc	r23, r1
    9f08:	09 f4       	brne	.+2      	; 0x9f0c <Reader14443AAppProcess+0xb8>
    9f0a:	c7 c0       	rjmp	.+398    	; 0xa09a <Reader14443AAppProcess+0x246>
                Reader14443CurrentCommand = Reader14443_Do_Nothing;
                CommandLinePendingTaskFinished(COMMAND_INFO_OK_WITH_TEXT_ID, tmpBuf);
                return 0;
            }
            char tmpBuf[128];
            bool parity = checkParityBits(Buffer, BitCount);
    9f0c:	c7 01       	movw	r24, r14
    9f0e:	88 dc       	rcall	.-1776   	; 0x9820 <checkParityBits>
    9f10:	d8 2e       	mov	r13, r24
            BitCount = removeParityBits(Buffer, BitCount);
    9f12:	cf 5b       	subi	r28, 0xBF	; 191
    9f14:	dd 4f       	sbci	r29, 0xFD	; 253
    9f16:	68 81       	ld	r22, Y
    9f18:	79 81       	ldd	r23, Y+1	; 0x01
    9f1a:	c1 54       	subi	r28, 0x41	; 65
    9f1c:	d2 40       	sbci	r29, 0x02	; 2
    9f1e:	c7 01       	movw	r24, r14
    9f20:	31 dc       	rcall	.-1950   	; 0x9784 <removeParityBits>
    9f22:	cf 5b       	subi	r28, 0xBF	; 191
    9f24:	dd 4f       	sbci	r29, 0xFD	; 253
    9f26:	88 83       	st	Y, r24
    9f28:	99 83       	std	Y+1, r25	; 0x01
    9f2a:	c1 54       	subi	r28, 0x41	; 65
    9f2c:	d2 40       	sbci	r29, 0x02	; 2
            if ((2 * (BitCount + 7) / 8 + 2 + 4) > 128) // 2 = \r\n, 4 = size of bitcount in hex
    9f2e:	9c 01       	movw	r18, r24
    9f30:	29 5f       	subi	r18, 0xF9	; 249
    9f32:	3f 4f       	sbci	r19, 0xFF	; 255
    9f34:	c9 01       	movw	r24, r18
    9f36:	88 0f       	add	r24, r24
    9f38:	99 1f       	adc	r25, r25
    9f3a:	73 e0       	ldi	r23, 0x03	; 3
    9f3c:	96 95       	lsr	r25
    9f3e:	87 95       	ror	r24
    9f40:	7a 95       	dec	r23
    9f42:	e1 f7       	brne	.-8      	; 0x9f3c <Reader14443AAppProcess+0xe8>
    9f44:	06 96       	adiw	r24, 0x06	; 6
    9f46:	81 38       	cpi	r24, 0x81	; 129
    9f48:	91 05       	cpc	r25, r1
    9f4a:	78 f0       	brcs	.+30     	; 0x9f6a <Reader14443AAppProcess+0x116>
            {
                sprintf(tmpBuf, "Too many data.");
    9f4c:	60 ed       	ldi	r22, 0xD0	; 208
    9f4e:	73 e2       	ldi	r23, 0x23	; 35
    9f50:	ce 01       	movw	r24, r28
    9f52:	01 96       	adiw	r24, 0x01	; 1
    9f54:	0e 94 13 66 	call	0xcc26	; 0xcc26 <strcpy>
                Reader14443CurrentCommand = Reader14443_Do_Nothing;
    9f58:	10 92 e5 2c 	sts	0x2CE5, r1
                CommandLinePendingTaskFinished(COMMAND_INFO_OK_WITH_TEXT_ID, tmpBuf);
    9f5c:	be 01       	movw	r22, r28
    9f5e:	6f 5f       	subi	r22, 0xFF	; 255
    9f60:	7f 4f       	sbci	r23, 0xFF	; 255
    9f62:	85 e6       	ldi	r24, 0x65	; 101
    9f64:	0e 94 4d 23 	call	0x469a	; 0x469a <CommandLinePendingTaskFinished>
                return 0;
    9f68:	6e c4       	rjmp	.+2268   	; 0xa846 <Reader14443AAppProcess+0x9f2>
            }
            uint16_t charCnt = BufferToHexString(tmpBuf, 128, Buffer, (BitCount + 7) / 8);
    9f6a:	43 e0       	ldi	r20, 0x03	; 3
    9f6c:	36 95       	lsr	r19
    9f6e:	27 95       	ror	r18
    9f70:	4a 95       	dec	r20
    9f72:	e1 f7       	brne	.-8      	; 0x9f6c <Reader14443AAppProcess+0x118>
    9f74:	a7 01       	movw	r20, r14
    9f76:	60 e8       	ldi	r22, 0x80	; 128
    9f78:	70 e0       	ldi	r23, 0x00	; 0
    9f7a:	ce 01       	movw	r24, r28
    9f7c:	01 96       	adiw	r24, 0x01	; 1
    9f7e:	0e 94 f8 0e 	call	0x1df0	; 0x1df0 <BufferToHexString>
    9f82:	7c 01       	movw	r14, r24
            uint8_t count[2] = {(BitCount>>8)&0xFF, BitCount&0xFF};
    9f84:	cf 5b       	subi	r28, 0xBF	; 191
    9f86:	dd 4f       	sbci	r29, 0xFD	; 253
    9f88:	88 81       	ld	r24, Y
    9f8a:	c1 54       	subi	r28, 0x41	; 65
    9f8c:	d2 40       	sbci	r29, 0x02	; 2
    9f8e:	ce 5b       	subi	r28, 0xBE	; 190
    9f90:	dd 4f       	sbci	r29, 0xFD	; 253
    9f92:	98 81       	ld	r25, Y
    9f94:	c2 54       	subi	r28, 0x42	; 66
    9f96:	d2 40       	sbci	r29, 0x02	; 2
    9f98:	cf 5f       	subi	r28, 0xFF	; 255
    9f9a:	dd 4f       	sbci	r29, 0xFD	; 253
    9f9c:	98 83       	st	Y, r25
    9f9e:	c1 50       	subi	r28, 0x01	; 1
    9fa0:	d2 40       	sbci	r29, 0x02	; 2
    9fa2:	ce 5f       	subi	r28, 0xFE	; 254
    9fa4:	dd 4f       	sbci	r29, 0xFD	; 253
    9fa6:	88 83       	st	Y, r24
    9fa8:	c2 50       	subi	r28, 0x02	; 2
    9faa:	d2 40       	sbci	r29, 0x02	; 2
            charCnt += snprintf(tmpBuf + charCnt, 128 - charCnt, "\r\n");
    9fac:	8f ed       	ldi	r24, 0xDF	; 223
    9fae:	93 e2       	ldi	r25, 0x23	; 35
    9fb0:	9f 93       	push	r25
    9fb2:	8f 93       	push	r24
    9fb4:	50 e8       	ldi	r21, 0x80	; 128
    9fb6:	a5 2e       	mov	r10, r21
    9fb8:	b1 2c       	mov	r11, r1
    9fba:	c5 01       	movw	r24, r10
    9fbc:	8e 19       	sub	r24, r14
    9fbe:	9f 09       	sbc	r25, r15
    9fc0:	9f 93       	push	r25
    9fc2:	8f 93       	push	r24
    9fc4:	81 e0       	ldi	r24, 0x01	; 1
    9fc6:	90 e0       	ldi	r25, 0x00	; 0
    9fc8:	8c 0f       	add	r24, r28
    9fca:	9d 1f       	adc	r25, r29
    9fcc:	8e 0d       	add	r24, r14
    9fce:	9f 1d       	adc	r25, r15
    9fd0:	9f 93       	push	r25
    9fd2:	8f 93       	push	r24
    9fd4:	0e 94 1a 66 	call	0xcc34	; 0xcc34 <snprintf>
    9fd8:	e8 0e       	add	r14, r24
    9fda:	f9 1e       	adc	r15, r25
            charCnt += BufferToHexString(tmpBuf + charCnt, 128 - charCnt, count, 2);
    9fdc:	b5 01       	movw	r22, r10
    9fde:	6e 19       	sub	r22, r14
    9fe0:	7f 09       	sbc	r23, r15
    9fe2:	22 e0       	ldi	r18, 0x02	; 2
    9fe4:	30 e0       	ldi	r19, 0x00	; 0
    9fe6:	ae 01       	movw	r20, r28
    9fe8:	4f 5f       	subi	r20, 0xFF	; 255
    9fea:	5d 4f       	sbci	r21, 0xFD	; 253
    9fec:	81 e0       	ldi	r24, 0x01	; 1
    9fee:	90 e0       	ldi	r25, 0x00	; 0
    9ff0:	8c 0f       	add	r24, r28
    9ff2:	9d 1f       	adc	r25, r29
    9ff4:	8e 0d       	add	r24, r14
    9ff6:	9f 1d       	adc	r25, r15
    9ff8:	0e 94 f8 0e 	call	0x1df0	; 0x1df0 <BufferToHexString>
    9ffc:	8e 0d       	add	r24, r14
    9ffe:	9f 1d       	adc	r25, r15
            if (!parity)
    a000:	0f 90       	pop	r0
    a002:	0f 90       	pop	r0
    a004:	0f 90       	pop	r0
    a006:	0f 90       	pop	r0
    a008:	0f 90       	pop	r0
    a00a:	0f 90       	pop	r0
    a00c:	a5 01       	movw	r20, r10
    a00e:	48 1b       	sub	r20, r24
    a010:	59 0b       	sbc	r21, r25
    a012:	21 e0       	ldi	r18, 0x01	; 1
    a014:	30 e0       	ldi	r19, 0x00	; 0
    a016:	2c 0f       	add	r18, r28
    a018:	3d 1f       	adc	r19, r29
    a01a:	28 0f       	add	r18, r24
    a01c:	39 1f       	adc	r19, r25
    a01e:	d1 10       	cpse	r13, r1
    a020:	03 c0       	rjmp	.+6      	; 0xa028 <Reader14443AAppProcess+0x1d4>
                snprintf(tmpBuf + charCnt, 128 - charCnt, "\r\nPARITY ERROR");
    a022:	82 ee       	ldi	r24, 0xE2	; 226
    a024:	93 e2       	ldi	r25, 0x23	; 35
    a026:	02 c0       	rjmp	.+4      	; 0xa02c <Reader14443AAppProcess+0x1d8>
            else
                snprintf(tmpBuf + charCnt, 128 - charCnt, "\r\nPARITY OK");
    a028:	81 ef       	ldi	r24, 0xF1	; 241
    a02a:	93 e2       	ldi	r25, 0x23	; 35
    a02c:	9f 93       	push	r25
    a02e:	8f 93       	push	r24
    a030:	5f 93       	push	r21
    a032:	4f 93       	push	r20
    a034:	3f 93       	push	r19
    a036:	2f 93       	push	r18
    a038:	0e 94 1a 66 	call	0xcc34	; 0xcc34 <snprintf>
    a03c:	0f 90       	pop	r0
    a03e:	0f 90       	pop	r0
    a040:	0f 90       	pop	r0
    a042:	0f 90       	pop	r0
    a044:	0f 90       	pop	r0
    a046:	0f 90       	pop	r0
    a048:	87 cf       	rjmp	.-242    	; 0x9f58 <Reader14443AAppProcess+0x104>
        }


        case Reader14443_Send_Raw:
        {
            if (ReaderSendBitCount)
    a04a:	00 91 54 2f 	lds	r16, 0x2F54
    a04e:	10 91 55 2f 	lds	r17, 0x2F55
    a052:	01 15       	cp	r16, r1
    a054:	11 05       	cpc	r17, r1
    a056:	c1 f0       	breq	.+48     	; 0xa088 <Reader14443AAppProcess+0x234>
            {
                memcpy(Buffer, ReaderSendBuffer, (ReaderSendBitCount + 7) / 8);
    a058:	a8 01       	movw	r20, r16
    a05a:	49 5f       	subi	r20, 0xF9	; 249
    a05c:	5f 4f       	sbci	r21, 0xFF	; 255
    a05e:	93 e0       	ldi	r25, 0x03	; 3
    a060:	56 95       	lsr	r21
    a062:	47 95       	ror	r20
    a064:	9a 95       	dec	r25
    a066:	e1 f7       	brne	.-8      	; 0xa060 <Reader14443AAppProcess+0x20c>
    a068:	62 e5       	ldi	r22, 0x52	; 82
    a06a:	7e e2       	ldi	r23, 0x2E	; 46
    a06c:	c7 01       	movw	r24, r14
    a06e:	0e 94 e7 65 	call	0xcbce	; 0xcbce <memcpy>
                uint16_t tmp = ReaderSendBitCount;
    a072:	90 91 54 2f 	lds	r25, 0x2F54
    a076:	80 91 55 2f 	lds	r24, 0x2F55
                ReaderSendBitCount = 0;
    a07a:	10 92 54 2f 	sts	0x2F54, r1
    a07e:	10 92 55 2f 	sts	0x2F55, r1
                return tmp;
    a082:	09 2f       	mov	r16, r25
    a084:	18 2f       	mov	r17, r24
    a086:	df c3       	rjmp	.+1982   	; 0xa846 <Reader14443AAppProcess+0x9f2>
            }

            if (BitCount == 0)
    a088:	cf 5b       	subi	r28, 0xBF	; 191
    a08a:	dd 4f       	sbci	r29, 0xFD	; 253
    a08c:	28 81       	ld	r18, Y
    a08e:	39 81       	ldd	r19, Y+1	; 0x01
    a090:	c1 54       	subi	r28, 0x41	; 65
    a092:	d2 40       	sbci	r29, 0x02	; 2
    a094:	21 15       	cp	r18, r1
    a096:	31 05       	cpc	r19, r1
    a098:	51 f4       	brne	.+20     	; 0xa0ae <Reader14443AAppProcess+0x25a>
            {
                char tmpBuf[] = "NO DATA";
    a09a:	88 e0       	ldi	r24, 0x08	; 8
    a09c:	e5 e6       	ldi	r30, 0x65	; 101
    a09e:	f4 e2       	ldi	r31, 0x24	; 36
    a0a0:	de 01       	movw	r26, r28
    a0a2:	11 96       	adiw	r26, 0x01	; 1
    a0a4:	01 90       	ld	r0, Z+
    a0a6:	0d 92       	st	X+, r0
    a0a8:	8a 95       	dec	r24
    a0aa:	e1 f7       	brne	.-8      	; 0xa0a4 <Reader14443AAppProcess+0x250>
    a0ac:	55 cf       	rjmp	.-342    	; 0x9f58 <Reader14443AAppProcess+0x104>
                CommandLinePendingTaskFinished(COMMAND_INFO_OK_WITH_TEXT_ID, tmpBuf);
                return 0;
            }

            char tmpBuf[128];
            uint16_t charCnt = BufferToHexString(tmpBuf, 128, Buffer, (BitCount + 7) / 8);
    a0ae:	29 5f       	subi	r18, 0xF9	; 249
    a0b0:	3f 4f       	sbci	r19, 0xFF	; 255
    a0b2:	b3 e0       	ldi	r27, 0x03	; 3
    a0b4:	36 95       	lsr	r19
    a0b6:	27 95       	ror	r18
    a0b8:	ba 95       	dec	r27
    a0ba:	e1 f7       	brne	.-8      	; 0xa0b4 <Reader14443AAppProcess+0x260>
    a0bc:	a7 01       	movw	r20, r14
    a0be:	60 e8       	ldi	r22, 0x80	; 128
    a0c0:	70 e0       	ldi	r23, 0x00	; 0
    a0c2:	ce 01       	movw	r24, r28
    a0c4:	01 96       	adiw	r24, 0x01	; 1
    a0c6:	0e 94 f8 0e 	call	0x1df0	; 0x1df0 <BufferToHexString>
    a0ca:	7c 01       	movw	r14, r24
            uint8_t count[2] = {(BitCount>>8)&0xFF, BitCount&0xFF};
    a0cc:	cf 5b       	subi	r28, 0xBF	; 191
    a0ce:	dd 4f       	sbci	r29, 0xFD	; 253
    a0d0:	88 81       	ld	r24, Y
    a0d2:	c1 54       	subi	r28, 0x41	; 65
    a0d4:	d2 40       	sbci	r29, 0x02	; 2
    a0d6:	ce 5b       	subi	r28, 0xBE	; 190
    a0d8:	dd 4f       	sbci	r29, 0xFD	; 253
    a0da:	98 81       	ld	r25, Y
    a0dc:	c2 54       	subi	r28, 0x42	; 66
    a0de:	d2 40       	sbci	r29, 0x02	; 2
    a0e0:	cf 5f       	subi	r28, 0xFF	; 255
    a0e2:	dd 4f       	sbci	r29, 0xFD	; 253
    a0e4:	98 83       	st	Y, r25
    a0e6:	c1 50       	subi	r28, 0x01	; 1
    a0e8:	d2 40       	sbci	r29, 0x02	; 2
    a0ea:	ce 5f       	subi	r28, 0xFE	; 254
    a0ec:	dd 4f       	sbci	r29, 0xFD	; 253
    a0ee:	88 83       	st	Y, r24
    a0f0:	c2 50       	subi	r28, 0x02	; 2
    a0f2:	d2 40       	sbci	r29, 0x02	; 2
            charCnt += snprintf(tmpBuf + charCnt, 128 - charCnt, "\r\n");
    a0f4:	8f ed       	ldi	r24, 0xDF	; 223
    a0f6:	93 e2       	ldi	r25, 0x23	; 35
    a0f8:	9f 93       	push	r25
    a0fa:	8f 93       	push	r24
    a0fc:	80 e8       	ldi	r24, 0x80	; 128
    a0fe:	c8 2e       	mov	r12, r24
    a100:	d1 2c       	mov	r13, r1
    a102:	c6 01       	movw	r24, r12
    a104:	8e 19       	sub	r24, r14
    a106:	9f 09       	sbc	r25, r15
    a108:	9f 93       	push	r25
    a10a:	8f 93       	push	r24
    a10c:	81 e0       	ldi	r24, 0x01	; 1
    a10e:	90 e0       	ldi	r25, 0x00	; 0
    a110:	8c 0f       	add	r24, r28
    a112:	9d 1f       	adc	r25, r29
    a114:	8e 0d       	add	r24, r14
    a116:	9f 1d       	adc	r25, r15
    a118:	9f 93       	push	r25
    a11a:	8f 93       	push	r24
    a11c:	0e 94 1a 66 	call	0xcc34	; 0xcc34 <snprintf>
    a120:	8e 0d       	add	r24, r14
    a122:	9f 1d       	adc	r25, r15
            charCnt += BufferToHexString(tmpBuf + charCnt, 128 - charCnt, count, 2);
    a124:	b6 01       	movw	r22, r12
    a126:	68 1b       	sub	r22, r24
    a128:	79 0b       	sbc	r23, r25
    a12a:	22 e0       	ldi	r18, 0x02	; 2
    a12c:	30 e0       	ldi	r19, 0x00	; 0
    a12e:	ae 01       	movw	r20, r28
    a130:	4f 5f       	subi	r20, 0xFF	; 255
    a132:	5d 4f       	sbci	r21, 0xFD	; 253
    a134:	a1 e0       	ldi	r26, 0x01	; 1
    a136:	b0 e0       	ldi	r27, 0x00	; 0
    a138:	ac 0f       	add	r26, r28
    a13a:	bd 1f       	adc	r27, r29
    a13c:	8a 0f       	add	r24, r26
    a13e:	9b 1f       	adc	r25, r27
    a140:	0e 94 f8 0e 	call	0x1df0	; 0x1df0 <BufferToHexString>
            Reader14443CurrentCommand = Reader14443_Do_Nothing;
    a144:	10 92 e5 2c 	sts	0x2CE5, r1
            CommandLinePendingTaskFinished(COMMAND_INFO_OK_WITH_TEXT_ID, tmpBuf);
    a148:	be 01       	movw	r22, r28
    a14a:	6f 5f       	subi	r22, 0xFF	; 255
    a14c:	7f 4f       	sbci	r23, 0xFF	; 255
    a14e:	85 e6       	ldi	r24, 0x65	; 101
    a150:	0e 94 4d 23 	call	0x469a	; 0x469a <CommandLinePendingTaskFinished>
            return 0;
    a154:	0f 90       	pop	r0
    a156:	0f 90       	pop	r0
    a158:	0f 90       	pop	r0
    a15a:	0f 90       	pop	r0
    a15c:	0f 90       	pop	r0
    a15e:	0f 90       	pop	r0
    a160:	72 c3       	rjmp	.+1764   	; 0xa846 <Reader14443AAppProcess+0x9f2>
        }

        case Reader14443_Get_UID:
        {
            uint16_t rVal = Reader14443A_Select(Buffer, BitCount);
    a162:	cf 5b       	subi	r28, 0xBF	; 191
    a164:	dd 4f       	sbci	r29, 0xFD	; 253
    a166:	68 81       	ld	r22, Y
    a168:	79 81       	ldd	r23, Y+1	; 0x01
    a16a:	c1 54       	subi	r28, 0x41	; 65
    a16c:	d2 40       	sbci	r29, 0x02	; 2
    a16e:	c7 01       	movw	r24, r14
    a170:	e5 db       	rcall	.-2102   	; 0x993c <Reader14443A_Select>
            if (Selected) // we are done finding the UID
    a172:	20 91 c0 2d 	lds	r18, 0x2DC0
    a176:	22 23       	and	r18, r18
    a178:	09 f4       	brne	.+2      	; 0xa17c <Reader14443AAppProcess+0x328>
    a17a:	28 c3       	rjmp	.+1616   	; 0xa7cc <Reader14443AAppProcess+0x978>
            {
                char tmpBuf[20];
                BufferToHexString(tmpBuf, 20, CardCharacteristics.UID, CardCharacteristics.UIDSize);
    a17c:	20 91 be 2d 	lds	r18, 0x2DBE
    a180:	30 e0       	ldi	r19, 0x00	; 0
    a182:	44 eb       	ldi	r20, 0xB4	; 180
    a184:	5d e2       	ldi	r21, 0x2D	; 45
    a186:	64 e1       	ldi	r22, 0x14	; 20
    a188:	70 e0       	ldi	r23, 0x00	; 0
    a18a:	ce 01       	movw	r24, r28
    a18c:	01 96       	adiw	r24, 0x01	; 1
    a18e:	0e 94 f8 0e 	call	0x1df0	; 0x1df0 <BufferToHexString>
                CommandLinePendingTaskFinished(COMMAND_INFO_OK_WITH_TEXT_ID, tmpBuf);
    a192:	be 01       	movw	r22, r28
    a194:	6f 5f       	subi	r22, 0xFF	; 255
    a196:	7f 4f       	sbci	r23, 0xFF	; 255
    a198:	85 e6       	ldi	r24, 0x65	; 101
    a19a:	0e 94 4d 23 	call	0x469a	; 0x469a <CommandLinePendingTaskFinished>
                Selected = false;
    a19e:	10 92 c0 2d 	sts	0x2DC0, r1
                Reader14443CurrentCommand = Reader14443_Do_Nothing;
    a1a2:	10 92 e5 2c 	sts	0x2CE5, r1
                CodecReaderFieldStop();
    a1a6:	0e 94 e4 23 	call	0x47c8	; 0x47c8 <CodecReaderFieldStop>
    a1aa:	0d c3       	rjmp	.+1562   	; 0xa7c6 <Reader14443AAppProcess+0x972>
                RT_STATE_SEARCHING
            } RTState = RT_STATE_IDLE;
            static uint8_t TryCount = 0;
            static uint8_t Thresholds[(CODEC_THRESHOLD_CALIBRATE_MAX - CODEC_THRESHOLD_CALIBRATE_MIN) / CODEC_THRESHOLD_CALIBRATE_STEPS] = {0};

            if (RTState == RT_STATE_IDLE)
    a1ac:	80 91 a0 2d 	lds	r24, 0x2DA0
    a1b0:	81 11       	cpse	r24, r1
    a1b2:	08 c0       	rjmp	.+16     	; 0xa1c4 <Reader14443AAppProcess+0x370>
            {
                CodecThresholdSet(CODEC_THRESHOLD_CALIBRATE_MIN);
    a1b4:	80 e8       	ldi	r24, 0x80	; 128
    a1b6:	90 e0       	ldi	r25, 0x00	; 0
    a1b8:	0e 94 38 24 	call	0x4870	; 0x4870 <CodecThresholdSet>
                RTState = RT_STATE_SEARCHING;
    a1bc:	81 e0       	ldi	r24, 0x01	; 1
    a1be:	80 93 a0 2d 	sts	0x2DA0, r24
    a1c2:	7d c0       	rjmp	.+250    	; 0xa2be <Reader14443AAppProcess+0x46a>
                TryCount = 0;
            } else if (RTState == RT_STATE_SEARCHING && ReaderState <= STATE_HALT) {
    a1c4:	81 30       	cpi	r24, 0x01	; 1
    a1c6:	09 f0       	breq	.+2      	; 0xa1ca <Reader14443AAppProcess+0x376>
    a1c8:	7c c0       	rjmp	.+248    	; 0xa2c2 <Reader14443AAppProcess+0x46e>
    a1ca:	80 91 bf 2d 	lds	r24, 0x2DBF
    a1ce:	82 30       	cpi	r24, 0x02	; 2
    a1d0:	08 f0       	brcs	.+2      	; 0xa1d4 <Reader14443AAppProcess+0x380>
    a1d2:	77 c0       	rjmp	.+238    	; 0xa2c2 <Reader14443AAppProcess+0x46e>
                if (++TryCount == TRYCOUNT_MAX)
    a1d4:	80 91 9f 2d 	lds	r24, 0x2D9F
    a1d8:	8f 5f       	subi	r24, 0xFF	; 255
    a1da:	80 93 9f 2d 	sts	0x2D9F, r24
    a1de:	80 31       	cpi	r24, 0x10	; 16
    a1e0:	09 f0       	breq	.+2      	; 0xa1e4 <Reader14443AAppProcess+0x390>
    a1e2:	6f c0       	rjmp	.+222    	; 0xa2c2 <Reader14443AAppProcess+0x46e>
                {
                    uint16_t tmp_th = CodecThresholdIncrement();
    a1e4:	0e 94 43 24 	call	0x4886	; 0x4886 <CodecThresholdIncrement>
    a1e8:	8c 01       	movw	r16, r24
                    if ((tmp_th >= CODEC_THRESHOLD_CALIBRATE_MID && (tmp_th - CODEC_THRESHOLD_CALIBRATE_STEPS) < CODEC_THRESHOLD_CALIBRATE_MID)
    a1ea:	93 50       	subi	r25, 0x03	; 3
    a1ec:	40 97       	sbiw	r24, 0x10	; 16
    a1ee:	68 f0       	brcs	.+26     	; 0xa20a <Reader14443AAppProcess+0x3b6>
                        ||
    a1f0:	01 15       	cp	r16, r1
    a1f2:	b8 e0       	ldi	r27, 0x08	; 8
    a1f4:	1b 07       	cpc	r17, r27
    a1f6:	08 f4       	brcc	.+2      	; 0xa1fa <Reader14443AAppProcess+0x3a6>
    a1f8:	62 c0       	rjmp	.+196    	; 0xa2be <Reader14443AAppProcess+0x46a>
    a1fa:	60 e1       	ldi	r22, 0x10	; 16
    a1fc:	70 e0       	ldi	r23, 0x00	; 0
    a1fe:	e0 e0       	ldi	r30, 0x00	; 0
    a200:	f0 e0       	ldi	r31, 0x00	; 0
    a202:	a1 2c       	mov	r10, r1
    a204:	b1 2c       	mov	r11, r1
    a206:	90 e0       	ldi	r25, 0x00	; 0
    a208:	42 c0       	rjmp	.+132    	; 0xa28e <Reader14443AAppProcess+0x43a>
    a20a:	a7 e2       	ldi	r26, 0x27	; 39
    a20c:	bd e2       	ldi	r27, 0x2D	; 45
                TryCount = 0;
            } else if (RTState == RT_STATE_SEARCHING && ReaderState <= STATE_HALT) {
                if (++TryCount == TRYCOUNT_MAX)
                {
                    uint16_t tmp_th = CodecThresholdIncrement();
                    if ((tmp_th >= CODEC_THRESHOLD_CALIBRATE_MID && (tmp_th - CODEC_THRESHOLD_CALIBRATE_STEPS) < CODEC_THRESHOLD_CALIBRATE_MID)
    a20e:	40 e0       	ldi	r20, 0x00	; 0
    a210:	50 e0       	ldi	r21, 0x00	; 0
    a212:	e0 e0       	ldi	r30, 0x00	; 0
    a214:	f0 e0       	ldi	r31, 0x00	; 0
    a216:	20 e0       	ldi	r18, 0x00	; 0
    a218:	30 e0       	ldi	r19, 0x00	; 0
    a21a:	60 e0       	ldi	r22, 0x00	; 0
    a21c:	70 e0       	ldi	r23, 0x00	; 0
    a21e:	90 e0       	ldi	r25, 0x00	; 0
                        // first, search inside the usual search space
                        if (tmp_th >= CODEC_THRESHOLD_CALIBRATE_MID && (tmp_th - CODEC_THRESHOLD_CALIBRATE_STEPS) < CODEC_THRESHOLD_CALIBRATE_MID)
                        {
                            for (i = 0; i < (CODEC_THRESHOLD_CALIBRATE_MID - CODEC_THRESHOLD_CALIBRATE_MIN) / CODEC_THRESHOLD_CALIBRATE_STEPS; i++)
                            {
                                if (Thresholds[i] == TRYCOUNT_MAX && i < ((CODEC_THRESHOLD_CALIBRATE_MID - CODEC_THRESHOLD_CALIBRATE_MIN) / CODEC_THRESHOLD_CALIBRATE_STEPS - 1))
    a220:	8d 91       	ld	r24, X+
    a222:	80 31       	cpi	r24, 0x10	; 16
    a224:	49 f4       	brne	.+18     	; 0xa238 <Reader14443AAppProcess+0x3e4>
    a226:	47 32       	cpi	r20, 0x27	; 39
    a228:	51 05       	cpc	r21, r1
    a22a:	09 f4       	brne	.+2      	; 0xa22e <Reader14443AAppProcess+0x3da>
    a22c:	09 c3       	rjmp	.+1554   	; 0xa840 <Reader14443AAppProcess+0x9ec>
                                {
                                    if (!block)
    a22e:	91 11       	cpse	r25, r1
    a230:	0e c0       	rjmp	.+28     	; 0xa24e <Reader14443AAppProcess+0x3fa>
    a232:	ba 01       	movw	r22, r20
                                    {
                                        block = true;
    a234:	91 e0       	ldi	r25, 0x01	; 1
    a236:	0b c0       	rjmp	.+22     	; 0xa24e <Reader14443AAppProcess+0x3fa>
                                        min = i;
                                    }
                                } else {
                                    if (block)
    a238:	99 23       	and	r25, r25
    a23a:	49 f0       	breq	.+18     	; 0xa24e <Reader14443AAppProcess+0x3fa>
                                    {
                                        block = false;
                                        max = i;
                                        if ((max - min) >= maxdiff)
    a23c:	ca 01       	movw	r24, r20
    a23e:	86 1b       	sub	r24, r22
    a240:	97 0b       	sbc	r25, r23
    a242:	82 17       	cp	r24, r18
    a244:	93 07       	cpc	r25, r19
    a246:	10 f0       	brcs	.+4      	; 0xa24c <Reader14443AAppProcess+0x3f8>
    a248:	fb 01       	movw	r30, r22
    a24a:	9c 01       	movw	r18, r24
                                        min = i;
                                    }
                                } else {
                                    if (block)
                                    {
                                        block = false;
    a24c:	90 e0       	ldi	r25, 0x00	; 0
                        uint16_t i;

                        // first, search inside the usual search space
                        if (tmp_th >= CODEC_THRESHOLD_CALIBRATE_MID && (tmp_th - CODEC_THRESHOLD_CALIBRATE_STEPS) < CODEC_THRESHOLD_CALIBRATE_MID)
                        {
                            for (i = 0; i < (CODEC_THRESHOLD_CALIBRATE_MID - CODEC_THRESHOLD_CALIBRATE_MIN) / CODEC_THRESHOLD_CALIBRATE_STEPS; i++)
    a24e:	4f 5f       	subi	r20, 0xFF	; 255
    a250:	5f 4f       	sbci	r21, 0xFF	; 255
    a252:	48 32       	cpi	r20, 0x28	; 40
    a254:	51 05       	cpc	r21, r1
    a256:	21 f7       	brne	.-56     	; 0xa220 <Reader14443AAppProcess+0x3cc>
                                            maxdiffoffset = min;
                                        }
                                    }
                                }
                            }
                            if (maxdiff >= 4) // if we have found something with at least 5 consecutive working thresholds (only if these thresholds have worked for evers attempt), we are done
    a258:	24 30       	cpi	r18, 0x04	; 4
    a25a:	31 05       	cpc	r19, r1
    a25c:	08 f0       	brcs	.+2      	; 0xa260 <Reader14443AAppProcess+0x40c>
    a25e:	3d c2       	rjmp	.+1146   	; 0xa6da <Reader14443AAppProcess+0x886>
    a260:	2e c0       	rjmp	.+92     	; 0xa2be <Reader14443AAppProcess+0x46a>
                        } else { // we have searched the whole space
                            for (numworked = TRYCOUNT_MAX; numworked > 0; numworked--)
                            {
                                for (i = 0; i < (CODEC_THRESHOLD_CALIBRATE_MAX - CODEC_THRESHOLD_CALIBRATE_MIN) / CODEC_THRESHOLD_CALIBRATE_STEPS; i++)
                                {
                                    if (Thresholds[i] >= numworked)
    a262:	d6 01       	movw	r26, r12
    a264:	ed 90       	ld	r14, X+
    a266:	6d 01       	movw	r12, r26
    a268:	f1 2c       	mov	r15, r1
    a26a:	e6 16       	cp	r14, r22
    a26c:	f7 06       	cpc	r15, r23
    a26e:	c0 f4       	brcc	.+48     	; 0xa2a0 <Reader14443AAppProcess+0x44c>
                                        {
                                            block = true;
                                            min = i;
                                        }
                                    } else {
                                        if (block)
    a270:	91 11       	cpse	r25, r1
    a272:	1b c0       	rjmp	.+54     	; 0xa2aa <Reader14443AAppProcess+0x456>
                                finished = true;
                            }
                        } else { // we have searched the whole space
                            for (numworked = TRYCOUNT_MAX; numworked > 0; numworked--)
                            {
                                for (i = 0; i < (CODEC_THRESHOLD_CALIBRATE_MAX - CODEC_THRESHOLD_CALIBRATE_MIN) / CODEC_THRESHOLD_CALIBRATE_STEPS; i++)
    a274:	4f 5f       	subi	r20, 0xFF	; 255
    a276:	5f 4f       	sbci	r21, 0xFF	; 255
    a278:	48 37       	cpi	r20, 0x78	; 120
    a27a:	51 05       	cpc	r21, r1
    a27c:	91 f7       	brne	.-28     	; 0xa262 <Reader14443AAppProcess+0x40e>
                                                maxdiffoffset = min;
                                            }
                                        }
                                    }
                                }
                                if (maxdiff > 0)
    a27e:	21 15       	cp	r18, r1
    a280:	31 05       	cpc	r19, r1
    a282:	09 f0       	breq	.+2      	; 0xa286 <Reader14443AAppProcess+0x432>
    a284:	2a c2       	rjmp	.+1108   	; 0xa6da <Reader14443AAppProcess+0x886>
    a286:	61 50       	subi	r22, 0x01	; 1
    a288:	71 09       	sbc	r23, r1
                            if (maxdiff >= 4) // if we have found something with at least 5 consecutive working thresholds (only if these thresholds have worked for evers attempt), we are done
                            {
                                finished = true;
                            }
                        } else { // we have searched the whole space
                            for (numworked = TRYCOUNT_MAX; numworked > 0; numworked--)
    a28a:	09 f4       	brne	.+2      	; 0xa28e <Reader14443AAppProcess+0x43a>
    a28c:	26 c2       	rjmp	.+1100   	; 0xa6da <Reader14443AAppProcess+0x886>
    a28e:	a7 e2       	ldi	r26, 0x27	; 39
    a290:	ca 2e       	mov	r12, r26
    a292:	ad e2       	ldi	r26, 0x2D	; 45
    a294:	da 2e       	mov	r13, r26
                                        min = i;
                                    }
                                } else {
                                    if (block)
                                    {
                                        block = false;
    a296:	40 e0       	ldi	r20, 0x00	; 0
    a298:	50 e0       	ldi	r21, 0x00	; 0
    a29a:	20 e0       	ldi	r18, 0x00	; 0
    a29c:	30 e0       	ldi	r19, 0x00	; 0
    a29e:	e1 cf       	rjmp	.-62     	; 0xa262 <Reader14443AAppProcess+0x40e>
                            {
                                for (i = 0; i < (CODEC_THRESHOLD_CALIBRATE_MAX - CODEC_THRESHOLD_CALIBRATE_MIN) / CODEC_THRESHOLD_CALIBRATE_STEPS; i++)
                                {
                                    if (Thresholds[i] >= numworked)
                                    {
                                        if (!block)
    a2a0:	91 11       	cpse	r25, r1
    a2a2:	e8 cf       	rjmp	.-48     	; 0xa274 <Reader14443AAppProcess+0x420>
    a2a4:	5a 01       	movw	r10, r20
                                        {
                                            block = true;
    a2a6:	91 e0       	ldi	r25, 0x01	; 1
    a2a8:	e5 cf       	rjmp	.-54     	; 0xa274 <Reader14443AAppProcess+0x420>
                                    } else {
                                        if (block)
                                        {
                                            block = false;
                                            max = i;
                                            if ((max - min) >= maxdiff)
    a2aa:	ca 01       	movw	r24, r20
    a2ac:	8a 19       	sub	r24, r10
    a2ae:	9b 09       	sbc	r25, r11
    a2b0:	82 17       	cp	r24, r18
    a2b2:	93 07       	cpc	r25, r19
    a2b4:	10 f0       	brcs	.+4      	; 0xa2ba <Reader14443AAppProcess+0x466>
    a2b6:	f5 01       	movw	r30, r10
    a2b8:	9c 01       	movw	r18, r24
                                            min = i;
                                        }
                                    } else {
                                        if (block)
                                        {
                                            block = false;
    a2ba:	90 e0       	ldi	r25, 0x00	; 0
    a2bc:	db cf       	rjmp	.-74     	; 0xa274 <Reader14443AAppProcess+0x420>
                            Reader14443CurrentCommand = Reader14443_Do_Nothing;
                            Reader14443ACodecReset();
                            return 0;
                        }
                    }
                    TryCount = 0;
    a2be:	10 92 9f 2d 	sts	0x2D9F, r1
                }
            }

            uint16_t rVal = Reader14443A_Select(Buffer, BitCount);
    a2c2:	cf 5b       	subi	r28, 0xBF	; 191
    a2c4:	dd 4f       	sbci	r29, 0xFD	; 253
    a2c6:	68 81       	ld	r22, Y
    a2c8:	79 81       	ldd	r23, Y+1	; 0x01
    a2ca:	c1 54       	subi	r28, 0x41	; 65
    a2cc:	d2 40       	sbci	r29, 0x02	; 2
    a2ce:	c7 01       	movw	r24, r14
    a2d0:	35 db       	rcall	.-2454   	; 0x993c <Reader14443A_Select>
            if (Selected) // we are done finding the threshold
    a2d2:	20 91 c0 2d 	lds	r18, 0x2DC0
    a2d6:	22 23       	and	r18, r18
    a2d8:	09 f4       	brne	.+2      	; 0xa2dc <Reader14443AAppProcess+0x488>
    a2da:	78 c2       	rjmp	.+1264   	; 0xa7cc <Reader14443AAppProcess+0x978>
            {
                Thresholds[(GlobalSettings.ActiveSettingPtr->ReaderThreshold - CODEC_THRESHOLD_CALIBRATE_MIN) / CODEC_THRESHOLD_CALIBRATE_STEPS] += 1;
    a2dc:	e0 91 71 2f 	lds	r30, 0x2F71
    a2e0:	f0 91 72 2f 	lds	r31, 0x2F72
    a2e4:	02 84       	ldd	r0, Z+10	; 0x0a
    a2e6:	f3 85       	ldd	r31, Z+11	; 0x0b
    a2e8:	e0 2d       	mov	r30, r0
    a2ea:	e0 58       	subi	r30, 0x80	; 128
    a2ec:	f1 09       	sbc	r31, r1
    a2ee:	54 e0       	ldi	r21, 0x04	; 4
    a2f0:	f6 95       	lsr	r31
    a2f2:	e7 95       	ror	r30
    a2f4:	5a 95       	dec	r21
    a2f6:	e1 f7       	brne	.-8      	; 0xa2f0 <Reader14443AAppProcess+0x49c>
    a2f8:	e9 5d       	subi	r30, 0xD9	; 217
    a2fa:	f2 4d       	sbci	r31, 0xD2	; 210
    a2fc:	80 81       	ld	r24, Z
    a2fe:	8f 5f       	subi	r24, 0xFF	; 255
    a300:	80 83       	st	Z, r24
                if (TryCount == TRYCOUNT_MAX)
    a302:	80 91 9f 2d 	lds	r24, 0x2D9F
    a306:	80 31       	cpi	r24, 0x10	; 16
    a308:	21 f4       	brne	.+8      	; 0xa312 <Reader14443AAppProcess+0x4be>
                {
                    CodecThresholdIncrement();
    a30a:	0e 94 43 24 	call	0x4886	; 0x4886 <CodecThresholdIncrement>
                    TryCount = 0;
    a30e:	10 92 9f 2d 	sts	0x2D9F, r1
                }
                ReaderState = STATE_IDLE;
    a312:	10 92 bf 2d 	sts	0x2DBF, r1
                Reader14443ACodecStart();
    a316:	0e 94 cd 2c 	call	0x599a	; 0x599a <Reader14443ACodecStart>
    }
}

INLINE uint16_t Reader14443A_Halt(uint8_t* Buffer)
{
    Buffer[0] = ISO14443A_CMD_HLTA;
    a31a:	80 e5       	ldi	r24, 0x50	; 80
    a31c:	f7 01       	movw	r30, r14
    a31e:	80 83       	st	Z, r24
    Buffer[1] = 0x00;
    a320:	11 82       	std	Z+1, r1	; 0x01
    ISO14443AAppendCRCA(Buffer, 2);
    a322:	62 e0       	ldi	r22, 0x02	; 2
    a324:	70 e0       	ldi	r23, 0x00	; 0
    a326:	c7 01       	movw	r24, r14
    a328:	0e 94 63 3d 	call	0x7ac6	; 0x7ac6 <ISO14443AAppendCRCA>
    ReaderState = STATE_HALT;
    a32c:	81 e0       	ldi	r24, 0x01	; 1
    a32e:	80 93 bf 2d 	sts	0x2DBF, r24
    Selected = false;
    a332:	10 92 c0 2d 	sts	0x2DC0, r1
    return addParityBits(Buffer, 4 * BITS_PER_BYTE);
    a336:	60 e2       	ldi	r22, 0x20	; 32
    a338:	70 e0       	ldi	r23, 0x00	; 0
    a33a:	c7 01       	movw	r24, r14
    a33c:	a0 d9       	rcall	.-3264   	; 0x967e <addParityBits>
    a33e:	8c 01       	movw	r16, r24
                    CodecThresholdIncrement();
                    TryCount = 0;
                }
                ReaderState = STATE_IDLE;
                Reader14443ACodecStart();
                return Reader14443A_Halt(Buffer);
    a340:	82 c2       	rjmp	.+1284   	; 0xa846 <Reader14443AAppProcess+0x9f2>
        case Reader14443_Read_MF_Ultralight:
        {
            static uint8_t MFURead_CurrentAdress = 0;
            static uint8_t MFUContents[64];

            uint16_t rVal = Reader14443A_Select(Buffer, BitCount);
    a342:	cf 5b       	subi	r28, 0xBF	; 191
    a344:	dd 4f       	sbci	r29, 0xFD	; 253
    a346:	68 81       	ld	r22, Y
    a348:	79 81       	ldd	r23, Y+1	; 0x01
    a34a:	c1 54       	subi	r28, 0x41	; 65
    a34c:	d2 40       	sbci	r29, 0x02	; 2
    a34e:	c7 01       	movw	r24, r14
    a350:	f5 da       	rcall	.-2582   	; 0x993c <Reader14443A_Select>
            if (Selected)
    a352:	20 91 c0 2d 	lds	r18, 0x2DC0
    a356:	22 23       	and	r18, r18
    a358:	09 f4       	brne	.+2      	; 0xa35c <Reader14443AAppProcess+0x508>
    a35a:	38 c2       	rjmp	.+1136   	; 0xa7cc <Reader14443AAppProcess+0x978>
            {
                if (MFURead_CurrentAdress != 0)
    a35c:	d0 90 26 2d 	lds	r13, 0x2D26
    a360:	dd 20       	and	r13, r13
    a362:	09 f4       	brne	.+2      	; 0xa366 <Reader14443AAppProcess+0x512>
    a364:	46 c0       	rjmp	.+140    	; 0xa3f2 <Reader14443AAppProcess+0x59e>
                {
                    if (BitCount == 0) // relaunch select protocol
    a366:	cf 5b       	subi	r28, 0xBF	; 191
    a368:	dd 4f       	sbci	r29, 0xFD	; 253
    a36a:	08 81       	ld	r16, Y
    a36c:	19 81       	ldd	r17, Y+1	; 0x01
    a36e:	c1 54       	subi	r28, 0x41	; 65
    a370:	d2 40       	sbci	r29, 0x02	; 2
    a372:	01 15       	cp	r16, r1
    a374:	11 05       	cpc	r17, r1
    a376:	49 f4       	brne	.+18     	; 0xa38a <Reader14443AAppProcess+0x536>
                    {
                        MFURead_CurrentAdress = 0; // reset read address
    a378:	10 92 26 2d 	sts	0x2D26, r1
                        Selected = false;
    a37c:	10 92 c0 2d 	sts	0x2DC0, r1
                        ReaderState = STATE_IDLE;
    a380:	10 92 bf 2d 	sts	0x2DBF, r1
                        Reader14443ACodecStart();
    a384:	0e 94 cd 2c 	call	0x599a	; 0x599a <Reader14443ACodecStart>
                        return 0;
    a388:	5e c2       	rjmp	.+1212   	; 0xa846 <Reader14443AAppProcess+0x9f2>
                    }
                    bool readPageAgain = (BitCount < 162) || !checkParityBits(Buffer, BitCount);
    a38a:	02 3a       	cpi	r16, 0xA2	; 162
    a38c:	11 05       	cpc	r17, r1
    a38e:	40 f0       	brcs	.+16     	; 0xa3a0 <Reader14443AAppProcess+0x54c>
    a390:	b8 01       	movw	r22, r16
    a392:	c7 01       	movw	r24, r14
    a394:	45 da       	rcall	.-2934   	; 0x9820 <checkParityBits>
    a396:	01 e0       	ldi	r16, 0x01	; 1
    a398:	80 27       	eor	r24, r16
    a39a:	08 2f       	mov	r16, r24
    a39c:	10 e0       	ldi	r17, 0x00	; 0
    a39e:	02 c0       	rjmp	.+4      	; 0xa3a4 <Reader14443AAppProcess+0x550>
    a3a0:	01 e0       	ldi	r16, 0x01	; 1
    a3a2:	10 e0       	ldi	r17, 0x00	; 0
                    BitCount = removeParityBits(Buffer, BitCount);
    a3a4:	cf 5b       	subi	r28, 0xBF	; 191
    a3a6:	dd 4f       	sbci	r29, 0xFD	; 253
    a3a8:	68 81       	ld	r22, Y
    a3aa:	79 81       	ldd	r23, Y+1	; 0x01
    a3ac:	c1 54       	subi	r28, 0x41	; 65
    a3ae:	d2 40       	sbci	r29, 0x02	; 2
    a3b0:	c7 01       	movw	r24, r14
    a3b2:	e8 d9       	rcall	.-3120   	; 0x9784 <removeParityBits>
    a3b4:	cf 5b       	subi	r28, 0xBF	; 191
    a3b6:	dd 4f       	sbci	r29, 0xFD	; 253
    a3b8:	88 83       	st	Y, r24
    a3ba:	99 83       	std	Y+1, r25	; 0x01
    a3bc:	c1 54       	subi	r28, 0x41	; 65
    a3be:	d2 40       	sbci	r29, 0x02	; 2
                    if (readPageAgain || ISO14443_CRCA(Buffer, 18)) // the CRC function should return 0 if everything is ok
    a3c0:	01 2b       	or	r16, r17
    a3c2:	29 f4       	brne	.+10     	; 0xa3ce <Reader14443AAppProcess+0x57a>
    a3c4:	62 e1       	ldi	r22, 0x12	; 18
    a3c6:	c7 01       	movw	r24, r14
    a3c8:	95 da       	rcall	.-2774   	; 0x98f4 <ISO14443_CRCA>
    a3ca:	89 2b       	or	r24, r25
    a3cc:	29 f0       	breq	.+10     	; 0xa3d8 <Reader14443AAppProcess+0x584>
                    {
                        MFURead_CurrentAdress -= 4;
    a3ce:	ac ef       	ldi	r26, 0xFC	; 252
    a3d0:	ad 0d       	add	r26, r13
    a3d2:	a0 93 26 2d 	sts	0x2D26, r26
    a3d6:	2a c0       	rjmp	.+84     	; 0xa42c <Reader14443AAppProcess+0x5d8>
                    } else { // everything is ok for this page
                        memcpy(MFUContents + (MFURead_CurrentAdress - 4) * 4, Buffer, 16);
    a3d8:	f4 e0       	ldi	r31, 0x04	; 4
    a3da:	df 9e       	mul	r13, r31
    a3dc:	d0 01       	movw	r26, r0
    a3de:	11 24       	eor	r1, r1
    a3e0:	aa 52       	subi	r26, 0x2A	; 42
    a3e2:	b3 4d       	sbci	r27, 0xD3	; 211
    a3e4:	80 e1       	ldi	r24, 0x10	; 16
    a3e6:	f7 01       	movw	r30, r14
    a3e8:	01 90       	ld	r0, Z+
    a3ea:	0d 92       	st	X+, r0
    a3ec:	8a 95       	dec	r24
    a3ee:	e1 f7       	brne	.-8      	; 0xa3e8 <Reader14443AAppProcess+0x594>
    a3f0:	1d c0       	rjmp	.+58     	; 0xa42c <Reader14443AAppProcess+0x5d8>
                    }
                } else {
                    uint16_t RefATQA;
                    memcpy_P(&RefATQA, &CardIdentificationList[CardType_NXP_MIFARE_Ultralight].ATQA, 2);
    a3f2:	42 e0       	ldi	r20, 0x02	; 2
    a3f4:	50 e0       	ldi	r21, 0x00	; 0
    a3f6:	61 e2       	ldi	r22, 0x21	; 33
    a3f8:	73 e1       	ldi	r23, 0x13	; 19
    a3fa:	ce 01       	movw	r24, r28
    a3fc:	01 96       	adiw	r24, 0x01	; 1
    a3fe:	0e 94 b9 65 	call	0xcb72	; 0xcb72 <memcpy_P>
                    uint8_t RefSAK = pgm_read_byte(&CardIdentificationList[CardType_NXP_MIFARE_Ultralight].SAK);
    a402:	e4 e2       	ldi	r30, 0x24	; 36
    a404:	f3 e1       	ldi	r31, 0x13	; 19
    a406:	e4 91       	lpm	r30, Z
                    if (CardCharacteristics.ATQA != RefATQA || CardCharacteristics.SAK != RefSAK) // seems to be no MiFare Ultralight card, so retry
    a408:	20 91 b1 2d 	lds	r18, 0x2DB1
    a40c:	30 91 b2 2d 	lds	r19, 0x2DB2
    a410:	89 81       	ldd	r24, Y+1	; 0x01
    a412:	9a 81       	ldd	r25, Y+2	; 0x02
    a414:	28 17       	cp	r18, r24
    a416:	39 07       	cpc	r19, r25
    a418:	21 f4       	brne	.+8      	; 0xa422 <Reader14443AAppProcess+0x5ce>
    a41a:	80 91 b3 2d 	lds	r24, 0x2DB3
    a41e:	8e 17       	cp	r24, r30
    a420:	29 f0       	breq	.+10     	; 0xa42c <Reader14443AAppProcess+0x5d8>
                    {
                        ReaderState = STATE_IDLE;
    a422:	10 92 bf 2d 	sts	0x2DBF, r1
                        Reader14443ACodecStart();
    a426:	0e 94 cd 2c 	call	0x599a	; 0x599a <Reader14443ACodecStart>
    a42a:	cd c1       	rjmp	.+922    	; 0xa7c6 <Reader14443AAppProcess+0x972>
                        return 0;
                    }
                }
                if (MFURead_CurrentAdress == 16)
    a42c:	80 91 26 2d 	lds	r24, 0x2D26
    a430:	80 31       	cpi	r24, 0x10	; 16
    a432:	09 f0       	breq	.+2      	; 0xa436 <Reader14443AAppProcess+0x5e2>
    a434:	4d c0       	rjmp	.+154    	; 0xa4d0 <Reader14443AAppProcess+0x67c>
                {
                    Selected = false;
    a436:	10 92 c0 2d 	sts	0x2DC0, r1
                    MFURead_CurrentAdress = 0;
    a43a:	10 92 26 2d 	sts	0x2D26, r1
                    Reader14443CurrentCommand = Reader14443_Do_Nothing;
    a43e:	10 92 e5 2c 	sts	0x2CE5, r1

                    char tmpBuf[135]; // 135 = 128 hex digits + 3 * \r\n + \0
                    BufferToHexString(	tmpBuf, 							135, 							MFUContents, 16);
    a442:	20 e1       	ldi	r18, 0x10	; 16
    a444:	30 e0       	ldi	r19, 0x00	; 0
    a446:	46 ee       	ldi	r20, 0xE6	; 230
    a448:	5c e2       	ldi	r21, 0x2C	; 44
    a44a:	67 e8       	ldi	r22, 0x87	; 135
    a44c:	70 e0       	ldi	r23, 0x00	; 0
    a44e:	ce 01       	movw	r24, r28
    a450:	01 96       	adiw	r24, 0x01	; 1
    a452:	0e 94 f8 0e 	call	0x1df0	; 0x1df0 <BufferToHexString>
                    snprintf(			tmpBuf + 32, 						135 - 32, 						"\r\n");
    a456:	6f ed       	ldi	r22, 0xDF	; 223
    a458:	73 e2       	ldi	r23, 0x23	; 35
    a45a:	ce 01       	movw	r24, r28
    a45c:	81 96       	adiw	r24, 0x21	; 33
    a45e:	0e 94 13 66 	call	0xcc26	; 0xcc26 <strcpy>
                    BufferToHexString(	tmpBuf + 32 + 2, 					135 - 32 - 2, 					MFUContents + 16, 16);
    a462:	20 e1       	ldi	r18, 0x10	; 16
    a464:	30 e0       	ldi	r19, 0x00	; 0
    a466:	46 ef       	ldi	r20, 0xF6	; 246
    a468:	5c e2       	ldi	r21, 0x2C	; 44
    a46a:	65 e6       	ldi	r22, 0x65	; 101
    a46c:	70 e0       	ldi	r23, 0x00	; 0
    a46e:	ce 01       	movw	r24, r28
    a470:	83 96       	adiw	r24, 0x23	; 35
    a472:	0e 94 f8 0e 	call	0x1df0	; 0x1df0 <BufferToHexString>
                    snprintf(			tmpBuf + 32 + 2 + 32, 				135 - 32 - 2 - 32, 				"\r\n");
    a476:	6f ed       	ldi	r22, 0xDF	; 223
    a478:	73 e2       	ldi	r23, 0x23	; 35
    a47a:	ce 01       	movw	r24, r28
    a47c:	8d 5b       	subi	r24, 0xBD	; 189
    a47e:	9f 4f       	sbci	r25, 0xFF	; 255
    a480:	0e 94 13 66 	call	0xcc26	; 0xcc26 <strcpy>
                    BufferToHexString(	tmpBuf + 32 + 2 + 32 + 2, 			135 - 32 - 2 - 32 - 2, 			MFUContents + 32, 16);
    a484:	20 e1       	ldi	r18, 0x10	; 16
    a486:	30 e0       	ldi	r19, 0x00	; 0
    a488:	46 e0       	ldi	r20, 0x06	; 6
    a48a:	5d e2       	ldi	r21, 0x2D	; 45
    a48c:	63 e4       	ldi	r22, 0x43	; 67
    a48e:	70 e0       	ldi	r23, 0x00	; 0
    a490:	ce 01       	movw	r24, r28
    a492:	8b 5b       	subi	r24, 0xBB	; 187
    a494:	9f 4f       	sbci	r25, 0xFF	; 255
    a496:	0e 94 f8 0e 	call	0x1df0	; 0x1df0 <BufferToHexString>
                    snprintf(			tmpBuf + 32 + 2 + 32 + 2 + 32, 		135 - 32 - 2 - 32 - 2 - 32, 	"\r\n");
    a49a:	6f ed       	ldi	r22, 0xDF	; 223
    a49c:	73 e2       	ldi	r23, 0x23	; 35
    a49e:	ce 01       	movw	r24, r28
    a4a0:	8b 59       	subi	r24, 0x9B	; 155
    a4a2:	9f 4f       	sbci	r25, 0xFF	; 255
    a4a4:	0e 94 13 66 	call	0xcc26	; 0xcc26 <strcpy>
                    BufferToHexString(	tmpBuf + 32 + 2 + 32 + 2 + 32 + 2, 	135 - 32 - 2 - 32 - 2 - 32 - 2, MFUContents + 48, 16);
    a4a8:	20 e1       	ldi	r18, 0x10	; 16
    a4aa:	30 e0       	ldi	r19, 0x00	; 0
    a4ac:	46 e1       	ldi	r20, 0x16	; 22
    a4ae:	5d e2       	ldi	r21, 0x2D	; 45
    a4b0:	61 e2       	ldi	r22, 0x21	; 33
    a4b2:	70 e0       	ldi	r23, 0x00	; 0
    a4b4:	ce 01       	movw	r24, r28
    a4b6:	89 59       	subi	r24, 0x99	; 153
    a4b8:	9f 4f       	sbci	r25, 0xFF	; 255
    a4ba:	0e 94 f8 0e 	call	0x1df0	; 0x1df0 <BufferToHexString>
                    CodecReaderFieldStop();
    a4be:	0e 94 e4 23 	call	0x47c8	; 0x47c8 <CodecReaderFieldStop>
                    CommandLinePendingTaskFinished(COMMAND_INFO_OK_WITH_TEXT_ID, tmpBuf);
    a4c2:	be 01       	movw	r22, r28
    a4c4:	6f 5f       	subi	r22, 0xFF	; 255
    a4c6:	7f 4f       	sbci	r23, 0xFF	; 255
    a4c8:	85 e6       	ldi	r24, 0x65	; 101
    a4ca:	0e 94 4d 23 	call	0x469a	; 0x469a <CommandLinePendingTaskFinished>
    a4ce:	7b c1       	rjmp	.+758    	; 0xa7c6 <Reader14443AAppProcess+0x972>
                    return 0;
                }
                Buffer[0] = 0x30; // MiFare Ultralight read command
    a4d0:	90 e3       	ldi	r25, 0x30	; 48
    a4d2:	d7 01       	movw	r26, r14
    a4d4:	9c 93       	st	X, r25
                Buffer[1] = MFURead_CurrentAdress;
    a4d6:	11 96       	adiw	r26, 0x01	; 1
    a4d8:	8c 93       	st	X, r24
                ISO14443AAppendCRCA(Buffer, 2);
    a4da:	62 e0       	ldi	r22, 0x02	; 2
    a4dc:	70 e0       	ldi	r23, 0x00	; 0
    a4de:	c7 01       	movw	r24, r14
    a4e0:	0e 94 63 3d 	call	0x7ac6	; 0x7ac6 <ISO14443AAppendCRCA>

                MFURead_CurrentAdress += 4;
    a4e4:	80 91 26 2d 	lds	r24, 0x2D26
    a4e8:	8c 5f       	subi	r24, 0xFC	; 252
    a4ea:	80 93 26 2d 	sts	0x2D26, r24
    a4ee:	23 cf       	rjmp	.-442    	; 0xa336 <Reader14443AAppProcess+0x4e2>
        /************************************
         * This function identifies a PICC. *
         ************************************/
        case Reader14443_Identify:
        {
            if (Identify(Buffer, &BitCount))
    a4f0:	be 01       	movw	r22, r28
    a4f2:	6f 5b       	subi	r22, 0xBF	; 191
    a4f4:	7d 4f       	sbci	r23, 0xFD	; 253
    a4f6:	c7 01       	movw	r24, r14
    a4f8:	38 db       	rcall	.-2448   	; 0x9b6a <Identify>
    a4fa:	88 23       	and	r24, r24
    a4fc:	09 f4       	brne	.+2      	; 0xa500 <Reader14443AAppProcess+0x6ac>
    a4fe:	e6 c0       	rjmp	.+460    	; 0xa6cc <Reader14443AAppProcess+0x878>
            {
                if (CardCandidatesIdx == 0)
    a500:	80 91 a1 2d 	lds	r24, 0x2DA1
    a504:	81 11       	cpse	r24, r1
    a506:	03 c0       	rjmp	.+6      	; 0xa50e <Reader14443AAppProcess+0x6ba>
                {
                    CommandLinePendingTaskFinished(COMMAND_INFO_OK_WITH_TEXT_ID, "Unknown card type.");
    a508:	67 e0       	ldi	r22, 0x07	; 7
    a50a:	74 e2       	ldi	r23, 0x24	; 36
    a50c:	13 c0       	rjmp	.+38     	; 0xa534 <Reader14443AAppProcess+0x6e0>
                } else if (CardCandidatesIdx == 1) {
    a50e:	81 30       	cpi	r24, 0x01	; 1
    a510:	a9 f4       	brne	.+42     	; 0xa53c <Reader14443AAppProcess+0x6e8>
                    char tmpType[64];
                    memcpy_P(tmpType, &CardIdentificationList[CardCandidates[0]].Type, 64);
    a512:	60 91 a2 2d 	lds	r22, 0x2DA2
    a516:	b7 e6       	ldi	r27, 0x67	; 103
    a518:	6b 9f       	mul	r22, r27
    a51a:	b0 01       	movw	r22, r0
    a51c:	11 24       	eor	r1, r1
    a51e:	6d 5e       	subi	r22, 0xED	; 237
    a520:	7d 4e       	sbci	r23, 0xED	; 237
    a522:	40 e4       	ldi	r20, 0x40	; 64
    a524:	50 e0       	ldi	r21, 0x00	; 0
    a526:	ce 01       	movw	r24, r28
    a528:	01 96       	adiw	r24, 0x01	; 1
    a52a:	0e 94 b9 65 	call	0xcb72	; 0xcb72 <memcpy_P>
                    CommandLinePendingTaskFinished(COMMAND_INFO_OK_WITH_TEXT_ID, tmpType);
    a52e:	be 01       	movw	r22, r28
    a530:	6f 5f       	subi	r22, 0xFF	; 255
    a532:	7f 4f       	sbci	r23, 0xFF	; 255
    a534:	85 e6       	ldi	r24, 0x65	; 101
    a536:	0e 94 4d 23 	call	0x469a	; 0x469a <CommandLinePendingTaskFinished>
    a53a:	68 c0       	rjmp	.+208    	; 0xa60c <Reader14443AAppProcess+0x7b8>
    a53c:	91 2c       	mov	r9, r1
    a53e:	80 e0       	ldi	r24, 0x00	; 0
    a540:	90 e0       	ldi	r25, 0x00	; 0
    a542:	00 e0       	ldi	r16, 0x00	; 0
    a544:	10 e0       	ldi	r17, 0x00	; 0
                    for (i = 0; i < CardCandidatesIdx; i++)
                    {
                        if (size <= TERMINAL_BUFFER_SIZE) // prevents buffer overflow
                        {
                            char tmpType[64];
                            memcpy_P(tmpType, &CardIdentificationList[CardCandidates[i]].Type, 64);
    a546:	27 e6       	ldi	r18, 0x67	; 103
    a548:	82 2e       	mov	r8, r18
    a54a:	7e 01       	movw	r14, r28
    a54c:	3f ef       	ldi	r19, 0xFF	; 255
    a54e:	e3 1a       	sub	r14, r19
    a550:	3d ef       	ldi	r19, 0xFD	; 253
    a552:	f3 0a       	sbc	r15, r19
                            tmpsize = snprintf(tmpBuf + size, TERMINAL_BUFFER_SIZE - size, "%s or ", tmpType);
    a554:	3a e1       	ldi	r19, 0x1A	; 26
    a556:	a3 2e       	mov	r10, r19
    a558:	34 e2       	ldi	r19, 0x24	; 36
    a55a:	b3 2e       	mov	r11, r19
    a55c:	c1 2c       	mov	r12, r1
    a55e:	42 e0       	ldi	r20, 0x02	; 2
    a560:	d4 2e       	mov	r13, r20
                    char tmpBuf[TERMINAL_BUFFER_SIZE];
                    uint16_t size = 0, tmpsize = 0;
                    bool enoughspace = true;

                    uint8_t i;
                    for (i = 0; i < CardCandidatesIdx; i++)
    a562:	20 91 a1 2d 	lds	r18, 0x2DA1
    a566:	92 16       	cp	r9, r18
    a568:	80 f5       	brcc	.+96     	; 0xa5ca <Reader14443AAppProcess+0x776>
                    {
                        if (size <= TERMINAL_BUFFER_SIZE) // prevents buffer overflow
    a56a:	01 30       	cpi	r16, 0x01	; 1
    a56c:	e2 e0       	ldi	r30, 0x02	; 2
    a56e:	1e 07       	cpc	r17, r30
    a570:	20 f0       	brcs	.+8      	; 0xa57a <Reader14443AAppProcess+0x726>
                            break;
                        }
                    }
                    if (size > TERMINAL_BUFFER_SIZE)
                    {
                        size -= tmpsize;
    a572:	08 1b       	sub	r16, r24
    a574:	19 0b       	sbc	r17, r25
                        enoughspace = false;
    a576:	f1 2c       	mov	r15, r1
    a578:	2e c0       	rjmp	.+92     	; 0xa5d6 <Reader14443AAppProcess+0x782>
                    for (i = 0; i < CardCandidatesIdx; i++)
                    {
                        if (size <= TERMINAL_BUFFER_SIZE) // prevents buffer overflow
                        {
                            char tmpType[64];
                            memcpy_P(tmpType, &CardIdentificationList[CardCandidates[i]].Type, 64);
    a57a:	e9 2d       	mov	r30, r9
    a57c:	f0 e0       	ldi	r31, 0x00	; 0
    a57e:	ee 55       	subi	r30, 0x5E	; 94
    a580:	f2 4d       	sbci	r31, 0xD2	; 210
    a582:	60 81       	ld	r22, Z
    a584:	86 9e       	mul	r8, r22
    a586:	b0 01       	movw	r22, r0
    a588:	11 24       	eor	r1, r1
    a58a:	6d 5e       	subi	r22, 0xED	; 237
    a58c:	7d 4e       	sbci	r23, 0xED	; 237
    a58e:	40 e4       	ldi	r20, 0x40	; 64
    a590:	50 e0       	ldi	r21, 0x00	; 0
    a592:	c7 01       	movw	r24, r14
    a594:	0e 94 b9 65 	call	0xcb72	; 0xcb72 <memcpy_P>
                            tmpsize = snprintf(tmpBuf + size, TERMINAL_BUFFER_SIZE - size, "%s or ", tmpType);
    a598:	ff 92       	push	r15
    a59a:	ef 92       	push	r14
    a59c:	bf 92       	push	r11
    a59e:	af 92       	push	r10
    a5a0:	c6 01       	movw	r24, r12
    a5a2:	80 1b       	sub	r24, r16
    a5a4:	91 0b       	sbc	r25, r17
    a5a6:	9f 93       	push	r25
    a5a8:	8f 93       	push	r24
    a5aa:	81 e0       	ldi	r24, 0x01	; 1
    a5ac:	90 e0       	ldi	r25, 0x00	; 0
    a5ae:	8c 0f       	add	r24, r28
    a5b0:	9d 1f       	adc	r25, r29
    a5b2:	80 0f       	add	r24, r16
    a5b4:	91 1f       	adc	r25, r17
    a5b6:	9f 93       	push	r25
    a5b8:	8f 93       	push	r24
    a5ba:	0e 94 1a 66 	call	0xcc34	; 0xcc34 <snprintf>
                            size += tmpsize;
    a5be:	08 0f       	add	r16, r24
    a5c0:	19 1f       	adc	r17, r25
                    char tmpBuf[TERMINAL_BUFFER_SIZE];
                    uint16_t size = 0, tmpsize = 0;
                    bool enoughspace = true;

                    uint8_t i;
                    for (i = 0; i < CardCandidatesIdx; i++)
    a5c2:	93 94       	inc	r9
    a5c4:	cd bf       	out	0x3d, r28	; 61
    a5c6:	de bf       	out	0x3e, r29	; 62
    a5c8:	cc cf       	rjmp	.-104    	; 0xa562 <Reader14443AAppProcess+0x70e>
                            size += tmpsize;
                        } else {
                            break;
                        }
                    }
                    if (size > TERMINAL_BUFFER_SIZE)
    a5ca:	01 30       	cpi	r16, 0x01	; 1
    a5cc:	a2 e0       	ldi	r26, 0x02	; 2
    a5ce:	1a 07       	cpc	r17, r26
    a5d0:	80 f6       	brcc	.-96     	; 0xa572 <Reader14443AAppProcess+0x71e>
                    memcpy_P(tmpType, &CardIdentificationList[CardCandidates[0]].Type, 64);
                    CommandLinePendingTaskFinished(COMMAND_INFO_OK_WITH_TEXT_ID, tmpType);
                } else {
                    char tmpBuf[TERMINAL_BUFFER_SIZE];
                    uint16_t size = 0, tmpsize = 0;
                    bool enoughspace = true;
    a5d2:	ff 24       	eor	r15, r15
    a5d4:	f3 94       	inc	r15
                    if (size > TERMINAL_BUFFER_SIZE)
                    {
                        size -= tmpsize;
                        enoughspace = false;
                    }
                    tmpBuf[size-4] = '.';
    a5d6:	ed ef       	ldi	r30, 0xFD	; 253
    a5d8:	ff ef       	ldi	r31, 0xFF	; 255
    a5da:	ec 0f       	add	r30, r28
    a5dc:	fd 1f       	adc	r31, r29
    a5de:	e0 0f       	add	r30, r16
    a5e0:	f1 1f       	adc	r31, r17
    a5e2:	8e e2       	ldi	r24, 0x2E	; 46
    a5e4:	80 83       	st	Z, r24
                    tmpBuf[size-3] = '\0';
    a5e6:	ee ef       	ldi	r30, 0xFE	; 254
    a5e8:	ff ef       	ldi	r31, 0xFF	; 255
    a5ea:	ec 0f       	add	r30, r28
    a5ec:	fd 1f       	adc	r31, r29
    a5ee:	e0 0f       	add	r30, r16
    a5f0:	f1 1f       	adc	r31, r17
    a5f2:	10 82       	st	Z, r1
                    CommandLinePendingTaskFinished(COMMAND_INFO_OK_WITH_TEXT_ID, tmpBuf);
    a5f4:	be 01       	movw	r22, r28
    a5f6:	6f 5f       	subi	r22, 0xFF	; 255
    a5f8:	7f 4f       	sbci	r23, 0xFF	; 255
    a5fa:	85 e6       	ldi	r24, 0x65	; 101
    a5fc:	0e 94 4d 23 	call	0x469a	; 0x469a <CommandLinePendingTaskFinished>
                    if (!enoughspace)
    a600:	f1 10       	cpse	r15, r1
    a602:	04 c0       	rjmp	.+8      	; 0xa60c <Reader14443AAppProcess+0x7b8>
                        TerminalSendStringP(PSTR("There is at least one more card type candidate, but there was not enough terminal buffer space.\r\n"));
    a604:	87 e8       	ldi	r24, 0x87	; 135
    a606:	91 e1       	ldi	r25, 0x11	; 17
    a608:	0e 94 a8 19 	call	0x3350	; 0x3350 <TerminalSendStringP>
                }
                // print general data
                TerminalSendStringP(PSTR("ATQA:\t"));
    a60c:	80 e8       	ldi	r24, 0x80	; 128
    a60e:	91 e1       	ldi	r25, 0x11	; 17
    a610:	0e 94 a8 19 	call	0x3350	; 0x3350 <TerminalSendStringP>
                CommandLineAppendData(&CardCharacteristics.ATQA, 2);
    a614:	62 e0       	ldi	r22, 0x02	; 2
    a616:	70 e0       	ldi	r23, 0x00	; 0
    a618:	81 eb       	ldi	r24, 0xB1	; 177
    a61a:	9d e2       	ldi	r25, 0x2D	; 45
    a61c:	0e 94 6b 23 	call	0x46d6	; 0x46d6 <CommandLineAppendData>
                TerminalSendStringP(PSTR("UID:\t"));
    a620:	8a e7       	ldi	r24, 0x7A	; 122
    a622:	91 e1       	ldi	r25, 0x11	; 17
    a624:	0e 94 a8 19 	call	0x3350	; 0x3350 <TerminalSendStringP>
                CommandLineAppendData(CardCharacteristics.UID, CardCharacteristics.UIDSize);
    a628:	60 91 be 2d 	lds	r22, 0x2DBE
    a62c:	70 e0       	ldi	r23, 0x00	; 0
    a62e:	84 eb       	ldi	r24, 0xB4	; 180
    a630:	9d e2       	ldi	r25, 0x2D	; 45
    a632:	0e 94 6b 23 	call	0x46d6	; 0x46d6 <CommandLineAppendData>
                TerminalSendStringP(PSTR("SAK:\t"));
    a636:	84 e7       	ldi	r24, 0x74	; 116
    a638:	91 e1       	ldi	r25, 0x11	; 17
    a63a:	0e 94 a8 19 	call	0x3350	; 0x3350 <TerminalSendStringP>
                CommandLineAppendData(&CardCharacteristics.SAK, 1);
    a63e:	61 e0       	ldi	r22, 0x01	; 1
    a640:	70 e0       	ldi	r23, 0x00	; 0
    a642:	83 eb       	ldi	r24, 0xB3	; 179
    a644:	9d e2       	ldi	r25, 0x2D	; 45
    a646:	0e 94 6b 23 	call	0x46d6	; 0x46d6 <CommandLineAppendData>
    a64a:	37 c0       	rjmp	.+110    	; 0xa6ba <Reader14443AAppProcess+0x866>
            }
        }

        case Reader14443_Identify_Clone:
        {
        	if (Identify(Buffer, &BitCount))
    a64c:	be 01       	movw	r22, r28
    a64e:	6f 5b       	subi	r22, 0xBF	; 191
    a650:	7d 4f       	sbci	r23, 0xFD	; 253
    a652:	c7 01       	movw	r24, r14
    a654:	8a da       	rcall	.-2796   	; 0x9b6a <Identify>
    a656:	88 23       	and	r24, r24
    a658:	c9 f1       	breq	.+114    	; 0xa6cc <Reader14443AAppProcess+0x878>
        	{
				if (CardCandidatesIdx == 1)
    a65a:	80 91 a1 2d 	lds	r24, 0x2DA1
    a65e:	81 30       	cpi	r24, 0x01	; 1
    a660:	39 f5       	brne	.+78     	; 0xa6b0 <Reader14443AAppProcess+0x85c>
				{
					int cfgid = -1;
					switch (CardCandidates[0])
    a662:	80 91 a2 2d 	lds	r24, 0x2DA2
    a666:	83 30       	cpi	r24, 0x03	; 3
    a668:	09 f4       	brne	.+2      	; 0xa66c <Reader14443AAppProcess+0x818>
    a66a:	bf c0       	rjmp	.+382    	; 0xa7ea <Reader14443AAppProcess+0x996>
    a66c:	28 f4       	brcc	.+10     	; 0xa678 <Reader14443AAppProcess+0x824>
    a66e:	81 30       	cpi	r24, 0x01	; 1
    a670:	59 f0       	breq	.+22     	; 0xa688 <Reader14443AAppProcess+0x834>
    a672:	82 30       	cpi	r24, 0x02	; 2
    a674:	99 f0       	breq	.+38     	; 0xa69c <Reader14443AAppProcess+0x848>
    a676:	e1 c0       	rjmp	.+450    	; 0xa83a <Reader14443AAppProcess+0x9e6>
    a678:	8a 30       	cpi	r24, 0x0A	; 10
    a67a:	31 f0       	breq	.+12     	; 0xa688 <Reader14443AAppProcess+0x834>
    a67c:	08 f4       	brcc	.+2      	; 0xa680 <Reader14443AAppProcess+0x82c>
    a67e:	dd c0       	rjmp	.+442    	; 0xa83a <Reader14443AAppProcess+0x9e6>
    a680:	8d 50       	subi	r24, 0x0D	; 13
    a682:	82 30       	cpi	r24, 0x02	; 2
    a684:	58 f0       	brcs	.+22     	; 0xa69c <Reader14443AAppProcess+0x848>
    a686:	d9 c0       	rjmp	.+434    	; 0xa83a <Reader14443AAppProcess+0x9e6>
							break;
						}
						case CardType_NXP_MIFARE_Classic_1k:
						case CardType_Infineon_MIFARE_Classic_1k:
						{
							if (CardCharacteristics.UIDSize == UIDSize_Single)
    a688:	80 91 be 2d 	lds	r24, 0x2DBE
    a68c:	84 30       	cpi	r24, 0x04	; 4
    a68e:	09 f4       	brne	.+2      	; 0xa692 <Reader14443AAppProcess+0x83e>
    a690:	ae c0       	rjmp	.+348    	; 0xa7ee <Reader14443AAppProcess+0x99a>
							{
								cfgid = CONFIG_MF_CLASSIC_1K;
							} else if (CardCharacteristics.UIDSize == UIDSize_Double) {
    a692:	87 30       	cpi	r24, 0x07	; 7
    a694:	09 f0       	breq	.+2      	; 0xa698 <Reader14443AAppProcess+0x844>
    a696:	d1 c0       	rjmp	.+418    	; 0xa83a <Reader14443AAppProcess+0x9e6>
								cfgid = CONFIG_MF_CLASSIC_1K_7B;
    a698:	15 e0       	ldi	r17, 0x05	; 5
    a69a:	ac c0       	rjmp	.+344    	; 0xa7f4 <Reader14443AAppProcess+0x9a0>
						}
						case CardType_NXP_MIFARE_Classic_4k:
						case CardType_Nokia_MIFARE_Classic_4k_emulated_6212:
						case CardType_Nokia_MIFARE_Classic_4k_emulated_6131:
						{
							if (CardCharacteristics.UIDSize == UIDSize_Single)
    a69c:	80 91 be 2d 	lds	r24, 0x2DBE
    a6a0:	84 30       	cpi	r24, 0x04	; 4
    a6a2:	09 f4       	brne	.+2      	; 0xa6a6 <Reader14443AAppProcess+0x852>
    a6a4:	a6 c0       	rjmp	.+332    	; 0xa7f2 <Reader14443AAppProcess+0x99e>
							{
								cfgid = CONFIG_MF_CLASSIC_4K;
							} else if (CardCharacteristics.UIDSize == UIDSize_Double) {
    a6a6:	87 30       	cpi	r24, 0x07	; 7
    a6a8:	09 f0       	breq	.+2      	; 0xa6ac <Reader14443AAppProcess+0x858>
    a6aa:	c7 c0       	rjmp	.+398    	; 0xa83a <Reader14443AAppProcess+0x9e6>
								cfgid = CONFIG_MF_CLASSIC_4K_7B;
    a6ac:	17 e0       	ldi	r17, 0x07	; 7
    a6ae:	a2 c0       	rjmp	.+324    	; 0xa7f4 <Reader14443AAppProcess+0x9a0>
						SettingsSave();
					} else {
						CommandLinePendingTaskFinished(COMMAND_INFO_OK_WITH_TEXT_ID, "Clone unsupported!");
					}
				} else {
					CommandLinePendingTaskFinished(COMMAND_INFO_OK_WITH_TEXT_ID, "Multiple possibilities, not clonable!");
    a6b0:	61 e2       	ldi	r22, 0x21	; 33
    a6b2:	74 e2       	ldi	r23, 0x24	; 36
    a6b4:	85 e6       	ldi	r24, 0x65	; 101
    a6b6:	0e 94 4d 23 	call	0x469a	; 0x469a <CommandLinePendingTaskFinished>
				}
				Reader14443CurrentCommand = Reader14443_Do_Nothing;
    a6ba:	10 92 e5 2c 	sts	0x2CE5, r1
				CardCandidatesIdx = 0;
    a6be:	10 92 a1 2d 	sts	0x2DA1, r1
				CodecReaderFieldStop();
    a6c2:	0e 94 e4 23 	call	0x47c8	; 0x47c8 <CodecReaderFieldStop>
				Selected = false;
    a6c6:	10 92 c0 2d 	sts	0x2DC0, r1
    a6ca:	7d c0       	rjmp	.+250    	; 0xa7c6 <Reader14443AAppProcess+0x972>
				return 0;
			} else {
				return BitCount;
    a6cc:	cf 5b       	subi	r28, 0xBF	; 191
    a6ce:	dd 4f       	sbci	r29, 0xFD	; 253
    a6d0:	08 81       	ld	r16, Y
    a6d2:	19 81       	ldd	r17, Y+1	; 0x01
    a6d4:	c1 54       	subi	r28, 0x41	; 65
    a6d6:	d2 40       	sbci	r29, 0x02	; 2
    a6d8:	b6 c0       	rjmp	.+364    	; 0xa846 <Reader14443AAppProcess+0x9f2>
                        }

                        if (finished)
                        {

                            RTState = RT_STATE_IDLE;
    a6da:	10 92 a0 2d 	sts	0x2DA0, r1

                            if (maxdiff != 0)
    a6de:	21 15       	cp	r18, r1
    a6e0:	31 05       	cpc	r19, r1
    a6e2:	09 f4       	brne	.+2      	; 0xa6e6 <Reader14443AAppProcess+0x892>
    a6e4:	75 c0       	rjmp	.+234    	; 0xa7d0 <Reader14443AAppProcess+0x97c>
    a6e6:	cf 01       	movw	r24, r30
    a6e8:	08 96       	adiw	r24, 0x08	; 8
                                CodecThresholdSet((maxdiffoffset + maxdiff / 2) * CODEC_THRESHOLD_CALIBRATE_STEPS + CODEC_THRESHOLD_CALIBRATE_MIN);
    a6ea:	36 95       	lsr	r19
    a6ec:	27 95       	ror	r18
    a6ee:	82 0f       	add	r24, r18
    a6f0:	93 1f       	adc	r25, r19
    a6f2:	54 e0       	ldi	r21, 0x04	; 4
    a6f4:	88 0f       	add	r24, r24
    a6f6:	99 1f       	adc	r25, r25
    a6f8:	5a 95       	dec	r21
    a6fa:	e1 f7       	brne	.-8      	; 0xa6f4 <Reader14443AAppProcess+0x8a0>
    a6fc:	0e 94 38 24 	call	0x4870	; 0x4870 <CodecThresholdSet>
                            else
                                CodecThresholdReset();
                            SETTING_UPDATE(GlobalSettings.ActiveSettingPtr->ReaderThreshold);
    a700:	e0 91 71 2f 	lds	r30, 0x2F71
    a704:	f0 91 72 2f 	lds	r31, 0x2F72
    case 1:
        eeprom_update_byte((uint8_t *)EEAddr, *(uint8_t*)addr);
        break;

    case 2:
        eeprom_update_word((uint16_t *)EEAddr, *(uint16_t*)addr);
    a708:	62 85       	ldd	r22, Z+10	; 0x0a
    a70a:	73 85       	ldd	r23, Z+11	; 0x0b
    a70c:	cf 01       	movw	r24, r30
    a70e:	86 56       	subi	r24, 0x66	; 102
    a710:	9f 42       	sbci	r25, 0x2F	; 47
    a712:	8f 5f       	subi	r24, 0xFF	; 255
    a714:	9f 4f       	sbci	r25, 0xFF	; 255
    a716:	0e 94 7c 6c 	call	0xd8f8	; 0xd8f8 <eeprom_update_word>

                            CommandLinePendingTaskFinished(COMMAND_INFO_OK_WITH_TEXT_ID, NULL);
    a71a:	60 e0       	ldi	r22, 0x00	; 0
    a71c:	70 e0       	ldi	r23, 0x00	; 0
    a71e:	85 e6       	ldi	r24, 0x65	; 101
    a720:	0e 94 4d 23 	call	0x469a	; 0x469a <CommandLinePendingTaskFinished>
                            uint16_t i_max = (CODEC_THRESHOLD_CALIBRATE_MID - CODEC_THRESHOLD_CALIBRATE_MIN) / CODEC_THRESHOLD_CALIBRATE_STEPS;
                            if (tmp_th >= CODEC_THRESHOLD_CALIBRATE_MAX)
    a724:	01 15       	cp	r16, r1
    a726:	18 40       	sbci	r17, 0x08	; 8
    a728:	08 f4       	brcc	.+2      	; 0xa72c <Reader14443AAppProcess+0x8d8>
    a72a:	55 c0       	rjmp	.+170    	; 0xa7d6 <Reader14443AAppProcess+0x982>
                                i_max = (CODEC_THRESHOLD_CALIBRATE_MAX - CODEC_THRESHOLD_CALIBRATE_MIN) / CODEC_THRESHOLD_CALIBRATE_STEPS;
    a72c:	b8 e7       	ldi	r27, 0x78	; 120
    a72e:	ab 2e       	mov	r10, r27
    a730:	b1 2c       	mov	r11, r1
    a732:	07 e2       	ldi	r16, 0x27	; 39
    a734:	1d e2       	ldi	r17, 0x2D	; 45
    a736:	60 e8       	ldi	r22, 0x80	; 128
    a738:	e6 2e       	mov	r14, r22
    a73a:	f1 2c       	mov	r15, r1
                            for (i = 0; i < i_max; i++)
                            {
                                char tmpBuf[10];
                                snprintf(tmpBuf, 10, "%4" PRIu16 ": ", i*CODEC_THRESHOLD_CALIBRATE_STEPS + CODEC_THRESHOLD_CALIBRATE_MIN);
    a73c:	7d ef       	ldi	r23, 0xFD	; 253
    a73e:	87 2e       	mov	r8, r23
    a740:	73 e2       	ldi	r23, 0x23	; 35
    a742:	97 2e       	mov	r9, r23
    a744:	ea e0       	ldi	r30, 0x0A	; 10
    a746:	5e 2e       	mov	r5, r30
    a748:	fe 01       	movw	r30, r28
    a74a:	31 96       	adiw	r30, 0x01	; 1
    a74c:	6f 01       	movw	r12, r30
                                TerminalSendString(tmpBuf);
                                if (Thresholds[i])
                                {
                                    snprintf(tmpBuf, 10, "%3" PRIu16, Thresholds[i]);
    a74e:	f3 e0       	ldi	r31, 0x03	; 3
    a750:	6f 2e       	mov	r6, r31
    a752:	f4 e2       	ldi	r31, 0x24	; 36
    a754:	7f 2e       	mov	r7, r31
                            if (tmp_th >= CODEC_THRESHOLD_CALIBRATE_MAX)
                                i_max = (CODEC_THRESHOLD_CALIBRATE_MAX - CODEC_THRESHOLD_CALIBRATE_MIN) / CODEC_THRESHOLD_CALIBRATE_STEPS;
                            for (i = 0; i < i_max; i++)
                            {
                                char tmpBuf[10];
                                snprintf(tmpBuf, 10, "%4" PRIu16 ": ", i*CODEC_THRESHOLD_CALIBRATE_STEPS + CODEC_THRESHOLD_CALIBRATE_MIN);
    a756:	ff 92       	push	r15
    a758:	ef 92       	push	r14
    a75a:	9f 92       	push	r9
    a75c:	8f 92       	push	r8
    a75e:	1f 92       	push	r1
    a760:	5f 92       	push	r5
    a762:	df 92       	push	r13
    a764:	cf 92       	push	r12
    a766:	0e 94 1a 66 	call	0xcc34	; 0xcc34 <snprintf>
                                TerminalSendString(tmpBuf);
    a76a:	c6 01       	movw	r24, r12
    a76c:	0e 94 a3 19 	call	0x3346	; 0x3346 <TerminalSendString>
                                if (Thresholds[i])
    a770:	d8 01       	movw	r26, r16
    a772:	8c 91       	ld	r24, X
    a774:	cd bf       	out	0x3d, r28	; 61
    a776:	de bf       	out	0x3e, r29	; 62
    a778:	88 23       	and	r24, r24
    a77a:	89 f1       	breq	.+98     	; 0xa7de <Reader14443AAppProcess+0x98a>
                                {
                                    snprintf(tmpBuf, 10, "%3" PRIu16, Thresholds[i]);
    a77c:	1f 92       	push	r1
    a77e:	8f 93       	push	r24
    a780:	7f 92       	push	r7
    a782:	6f 92       	push	r6
    a784:	1f 92       	push	r1
    a786:	5f 92       	push	r5
    a788:	df 92       	push	r13
    a78a:	cf 92       	push	r12
    a78c:	0e 94 1a 66 	call	0xcc34	; 0xcc34 <snprintf>
                                    TerminalSendString(tmpBuf);
    a790:	c6 01       	movw	r24, r12
    a792:	0e 94 a3 19 	call	0x3346	; 0x3346 <TerminalSendString>
    a796:	cd bf       	out	0x3d, r28	; 61
    a798:	de bf       	out	0x3e, r29	; 62
                                } else {
                                    TerminalSendChar('-');
                                }
                                TerminalSendStringP(PSTR("\r\n"));
    a79a:	89 ee       	ldi	r24, 0xE9	; 233
    a79c:	91 e1       	ldi	r25, 0x11	; 17
    a79e:	0e 94 a8 19 	call	0x3350	; 0x3350 <TerminalSendStringP>
                                Thresholds[i] = 0; // reset the threshold so the next run won't show old results
    a7a2:	d8 01       	movw	r26, r16
    a7a4:	1d 92       	st	X+, r1
    a7a6:	8d 01       	movw	r16, r26
    a7a8:	b0 e1       	ldi	r27, 0x10	; 16
    a7aa:	eb 0e       	add	r14, r27
    a7ac:	f1 1c       	adc	r15, r1
    a7ae:	c8 01       	movw	r24, r16
    a7b0:	87 52       	subi	r24, 0x27	; 39
    a7b2:	9d 42       	sbci	r25, 0x2D	; 45

                            CommandLinePendingTaskFinished(COMMAND_INFO_OK_WITH_TEXT_ID, NULL);
                            uint16_t i_max = (CODEC_THRESHOLD_CALIBRATE_MID - CODEC_THRESHOLD_CALIBRATE_MIN) / CODEC_THRESHOLD_CALIBRATE_STEPS;
                            if (tmp_th >= CODEC_THRESHOLD_CALIBRATE_MAX)
                                i_max = (CODEC_THRESHOLD_CALIBRATE_MAX - CODEC_THRESHOLD_CALIBRATE_MIN) / CODEC_THRESHOLD_CALIBRATE_STEPS;
                            for (i = 0; i < i_max; i++)
    a7b4:	8a 15       	cp	r24, r10
    a7b6:	9b 05       	cpc	r25, r11
    a7b8:	70 f2       	brcs	.-100    	; 0xa756 <Reader14443AAppProcess+0x902>
                                TerminalSendStringP(PSTR("\r\n"));
                                Thresholds[i] = 0; // reset the threshold so the next run won't show old results
                            }


                            Selected = false;
    a7ba:	10 92 c0 2d 	sts	0x2DC0, r1
                            Reader14443CurrentCommand = Reader14443_Do_Nothing;
    a7be:	10 92 e5 2c 	sts	0x2CE5, r1
                            Reader14443ACodecReset();
    a7c2:	0e 94 d4 2c 	call	0x59a8	; 0x59a8 <Reader14443ACodecReset>
			}
        	return 0;
        }

        default: // e.g. Do_Nothing
            return 0;
    a7c6:	00 e0       	ldi	r16, 0x00	; 0
    a7c8:	10 e0       	ldi	r17, 0x00	; 0
    a7ca:	3d c0       	rjmp	.+122    	; 0xa846 <Reader14443AAppProcess+0x9f2>

                MFURead_CurrentAdress += 4;

                return addParityBits(Buffer, 4 * BITS_PER_BYTE);
            }
            return rVal;
    a7cc:	8c 01       	movw	r16, r24
    a7ce:	3b c0       	rjmp	.+118    	; 0xa846 <Reader14443AAppProcess+0x9f2>
                            RTState = RT_STATE_IDLE;

                            if (maxdiff != 0)
                                CodecThresholdSet((maxdiffoffset + maxdiff / 2) * CODEC_THRESHOLD_CALIBRATE_STEPS + CODEC_THRESHOLD_CALIBRATE_MIN);
                            else
                                CodecThresholdReset();
    a7d0:	0e 94 53 24 	call	0x48a6	; 0x48a6 <CodecThresholdReset>
    a7d4:	95 cf       	rjmp	.-214    	; 0xa700 <Reader14443AAppProcess+0x8ac>
                            SETTING_UPDATE(GlobalSettings.ActiveSettingPtr->ReaderThreshold);

                            CommandLinePendingTaskFinished(COMMAND_INFO_OK_WITH_TEXT_ID, NULL);
                            uint16_t i_max = (CODEC_THRESHOLD_CALIBRATE_MID - CODEC_THRESHOLD_CALIBRATE_MIN) / CODEC_THRESHOLD_CALIBRATE_STEPS;
    a7d6:	a8 e2       	ldi	r26, 0x28	; 40
    a7d8:	aa 2e       	mov	r10, r26
    a7da:	b1 2c       	mov	r11, r1
    a7dc:	aa cf       	rjmp	.-172    	; 0xa732 <Reader14443AAppProcess+0x8de>
void EVENT_USB_Device_Connect(void);
void EVENT_USB_Device_Disconnect(void);
void EVENT_USB_Device_ConfigurationChanged(void);
void EVENT_USB_Device_ControlRequest(void);

INLINE void TerminalSendChar(char c) { CDC_Device_SendByte(&TerminalHandle, c); }
    a7de:	6d e2       	ldi	r22, 0x2D	; 45
    a7e0:	83 e0       	ldi	r24, 0x03	; 3
    a7e2:	90 e2       	ldi	r25, 0x20	; 32
    a7e4:	0e 94 bf 63 	call	0xc77e	; 0xc77e <CDC_Device_SendByte>
    a7e8:	d8 cf       	rjmp	.-80     	; 0xa79a <Reader14443AAppProcess+0x946>
					int cfgid = -1;
					switch (CardCandidates[0])
					{
						case CardType_NXP_MIFARE_Ultralight:
						{
							cfgid = CONFIG_MF_ULTRALIGHT;
    a7ea:	11 e0       	ldi	r17, 0x01	; 1
    a7ec:	03 c0       	rjmp	.+6      	; 0xa7f4 <Reader14443AAppProcess+0x9a0>
						case CardType_NXP_MIFARE_Classic_1k:
						case CardType_Infineon_MIFARE_Classic_1k:
						{
							if (CardCharacteristics.UIDSize == UIDSize_Single)
							{
								cfgid = CONFIG_MF_CLASSIC_1K;
    a7ee:	14 e0       	ldi	r17, 0x04	; 4
    a7f0:	01 c0       	rjmp	.+2      	; 0xa7f4 <Reader14443AAppProcess+0x9a0>
						case CardType_Nokia_MIFARE_Classic_4k_emulated_6212:
						case CardType_Nokia_MIFARE_Classic_4k_emulated_6131:
						{
							if (CardCharacteristics.UIDSize == UIDSize_Single)
							{
								cfgid = CONFIG_MF_CLASSIC_4K;
    a7f2:	16 e0       	ldi	r17, 0x06	; 6
							cfgid = -1;
					}

					if (cfgid > -1)
					{
						CommandLinePendingTaskFinished(COMMAND_INFO_OK_WITH_TEXT_ID, "Cloned OK!");
    a7f4:	67 e4       	ldi	r22, 0x47	; 71
    a7f6:	74 e2       	ldi	r23, 0x24	; 36
    a7f8:	85 e6       	ldi	r24, 0x65	; 101
    a7fa:	0e 94 4d 23 	call	0x469a	; 0x469a <CommandLinePendingTaskFinished>
						ConfigurationSetById(cfgid);
    a7fe:	81 2f       	mov	r24, r17
    a800:	0e 94 55 0e 	call	0x1caa	; 0x1caa <ConfigurationSetById>
    a804:	e0 91 5e 2f 	lds	r30, 0x2F5E
    a808:	f0 91 5f 2f 	lds	r31, 0x2F5F
    a80c:	19 95       	eicall
INLINE void ApplicationGetUid(ConfigurationUidType Uid) {
    ActiveConfiguration.ApplicationGetUidFunc(Uid);
}

INLINE void ApplicationSetUid(ConfigurationUidType Uid) {
    ActiveConfiguration.ApplicationSetUidFunc(Uid);
    a80e:	e0 91 68 2f 	lds	r30, 0x2F68
    a812:	f0 91 69 2f 	lds	r31, 0x2F69
    a816:	84 eb       	ldi	r24, 0xB4	; 180
    a818:	9d e2       	ldi	r25, 0x2D	; 45
    a81a:	19 95       	eicall
    a81c:	e0 91 6e 2f 	lds	r30, 0x2F6E
    a820:	f0 91 6f 2f 	lds	r31, 0x2F6F
    a824:	40 91 6c 2f 	lds	r20, 0x2F6C
    a828:	64 eb       	ldi	r22, 0xB4	; 180
    a82a:	7d e2       	ldi	r23, 0x2D	; 45
    a82c:	83 e1       	ldi	r24, 0x13	; 19
    a82e:	19 95       	eicall
						ApplicationReset();
						ApplicationSetUid(CardCharacteristics.UID);
						MemoryStore();
    a830:	0e 94 02 11 	call	0x2204	; 0x2204 <MemoryStore>
						SettingsSave();
    a834:	0e 94 9c 17 	call	0x2f38	; 0x2f38 <SettingsSave>
    a838:	40 cf       	rjmp	.-384    	; 0xa6ba <Reader14443AAppProcess+0x866>
					} else {
						CommandLinePendingTaskFinished(COMMAND_INFO_OK_WITH_TEXT_ID, "Clone unsupported!");
    a83a:	62 e5       	ldi	r22, 0x52	; 82
    a83c:	74 e2       	ldi	r23, 0x24	; 36
    a83e:	3a cf       	rjmp	.-396    	; 0xa6b4 <Reader14443AAppProcess+0x860>
                                    {
                                        block = true;
                                        min = i;
                                    }
                                } else {
                                    if (block)
    a840:	91 11       	cpse	r25, r1
    a842:	fc cc       	rjmp	.-1544   	; 0xa23c <Reader14443AAppProcess+0x3e8>
    a844:	09 cd       	rjmp	.-1518   	; 0xa258 <Reader14443AAppProcess+0x404>

        default: // e.g. Do_Nothing
            return 0;
    }
    return 0;
}
    a846:	c8 01       	movw	r24, r16
    a848:	ce 5b       	subi	r28, 0xBE	; 190
    a84a:	dd 4f       	sbci	r29, 0xFD	; 253
    a84c:	cd bf       	out	0x3d, r28	; 61
    a84e:	de bf       	out	0x3e, r29	; 62
    a850:	df 91       	pop	r29
    a852:	cf 91       	pop	r28
    a854:	1f 91       	pop	r17
    a856:	0f 91       	pop	r16
    a858:	ff 90       	pop	r15
    a85a:	ef 90       	pop	r14
    a85c:	df 90       	pop	r13
    a85e:	cf 90       	pop	r12
    a860:	bf 90       	pop	r11
    a862:	af 90       	pop	r10
    a864:	9f 90       	pop	r9
    a866:	8f 90       	pop	r8
    a868:	7f 90       	pop	r7
    a86a:	6f 90       	pop	r6
    a86c:	5f 90       	pop	r5
    a86e:	08 95       	ret

0000a870 <Sniff14443AAppInit>:
static uint16_t tmp_th = CODEC_THRESHOLD_CALIBRATE_MIN;
static uint8_t Thresholds[(CODEC_THRESHOLD_CALIBRATE_MAX - CODEC_THRESHOLD_CALIBRATE_MIN) /
                          CODEC_THRESHOLD_CALIBRATE_STEPS] = {0};

void Sniff14443AAppInit(void){
    SniffState = STATE_REQA;
    a870:	81 e0       	ldi	r24, 0x01	; 1
    a872:	80 93 3a 2e 	sts	0x2E3A, r24
    // Get current threshold and continue searching from here
    tmp_th = GlobalSettings.ActiveSettingPtr->ReaderThreshold;
    a876:	e0 91 71 2f 	lds	r30, 0x2F71
    a87a:	f0 91 72 2f 	lds	r31, 0x2F72
    a87e:	82 85       	ldd	r24, Z+10	; 0x0a
    a880:	93 85       	ldd	r25, Z+11	; 0x0b
    a882:	80 93 20 20 	sts	0x2020, r24
    a886:	90 93 21 20 	sts	0x2021, r25
    a88a:	08 95       	ret

0000a88c <Sniff14443AAppReset>:
}

void Sniff14443AAppReset(void){
    SniffState = STATE_IDLE;
    a88c:	10 92 3a 2e 	sts	0x2E3A, r1

    Sniff14443CurrentCommand = Sniff14443_Do_Nothing;
    a890:	10 92 c1 2d 	sts	0x2DC1, r1
    a894:	08 95       	ret

0000a896 <Sniff14443AAppTask>:
}
// Currently APPTask and AppTick is not being used
void Sniff14443AAppTask(void){/* Empty */}
    a896:	08 95       	ret

0000a898 <Sniff14443AAppTick>:
void Sniff14443AAppTick(void){/* Empty */}
    a898:	08 95       	ret

0000a89a <Sniff14443AAppTimeout>:

void Sniff14443AAppTimeout(void){
    Sniff14443AAppReset();
    a89a:	f8 cf       	rjmp	.-16     	; 0xa88c <Sniff14443AAppReset>

0000a89c <Sniff14443AAppProcess>:
    } else{
        // mark finish
        CommandLinePendingTaskFinished(COMMAND_INFO_FALSE, NULL);
    }
}
uint16_t Sniff14443AAppProcess(uint8_t* Buffer, uint16_t BitCount){
    a89c:	0f 93       	push	r16
    a89e:	1f 93       	push	r17
    a8a0:	cf 93       	push	r28
    a8a2:	df 93       	push	r29
    a8a4:	cd b7       	in	r28, 0x3d	; 61
    a8a6:	de b7       	in	r29, 0x3e	; 62
    a8a8:	2a 97       	sbiw	r28, 0x0a	; 10
    a8aa:	cd bf       	out	0x3d, r28	; 61
    a8ac:	de bf       	out	0x3e, r29	; 62
    switch (Sniff14443CurrentCommand){
    a8ae:	20 91 c1 2d 	lds	r18, 0x2DC1
    a8b2:	21 30       	cpi	r18, 0x01	; 1
    a8b4:	09 f0       	breq	.+2      	; 0xa8b8 <Sniff14443AAppProcess+0x1c>
    a8b6:	26 c1       	rjmp	.+588    	; 0xab04 <Sniff14443AAppProcess+0x268>
    a8b8:	8c 01       	movw	r16, r24
        case Sniff14443_Do_Nothing: {
            return 0;
        }
        case Sniff14443_Autocalibrate: {

            switch (SniffState) {
    a8ba:	80 91 3a 2e 	lds	r24, 0x2E3A
    a8be:	83 30       	cpi	r24, 0x03	; 3
    a8c0:	09 f4       	brne	.+2      	; 0xa8c4 <Sniff14443AAppProcess+0x28>
    a8c2:	46 c0       	rjmp	.+140    	; 0xa950 <Sniff14443AAppProcess+0xb4>
    a8c4:	28 f4       	brcc	.+10     	; 0xa8d0 <Sniff14443AAppProcess+0x34>
    a8c6:	81 30       	cpi	r24, 0x01	; 1
    a8c8:	61 f0       	breq	.+24     	; 0xa8e2 <Sniff14443AAppProcess+0x46>
    a8ca:	82 30       	cpi	r24, 0x02	; 2
    a8cc:	d1 f0       	breq	.+52     	; 0xa902 <Sniff14443AAppProcess+0x66>
    a8ce:	19 c1       	rjmp	.+562    	; 0xab02 <Sniff14443AAppProcess+0x266>
    a8d0:	85 30       	cpi	r24, 0x05	; 5
    a8d2:	09 f4       	brne	.+2      	; 0xa8d6 <Sniff14443AAppProcess+0x3a>
    a8d4:	52 c0       	rjmp	.+164    	; 0xa97a <Sniff14443AAppProcess+0xde>
    a8d6:	08 f4       	brcc	.+2      	; 0xa8da <Sniff14443AAppProcess+0x3e>
    a8d8:	76 c0       	rjmp	.+236    	; 0xa9c6 <Sniff14443AAppProcess+0x12a>
    a8da:	86 30       	cpi	r24, 0x06	; 6
    a8dc:	09 f4       	brne	.+2      	; 0xa8e0 <Sniff14443AAppProcess+0x44>
    a8de:	99 c0       	rjmp	.+306    	; 0xaa12 <Sniff14443AAppProcess+0x176>
    a8e0:	10 c1       	rjmp	.+544    	; 0xab02 <Sniff14443AAppProcess+0x266>
                case STATE_REQA:
                    LED_PORT.OUTCLR = LED_RED;
    a8e2:	88 e0       	ldi	r24, 0x08	; 8
    a8e4:	80 93 06 06 	sts	0x0606, r24
                    // If received Reader REQA or WUPA
                    if (TrafficSource == TRAFFIC_READER &&
    a8e8:	80 91 4d 2e 	lds	r24, 0x2E4D
    a8ec:	81 11       	cpse	r24, r1
    a8ee:	09 c1       	rjmp	.+530    	; 0xab02 <Sniff14443AAppProcess+0x266>
                        (Buffer[0] == 0x26 || Buffer[0] == 0x52)) {
    a8f0:	f8 01       	movw	r30, r16
    a8f2:	80 81       	ld	r24, Z

            switch (SniffState) {
                case STATE_REQA:
                    LED_PORT.OUTCLR = LED_RED;
                    // If received Reader REQA or WUPA
                    if (TrafficSource == TRAFFIC_READER &&
    a8f4:	86 32       	cpi	r24, 0x26	; 38
    a8f6:	19 f0       	breq	.+6      	; 0xa8fe <Sniff14443AAppProcess+0x62>
                        (Buffer[0] == 0x26 || Buffer[0] == 0x52)) {
    a8f8:	82 35       	cpi	r24, 0x52	; 82
    a8fa:	09 f0       	breq	.+2      	; 0xa8fe <Sniff14443AAppProcess+0x62>
    a8fc:	02 c1       	rjmp	.+516    	; 0xab02 <Sniff14443AAppProcess+0x266>
                        SniffState = STATE_ATQA;
    a8fe:	82 e0       	ldi	r24, 0x02	; 2
    a900:	76 c0       	rjmp	.+236    	; 0xa9ee <Sniff14443AAppProcess+0x152>
                        // Stay in this state, do noting
                    }
                    break;
                case STATE_ATQA:
                    // ATQA: P RRRR XXXX  P XXRX XXXX
                    if (TrafficSource == TRAFFIC_CARD &&
    a902:	80 91 4d 2e 	lds	r24, 0x2E4D
    a906:	81 30       	cpi	r24, 0x01	; 1
    a908:	b1 f4       	brne	.+44     	; 0xa936 <Sniff14443AAppProcess+0x9a>
    a90a:	62 31       	cpi	r22, 0x12	; 18
    a90c:	71 05       	cpc	r23, r1
    a90e:	99 f4       	brne	.+38     	; 0xa936 <Sniff14443AAppProcess+0x9a>
                        BitCount == 2 * 9 &&
                        (Buffer[0] & 0x20) == 0x00 &&        // Bit6 RFU shall be 0
    a910:	f8 01       	movw	r30, r16
    a912:	80 81       	ld	r24, Z
                    }
                    break;
                case STATE_ATQA:
                    // ATQA: P RRRR XXXX  P XXRX XXXX
                    if (TrafficSource == TRAFFIC_CARD &&
                        BitCount == 2 * 9 &&
    a914:	85 fd       	sbrc	r24, 5
    a916:	0f c0       	rjmp	.+30     	; 0xa936 <Sniff14443AAppProcess+0x9a>
                        (Buffer[0] & 0x20) == 0x00 &&        // Bit6 RFU shall be 0
                        (Buffer[1] & 0xE0) == 0x00 &&      // bit13-16 RFU shall be 0
    a918:	81 81       	ldd	r24, Z+1	; 0x01
    a91a:	80 7e       	andi	r24, 0xE0	; 224
                    break;
                case STATE_ATQA:
                    // ATQA: P RRRR XXXX  P XXRX XXXX
                    if (TrafficSource == TRAFFIC_CARD &&
                        BitCount == 2 * 9 &&
                        (Buffer[0] & 0x20) == 0x00 &&        // Bit6 RFU shall be 0
    a91c:	61 f4       	brne	.+24     	; 0xa936 <Sniff14443AAppProcess+0x9a>
                        (Buffer[1] & 0xE0) == 0x00 &&      // bit13-16 RFU shall be 0
                        (Buffer[2] & 0x01) == 0x00 &&
    a91e:	82 81       	ldd	r24, Z+2	; 0x02
                case STATE_ATQA:
                    // ATQA: P RRRR XXXX  P XXRX XXXX
                    if (TrafficSource == TRAFFIC_CARD &&
                        BitCount == 2 * 9 &&
                        (Buffer[0] & 0x20) == 0x00 &&        // Bit6 RFU shall be 0
                        (Buffer[1] & 0xE0) == 0x00 &&      // bit13-16 RFU shall be 0
    a920:	80 fd       	sbrc	r24, 0
    a922:	09 c0       	rjmp	.+18     	; 0xa936 <Sniff14443AAppProcess+0x9a>
                        (Buffer[2] & 0x01) == 0x00 &&
                        checkParityBits(Buffer, BitCount)) {
    a924:	62 e1       	ldi	r22, 0x12	; 18
    a926:	70 e0       	ldi	r23, 0x00	; 0
    a928:	c8 01       	movw	r24, r16
    a92a:	0e 94 10 4c 	call	0x9820	; 0x9820 <checkParityBits>
                    // ATQA: P RRRR XXXX  P XXRX XXXX
                    if (TrafficSource == TRAFFIC_CARD &&
                        BitCount == 2 * 9 &&
                        (Buffer[0] & 0x20) == 0x00 &&        // Bit6 RFU shall be 0
                        (Buffer[1] & 0xE0) == 0x00 &&      // bit13-16 RFU shall be 0
                        (Buffer[2] & 0x01) == 0x00 &&
    a92e:	88 23       	and	r24, r24
    a930:	11 f0       	breq	.+4      	; 0xa936 <Sniff14443AAppProcess+0x9a>
                        checkParityBits(Buffer, BitCount)) {
                        // Assume this is a good ATQA
                        SniffState = STATE_ANTICOLLI;
    a932:	83 e0       	ldi	r24, 0x03	; 3
    a934:	5c c0       	rjmp	.+184    	; 0xa9ee <Sniff14443AAppProcess+0x152>
                    } else {
                        // If not ATQA, but REQA, then stay on this state,
                        // Reset to REQA, save the counter and reset the counter
                        if (TrafficSource == TRAFFIC_READER &&
    a936:	80 91 4d 2e 	lds	r24, 0x2E4D
    a93a:	81 11       	cpse	r24, r1
    a93c:	5b c0       	rjmp	.+182    	; 0xa9f4 <Sniff14443AAppProcess+0x158>
                            (Buffer[0] == 0x26 || Buffer[0] == 0x52)) {
    a93e:	f8 01       	movw	r30, r16
    a940:	80 81       	ld	r24, Z
                        // Assume this is a good ATQA
                        SniffState = STATE_ANTICOLLI;
                    } else {
                        // If not ATQA, but REQA, then stay on this state,
                        // Reset to REQA, save the counter and reset the counter
                        if (TrafficSource == TRAFFIC_READER &&
    a942:	86 32       	cpi	r24, 0x26	; 38
    a944:	09 f4       	brne	.+2      	; 0xa948 <Sniff14443AAppProcess+0xac>
    a946:	dd c0       	rjmp	.+442    	; 0xab02 <Sniff14443AAppProcess+0x266>
                            (Buffer[0] == 0x26 || Buffer[0] == 0x52)) {
    a948:	82 35       	cpi	r24, 0x52	; 82
    a94a:	09 f0       	breq	.+2      	; 0xa94e <Sniff14443AAppProcess+0xb2>
    a94c:	53 c0       	rjmp	.+166    	; 0xa9f4 <Sniff14443AAppProcess+0x158>
    a94e:	d9 c0       	rjmp	.+434    	; 0xab02 <Sniff14443AAppProcess+0x266>
                        }
                    }
                    break;
                case STATE_ANTICOLLI:
                    // SEL: 93/95/97
                    if (TrafficSource == TRAFFIC_READER &&
    a950:	80 91 4d 2e 	lds	r24, 0x2E4D
    a954:	81 11       	cpse	r24, r1
    a956:	4e c0       	rjmp	.+156    	; 0xa9f4 <Sniff14443AAppProcess+0x158>
    a958:	60 31       	cpi	r22, 0x10	; 16
    a95a:	71 05       	cpc	r23, r1
    a95c:	09 f0       	breq	.+2      	; 0xa960 <Sniff14443AAppProcess+0xc4>
    a95e:	4a c0       	rjmp	.+148    	; 0xa9f4 <Sniff14443AAppProcess+0x158>
                        BitCount == 2 * 8 &&
                        (Buffer[0] & 0xf0) == 0x90 &&
    a960:	f8 01       	movw	r30, r16
    a962:	80 81       	ld	r24, Z
    a964:	98 2f       	mov	r25, r24
    a966:	90 7f       	andi	r25, 0xF0	; 240
                    }
                    break;
                case STATE_ANTICOLLI:
                    // SEL: 93/95/97
                    if (TrafficSource == TRAFFIC_READER &&
                        BitCount == 2 * 8 &&
    a968:	90 39       	cpi	r25, 0x90	; 144
    a96a:	09 f0       	breq	.+2      	; 0xa96e <Sniff14443AAppProcess+0xd2>
    a96c:	43 c0       	rjmp	.+134    	; 0xa9f4 <Sniff14443AAppProcess+0x158>
                        (Buffer[0] & 0xf0) == 0x90 &&
                        (Buffer[0] & 0x09) == 0x01) {
    a96e:	89 70       	andi	r24, 0x09	; 9
                    break;
                case STATE_ANTICOLLI:
                    // SEL: 93/95/97
                    if (TrafficSource == TRAFFIC_READER &&
                        BitCount == 2 * 8 &&
                        (Buffer[0] & 0xf0) == 0x90 &&
    a970:	81 30       	cpi	r24, 0x01	; 1
    a972:	09 f0       	breq	.+2      	; 0xa976 <Sniff14443AAppProcess+0xda>
    a974:	3f c0       	rjmp	.+126    	; 0xa9f4 <Sniff14443AAppProcess+0x158>
                        (Buffer[0] & 0x09) == 0x01) {
                        SniffState = STATE_UID;
    a976:	85 e0       	ldi	r24, 0x05	; 5
    a978:	3a c0       	rjmp	.+116    	; 0xa9ee <Sniff14443AAppProcess+0x152>
                    } else {
                        reset2REQA();
                    }
                    break;
                case STATE_UID:
                    if (TrafficSource == TRAFFIC_CARD &&
    a97a:	80 91 4d 2e 	lds	r24, 0x2E4D
    a97e:	81 30       	cpi	r24, 0x01	; 1
    a980:	61 f4       	brne	.+24     	; 0xa99a <Sniff14443AAppProcess+0xfe>
    a982:	6d 32       	cpi	r22, 0x2D	; 45
    a984:	71 05       	cpc	r23, r1
    a986:	49 f4       	brne	.+18     	; 0xa99a <Sniff14443AAppProcess+0xfe>
                        BitCount == 5 * 9 &&
                        checkParityBits(Buffer, BitCount)) {
    a988:	6d e2       	ldi	r22, 0x2D	; 45
    a98a:	70 e0       	ldi	r23, 0x00	; 0
    a98c:	c8 01       	movw	r24, r16
    a98e:	0e 94 10 4c 	call	0x9820	; 0x9820 <checkParityBits>
                        reset2REQA();
                    }
                    break;
                case STATE_UID:
                    if (TrafficSource == TRAFFIC_CARD &&
                        BitCount == 5 * 9 &&
    a992:	88 23       	and	r24, r24
    a994:	11 f0       	breq	.+4      	; 0xa99a <Sniff14443AAppProcess+0xfe>
                        checkParityBits(Buffer, BitCount)) {
                        SniffState = STATE_SELECT;
    a996:	84 e0       	ldi	r24, 0x04	; 4
    a998:	2a c0       	rjmp	.+84     	; 0xa9ee <Sniff14443AAppProcess+0x152>
void Sniff14443AAppTimeout(void){
    Sniff14443AAppReset();
}

INLINE void reset2REQA(void){
    SniffState = STATE_REQA;
    a99a:	81 e0       	ldi	r24, 0x01	; 1
    a99c:	80 93 3a 2e 	sts	0x2E3A, r24
    LED_PORT.OUTCLR = LED_RED;
    a9a0:	88 e0       	ldi	r24, 0x08	; 8
    a9a2:	80 93 06 06 	sts	0x0606, r24

    // Mark the current threshold as fail and continue
    if(tmp_th < CODEC_THRESHOLD_CALIBRATE_MAX){
    a9a6:	80 91 20 20 	lds	r24, 0x2020
    a9aa:	90 91 21 20 	lds	r25, 0x2021
    a9ae:	81 15       	cp	r24, r1
    a9b0:	28 e0       	ldi	r18, 0x08	; 8
    a9b2:	92 07       	cpc	r25, r18
    a9b4:	08 f4       	brcc	.+2      	; 0xa9b8 <Sniff14443AAppProcess+0x11c>
    a9b6:	94 c0       	rjmp	.+296    	; 0xaae0 <Sniff14443AAppProcess+0x244>
        Thresholds[(tmp_th - CODEC_THRESHOLD_CALIBRATE_MIN) / CODEC_THRESHOLD_CALIBRATE_STEPS] = 0;
        tmp_th = CodecThresholdIncrement();
    } else{
        // mark finish
        CommandLinePendingTaskFinished(COMMAND_INFO_FALSE, NULL);
    a9b8:	60 e0       	ldi	r22, 0x00	; 0
    a9ba:	70 e0       	ldi	r23, 0x00	; 0
    a9bc:	8d e6       	ldi	r24, 0x6D	; 109
    a9be:	94 e2       	ldi	r25, 0x24	; 36
    a9c0:	0e 94 4d 23 	call	0x469a	; 0x469a <CommandLinePendingTaskFinished>
    a9c4:	9e c0       	rjmp	.+316    	; 0xab02 <Sniff14443AAppProcess+0x266>
                    }
                    break;
                case STATE_SELECT:

                    // SELECT: 9 bytes, SEL = 93/95/97, NVB=70
                    if (TrafficSource == TRAFFIC_READER &&
    a9c6:	80 91 4d 2e 	lds	r24, 0x2E4D
    a9ca:	81 11       	cpse	r24, r1
    a9cc:	13 c0       	rjmp	.+38     	; 0xa9f4 <Sniff14443AAppProcess+0x158>
    a9ce:	68 34       	cpi	r22, 0x48	; 72
    a9d0:	71 05       	cpc	r23, r1
    a9d2:	81 f4       	brne	.+32     	; 0xa9f4 <Sniff14443AAppProcess+0x158>
                        BitCount == 9 * 8 &&
                        (Buffer[0] & 0xf0) == 0x90 &&
    a9d4:	f8 01       	movw	r30, r16
    a9d6:	80 81       	ld	r24, Z
    a9d8:	98 2f       	mov	r25, r24
    a9da:	90 7f       	andi	r25, 0xF0	; 240
                    break;
                case STATE_SELECT:

                    // SELECT: 9 bytes, SEL = 93/95/97, NVB=70
                    if (TrafficSource == TRAFFIC_READER &&
                        BitCount == 9 * 8 &&
    a9dc:	90 39       	cpi	r25, 0x90	; 144
    a9de:	51 f4       	brne	.+20     	; 0xa9f4 <Sniff14443AAppProcess+0x158>
                        (Buffer[0] & 0xf0) == 0x90 &&
                        (Buffer[0] & 0x09) == 0x01 &&
    a9e0:	89 70       	andi	r24, 0x09	; 9
                case STATE_SELECT:

                    // SELECT: 9 bytes, SEL = 93/95/97, NVB=70
                    if (TrafficSource == TRAFFIC_READER &&
                        BitCount == 9 * 8 &&
                        (Buffer[0] & 0xf0) == 0x90 &&
    a9e2:	81 30       	cpi	r24, 0x01	; 1
    a9e4:	39 f4       	brne	.+14     	; 0xa9f4 <Sniff14443AAppProcess+0x158>
                        (Buffer[0] & 0x09) == 0x01 &&
    a9e6:	81 81       	ldd	r24, Z+1	; 0x01
    a9e8:	80 37       	cpi	r24, 0x70	; 112
    a9ea:	21 f4       	brne	.+8      	; 0xa9f4 <Sniff14443AAppProcess+0x158>
                        Buffer[1] == 0x70) {
                        SniffState = STATE_SAK;
    a9ec:	86 e0       	ldi	r24, 0x06	; 6
    a9ee:	80 93 3a 2e 	sts	0x2E3A, r24
    a9f2:	87 c0       	rjmp	.+270    	; 0xab02 <Sniff14443AAppProcess+0x266>
void Sniff14443AAppTimeout(void){
    Sniff14443AAppReset();
}

INLINE void reset2REQA(void){
    SniffState = STATE_REQA;
    a9f4:	81 e0       	ldi	r24, 0x01	; 1
    a9f6:	80 93 3a 2e 	sts	0x2E3A, r24
    LED_PORT.OUTCLR = LED_RED;
    a9fa:	88 e0       	ldi	r24, 0x08	; 8
    a9fc:	80 93 06 06 	sts	0x0606, r24

    // Mark the current threshold as fail and continue
    if(tmp_th < CODEC_THRESHOLD_CALIBRATE_MAX){
    aa00:	80 91 20 20 	lds	r24, 0x2020
    aa04:	90 91 21 20 	lds	r25, 0x2021
    aa08:	81 15       	cp	r24, r1
    aa0a:	f8 e0       	ldi	r31, 0x08	; 8
    aa0c:	9f 07       	cpc	r25, r31
    aa0e:	a0 f6       	brcc	.-88     	; 0xa9b8 <Sniff14443AAppProcess+0x11c>
    aa10:	67 c0       	rjmp	.+206    	; 0xaae0 <Sniff14443AAppProcess+0x244>
                        reset2REQA();
                    }
                    break;
                case STATE_SAK:
                    // SAK: 1Byte SAK + CRC
                    if (TrafficSource == TRAFFIC_CARD &&
    aa12:	80 91 4d 2e 	lds	r24, 0x2E4D
    aa16:	81 30       	cpi	r24, 0x01	; 1
    aa18:	09 f0       	breq	.+2      	; 0xaa1c <Sniff14443AAppProcess+0x180>
    aa1a:	53 c0       	rjmp	.+166    	; 0xaac2 <Sniff14443AAppProcess+0x226>
    aa1c:	6b 31       	cpi	r22, 0x1B	; 27
    aa1e:	71 05       	cpc	r23, r1
    aa20:	09 f0       	breq	.+2      	; 0xaa24 <Sniff14443AAppProcess+0x188>
    aa22:	4f c0       	rjmp	.+158    	; 0xaac2 <Sniff14443AAppProcess+0x226>
                        BitCount == 3 * 9 &&
                        checkParityBits(Buffer, BitCount)) {
    aa24:	6b e1       	ldi	r22, 0x1B	; 27
    aa26:	70 e0       	ldi	r23, 0x00	; 0
    aa28:	c8 01       	movw	r24, r16
    aa2a:	0e 94 10 4c 	call	0x9820	; 0x9820 <checkParityBits>
                    }
                    break;
                case STATE_SAK:
                    // SAK: 1Byte SAK + CRC
                    if (TrafficSource == TRAFFIC_CARD &&
                        BitCount == 3 * 9 &&
    aa2e:	88 23       	and	r24, r24
    aa30:	09 f4       	brne	.+2      	; 0xaa34 <Sniff14443AAppProcess+0x198>
    aa32:	47 c0       	rjmp	.+142    	; 0xaac2 <Sniff14443AAppProcess+0x226>
                        checkParityBits(Buffer, BitCount)) {
                        if ((Buffer[0] & 0x04) == 0x00) {
    aa34:	f8 01       	movw	r30, r16
    aa36:	80 81       	ld	r24, Z
    aa38:	82 fd       	sbrc	r24, 2
    aa3a:	7b cf       	rjmp	.-266    	; 0xa932 <Sniff14443AAppProcess+0x96>
                            // UID complete, success SELECTED,
                            // Mark the current threshold as ok and finish
                            // reset
                            SniffState = STATE_REQA;
    aa3c:	81 e0       	ldi	r24, 0x01	; 1
    aa3e:	80 93 3a 2e 	sts	0x2E3A, r24
                            LED_PORT.OUTSET = LED_RED;
    aa42:	88 e0       	ldi	r24, 0x08	; 8
    aa44:	80 93 05 06 	sts	0x0605, r24
                            Thresholds[(tmp_th - CODEC_THRESHOLD_CALIBRATE_MIN) / CODEC_THRESHOLD_CALIBRATE_STEPS] += 1;
    aa48:	e0 91 20 20 	lds	r30, 0x2020
    aa4c:	f0 91 21 20 	lds	r31, 0x2021
    aa50:	e0 58       	subi	r30, 0x80	; 128
    aa52:	f1 09       	sbc	r31, r1
    aa54:	94 e0       	ldi	r25, 0x04	; 4
    aa56:	f6 95       	lsr	r31
    aa58:	e7 95       	ror	r30
    aa5a:	9a 95       	dec	r25
    aa5c:	e1 f7       	brne	.-8      	; 0xaa56 <Sniff14443AAppProcess+0x1ba>
    aa5e:	ee 53       	subi	r30, 0x3E	; 62
    aa60:	f2 4d       	sbci	r31, 0xD2	; 210
    aa62:	80 81       	ld	r24, Z
    aa64:	8f 5f       	subi	r24, 0xFF	; 255
    aa66:	80 83       	st	Z, r24
                            CommandLinePendingTaskFinished(COMMAND_INFO_OK_WITH_TEXT_ID, NULL);
    aa68:	60 e0       	ldi	r22, 0x00	; 0
    aa6a:	70 e0       	ldi	r23, 0x00	; 0
    aa6c:	85 e6       	ldi	r24, 0x65	; 101
    aa6e:	0e 94 4d 23 	call	0x469a	; 0x469a <CommandLinePendingTaskFinished>
                            // Send this threshold to terminal
                            char tmpBuf[10];
                            snprintf(tmpBuf, 10, "%4" PRIu16 ": ", tmp_th);
    aa72:	80 91 21 20 	lds	r24, 0x2021
    aa76:	8f 93       	push	r24
    aa78:	80 91 20 20 	lds	r24, 0x2020
    aa7c:	8f 93       	push	r24
    aa7e:	8d ef       	ldi	r24, 0xFD	; 253
    aa80:	93 e2       	ldi	r25, 0x23	; 35
    aa82:	9f 93       	push	r25
    aa84:	8f 93       	push	r24
    aa86:	1f 92       	push	r1
    aa88:	8a e0       	ldi	r24, 0x0A	; 10
    aa8a:	8f 93       	push	r24
    aa8c:	8e 01       	movw	r16, r28
    aa8e:	0f 5f       	subi	r16, 0xFF	; 255
    aa90:	1f 4f       	sbci	r17, 0xFF	; 255
    aa92:	1f 93       	push	r17
    aa94:	0f 93       	push	r16
    aa96:	0e 94 1a 66 	call	0xcc34	; 0xcc34 <snprintf>
                            TerminalSendString(tmpBuf);
    aa9a:	c8 01       	movw	r24, r16
    aa9c:	0e 94 a3 19 	call	0x3346	; 0x3346 <TerminalSendString>

                            // Save value to EEPROM
                            SETTING_UPDATE(GlobalSettings.ActiveSettingPtr->ReaderThreshold);
    aaa0:	e0 91 71 2f 	lds	r30, 0x2F71
    aaa4:	f0 91 72 2f 	lds	r31, 0x2F72
    aaa8:	62 85       	ldd	r22, Z+10	; 0x0a
    aaaa:	73 85       	ldd	r23, Z+11	; 0x0b
    aaac:	cf 01       	movw	r24, r30
    aaae:	86 56       	subi	r24, 0x66	; 102
    aab0:	9f 42       	sbci	r25, 0x2F	; 47
    aab2:	8f 5f       	subi	r24, 0xFF	; 255
    aab4:	9f 4f       	sbci	r25, 0xFF	; 255
    aab6:	0e 94 7c 6c 	call	0xd8f8	; 0xd8f8 <eeprom_update_word>

                            Sniff14443AAppReset();
    aaba:	e8 de       	rcall	.-560    	; 0xa88c <Sniff14443AAppReset>
    aabc:	cd bf       	out	0x3d, r28	; 61
    aabe:	de bf       	out	0x3e, r29	; 62
    aac0:	20 c0       	rjmp	.+64     	; 0xab02 <Sniff14443AAppProcess+0x266>
void Sniff14443AAppTimeout(void){
    Sniff14443AAppReset();
}

INLINE void reset2REQA(void){
    SniffState = STATE_REQA;
    aac2:	81 e0       	ldi	r24, 0x01	; 1
    aac4:	80 93 3a 2e 	sts	0x2E3A, r24
    LED_PORT.OUTCLR = LED_RED;
    aac8:	88 e0       	ldi	r24, 0x08	; 8
    aaca:	80 93 06 06 	sts	0x0606, r24

    // Mark the current threshold as fail and continue
    if(tmp_th < CODEC_THRESHOLD_CALIBRATE_MAX){
    aace:	80 91 20 20 	lds	r24, 0x2020
    aad2:	90 91 21 20 	lds	r25, 0x2021
    aad6:	81 15       	cp	r24, r1
    aad8:	e8 e0       	ldi	r30, 0x08	; 8
    aada:	9e 07       	cpc	r25, r30
    aadc:	08 f0       	brcs	.+2      	; 0xaae0 <Sniff14443AAppProcess+0x244>
    aade:	6c cf       	rjmp	.-296    	; 0xa9b8 <Sniff14443AAppProcess+0x11c>
        Thresholds[(tmp_th - CODEC_THRESHOLD_CALIBRATE_MIN) / CODEC_THRESHOLD_CALIBRATE_STEPS] = 0;
    aae0:	fc 01       	movw	r30, r24
    aae2:	e0 58       	subi	r30, 0x80	; 128
    aae4:	f1 09       	sbc	r31, r1
    aae6:	84 e0       	ldi	r24, 0x04	; 4
    aae8:	f6 95       	lsr	r31
    aaea:	e7 95       	ror	r30
    aaec:	8a 95       	dec	r24
    aaee:	e1 f7       	brne	.-8      	; 0xaae8 <Sniff14443AAppProcess+0x24c>
    aaf0:	ee 53       	subi	r30, 0x3E	; 62
    aaf2:	f2 4d       	sbci	r31, 0xD2	; 210
    aaf4:	10 82       	st	Z, r1
        tmp_th = CodecThresholdIncrement();
    aaf6:	0e 94 43 24 	call	0x4886	; 0x4886 <CodecThresholdIncrement>
    aafa:	80 93 20 20 	sts	0x2020, r24
    aafe:	90 93 21 20 	sts	0x2021, r25
    ab02:	02 c0       	rjmp	.+4      	; 0xab08 <Sniff14443AAppProcess+0x26c>
    ab04:	80 e0       	ldi	r24, 0x00	; 0
    ab06:	90 e0       	ldi	r25, 0x00	; 0
            break;
        }
        default:
            return 0;
    }
    ab08:	2a 96       	adiw	r28, 0x0a	; 10
    ab0a:	cd bf       	out	0x3d, r28	; 61
    ab0c:	de bf       	out	0x3e, r29	; 62
    ab0e:	df 91       	pop	r29
    ab10:	cf 91       	pop	r28
    ab12:	1f 91       	pop	r17
    ab14:	0f 91       	pop	r16
    ab16:	08 95       	ret

0000ab18 <isr_ISO15693_CODEC_DEMOD_IN_INT0_VECT>:
// Started when a single pulse has been detected
// ISR(CODEC_DEMOD_IN_INT0_VECT) 
void isr_ISO15693_CODEC_DEMOD_IN_INT0_VECT(void)
{
    // Start sample timer
    CODEC_TIMER_SAMPLING.INTFLAGS = TC0_CCCIF_bm;
    ab18:	e0 e0       	ldi	r30, 0x00	; 0
    ab1a:	f9 e0       	ldi	r31, 0x09	; 9
    ab1c:	80 e4       	ldi	r24, 0x40	; 64
    ab1e:	84 87       	std	Z+12, r24	; 0x0c
    CODEC_TIMER_SAMPLING.INTCTRLB = TC_CCCINTLVL_HI_gc;
    ab20:	80 e3       	ldi	r24, 0x30	; 48
    ab22:	87 83       	std	Z+7, r24	; 0x07
    /* Disable this interrupt */
    CODEC_DEMOD_IN_PORT.INT0MASK = 0;
    ab24:	10 92 2a 06 	sts	0x062A, r1
    ab28:	08 95       	ret

0000ab2a <isr_ISO15693_CODEC_TIMER_SAMPLING_CCC_VECT>:

// ISR(CODEC_TIMER_SAMPLING_CCC_VECT) // Reading data sent from the reader
void isr_ISO15693_CODEC_TIMER_SAMPLING_CCC_VECT(void)  
{
    /* Shift demod data */
    SampleRegister = (SampleRegister << 1) | (!(CODEC_DEMOD_IN_PORT.IN & CODEC_DEMOD_IN_MASK) ? 0x01 : 0x00);
    ab2a:	93 b1       	in	r25, 0x03	; 3
    ab2c:	20 91 28 06 	lds	r18, 0x0628
    ab30:	26 70       	andi	r18, 0x06	; 6
    ab32:	81 e0       	ldi	r24, 0x01	; 1
    ab34:	09 f0       	breq	.+2      	; 0xab38 <isr_ISO15693_CODEC_TIMER_SAMPLING_CCC_VECT+0xe>
    ab36:	80 e0       	ldi	r24, 0x00	; 0
    ab38:	99 0f       	add	r25, r25
    ab3a:	89 2b       	or	r24, r25
    ab3c:	83 b9       	out	0x03, r24	; 3

    if (++BitSampleCount == 8)
    ab3e:	86 b1       	in	r24, 0x06	; 6
    ab40:	97 b1       	in	r25, 0x07	; 7
    ab42:	01 96       	adiw	r24, 0x01	; 1
    ab44:	86 b9       	out	0x06, r24	; 6
    ab46:	97 b9       	out	0x07, r25	; 7
    ab48:	08 97       	sbiw	r24, 0x08	; 8
    ab4a:	09 f0       	breq	.+2      	; 0xab4e <isr_ISO15693_CODEC_TIMER_SAMPLING_CCC_VECT+0x24>
    ab4c:	c9 c0       	rjmp	.+402    	; 0xace0 <isr_ISO15693_CODEC_TIMER_SAMPLING_CCC_VECT+0x1b6>
    {
        BitSampleCount = 0;
    ab4e:	16 b8       	out	0x06, r1	; 6
    ab50:	17 b8       	out	0x07, r1	; 7
        switch (DemodState)
    ab52:	80 91 45 2e 	lds	r24, 0x2E45
    ab56:	81 30       	cpi	r24, 0x01	; 1
    ab58:	e9 f0       	breq	.+58     	; 0xab94 <isr_ISO15693_CODEC_TIMER_SAMPLING_CCC_VECT+0x6a>
    ab5a:	20 f0       	brcs	.+8      	; 0xab64 <isr_ISO15693_CODEC_TIMER_SAMPLING_CCC_VECT+0x3a>
    ab5c:	82 30       	cpi	r24, 0x02	; 2
    ab5e:	09 f4       	brne	.+2      	; 0xab62 <isr_ISO15693_CODEC_TIMER_SAMPLING_CCC_VECT+0x38>
    ab60:	4e c0       	rjmp	.+156    	; 0xabfe <isr_ISO15693_CODEC_TIMER_SAMPLING_CCC_VECT+0xd4>
    ab62:	be c0       	rjmp	.+380    	; 0xace0 <isr_ISO15693_CODEC_TIMER_SAMPLING_CCC_VECT+0x1b6>
        {
            case DEMOD_SOC_STATE:
                if (SampleRegister == SOC_1_OF_4_CODE)
    ab64:	83 b1       	in	r24, 0x03	; 3
    ab66:	8b 37       	cpi	r24, 0x7B	; 123
    ab68:	49 f4       	brne	.+18     	; 0xab7c <isr_ISO15693_CODEC_TIMER_SAMPLING_CCC_VECT+0x52>
                {
                    DemodState = DEMOD_1_OUT_OF_4_STATE;
    ab6a:	81 e0       	ldi	r24, 0x01	; 1
    ab6c:	80 93 45 2e 	sts	0x2E45, r24
                    SampleDataCount = 0;
    ab70:	10 92 3d 2e 	sts	0x2E3D, r1
    ab74:	10 92 3e 2e 	sts	0x2E3E, r1
                    ModulationPauseCount = 0;
    ab78:	12 b8       	out	0x02, r1	; 2
    ab7a:	b2 c0       	rjmp	.+356    	; 0xace0 <isr_ISO15693_CODEC_TIMER_SAMPLING_CCC_VECT+0x1b6>
                } else if (SampleRegister == SOC_1_OF_256_CODE) {
    ab7c:	83 b1       	in	r24, 0x03	; 3
    ab7e:	8e 37       	cpi	r24, 0x7E	; 126
    ab80:	09 f0       	breq	.+2      	; 0xab84 <isr_ISO15693_CODEC_TIMER_SAMPLING_CCC_VECT+0x5a>
    ab82:	79 c0       	rjmp	.+242    	; 0xac76 <isr_ISO15693_CODEC_TIMER_SAMPLING_CCC_VECT+0x14c>
                    DemodState = DEMOD_1_OUT_OF_256_STATE;
    ab84:	82 e0       	ldi	r24, 0x02	; 2
    ab86:	80 93 45 2e 	sts	0x2E45, r24
                    SampleDataCount = 0;
    ab8a:	10 92 3d 2e 	sts	0x2E3D, r1
    ab8e:	10 92 3e 2e 	sts	0x2E3E, r1
    ab92:	a6 c0       	rjmp	.+332    	; 0xace0 <isr_ISO15693_CODEC_TIMER_SAMPLING_CCC_VECT+0x1b6>
                    CODEC_TIMER_SAMPLING.INTCTRLB = 0;
                }
                break;
                
            case DEMOD_1_OUT_OF_4_STATE:
                if (SampleRegister == EOC_CODE)
    ab94:	83 b1       	in	r24, 0x03	; 3
    ab96:	8f 3d       	cpi	r24, 0xDF	; 223
    ab98:	b1 f1       	breq	.+108    	; 0xac06 <isr_ISO15693_CODEC_TIMER_SAMPLING_CCC_VECT+0xdc>
                {
                    ISO15693_EOC();
                } else {
                    uint8_t SampleData = ~SampleRegister;
    ab9a:	83 b1       	in	r24, 0x03	; 3
    ab9c:	80 95       	com	r24
                    if (SampleData == (0x01 << 6))
    ab9e:	80 34       	cpi	r24, 0x40	; 64
    aba0:	39 f4       	brne	.+14     	; 0xabb0 <isr_ISO15693_CODEC_TIMER_SAMPLING_CCC_VECT+0x86>
                    {
                        /* ^_^^^^^^ -> 00 */
                        ModulationPauseCount++;
    aba2:	82 b1       	in	r24, 0x02	; 2
    aba4:	8f 5f       	subi	r24, 0xFF	; 255
    aba6:	82 b9       	out	0x02, r24	; 2
                        DataRegister >>= 2;
    aba8:	80 b1       	in	r24, 0x00	; 0
    abaa:	86 95       	lsr	r24
    abac:	86 95       	lsr	r24
    abae:	21 c0       	rjmp	.+66     	; 0xabf2 <isr_ISO15693_CODEC_TIMER_SAMPLING_CCC_VECT+0xc8>

                    } else if (SampleData == (0x01 << 4)) {
    abb0:	80 31       	cpi	r24, 0x10	; 16
    abb2:	49 f4       	brne	.+18     	; 0xabc6 <isr_ISO15693_CODEC_TIMER_SAMPLING_CCC_VECT+0x9c>
                        /* ^^^_^^^^ -> 01 */
                        ModulationPauseCount++;
    abb4:	82 b1       	in	r24, 0x02	; 2
    abb6:	8f 5f       	subi	r24, 0xFF	; 255
    abb8:	82 b9       	out	0x02, r24	; 2
                        DataRegister >>= 2;
    abba:	80 b1       	in	r24, 0x00	; 0
    abbc:	86 95       	lsr	r24
    abbe:	86 95       	lsr	r24
    abc0:	80 b9       	out	0x00, r24	; 0
                        DataRegister |= 0b01 << 6;
    abc2:	06 9a       	sbi	0x00, 6	; 0
    abc4:	17 c0       	rjmp	.+46     	; 0xabf4 <isr_ISO15693_CODEC_TIMER_SAMPLING_CCC_VECT+0xca>

                    } else if (SampleData == (0x01 << 2)) {
    abc6:	84 30       	cpi	r24, 0x04	; 4
    abc8:	49 f4       	brne	.+18     	; 0xabdc <isr_ISO15693_CODEC_TIMER_SAMPLING_CCC_VECT+0xb2>
                        /* ^^^^^_^^ -> 10 */
                        ModulationPauseCount++;
    abca:	82 b1       	in	r24, 0x02	; 2
    abcc:	8f 5f       	subi	r24, 0xFF	; 255
    abce:	82 b9       	out	0x02, r24	; 2
                        DataRegister >>= 2;
    abd0:	80 b1       	in	r24, 0x00	; 0
    abd2:	86 95       	lsr	r24
    abd4:	86 95       	lsr	r24
    abd6:	80 b9       	out	0x00, r24	; 0
                        DataRegister |= 0b10 << 6;
    abd8:	07 9a       	sbi	0x00, 7	; 0
    abda:	0c c0       	rjmp	.+24     	; 0xabf4 <isr_ISO15693_CODEC_TIMER_SAMPLING_CCC_VECT+0xca>

                    } else if (SampleData == (0x01 << 0)) {
    abdc:	81 30       	cpi	r24, 0x01	; 1
    abde:	51 f4       	brne	.+20     	; 0xabf4 <isr_ISO15693_CODEC_TIMER_SAMPLING_CCC_VECT+0xca>
                        /* ^^^^^^^_ -> 11 */
                        ModulationPauseCount++;
    abe0:	82 b1       	in	r24, 0x02	; 2
    abe2:	8f 5f       	subi	r24, 0xFF	; 255
    abe4:	82 b9       	out	0x02, r24	; 2
                        DataRegister >>= 2;
    abe6:	80 b1       	in	r24, 0x00	; 0
    abe8:	86 95       	lsr	r24
    abea:	86 95       	lsr	r24
    abec:	80 b9       	out	0x00, r24	; 0
                        DataRegister |= 0b11 << 6;
    abee:	80 b1       	in	r24, 0x00	; 0
    abf0:	80 6c       	ori	r24, 0xC0	; 192
    abf2:	80 b9       	out	0x00, r24	; 0
                    }

                    if (ModulationPauseCount == 4)
    abf4:	82 b1       	in	r24, 0x02	; 2
    abf6:	84 30       	cpi	r24, 0x04	; 4
    abf8:	09 f0       	breq	.+2      	; 0xabfc <isr_ISO15693_CODEC_TIMER_SAMPLING_CCC_VECT+0xd2>
    abfa:	72 c0       	rjmp	.+228    	; 0xace0 <isr_ISO15693_CODEC_TIMER_SAMPLING_CCC_VECT+0x1b6>
    abfc:	62 c0       	rjmp	.+196    	; 0xacc2 <isr_ISO15693_CODEC_TIMER_SAMPLING_CCC_VECT+0x198>
                    }
                }
                break;
            
            case DEMOD_1_OUT_OF_256_STATE:
                if (SampleRegister == EOC_CODE)
    abfe:	83 b1       	in	r24, 0x03	; 3
    ac00:	8f 3d       	cpi	r24, 0xDF	; 223
    ac02:	09 f0       	breq	.+2      	; 0xac06 <isr_ISO15693_CODEC_TIMER_SAMPLING_CCC_VECT+0xdc>
    ac04:	40 c0       	rjmp	.+128    	; 0xac86 <isr_ISO15693_CODEC_TIMER_SAMPLING_CCC_VECT+0x15c>
    CODEC_DEMOD_IN_PORT.INT0MASK = 0;
}

INLINE void ISO15693_EOC(void)
{
    BitRate1 = 256 * 4;
    ac06:	80 e0       	ldi	r24, 0x00	; 0
    ac08:	94 e0       	ldi	r25, 0x04	; 4
    ac0a:	80 93 41 2e 	sts	0x2E41, r24
    ac0e:	90 93 42 2e 	sts	0x2E42, r25
    if (CodecBuffer[0] & ISO15693_REQ_DATARATE_HIGH)
    ac12:	80 91 d3 31 	lds	r24, 0x31D3
    ac16:	98 2f       	mov	r25, r24
    ac18:	92 70       	andi	r25, 0x02	; 2
    ac1a:	81 ff       	sbrs	r24, 1
    ac1c:	06 c0       	rjmp	.+12     	; 0xac2a <isr_ISO15693_CODEC_TIMER_SAMPLING_CCC_VECT+0x100>
        BitRate1 = 256;
    ac1e:	20 e0       	ldi	r18, 0x00	; 0
    ac20:	31 e0       	ldi	r19, 0x01	; 1
    ac22:	20 93 41 2e 	sts	0x2E41, r18
    ac26:	30 93 42 2e 	sts	0x2E42, r19

    if (CodecBuffer[0] & ISO15693_REQ_SUBCARRIER_DUAL)
    ac2a:	80 ff       	sbrs	r24, 0
    ac2c:	0b c0       	rjmp	.+22     	; 0xac44 <isr_ISO15693_CODEC_TIMER_SAMPLING_CCC_VECT+0x11a>
    {
        BitRate2 = 252 * 4;
    ac2e:	20 ef       	ldi	r18, 0xF0	; 240
    ac30:	33 e0       	ldi	r19, 0x03	; 3
    ac32:	20 93 3f 2e 	sts	0x2E3F, r18
    ac36:	30 93 40 2e 	sts	0x2E40, r19
        if (CodecBuffer[0] & ISO15693_REQ_DATARATE_HIGH)
    ac3a:	99 23       	and	r25, r25
    ac3c:	59 f0       	breq	.+22     	; 0xac54 <isr_ISO15693_CODEC_TIMER_SAMPLING_CCC_VECT+0x12a>
            BitRate2 = 252;
    ac3e:	8c ef       	ldi	r24, 0xFC	; 252
    ac40:	90 e0       	ldi	r25, 0x00	; 0
    ac42:	04 c0       	rjmp	.+8      	; 0xac4c <isr_ISO15693_CODEC_TIMER_SAMPLING_CCC_VECT+0x122>
    } else {
        BitRate2 = BitRate1;
    ac44:	80 91 41 2e 	lds	r24, 0x2E41
    ac48:	90 91 42 2e 	lds	r25, 0x2E42
    ac4c:	80 93 3f 2e 	sts	0x2E3F, r24
    ac50:	90 93 40 2e 	sts	0x2E40, r25
    }

    CODEC_TIMER_LOADMOD.CTRLD = 0;
    ac54:	10 92 03 0a 	sts	0x0A03, r1
    CODEC_TIMER_LOADMOD.INTFLAGS = TC0_CCBIF_bm;
    ac58:	80 e2       	ldi	r24, 0x20	; 32
    ac5a:	80 93 0c 0a 	sts	0x0A0C, r24
    CODEC_TIMER_LOADMOD.INTCTRLB = TC_CCBINTLVL_HI_gc;
    ac5e:	8c e0       	ldi	r24, 0x0C	; 12
    ac60:	80 93 07 0a 	sts	0x0A07, r24
    CODEC_TIMER_LOADMOD.PERBUF = BitRate1 - 1;
    ac64:	80 91 41 2e 	lds	r24, 0x2E41
    ac68:	90 91 42 2e 	lds	r25, 0x2E42
    ac6c:	01 97       	sbiw	r24, 0x01	; 1
    ac6e:	80 93 36 0a 	sts	0x0A36, r24
    ac72:	90 93 37 0a 	sts	0x0A37, r25

    Flags.DemodFinished = 1;
    ac76:	81 e0       	ldi	r24, 0x01	; 1
    ac78:	80 93 47 2e 	sts	0x2E47, r24
    CODEC_TIMER_SAMPLING.CTRLA = TC_CLKSEL_OFF_gc;
    ac7c:	10 92 00 09 	sts	0x0900, r1
    CODEC_TIMER_SAMPLING.INTCTRLB = 0;
    ac80:	10 92 07 09 	sts	0x0907, r1
    ac84:	2d c0       	rjmp	.+90     	; 0xace0 <isr_ISO15693_CODEC_TIMER_SAMPLING_CCC_VECT+0x1b6>
            case DEMOD_1_OUT_OF_256_STATE:
                if (SampleRegister == EOC_CODE)
                {
                    ISO15693_EOC();
                } else {
                    uint8_t Position = ((SampleDataCount / 2) % 256) - 1;
    ac86:	80 91 3d 2e 	lds	r24, 0x2E3D
    ac8a:	90 91 3e 2e 	lds	r25, 0x2E3E
    ac8e:	96 95       	lsr	r25
    ac90:	87 95       	ror	r24
                    uint8_t SampleData = ~SampleRegister;
    ac92:	23 b1       	in	r18, 0x03	; 3
    ac94:	20 95       	com	r18

                    if (SampleData == (0x01 << 6))
    ac96:	20 34       	cpi	r18, 0x40	; 64
    ac98:	11 f4       	brne	.+4      	; 0xac9e <isr_ISO15693_CODEC_TIMER_SAMPLING_CCC_VECT+0x174>
                    {
                        /* ^_^^^^^^ -> N-3 */
                        DataRegister = Position - 3;
    ac9a:	84 50       	subi	r24, 0x04	; 4
    ac9c:	0b c0       	rjmp	.+22     	; 0xacb4 <isr_ISO15693_CODEC_TIMER_SAMPLING_CCC_VECT+0x18a>
                        ModulationPauseCount++;

                    } else if (SampleData == (0x01 << 4)) {
    ac9e:	20 31       	cpi	r18, 0x10	; 16
    aca0:	11 f4       	brne	.+4      	; 0xaca6 <isr_ISO15693_CODEC_TIMER_SAMPLING_CCC_VECT+0x17c>
                        /* ^^^_^^^^ -> N-2 */
                        DataRegister = Position - 2;
    aca2:	83 50       	subi	r24, 0x03	; 3
    aca4:	07 c0       	rjmp	.+14     	; 0xacb4 <isr_ISO15693_CODEC_TIMER_SAMPLING_CCC_VECT+0x18a>
                        ModulationPauseCount++;

                    } else if (SampleData == (0x01 << 2)) {
    aca6:	24 30       	cpi	r18, 0x04	; 4
    aca8:	11 f4       	brne	.+4      	; 0xacae <isr_ISO15693_CODEC_TIMER_SAMPLING_CCC_VECT+0x184>
                        /* ^^^^^_^^ -> N-1 */
                        DataRegister = Position - 1;
    acaa:	82 50       	subi	r24, 0x02	; 2
    acac:	03 c0       	rjmp	.+6      	; 0xacb4 <isr_ISO15693_CODEC_TIMER_SAMPLING_CCC_VECT+0x18a>
                        ModulationPauseCount++;

                    } else if (SampleData == (0x01 << 0)) {
    acae:	21 30       	cpi	r18, 0x01	; 1
    acb0:	29 f4       	brne	.+10     	; 0xacbc <isr_ISO15693_CODEC_TIMER_SAMPLING_CCC_VECT+0x192>
            case DEMOD_1_OUT_OF_256_STATE:
                if (SampleRegister == EOC_CODE)
                {
                    ISO15693_EOC();
                } else {
                    uint8_t Position = ((SampleDataCount / 2) % 256) - 1;
    acb2:	81 50       	subi	r24, 0x01	; 1
                        DataRegister = Position - 1;
                        ModulationPauseCount++;

                    } else if (SampleData == (0x01 << 0)) {
                        /* ^^^^^^^_ -> N-0 */
                        DataRegister = Position - 0;
    acb4:	80 b9       	out	0x00, r24	; 0
                        ModulationPauseCount++;
    acb6:	82 b1       	in	r24, 0x02	; 2
    acb8:	8f 5f       	subi	r24, 0xFF	; 255
    acba:	82 b9       	out	0x02, r24	; 2
                    } 

                    if (ModulationPauseCount == 1)
    acbc:	82 b1       	in	r24, 0x02	; 2
    acbe:	81 30       	cpi	r24, 0x01	; 1
    acc0:	79 f4       	brne	.+30     	; 0xace0 <isr_ISO15693_CODEC_TIMER_SAMPLING_CCC_VECT+0x1b6>
                    {
                        ModulationPauseCount = 0;
    acc2:	12 b8       	out	0x02, r1	; 2
                        *CodecBufferPtr = DataRegister;
    acc4:	e8 b1       	in	r30, 0x08	; 8
    acc6:	f9 b1       	in	r31, 0x09	; 9
    acc8:	80 b1       	in	r24, 0x00	; 0
    acca:	80 83       	st	Z, r24
                        ++CodecBufferPtr;
    accc:	88 b1       	in	r24, 0x08	; 8
    acce:	99 b1       	in	r25, 0x09	; 9
    acd0:	01 96       	adiw	r24, 0x01	; 1
    acd2:	88 b9       	out	0x08, r24	; 8
    acd4:	99 b9       	out	0x09, r25	; 9
                        ++ByteCount;
    acd6:	80 91 43 2e 	lds	r24, 0x2E43
    acda:	8f 5f       	subi	r24, 0xFF	; 255
    acdc:	80 93 43 2e 	sts	0x2E43, r24
                    } 
                }
                break;
        }
    }
    SampleDataCount++;
    ace0:	80 91 3d 2e 	lds	r24, 0x2E3D
    ace4:	90 91 3e 2e 	lds	r25, 0x2E3E
    ace8:	01 96       	adiw	r24, 0x01	; 1
    acea:	80 93 3d 2e 	sts	0x2E3D, r24
    acee:	90 93 3e 2e 	sts	0x2E3E, r25
    acf2:	08 95       	ret

0000acf4 <isr_ISO15693_CODEC_TIMER_LOADMOD_CCB_VECT>:
        [LOADMOD_BIT1_DUAL] = &&LOADMOD_BIT1_DUAL_LABEL,
        [LOADMOD_EOF_DUAL] = &&LOADMOD_EOF_DUAL_LABEL,
        [LOADMOD_FINISHED] = &&LOADMOD_FINISHED_LABEL
    };

    if ( (StateRegister >= LOADMOD_START_SINGLE) && (StateRegister <= LOADMOD_FINISHED) ) {
    acf4:	81 b1       	in	r24, 0x01	; 1
    acf6:	88 23       	and	r24, r24
    acf8:	09 f4       	brne	.+2      	; 0xacfc <isr_ISO15693_CODEC_TIMER_LOADMOD_CCB_VECT+0x8>
    acfa:	59 c1       	rjmp	.+690    	; 0xafae <isr_ISO15693_CODEC_TIMER_LOADMOD_CCB_VECT+0x2ba>
    acfc:	81 b1       	in	r24, 0x01	; 1
    acfe:	8c 30       	cpi	r24, 0x0C	; 12
    ad00:	08 f0       	brcs	.+2      	; 0xad04 <isr_ISO15693_CODEC_TIMER_LOADMOD_CCB_VECT+0x10>
    ad02:	55 c1       	rjmp	.+682    	; 0xafae <isr_ISO15693_CODEC_TIMER_LOADMOD_CCB_VECT+0x2ba>
        goto *JumpTable[StateRegister];
    ad04:	e1 b1       	in	r30, 0x01	; 1
    ad06:	f0 e0       	ldi	r31, 0x00	; 0
    ad08:	ee 0f       	add	r30, r30
    ad0a:	ff 1f       	adc	r31, r31
    ad0c:	e8 54       	subi	r30, 0x48	; 72
    ad0e:	fc 4d       	sbci	r31, 0xDC	; 220
    ad10:	01 90       	ld	r0, Z+
    ad12:	f0 81       	ld	r31, Z
    ad14:	e0 2d       	mov	r30, r0
    ad16:	19 94       	eijmp
    CODEC_SUBCARRIER_TIMER.PER = Divider - 1;
}

INLINE void CodecStartSubcarrier(void)
{
    CODEC_SUBCARRIER_TIMER.CTRLA = CODEC_TIMER_CARRIER_CLKSEL;
    ad18:	8e e0       	ldi	r24, 0x0E	; 14
    ad1a:	80 93 40 08 	sts	0x0840, r24
        return;
    }
    
    LOADMOD_START_SINGLE_LABEL:
        CodecStartSubcarrier();
        ShiftRegister = SOF_PATTERN;  
    ad1e:	8d e1       	ldi	r24, 0x1D	; 29
    ad20:	80 93 44 2e 	sts	0x2E44, r24
        BitSent = 0;
    ad24:	14 b8       	out	0x04, r1	; 4
    ad26:	15 b8       	out	0x05, r1	; 5
        // fallthrough
    LOADMOD_SOF_SINGLE_LABEL:
        if (ShiftRegister & 0x80) {
    ad28:	80 91 44 2e 	lds	r24, 0x2E44
    ad2c:	87 ff       	sbrs	r24, 7
    ad2e:	02 c0       	rjmp	.+4      	; 0xad34 <isr_ISO15693_CODEC_TIMER_LOADMOD_CCB_VECT+0x40>
    }
}

INLINE void CodecSetLoadmodState(bool bOnOff) {
    if (bOnOff) {
        VPORT0.OUT |= CODEC_LOADMOD_MASK;
    ad30:	8e 9a       	sbi	0x11, 6	; 17
    ad32:	01 c0       	rjmp	.+2      	; 0xad36 <isr_ISO15693_CODEC_TIMER_LOADMOD_CCB_VECT+0x42>
    } else {
        VPORT0.OUT &= ~CODEC_LOADMOD_MASK;
    ad34:	8e 98       	cbi	0x11, 6	; 17
            CodecSetLoadmodState(true);
        } else {
            CodecSetLoadmodState(false);
        }

        ShiftRegister <<= 1;
    ad36:	80 91 44 2e 	lds	r24, 0x2E44
    ad3a:	88 0f       	add	r24, r24
    ad3c:	80 93 44 2e 	sts	0x2E44, r24
        BitSent++;
    ad40:	84 b1       	in	r24, 0x04	; 4
    ad42:	95 b1       	in	r25, 0x05	; 5
    ad44:	01 96       	adiw	r24, 0x01	; 1
    ad46:	84 b9       	out	0x04, r24	; 4
    ad48:	95 b9       	out	0x05, r25	; 5

        if ( (BitSent % 8) == 0) {
    ad4a:	84 b1       	in	r24, 0x04	; 4
    ad4c:	95 b1       	in	r25, 0x05	; 5
    ad4e:	87 70       	andi	r24, 0x07	; 7
    ad50:	99 27       	eor	r25, r25
    ad52:	89 2b       	or	r24, r25
    ad54:	11 f4       	brne	.+4      	; 0xad5a <isr_ISO15693_CODEC_TIMER_LOADMOD_CCB_VECT+0x66>
            /* Last SOF bit has been put out. Start sending out data */
            StateRegister = LOADMOD_BIT0_SINGLE;
    ad56:	83 e0       	ldi	r24, 0x03	; 3
    ad58:	82 c0       	rjmp	.+260    	; 0xae5e <isr_ISO15693_CODEC_TIMER_LOADMOD_CCB_VECT+0x16a>
            ShiftRegister = (*CodecBufferPtr++);
        } else {
            StateRegister = LOADMOD_SOF_SINGLE;
    ad5a:	82 e0       	ldi	r24, 0x02	; 2
    ad5c:	1b c1       	rjmp	.+566    	; 0xaf94 <isr_ISO15693_CODEC_TIMER_LOADMOD_CCB_VECT+0x2a0>
        }
    return;
    
    LOADMOD_BIT0_SINGLE_LABEL: //Manchester encoding
        if (ShiftRegister & 0x01) {
    ad5e:	80 91 44 2e 	lds	r24, 0x2E44
    ad62:	80 ff       	sbrs	r24, 0
    ad64:	02 c0       	rjmp	.+4      	; 0xad6a <isr_ISO15693_CODEC_TIMER_LOADMOD_CCB_VECT+0x76>
    ad66:	8e 98       	cbi	0x11, 6	; 17
    ad68:	01 c0       	rjmp	.+2      	; 0xad6c <isr_ISO15693_CODEC_TIMER_LOADMOD_CCB_VECT+0x78>
    }
}

INLINE void CodecSetLoadmodState(bool bOnOff) {
    if (bOnOff) {
        VPORT0.OUT |= CODEC_LOADMOD_MASK;
    ad6a:	8e 9a       	sbi	0x11, 6	; 17
        } else {
            /* Activate carrier */
            CodecSetLoadmodState(true);
        }

        StateRegister = LOADMOD_BIT1_SINGLE;
    ad6c:	84 e0       	ldi	r24, 0x04	; 4
    ad6e:	12 c1       	rjmp	.+548    	; 0xaf94 <isr_ISO15693_CODEC_TIMER_LOADMOD_CCB_VECT+0x2a0>
    return;
    
    LOADMOD_BIT1_SINGLE_LABEL: //Manchester encoding
        if (ShiftRegister & 0x01) {
    ad70:	80 91 44 2e 	lds	r24, 0x2E44
    ad74:	80 ff       	sbrs	r24, 0
    ad76:	02 c0       	rjmp	.+4      	; 0xad7c <isr_ISO15693_CODEC_TIMER_LOADMOD_CCB_VECT+0x88>
    ad78:	8e 9a       	sbi	0x11, 6	; 17
    ad7a:	01 c0       	rjmp	.+2      	; 0xad7e <isr_ISO15693_CODEC_TIMER_LOADMOD_CCB_VECT+0x8a>
    } else {
        VPORT0.OUT &= ~CODEC_LOADMOD_MASK;
    ad7c:	8e 98       	cbi	0x11, 6	; 17
            CodecSetLoadmodState(true);
        } else {
            CodecSetLoadmodState(false);
        }

        ShiftRegister >>= 1;
    ad7e:	80 91 44 2e 	lds	r24, 0x2E44
    ad82:	86 95       	lsr	r24
    ad84:	80 93 44 2e 	sts	0x2E44, r24
        BitSent++;
    ad88:	84 b1       	in	r24, 0x04	; 4
    ad8a:	95 b1       	in	r25, 0x05	; 5
    ad8c:	01 96       	adiw	r24, 0x01	; 1
    ad8e:	84 b9       	out	0x04, r24	; 4
    ad90:	95 b9       	out	0x05, r25	; 5

        StateRegister = LOADMOD_BIT0_SINGLE;
    ad92:	83 e0       	ldi	r24, 0x03	; 3
    ad94:	81 b9       	out	0x01, r24	; 1

        if ( (BitSent % 8) == 0 ) {
    ad96:	84 b1       	in	r24, 0x04	; 4
    ad98:	95 b1       	in	r25, 0x05	; 5
    ad9a:	87 70       	andi	r24, 0x07	; 7
    ad9c:	99 27       	eor	r25, r25
    ad9e:	89 2b       	or	r24, r25
    ada0:	09 f0       	breq	.+2      	; 0xada4 <isr_ISO15693_CODEC_TIMER_LOADMOD_CCB_VECT+0xb0>
    ada2:	05 c1       	rjmp	.+522    	; 0xafae <isr_ISO15693_CODEC_TIMER_LOADMOD_CCB_VECT+0x2ba>
            /* Byte boundary */
            if (--ByteCount == 0) {
    ada4:	80 91 43 2e 	lds	r24, 0x2E43
    ada8:	81 50       	subi	r24, 0x01	; 1
    adaa:	80 93 43 2e 	sts	0x2E43, r24
    adae:	81 11       	cpse	r24, r1
    adb0:	b6 c0       	rjmp	.+364    	; 0xaf1e <isr_ISO15693_CODEC_TIMER_LOADMOD_CCB_VECT+0x22a>
                /* No more data left */
                ShiftRegister = EOF_PATTERN;
    adb2:	88 eb       	ldi	r24, 0xB8	; 184
    adb4:	80 93 44 2e 	sts	0x2E44, r24
    adb8:	18 c0       	rjmp	.+48     	; 0xadea <isr_ISO15693_CODEC_TIMER_LOADMOD_CCB_VECT+0xf6>
        }
    return;
    
    LOADMOD_EOF_SINGLE_LABEL: //End of Manchester encoding
        /* Output EOF */
        if (ShiftRegister & 0x80) {
    adba:	80 91 44 2e 	lds	r24, 0x2E44
    adbe:	87 ff       	sbrs	r24, 7
    adc0:	02 c0       	rjmp	.+4      	; 0xadc6 <isr_ISO15693_CODEC_TIMER_LOADMOD_CCB_VECT+0xd2>
    }
}

INLINE void CodecSetLoadmodState(bool bOnOff) {
    if (bOnOff) {
        VPORT0.OUT |= CODEC_LOADMOD_MASK;
    adc2:	8e 9a       	sbi	0x11, 6	; 17
    adc4:	01 c0       	rjmp	.+2      	; 0xadc8 <isr_ISO15693_CODEC_TIMER_LOADMOD_CCB_VECT+0xd4>
    } else {
        VPORT0.OUT &= ~CODEC_LOADMOD_MASK;
    adc6:	8e 98       	cbi	0x11, 6	; 17
            CodecSetLoadmodState(true);
        } else {
            CodecSetLoadmodState(false);
        }

        ShiftRegister <<= 1;
    adc8:	80 91 44 2e 	lds	r24, 0x2E44
    adcc:	88 0f       	add	r24, r24
    adce:	80 93 44 2e 	sts	0x2E44, r24
        BitSent++;
    add2:	84 b1       	in	r24, 0x04	; 4
    add4:	95 b1       	in	r25, 0x05	; 5
    add6:	01 96       	adiw	r24, 0x01	; 1
    add8:	84 b9       	out	0x04, r24	; 4
    adda:	95 b9       	out	0x05, r25	; 5

        if ( (BitSent % 8) == 0) {
    addc:	84 b1       	in	r24, 0x04	; 4
    adde:	95 b1       	in	r25, 0x05	; 5
    ade0:	87 70       	andi	r24, 0x07	; 7
    ade2:	99 27       	eor	r25, r25
    ade4:	89 2b       	or	r24, r25
    ade6:	09 f4       	brne	.+2      	; 0xadea <isr_ISO15693_CODEC_TIMER_LOADMOD_CCB_VECT+0xf6>
    ade8:	d2 c0       	rjmp	.+420    	; 0xaf8e <isr_ISO15693_CODEC_TIMER_LOADMOD_CCB_VECT+0x29a>
            /* Last bit has been put out */
            StateRegister = LOADMOD_FINISHED;
        } else {
            StateRegister = LOADMOD_EOF_SINGLE;
    adea:	85 e0       	ldi	r24, 0x05	; 5
    adec:	d3 c0       	rjmp	.+422    	; 0xaf94 <isr_ISO15693_CODEC_TIMER_LOADMOD_CCB_VECT+0x2a0>
    CODEC_SUBCARRIER_TIMER.PER = Divider - 1;
}

INLINE void CodecStartSubcarrier(void)
{
    CODEC_SUBCARRIER_TIMER.CTRLA = CODEC_TIMER_CARRIER_CLKSEL;
    adee:	8e e0       	ldi	r24, 0x0E	; 14
    adf0:	80 93 40 08 	sts	0x0840, r24

   // ------------------------------------------------------------- 
   
   LOADMOD_START_DUAL_LABEL:
        CodecStartSubcarrier();
        ShiftRegister = SOF_PATTERN;
    adf4:	8d e1       	ldi	r24, 0x1D	; 29
    adf6:	80 93 44 2e 	sts	0x2E44, r24
        BitSent = 0;
    adfa:	14 b8       	out	0x04, r1	; 4
    adfc:	15 b8       	out	0x05, r1	; 5
    }
}

INLINE void CodecSetLoadmodState(bool bOnOff) {
    if (bOnOff) {
        VPORT0.OUT |= CODEC_LOADMOD_MASK;
    adfe:	8e 9a       	sbi	0x11, 6	; 17
        CodecSetLoadmodState(true);
        // fallthrough
    LOADMOD_SOF_DUAL_LABEL:
        if (ShiftRegister & 0x80) {
    ae00:	80 91 44 2e 	lds	r24, 0x2E44
    ae04:	87 ff       	sbrs	r24, 7
    ae06:	0b c0       	rjmp	.+22     	; 0xae1e <isr_ISO15693_CODEC_TIMER_LOADMOD_CCB_VECT+0x12a>
    }
}

INLINE void CodecChangeDivider(uint16_t Divider)
{
    CODEC_SUBCARRIER_TIMER.PER = Divider - 1;
    ae08:	8f e1       	ldi	r24, 0x1F	; 31
    ae0a:	90 e0       	ldi	r25, 0x00	; 0
    ae0c:	80 93 66 08 	sts	0x0866, r24
    ae10:	90 93 67 08 	sts	0x0867, r25
            CodecChangeDivider(SUBCARRIER_1);
            CODEC_TIMER_LOADMOD.PER = BitRate1 - 1;
    ae14:	80 91 41 2e 	lds	r24, 0x2E41
    ae18:	90 91 42 2e 	lds	r25, 0x2E42
    ae1c:	0a c0       	rjmp	.+20     	; 0xae32 <isr_ISO15693_CODEC_TIMER_LOADMOD_CCB_VECT+0x13e>
    ae1e:	8b e1       	ldi	r24, 0x1B	; 27
    ae20:	90 e0       	ldi	r25, 0x00	; 0
    ae22:	80 93 66 08 	sts	0x0866, r24
    ae26:	90 93 67 08 	sts	0x0867, r25
        } else {
            CodecChangeDivider(SUBCARRIER_2);
            CODEC_TIMER_LOADMOD.PER = BitRate2 - 1;
    ae2a:	80 91 3f 2e 	lds	r24, 0x2E3F
    ae2e:	90 91 40 2e 	lds	r25, 0x2E40
    ae32:	01 97       	sbiw	r24, 0x01	; 1
    ae34:	80 93 26 0a 	sts	0x0A26, r24
    ae38:	90 93 27 0a 	sts	0x0A27, r25
        }

        ShiftRegister <<= 1;
    ae3c:	80 91 44 2e 	lds	r24, 0x2E44
    ae40:	88 0f       	add	r24, r24
    ae42:	80 93 44 2e 	sts	0x2E44, r24
        BitSent++;
    ae46:	84 b1       	in	r24, 0x04	; 4
    ae48:	95 b1       	in	r25, 0x05	; 5
    ae4a:	01 96       	adiw	r24, 0x01	; 1
    ae4c:	84 b9       	out	0x04, r24	; 4
    ae4e:	95 b9       	out	0x05, r25	; 5

        if ( (BitSent % 8) == 0) {
    ae50:	84 b1       	in	r24, 0x04	; 4
    ae52:	95 b1       	in	r25, 0x05	; 5
    ae54:	87 70       	andi	r24, 0x07	; 7
    ae56:	99 27       	eor	r25, r25
    ae58:	89 2b       	or	r24, r25
    ae5a:	19 f4       	brne	.+6      	; 0xae62 <isr_ISO15693_CODEC_TIMER_LOADMOD_CCB_VECT+0x16e>
            /* Last SOF bit has been put out. Start sending out data */
            StateRegister = LOADMOD_BIT0_DUAL;
    ae5c:	88 e0       	ldi	r24, 0x08	; 8
    ae5e:	81 b9       	out	0x01, r24	; 1
    ae60:	5e c0       	rjmp	.+188    	; 0xaf1e <isr_ISO15693_CODEC_TIMER_LOADMOD_CCB_VECT+0x22a>
            ShiftRegister = (*CodecBufferPtr++);
        } else {
            StateRegister = LOADMOD_SOF_DUAL;
    ae62:	87 e0       	ldi	r24, 0x07	; 7
    ae64:	97 c0       	rjmp	.+302    	; 0xaf94 <isr_ISO15693_CODEC_TIMER_LOADMOD_CCB_VECT+0x2a0>
        }
    return;

    LOADMOD_BIT0_DUAL_LABEL: //Manchester encoding
        if (ShiftRegister & 0x01) {
    ae66:	80 91 44 2e 	lds	r24, 0x2E44
    ae6a:	80 ff       	sbrs	r24, 0
    ae6c:	0b c0       	rjmp	.+22     	; 0xae84 <isr_ISO15693_CODEC_TIMER_LOADMOD_CCB_VECT+0x190>
    ae6e:	8b e1       	ldi	r24, 0x1B	; 27
    ae70:	90 e0       	ldi	r25, 0x00	; 0
    ae72:	80 93 66 08 	sts	0x0866, r24
    ae76:	90 93 67 08 	sts	0x0867, r25
            CodecChangeDivider(SUBCARRIER_2);
            CODEC_TIMER_LOADMOD.PER = BitRate2 - 1;
    ae7a:	80 91 3f 2e 	lds	r24, 0x2E3F
    ae7e:	90 91 40 2e 	lds	r25, 0x2E40
    ae82:	0a c0       	rjmp	.+20     	; 0xae98 <isr_ISO15693_CODEC_TIMER_LOADMOD_CCB_VECT+0x1a4>
    ae84:	8f e1       	ldi	r24, 0x1F	; 31
    ae86:	90 e0       	ldi	r25, 0x00	; 0
    ae88:	80 93 66 08 	sts	0x0866, r24
    ae8c:	90 93 67 08 	sts	0x0867, r25
        } else {
            CodecChangeDivider(SUBCARRIER_1);
            CODEC_TIMER_LOADMOD.PER = BitRate1 - 1;
    ae90:	80 91 41 2e 	lds	r24, 0x2E41
    ae94:	90 91 42 2e 	lds	r25, 0x2E42
    ae98:	01 97       	sbiw	r24, 0x01	; 1
    ae9a:	80 93 26 0a 	sts	0x0A26, r24
    ae9e:	90 93 27 0a 	sts	0x0A27, r25
        }

        StateRegister = LOADMOD_BIT1_DUAL;
    aea2:	89 e0       	ldi	r24, 0x09	; 9
    aea4:	77 c0       	rjmp	.+238    	; 0xaf94 <isr_ISO15693_CODEC_TIMER_LOADMOD_CCB_VECT+0x2a0>
    return;

    LOADMOD_BIT1_DUAL_LABEL: //Manchester encoding
        if (ShiftRegister & 0x01) {
    aea6:	80 91 44 2e 	lds	r24, 0x2E44
    aeaa:	80 ff       	sbrs	r24, 0
    aeac:	0b c0       	rjmp	.+22     	; 0xaec4 <isr_ISO15693_CODEC_TIMER_LOADMOD_CCB_VECT+0x1d0>
    aeae:	8f e1       	ldi	r24, 0x1F	; 31
    aeb0:	90 e0       	ldi	r25, 0x00	; 0
    aeb2:	80 93 66 08 	sts	0x0866, r24
    aeb6:	90 93 67 08 	sts	0x0867, r25
            /* fc / 32 */
            CodecChangeDivider(SUBCARRIER_1);
            CODEC_TIMER_LOADMOD.PER = BitRate1 - 1;
    aeba:	80 91 41 2e 	lds	r24, 0x2E41
    aebe:	90 91 42 2e 	lds	r25, 0x2E42
    aec2:	0a c0       	rjmp	.+20     	; 0xaed8 <isr_ISO15693_CODEC_TIMER_LOADMOD_CCB_VECT+0x1e4>
    aec4:	8b e1       	ldi	r24, 0x1B	; 27
    aec6:	90 e0       	ldi	r25, 0x00	; 0
    aec8:	80 93 66 08 	sts	0x0866, r24
    aecc:	90 93 67 08 	sts	0x0867, r25
        } else {
            /* fc / 28 */
            CodecChangeDivider(SUBCARRIER_2);
            CODEC_TIMER_LOADMOD.PER = BitRate2 - 1;
    aed0:	80 91 3f 2e 	lds	r24, 0x2E3F
    aed4:	90 91 40 2e 	lds	r25, 0x2E40
    aed8:	01 97       	sbiw	r24, 0x01	; 1
    aeda:	80 93 26 0a 	sts	0x0A26, r24
    aede:	90 93 27 0a 	sts	0x0A27, r25
        }

        ShiftRegister >>= 1;
    aee2:	80 91 44 2e 	lds	r24, 0x2E44
    aee6:	86 95       	lsr	r24
    aee8:	80 93 44 2e 	sts	0x2E44, r24
        BitSent++;
    aeec:	84 b1       	in	r24, 0x04	; 4
    aeee:	95 b1       	in	r25, 0x05	; 5
    aef0:	01 96       	adiw	r24, 0x01	; 1
    aef2:	84 b9       	out	0x04, r24	; 4
    aef4:	95 b9       	out	0x05, r25	; 5

        StateRegister = LOADMOD_BIT0_DUAL;
    aef6:	88 e0       	ldi	r24, 0x08	; 8
    aef8:	81 b9       	out	0x01, r24	; 1

        if ( (BitSent % 8) == 0 ) {
    aefa:	84 b1       	in	r24, 0x04	; 4
    aefc:	95 b1       	in	r25, 0x05	; 5
    aefe:	87 70       	andi	r24, 0x07	; 7
    af00:	99 27       	eor	r25, r25
    af02:	89 2b       	or	r24, r25
    af04:	09 f0       	breq	.+2      	; 0xaf08 <isr_ISO15693_CODEC_TIMER_LOADMOD_CCB_VECT+0x214>
    af06:	53 c0       	rjmp	.+166    	; 0xafae <isr_ISO15693_CODEC_TIMER_LOADMOD_CCB_VECT+0x2ba>
            /* Byte boundary */
            if (--ByteCount == 0) {
    af08:	80 91 43 2e 	lds	r24, 0x2E43
    af0c:	81 50       	subi	r24, 0x01	; 1
    af0e:	80 93 43 2e 	sts	0x2E43, r24
    af12:	81 11       	cpse	r24, r1
    af14:	04 c0       	rjmp	.+8      	; 0xaf1e <isr_ISO15693_CODEC_TIMER_LOADMOD_CCB_VECT+0x22a>
                /* No more data left */
                ShiftRegister = EOF_PATTERN;
    af16:	88 eb       	ldi	r24, 0xB8	; 184
    af18:	80 93 44 2e 	sts	0x2E44, r24
    af1c:	3a c0       	rjmp	.+116    	; 0xaf92 <isr_ISO15693_CODEC_TIMER_LOADMOD_CCB_VECT+0x29e>
                StateRegister = LOADMOD_EOF_DUAL;
            } else {
                ShiftRegister = (*CodecBufferPtr++);
    af1e:	e8 b1       	in	r30, 0x08	; 8
    af20:	f9 b1       	in	r31, 0x09	; 9
    af22:	cf 01       	movw	r24, r30
    af24:	01 96       	adiw	r24, 0x01	; 1
    af26:	88 b9       	out	0x08, r24	; 8
    af28:	99 b9       	out	0x09, r25	; 9
    af2a:	80 81       	ld	r24, Z
    af2c:	80 93 44 2e 	sts	0x2E44, r24
    af30:	08 95       	ret
        }
    return;

    LOADMOD_EOF_DUAL_LABEL: //End of Manchester encoding
        /* Output EOF */
        if (ShiftRegister & 0x80) {
    af32:	80 91 44 2e 	lds	r24, 0x2E44
    af36:	87 ff       	sbrs	r24, 7
    af38:	0b c0       	rjmp	.+22     	; 0xaf50 <isr_ISO15693_CODEC_TIMER_LOADMOD_CCB_VECT+0x25c>
    af3a:	8f e1       	ldi	r24, 0x1F	; 31
    af3c:	90 e0       	ldi	r25, 0x00	; 0
    af3e:	80 93 66 08 	sts	0x0866, r24
    af42:	90 93 67 08 	sts	0x0867, r25
            CodecChangeDivider(SUBCARRIER_1);
            CODEC_TIMER_LOADMOD.PER = BitRate1 - 1;
    af46:	80 91 41 2e 	lds	r24, 0x2E41
    af4a:	90 91 42 2e 	lds	r25, 0x2E42
    af4e:	0a c0       	rjmp	.+20     	; 0xaf64 <isr_ISO15693_CODEC_TIMER_LOADMOD_CCB_VECT+0x270>
    af50:	8b e1       	ldi	r24, 0x1B	; 27
    af52:	90 e0       	ldi	r25, 0x00	; 0
    af54:	80 93 66 08 	sts	0x0866, r24
    af58:	90 93 67 08 	sts	0x0867, r25
        } else {
            CodecChangeDivider(SUBCARRIER_2);
            CODEC_TIMER_LOADMOD.PER = BitRate2 - 1;
    af5c:	80 91 3f 2e 	lds	r24, 0x2E3F
    af60:	90 91 40 2e 	lds	r25, 0x2E40
    af64:	01 97       	sbiw	r24, 0x01	; 1
    af66:	80 93 26 0a 	sts	0x0A26, r24
    af6a:	90 93 27 0a 	sts	0x0A27, r25
        }

        ShiftRegister <<= 1;
    af6e:	80 91 44 2e 	lds	r24, 0x2E44
    af72:	88 0f       	add	r24, r24
    af74:	80 93 44 2e 	sts	0x2E44, r24
        BitSent++;
    af78:	84 b1       	in	r24, 0x04	; 4
    af7a:	95 b1       	in	r25, 0x05	; 5
    af7c:	01 96       	adiw	r24, 0x01	; 1
    af7e:	84 b9       	out	0x04, r24	; 4
    af80:	95 b9       	out	0x05, r25	; 5

        if ( (BitSent % 8) == 0) {
    af82:	84 b1       	in	r24, 0x04	; 4
    af84:	95 b1       	in	r25, 0x05	; 5
    af86:	87 70       	andi	r24, 0x07	; 7
    af88:	99 27       	eor	r25, r25
    af8a:	89 2b       	or	r24, r25
    af8c:	11 f4       	brne	.+4      	; 0xaf92 <isr_ISO15693_CODEC_TIMER_LOADMOD_CCB_VECT+0x29e>
            /* Last bit has been put out */
            StateRegister = LOADMOD_FINISHED;
    af8e:	8b e0       	ldi	r24, 0x0B	; 11
    af90:	01 c0       	rjmp	.+2      	; 0xaf94 <isr_ISO15693_CODEC_TIMER_LOADMOD_CCB_VECT+0x2a0>
        } else {
            StateRegister = LOADMOD_EOF_DUAL;
    af92:	8a e0       	ldi	r24, 0x0A	; 10
    af94:	81 b9       	out	0x01, r24	; 1
    af96:	08 95       	ret
        }
    return;

    LOADMOD_FINISHED_LABEL:
        CODEC_TIMER_LOADMOD.CTRLA = TC_CLKSEL_OFF_gc;
    af98:	10 92 00 0a 	sts	0x0A00, r1
        CODEC_TIMER_LOADMOD.INTCTRLB = 0;
    af9c:	10 92 07 0a 	sts	0x0A07, r1
}

INLINE void CodecSetSubcarrier(SubcarrierModType ModType, uint16_t Divider)
{
    if (ModType == CODEC_SUBCARRIERMOD_OFF) {
        CODEC_SUBCARRIER_TIMER.CTRLA = TC_CLKSEL_OFF_gc;
    afa0:	10 92 40 08 	sts	0x0840, r1
        CODEC_SUBCARRIER_TIMER.CTRLB = 0;
    afa4:	10 92 41 08 	sts	0x0841, r1
        CodecSetSubcarrier(CODEC_SUBCARRIERMOD_OFF, SUBCARRIER_1);
        Flags.LoadmodFinished = 1;
    afa8:	81 e0       	ldi	r24, 0x01	; 1
    afaa:	80 93 48 2e 	sts	0x2E48, r24
    afae:	08 95       	ret

0000afb0 <StartISO15693Demod>:

#endif /* CONFIG_VICINITY_SUPPORT */

void StartISO15693Demod(void) {
    
    CodecBufferPtr = CodecBuffer;
    afb0:	83 ed       	ldi	r24, 0xD3	; 211
    afb2:	91 e3       	ldi	r25, 0x31	; 49
    afb4:	88 b9       	out	0x08, r24	; 8
    afb6:	99 b9       	out	0x09, r25	; 9
    Flags.DemodFinished = 0;
    afb8:	e7 e4       	ldi	r30, 0x47	; 71
    afba:	fe e2       	ldi	r31, 0x2E	; 46
    afbc:	10 82       	st	Z, r1
    Flags.LoadmodFinished = 0;
    afbe:	11 82       	std	Z+1, r1	; 0x01
    DemodState = DEMOD_SOC_STATE;
    afc0:	10 92 45 2e 	sts	0x2E45, r1
    DataRegister = 0;
    afc4:	10 b8       	out	0x00, r1	; 0
    SampleRegister = 0;
    afc6:	13 b8       	out	0x03, r1	; 3
    BitSampleCount = 0;
    afc8:	16 b8       	out	0x06, r1	; 6
    afca:	17 b8       	out	0x07, r1	; 7
    SampleDataCount = 0;
    afcc:	10 92 3d 2e 	sts	0x2E3D, r1
    afd0:	10 92 3e 2e 	sts	0x2E3E, r1
    ModulationPauseCount = 0;
    afd4:	12 b8       	out	0x02, r1	; 2
    ByteCount = 0;
    afd6:	10 92 43 2e 	sts	0x2E43, r1
    ShiftRegister = 0;
    afda:	10 92 44 2e 	sts	0x2E44, r1
}

INLINE void CodecSetDemodPower(bool bOnOff)
{
    if (bOnOff) {
        CODEC_DEMOD_POWER_PORT.OUTSET = CODEC_DEMOD_POWER_MASK;
    afde:	a0 e2       	ldi	r26, 0x20	; 32
    afe0:	b6 e0       	ldi	r27, 0x06	; 6
    afe2:	81 e0       	ldi	r24, 0x01	; 1
    afe4:	15 96       	adiw	r26, 0x05	; 5
    afe6:	8c 93       	st	X, r24
    afe8:	15 97       	sbiw	r26, 0x05	; 5
    
    CodecSetDemodPower(true);

    /* Configure sampling-timer free running and sync to first modulation-pause. */
    CODEC_TIMER_SAMPLING.CNT = 0;
    afea:	e0 e0       	ldi	r30, 0x00	; 0
    afec:	f9 e0       	ldi	r31, 0x09	; 9
    afee:	10 a2       	std	Z+32, r1	; 0x20
    aff0:	11 a2       	std	Z+33, r1	; 0x21
    CODEC_TIMER_SAMPLING.PER = ISO15693_SAMPLE_PERIOD - 1; 
    aff2:	8f e7       	ldi	r24, 0x7F	; 127
    aff4:	90 e0       	ldi	r25, 0x00	; 0
    aff6:	86 a3       	std	Z+38, r24	; 0x26
    aff8:	97 a3       	std	Z+39, r25	; 0x27
    CODEC_TIMER_SAMPLING.CCC = ISO15693_SAMPLE_PERIOD / 2 - 14 - 1; /* Half bit. ISR compensate*/
    affa:	81 e3       	ldi	r24, 0x31	; 49
    affc:	90 e0       	ldi	r25, 0x00	; 0
    affe:	84 a7       	std	Z+44, r24	; 0x2c
    b000:	95 a7       	std	Z+45, r25	; 0x2d
    CODEC_TIMER_SAMPLING.CTRLA = ISO15693_SAMPLE_CLK;
    b002:	82 e0       	ldi	r24, 0x02	; 2
    b004:	80 83       	st	Z, r24
    CODEC_TIMER_SAMPLING.CTRLD = TC_EVACT_RESTART_gc | CODEC_TIMER_MODSTART_EVSEL;
    b006:	98 e8       	ldi	r25, 0x88	; 136
    b008:	93 83       	std	Z+3, r25	; 0x03
    CODEC_TIMER_SAMPLING.INTFLAGS = TC0_CCCIF_bm;
    b00a:	20 e4       	ldi	r18, 0x40	; 64
    b00c:	24 87       	std	Z+12, r18	; 0x0c
    CODEC_TIMER_SAMPLING.INTCTRLB = TC_CCCINTLVL_OFF_gc;
    b00e:	17 82       	std	Z+7, r1	; 0x07

    CODEC_TIMER_LOADMOD.CTRLD = TC_EVACT_RESTART_gc | CODEC_TIMER_MODSTART_EVSEL;
    b010:	e0 e0       	ldi	r30, 0x00	; 0
    b012:	fa e0       	ldi	r31, 0x0A	; 10
    b014:	93 83       	std	Z+3, r25	; 0x03
    CODEC_TIMER_LOADMOD.PER = 4192 + 128 + 128 - 1;
    b016:	2f e5       	ldi	r18, 0x5F	; 95
    b018:	31 e1       	ldi	r19, 0x11	; 17
    b01a:	26 a3       	std	Z+38, r18	; 0x26
    b01c:	37 a3       	std	Z+39, r19	; 0x27
    CODEC_TIMER_LOADMOD.INTCTRLA = 0;
    b01e:	16 82       	std	Z+6, r1	; 0x06
    CODEC_TIMER_LOADMOD.INTCTRLB = 0;
    b020:	17 82       	std	Z+7, r1	; 0x07
    CODEC_TIMER_LOADMOD.CTRLA = TC_CLKSEL_EVCH6_gc;
    b022:	9e e0       	ldi	r25, 0x0E	; 14
    b024:	90 83       	st	Z, r25

    /* Start looking out for modulation pause via interrupt. */
    CODEC_DEMOD_IN_PORT.INTFLAGS = 0x03;
    b026:	93 e0       	ldi	r25, 0x03	; 3
    b028:	1c 96       	adiw	r26, 0x0c	; 12
    b02a:	9c 93       	st	X, r25
    b02c:	1c 97       	sbiw	r26, 0x0c	; 12
    CODEC_DEMOD_IN_PORT.INT0MASK = CODEC_DEMOD_IN_MASK0;
    b02e:	1a 96       	adiw	r26, 0x0a	; 10
    b030:	8c 93       	st	X, r24
    b032:	08 95       	ret

0000b034 <ISO15693CodecInit>:
}

void ISO15693CodecInit(void) 
{
    b034:	cf 93       	push	r28
    b036:	df 93       	push	r29
{
    /* Configure CARRIER input pin and route it to EVSYS.
     * Multiply by 2 again by using both edges when externally
     * dividing by 2 */
#if CODEC_CARRIER_IN_DIV == 2
    CODEC_CARRIER_IN_PORT.CODEC_CARRIER_IN_PINCTRL = PORT_ISC_BOTHEDGES_gc;
    b038:	e0 e4       	ldi	r30, 0x40	; 64
    b03a:	f6 e0       	ldi	r31, 0x06	; 6
    b03c:	12 8a       	std	Z+18, r1	; 0x12
#else
#error Option not supported
#endif
    CODEC_CARRIER_IN_PORT.DIRCLR = CODEC_CARRIER_IN_MASK;
    b03e:	84 e0       	ldi	r24, 0x04	; 4
    b040:	82 83       	std	Z+2, r24	; 0x02
    EVSYS.CH6MUX = CODEC_CARRIER_IN_EVMUX;
    b042:	c0 e8       	ldi	r28, 0x80	; 128
    b044:	d1 e0       	ldi	r29, 0x01	; 1
    b046:	82 e6       	ldi	r24, 0x62	; 98
    b048:	8e 83       	std	Y+6, r24	; 0x06

    /* Configure two DEMOD pins for input.
     * Configure event channel 0 for rising edge (begin of modulation pause)
     * Configure event channel 1 for falling edge (end of modulation pause) */
    CODEC_DEMOD_POWER_PORT.OUTCLR = CODEC_DEMOD_POWER_MASK;
    b04a:	a0 e2       	ldi	r26, 0x20	; 32
    b04c:	b6 e0       	ldi	r27, 0x06	; 6
    b04e:	81 e0       	ldi	r24, 0x01	; 1
    b050:	16 96       	adiw	r26, 0x06	; 6
    b052:	8c 93       	st	X, r24
    b054:	16 97       	sbiw	r26, 0x06	; 6
    CODEC_DEMOD_POWER_PORT.DIRSET = CODEC_DEMOD_POWER_MASK;
    b056:	11 96       	adiw	r26, 0x01	; 1
    b058:	8c 93       	st	X, r24
    b05a:	11 97       	sbiw	r26, 0x01	; 1
    CODEC_DEMOD_IN_PORT.DIRCLR = CODEC_DEMOD_IN_MASK;
    b05c:	96 e0       	ldi	r25, 0x06	; 6
    b05e:	12 96       	adiw	r26, 0x02	; 2
    b060:	9c 93       	st	X, r25
    b062:	12 97       	sbiw	r26, 0x02	; 2
    CODEC_DEMOD_IN_PORT.CODEC_DEMOD_IN_PINCTRL0 = PORT_ISC_RISING_gc;
    b064:	51 96       	adiw	r26, 0x11	; 17
    b066:	8c 93       	st	X, r24
    b068:	51 97       	sbiw	r26, 0x11	; 17
    CODEC_DEMOD_IN_PORT.CODEC_DEMOD_IN_PINCTRL1 = PORT_ISC_FALLING_gc;
    b06a:	32 e0       	ldi	r19, 0x02	; 2
    b06c:	52 96       	adiw	r26, 0x12	; 18
    b06e:	3c 93       	st	X, r19
    b070:	52 97       	sbiw	r26, 0x12	; 18
    CODEC_DEMOD_IN_PORT.INT0MASK = 0;
    b072:	1a 96       	adiw	r26, 0x0a	; 10
    b074:	1c 92       	st	X, r1
    b076:	1a 97       	sbiw	r26, 0x0a	; 10
    CODEC_DEMOD_IN_PORT.INT1MASK = 0;
    b078:	1b 96       	adiw	r26, 0x0b	; 11
    b07a:	1c 92       	st	X, r1
    b07c:	1b 97       	sbiw	r26, 0x0b	; 11
    CODEC_DEMOD_IN_PORT.INTCTRL = PORT_INT0LVL_HI_gc | PORT_INT1LVL_HI_gc;
    b07e:	9f e0       	ldi	r25, 0x0F	; 15
    b080:	19 96       	adiw	r26, 0x09	; 9
    b082:	9c 93       	st	X, r25
    EVSYS.CH0MUX = CODEC_DEMOD_IN_EVMUX0;
    b084:	99 e5       	ldi	r25, 0x59	; 89
    b086:	98 83       	st	Y, r25
    EVSYS.CH1MUX = CODEC_DEMOD_IN_EVMUX1;
    b088:	2a e5       	ldi	r18, 0x5A	; 90
    b08a:	29 83       	std	Y+1, r18	; 0x01

    EVSYS.CH2MUX = CODEC_DEMOD_IN_EVMUX0;
    b08c:	9a 83       	std	Y+2, r25	; 0x02


    /* Configure loadmod pin configuration and use a virtual port configuration
     * for single instruction cycle access */
    CODEC_LOADMOD_PORT.DIRSET = CODEC_LOADMOD_MASK;
    b08e:	90 e4       	ldi	r25, 0x40	; 64
    b090:	91 83       	std	Z+1, r25	; 0x01
    CODEC_LOADMOD_PORT.OUTCLR = CODEC_LOADMOD_MASK;
    b092:	96 83       	std	Z+6, r25	; 0x06
    PORTCFG.VPCTRLA &= ~PORTCFG_VP0MAP_gm;
    b094:	a0 eb       	ldi	r26, 0xB0	; 176
    b096:	b0 e0       	ldi	r27, 0x00	; 0
    b098:	12 96       	adiw	r26, 0x02	; 2
    b09a:	2c 91       	ld	r18, X
    b09c:	12 97       	sbiw	r26, 0x02	; 2
    b09e:	20 7f       	andi	r18, 0xF0	; 240
    b0a0:	12 96       	adiw	r26, 0x02	; 2
    b0a2:	2c 93       	st	X, r18
    b0a4:	12 97       	sbiw	r26, 0x02	; 2
    PORTCFG.VPCTRLA |= PORTCFG_VP02MAP_PORTC_gc;
    b0a6:	12 96       	adiw	r26, 0x02	; 2
    b0a8:	2c 91       	ld	r18, X
    b0aa:	12 97       	sbiw	r26, 0x02	; 2
    b0ac:	22 60       	ori	r18, 0x02	; 2
    b0ae:	12 96       	adiw	r26, 0x02	; 2
    b0b0:	2c 93       	st	X, r18

    /* Configure subcarrier pins for output */
    CODEC_SUBCARRIER_PORT.DIRSET = CODEC_SUBCARRIER_MASK;
    b0b2:	20 e3       	ldi	r18, 0x30	; 48
    b0b4:	21 83       	std	Z+1, r18	; 0x01
    CODEC_SUBCARRIER_PORT.OUTCLR = CODEC_SUBCARRIER_MASK;
    b0b6:	26 83       	std	Z+6, r18	; 0x06

    /* Configure pins for reader field with the LEFT output being inverted
     * and all bridge outputs static high */
    CODEC_READER_PORT.CODEC_READER_PINCTRL_LEFT = PORT_INVEN_bm;
    b0b8:	90 8b       	std	Z+16, r25	; 0x10
    CODEC_READER_PORT.OUTCLR = CODEC_READER_MASK_LEFT;
    b0ba:	86 83       	std	Z+6, r24	; 0x06
    CODEC_READER_PORT.OUTSET = CODEC_READER_MASK_RIGHT;
    b0bc:	35 83       	std	Z+5, r19	; 0x05
    CODEC_READER_PORT.DIRSET = CODEC_READER_MASK;
    b0be:	83 e0       	ldi	r24, 0x03	; 3
    b0c0:	81 83       	std	Z+1, r24	; 0x01

    /* Configure timer for generating reader field and configure AWEX for outputting pattern
     * with disabled outputs. */
    CODEC_READER_TIMER.CTRLB = TC0_CCAEN_bm | TC_WGMODE_SINGLESLOPE_gc;
    b0c2:	e0 e0       	ldi	r30, 0x00	; 0
    b0c4:	f8 e0       	ldi	r31, 0x08	; 8
    b0c6:	83 e1       	ldi	r24, 0x13	; 19
    b0c8:	81 83       	std	Z+1, r24	; 0x01
    CODEC_READER_TIMER.PER = F_CPU / CODEC_CARRIER_FREQ - 1;
    b0ca:	21 e0       	ldi	r18, 0x01	; 1
    b0cc:	30 e0       	ldi	r19, 0x00	; 0
    b0ce:	26 a3       	std	Z+38, r18	; 0x26
    b0d0:	37 a3       	std	Z+39, r19	; 0x27
    CODEC_READER_TIMER.CCA = F_CPU / CODEC_CARRIER_FREQ / 2 ;
    b0d2:	20 a7       	std	Z+40, r18	; 0x28
    b0d4:	31 a7       	std	Z+41, r19	; 0x29

    AWEXC.OUTOVEN = 0x00;
    b0d6:	e0 e8       	ldi	r30, 0x80	; 128
    b0d8:	f8 e0       	ldi	r31, 0x08	; 8
    b0da:	14 86       	std	Z+12, r1	; 0x0c
    AWEXC.CTRL = AWEX_CWCM_bm | AWEX_DTICCAEN_bm | AWEX_DTICCBEN_bm;
    b0dc:	80 83       	st	Z, r24

    /* Configure DAC for the reference voltage */
    DACB.EVCTRL = 0;
    b0de:	e0 e2       	ldi	r30, 0x20	; 32
    b0e0:	f3 e0       	ldi	r31, 0x03	; 3
    b0e2:	13 82       	std	Z+3, r1	; 0x03
    DACB.CTRLB = DAC_CHSEL_SINGLE_gc;
    b0e4:	11 82       	std	Z+1, r1	; 0x01
    DACB.CTRLC = DAC_REFSEL_AVCC_gc;
    b0e6:	88 e0       	ldi	r24, 0x08	; 8
    b0e8:	82 83       	std	Z+2, r24	; 0x02
    DACB.CTRLA = DAC_IDOEN_bm | DAC_ENABLE_bm;
    b0ea:	91 e1       	ldi	r25, 0x11	; 17
    b0ec:	90 83       	st	Z, r25
    DACB.CH0DATA = GlobalSettings.ActiveSettingPtr->ReaderThreshold; // real threshold voltage can be calculated with ch0data * Vref / 0xFFF
    b0ee:	a0 91 71 2f 	lds	r26, 0x2F71
    b0f2:	b0 91 72 2f 	lds	r27, 0x2F72
    b0f6:	1a 96       	adiw	r26, 0x0a	; 10
    b0f8:	2d 91       	ld	r18, X+
    b0fa:	3c 91       	ld	r19, X
    b0fc:	1b 97       	sbiw	r26, 0x0b	; 11
    b0fe:	20 8f       	std	Z+24, r18	; 0x18
    b100:	31 8f       	std	Z+25, r19	; 0x19

    /* Configure Analog Comparator 0 to detect changes in demodulated reader field */
    ACA.AC0MUXCTRL = AC_MUXPOS_DAC_gc | AC_MUXNEG_PIN7_gc;
    b102:	e0 e8       	ldi	r30, 0x80	; 128
    b104:	f3 e0       	ldi	r31, 0x03	; 3
    b106:	9c e3       	ldi	r25, 0x3C	; 60
    b108:	92 83       	std	Z+2, r25	; 0x02
    ACA.AC0CTRL = CODEC_AC_DEMOD_SETTINGS;
    b10a:	80 83       	st	Z, r24

    /* Configure Analog Comparator 1 to detect SOC */
    ACA.AC1MUXCTRL = AC_MUXPOS_DAC_gc | AC_MUXNEG_PIN7_gc;
    b10c:	93 83       	std	Z+3, r25	; 0x03
    ACA.AC1CTRL = CODEC_AC_DEMOD_SETTINGS;
    b10e:	81 83       	std	Z+1, r24	; 0x01
    CodecInitCommon();
    isr_func_TCD0_CCC_vect = &isr_ISO15693_CODEC_TIMER_SAMPLING_CCC_VECT;
    b110:	85 e9       	ldi	r24, 0x95	; 149
    b112:	95 e5       	ldi	r25, 0x55	; 85
    b114:	80 93 50 2e 	sts	0x2E50, r24
    b118:	90 93 51 2e 	sts	0x2E51, r25
    isr_func_CODEC_DEMOD_IN_INT0_VECT = &isr_ISO15693_CODEC_DEMOD_IN_INT0_VECT;
    b11c:	8c e8       	ldi	r24, 0x8C	; 140
    b11e:	95 e5       	ldi	r25, 0x55	; 85
    b120:	80 93 52 2f 	sts	0x2F52, r24
    b124:	90 93 53 2f 	sts	0x2F53, r25
    isr_func_CODEC_TIMER_LOADMOD_CCB_VECT = &isr_ISO15693_CODEC_TIMER_LOADMOD_CCB_VECT;
    b128:	8a e7       	ldi	r24, 0x7A	; 122
    b12a:	96 e5       	ldi	r25, 0x56	; 86
    b12c:	80 93 4e 2e 	sts	0x2E4E, r24
    b130:	90 93 4f 2e 	sts	0x2E4F, r25
    StartISO15693Demod();
}
    b134:	df 91       	pop	r29
    b136:	cf 91       	pop	r28
{
    CodecInitCommon();
    isr_func_TCD0_CCC_vect = &isr_ISO15693_CODEC_TIMER_SAMPLING_CCC_VECT;
    isr_func_CODEC_DEMOD_IN_INT0_VECT = &isr_ISO15693_CODEC_DEMOD_IN_INT0_VECT;
    isr_func_CODEC_TIMER_LOADMOD_CCB_VECT = &isr_ISO15693_CODEC_TIMER_LOADMOD_CCB_VECT;
    StartISO15693Demod();
    b138:	3b cf       	rjmp	.-394    	; 0xafb0 <StartISO15693Demod>

0000b13a <ISO15693CodecDeInit>:
}

void ISO15693CodecDeInit(void) 
{
    /* Gracefully shutdown codec */
    CODEC_DEMOD_IN_PORT.INT0MASK = 0;
    b13a:	a0 e2       	ldi	r26, 0x20	; 32
    b13c:	b6 e0       	ldi	r27, 0x06	; 6
    b13e:	1a 96       	adiw	r26, 0x0a	; 10
    b140:	1c 92       	st	X, r1
    b142:	1a 97       	sbiw	r26, 0x0a	; 10

    CodecBufferPtr = CodecBuffer;
    b144:	83 ed       	ldi	r24, 0xD3	; 211
    b146:	91 e3       	ldi	r25, 0x31	; 49
    b148:	88 b9       	out	0x08, r24	; 8
    b14a:	99 b9       	out	0x09, r25	; 9
    Flags.DemodFinished = 0;
    b14c:	e7 e4       	ldi	r30, 0x47	; 71
    b14e:	fe e2       	ldi	r31, 0x2E	; 46
    b150:	10 82       	st	Z, r1
    Flags.LoadmodFinished = 0;
    b152:	11 82       	std	Z+1, r1	; 0x01
    DemodState = DEMOD_SOC_STATE;
    b154:	10 92 45 2e 	sts	0x2E45, r1
    DataRegister = 0;
    b158:	10 b8       	out	0x00, r1	; 0
    SampleRegister = 0;
    b15a:	13 b8       	out	0x03, r1	; 3
    BitSampleCount = 0;
    b15c:	16 b8       	out	0x06, r1	; 6
    b15e:	17 b8       	out	0x07, r1	; 7
    SampleDataCount = 0;
    b160:	10 92 3d 2e 	sts	0x2E3D, r1
    b164:	10 92 3e 2e 	sts	0x2E3E, r1
    ModulationPauseCount = 0;
    b168:	12 b8       	out	0x02, r1	; 2
    ByteCount = 0;
    b16a:	10 92 43 2e 	sts	0x2E43, r1
    ShiftRegister = 0;
    b16e:	10 92 44 2e 	sts	0x2E44, r1

    //Disable sample timer
    CODEC_TIMER_SAMPLING.CTRLA = TC_CLKSEL_OFF_gc;
    b172:	e0 e0       	ldi	r30, 0x00	; 0
    b174:	f9 e0       	ldi	r31, 0x09	; 9
    b176:	10 82       	st	Z, r1
    CODEC_TIMER_SAMPLING.CTRLD = TC_EVACT_OFF_gc;
    b178:	13 82       	std	Z+3, r1	; 0x03
    CODEC_TIMER_SAMPLING.INTCTRLB = TC_CCCINTLVL_OFF_gc;
    b17a:	17 82       	std	Z+7, r1	; 0x07
    CODEC_TIMER_SAMPLING.INTFLAGS = TC0_CCCIF_bm;
    b17c:	80 e4       	ldi	r24, 0x40	; 64
    b17e:	84 87       	std	Z+12, r24	; 0x0c

    //Disable load modulation
    CODEC_TIMER_LOADMOD.CTRLD = TC_EVACT_OFF_gc;
    b180:	e0 e0       	ldi	r30, 0x00	; 0
    b182:	fa e0       	ldi	r31, 0x0A	; 10
    b184:	13 82       	std	Z+3, r1	; 0x03
    CODEC_TIMER_LOADMOD.INTCTRLB = TC_CCBINTLVL_OFF_gc;
    b186:	17 82       	std	Z+7, r1	; 0x07
    CODEC_TIMER_LOADMOD.INTFLAGS = TC0_CCBIF_bm;
    b188:	80 e2       	ldi	r24, 0x20	; 32
    b18a:	84 87       	std	Z+12, r24	; 0x0c
}

INLINE void CodecSetSubcarrier(SubcarrierModType ModType, uint16_t Divider)
{
    if (ModType == CODEC_SUBCARRIERMOD_OFF) {
        CODEC_SUBCARRIER_TIMER.CTRLA = TC_CLKSEL_OFF_gc;
    b18c:	e0 e4       	ldi	r30, 0x40	; 64
    b18e:	f8 e0       	ldi	r31, 0x08	; 8
    b190:	10 82       	st	Z, r1
        CODEC_SUBCARRIER_TIMER.CTRLB = 0;
    b192:	11 82       	std	Z+1, r1	; 0x01
INLINE void CodecSetDemodPower(bool bOnOff)
{
    if (bOnOff) {
        CODEC_DEMOD_POWER_PORT.OUTSET = CODEC_DEMOD_POWER_MASK;
    } else {
        CODEC_DEMOD_POWER_PORT.OUTCLR = CODEC_DEMOD_POWER_MASK;
    b194:	81 e0       	ldi	r24, 0x01	; 1
    b196:	16 96       	adiw	r26, 0x06	; 6
    b198:	8c 93       	st	X, r24

INLINE void CodecSetLoadmodState(bool bOnOff) {
    if (bOnOff) {
        VPORT0.OUT |= CODEC_LOADMOD_MASK;
    } else {
        VPORT0.OUT &= ~CODEC_LOADMOD_MASK;
    b19a:	8e 98       	cbi	0x11, 6	; 17
    b19c:	08 95       	ret

0000b19e <ISO15693CodecTask>:
    CodecSetDemodPower(false);
    CodecSetLoadmodState(false);
}

void ISO15693CodecTask(void) 
{
    b19e:	1f 93       	push	r17
    b1a0:	cf 93       	push	r28
    b1a2:	df 93       	push	r29
    if (Flags.DemodFinished) {
    b1a4:	80 91 47 2e 	lds	r24, 0x2E47
    b1a8:	88 23       	and	r24, r24
    b1aa:	09 f4       	brne	.+2      	; 0xb1ae <ISO15693CodecTask+0x10>
    b1ac:	62 c0       	rjmp	.+196    	; 0xb272 <ISO15693CodecTask+0xd4>
        Flags.DemodFinished = 0;
    b1ae:	10 92 47 2e 	sts	0x2E47, r1
        
        uint16_t DemodByteCount = ByteCount;
    b1b2:	40 91 43 2e 	lds	r20, 0x2E43
    b1b6:	c4 2f       	mov	r28, r20
    b1b8:	d0 e0       	ldi	r29, 0x00	; 0
        uint16_t AppReceivedByteCount = 0;
        bool bDualSubcarrier = false;
        
        if (DemodByteCount > 0)
    b1ba:	20 97       	sbiw	r28, 0x00	; 0
    b1bc:	b1 f0       	breq	.+44     	; 0xb1ea <ISO15693CodecTask+0x4c>
        {
            if (CodecBuffer[0] & ISO15693_REQ_SUBCARRIER_DUAL)
    b1be:	10 91 d3 31 	lds	r17, 0x31D3
void LogGetModeByName(char* Mode, uint16_t BufferSize);
void LogGetModeList(char* List, uint16_t BufferSize);
void LogSRAMToFRAM(void);

/* Wrapper function to call current logging function */
INLINE void LogEntry(LogEntryEnum Entry, const void* Data, uint8_t Length) { CurrentLogFunc(Entry, Data, Length); }
    b1c2:	e0 91 6e 2f 	lds	r30, 0x2F6E
    b1c6:	f0 91 6f 2f 	lds	r31, 0x2F6F
    b1ca:	63 ed       	ldi	r22, 0xD3	; 211
    b1cc:	71 e3       	ldi	r23, 0x31	; 49
    b1ce:	80 e4       	ldi	r24, 0x40	; 64
    b1d0:	19 95       	eicall
    b1d2:	e0 91 64 2f 	lds	r30, 0x2F64
    b1d6:	f0 91 65 2f 	lds	r31, 0x2F65
    b1da:	be 01       	movw	r22, r28
    b1dc:	83 ed       	ldi	r24, 0xD3	; 211
    b1de:	91 e3       	ldi	r25, 0x31	; 49
    b1e0:	19 95       	eicall
    b1e2:	ec 01       	movw	r28, r24
        } else {
            ApplicationReset();
        }
        
        //This is only reached when we've received a valid frame
        if (AppReceivedByteCount > 0) { 
    b1e4:	00 97       	sbiw	r24, 0x00	; 0
    b1e6:	39 f4       	brne	.+14     	; 0xb1f6 <ISO15693CodecTask+0x58>
    b1e8:	3f c0       	rjmp	.+126    	; 0xb268 <ISO15693CodecTask+0xca>
}

INLINE void ApplicationReset(void) {
    ActiveConfiguration.ApplicationResetFunc();
    b1ea:	e0 91 5e 2f 	lds	r30, 0x2F5E
    b1ee:	f0 91 5f 2f 	lds	r31, 0x2F5F
    b1f2:	19 95       	eicall
    b1f4:	39 c0       	rjmp	.+114    	; 0xb268 <ISO15693CodecTask+0xca>
    b1f6:	e0 91 6e 2f 	lds	r30, 0x2F6E
    b1fa:	f0 91 6f 2f 	lds	r31, 0x2F6F
    b1fe:	48 2f       	mov	r20, r24
    b200:	63 ed       	ldi	r22, 0xD3	; 211
    b202:	71 e3       	ldi	r23, 0x31	; 49
    b204:	81 e4       	ldi	r24, 0x41	; 65
    b206:	19 95       	eicall
            LogEntry(LOG_INFO_CODEC_TX_DATA, CodecBuffer, AppReceivedByteCount);
            CodecBufferPtr = CodecBuffer;
    b208:	83 ed       	ldi	r24, 0xD3	; 211
    b20a:	91 e3       	ldi	r25, 0x31	; 49
    b20c:	88 b9       	out	0x08, r24	; 8
    b20e:	99 b9       	out	0x09, r25	; 9
            ByteCount = AppReceivedByteCount;
    b210:	c0 93 43 2e 	sts	0x2E43, r28
    CODEC_SUBCARRIER_TIMER.PER = Divider - 1;
}

INLINE void CodecStartSubcarrier(void)
{
    CODEC_SUBCARRIER_TIMER.CTRLA = CODEC_TIMER_CARRIER_CLKSEL;
    b214:	8e e0       	ldi	r24, 0x0E	; 14
    b216:	80 93 40 08 	sts	0x0840, r24
            
            CodecStartSubcarrier();

            /* Start loadmodulating */
            if (bDualSubcarrier) {
    b21a:	10 ff       	sbrs	r17, 0
    b21c:	0f c0       	rjmp	.+30     	; 0xb23c <ISO15693CodecTask+0x9e>
                StateRegister = LOADMOD_START_DUAL;
    b21e:	86 e0       	ldi	r24, 0x06	; 6
    b220:	81 b9       	out	0x01, r24	; 1
    if (ModType == CODEC_SUBCARRIERMOD_OFF) {
        CODEC_SUBCARRIER_TIMER.CTRLA = TC_CLKSEL_OFF_gc;
        CODEC_SUBCARRIER_TIMER.CTRLB = 0;
    } else if (ModType == CODEC_SUBCARRIERMOD_OOK) {
        /* Configure subcarrier generation with 50% DC output using OOK */
        CODEC_SUBCARRIER_TIMER.CNT = 0;
    b222:	10 92 60 08 	sts	0x0860, r1
    b226:	10 92 61 08 	sts	0x0861, r1
        CODEC_SUBCARRIER_TIMER.PER = Divider - 1;
    b22a:	8b e1       	ldi	r24, 0x1B	; 27
    b22c:	90 e0       	ldi	r25, 0x00	; 0
    b22e:	80 93 66 08 	sts	0x0866, r24
    b232:	90 93 67 08 	sts	0x0867, r25
        CODEC_SUBCARRIER_TIMER.CODEC_SUBCARRIER_CC_OOK = Divider/2;
    b236:	8e e0       	ldi	r24, 0x0E	; 14
    b238:	90 e0       	ldi	r25, 0x00	; 0
    b23a:	0e c0       	rjmp	.+28     	; 0xb258 <ISO15693CodecTask+0xba>
                CodecSetSubcarrier(CODEC_SUBCARRIERMOD_OOK, SUBCARRIER_2);
            } else {
                StateRegister = LOADMOD_START_SINGLE;
    b23c:	81 e0       	ldi	r24, 0x01	; 1
    b23e:	81 b9       	out	0x01, r24	; 1
    if (ModType == CODEC_SUBCARRIERMOD_OFF) {
        CODEC_SUBCARRIER_TIMER.CTRLA = TC_CLKSEL_OFF_gc;
        CODEC_SUBCARRIER_TIMER.CTRLB = 0;
    } else if (ModType == CODEC_SUBCARRIERMOD_OOK) {
        /* Configure subcarrier generation with 50% DC output using OOK */
        CODEC_SUBCARRIER_TIMER.CNT = 0;
    b240:	10 92 60 08 	sts	0x0860, r1
    b244:	10 92 61 08 	sts	0x0861, r1
        CODEC_SUBCARRIER_TIMER.PER = Divider - 1;
    b248:	8f e1       	ldi	r24, 0x1F	; 31
    b24a:	90 e0       	ldi	r25, 0x00	; 0
    b24c:	80 93 66 08 	sts	0x0866, r24
    b250:	90 93 67 08 	sts	0x0867, r25
        CODEC_SUBCARRIER_TIMER.CODEC_SUBCARRIER_CC_OOK = Divider/2;
    b254:	80 e1       	ldi	r24, 0x10	; 16
    b256:	90 e0       	ldi	r25, 0x00	; 0
    b258:	80 93 6a 08 	sts	0x086A, r24
    b25c:	90 93 6b 08 	sts	0x086B, r25
        CODEC_SUBCARRIER_TIMER.CTRLB = CODEC_SUBCARRIER_CCEN_OOK | TC_WGMODE_SINGLESLOPE_gc;
    b260:	83 e2       	ldi	r24, 0x23	; 35
    b262:	80 93 41 08 	sts	0x0841, r24
    b266:	05 c0       	rjmp	.+10     	; 0xb272 <ISO15693CodecTask+0xd4>
            }
            
        } else {
            /* No data to be processed. Disable T1 waiting and
             * start listening again */
            CODEC_TIMER_LOADMOD.CTRLA = TC_CLKSEL_OFF_gc;
    b268:	10 92 00 0a 	sts	0x0A00, r1
            CODEC_TIMER_LOADMOD.INTCTRLB = TC_CCBINTLVL_OFF_gc;
    b26c:	10 92 07 0a 	sts	0x0A07, r1
            StartISO15693Demod();
    b270:	9f de       	rcall	.-706    	; 0xafb0 <StartISO15693Demod>
        }
    }
    
    if (Flags.LoadmodFinished) {
    b272:	80 91 48 2e 	lds	r24, 0x2E48
    b276:	88 23       	and	r24, r24
    b278:	31 f0       	breq	.+12     	; 0xb286 <ISO15693CodecTask+0xe8>
        Flags.LoadmodFinished = 0;
    b27a:	10 92 48 2e 	sts	0x2E48, r1
        /* Load modulation has been finished. Stop it and start to listen
         * for incoming data again. */
        StartISO15693Demod();
    }
}
    b27e:	df 91       	pop	r29
    b280:	cf 91       	pop	r28
    b282:	1f 91       	pop	r17
    
    if (Flags.LoadmodFinished) {
        Flags.LoadmodFinished = 0;
        /* Load modulation has been finished. Stop it and start to listen
         * for incoming data again. */
        StartISO15693Demod();
    b284:	95 ce       	rjmp	.-726    	; 0xafb0 <StartISO15693Demod>
    }
}
    b286:	df 91       	pop	r29
    b288:	cf 91       	pop	r28
    b28a:	1f 91       	pop	r17
    b28c:	08 95       	ret

0000b28e <VicinityAppInit>:
void sendIntToTermina(uint8_t val)
{
    char buf[16];
    snprintf(buf,16, "%d,",val);
    TerminalSendString(buf);
}
    b28e:	10 92 4a 2e 	sts	0x2E4A, r1
    b292:	08 95       	ret

0000b294 <VicinityAppReset>:
    b294:	10 92 4a 2e 	sts	0x2E4A, r1
    b298:	08 95       	ret

0000b29a <VicinityAppTask>:
    b29a:	08 95       	ret

0000b29c <VicinityAppTick>:
    b29c:	08 95       	ret

0000b29e <VicinityAppProcess>:

uint16_t VicinityAppProcess(uint8_t* FrameBuf, uint16_t FrameBytes)
{
    b29e:	0f 93       	push	r16
    b2a0:	1f 93       	push	r17
    b2a2:	cf 93       	push	r28
    b2a4:	df 93       	push	r29
    if (FrameBytes >= ISO15693_MIN_FRAME_SIZE) {
    b2a6:	65 30       	cpi	r22, 0x05	; 5
    b2a8:	71 05       	cpc	r23, r1
    b2aa:	08 f4       	brcc	.+2      	; 0xb2ae <VicinityAppProcess+0x10>
    b2ac:	c2 c0       	rjmp	.+388    	; 0xb432 <VicinityAppProcess+0x194>
    b2ae:	ec 01       	movw	r28, r24
        if(ISO15693CheckCRC(FrameBuf, FrameBytes - ISO15693_CRC16_SIZE)) {
    b2b0:	62 50       	subi	r22, 0x02	; 2
    b2b2:	71 09       	sbc	r23, r1
    b2b4:	61 d4       	rcall	.+2242   	; 0xbb78 <ISO15693CheckCRC>
    b2b6:	88 23       	and	r24, r24
    b2b8:	09 f4       	brne	.+2      	; 0xb2bc <VicinityAppProcess+0x1e>
    b2ba:	bb c0       	rjmp	.+374    	; 0xb432 <VicinityAppProcess+0x194>
            // At this point, we have a valid ISO15693 frame
            uint8_t Command = FrameBuf[1];
    b2bc:	89 81       	ldd	r24, Y+1	; 0x01
            uint16_t ResponseByteCount = ISO15693_APP_NO_RESPONSE;
            
            
            switch(State) {
    b2be:	90 91 4a 2e 	lds	r25, 0x2E4A
    b2c2:	99 23       	and	r25, r25
    b2c4:	21 f0       	breq	.+8      	; 0xb2ce <VicinityAppProcess+0x30>
    b2c6:	92 30       	cpi	r25, 0x02	; 2
    b2c8:	09 f4       	brne	.+2      	; 0xb2cc <VicinityAppProcess+0x2e>
    b2ca:	80 c0       	rjmp	.+256    	; 0xb3cc <VicinityAppProcess+0x12e>
    b2cc:	b2 c0       	rjmp	.+356    	; 0xb432 <VicinityAppProcess+0x194>
            case STATE_READY:
                if (Command == ISO15693_CMD_INVENTORY) {
    b2ce:	81 30       	cpi	r24, 0x01	; 1
    b2d0:	e9 f4       	brne	.+58     	; 0xb30c <VicinityAppProcess+0x6e>
                    FrameBuf[0] = 0x00; /* Flags */
    b2d2:	18 82       	st	Y, r1
                    FrameBuf[1] = 0x00; /* DSFID */
    b2d4:	19 82       	std	Y+1, r1	; 0x01
}

INLINE
void ISO15693CopyUid(uint8_t* DstUid, uint8_t* SrcUid)
{
    DstUid[0] = SrcUid[0];
    b2d6:	80 91 22 20 	lds	r24, 0x2022
    b2da:	8a 83       	std	Y+2, r24	; 0x02
    DstUid[1] = SrcUid[1];
    b2dc:	80 91 23 20 	lds	r24, 0x2023
    b2e0:	8b 83       	std	Y+3, r24	; 0x03
    DstUid[2] = SrcUid[2];
    b2e2:	80 91 24 20 	lds	r24, 0x2024
    b2e6:	8c 83       	std	Y+4, r24	; 0x04
    DstUid[3] = SrcUid[3];
    b2e8:	80 91 25 20 	lds	r24, 0x2025
    b2ec:	8d 83       	std	Y+5, r24	; 0x05
    DstUid[4] = SrcUid[4];
    b2ee:	80 91 26 20 	lds	r24, 0x2026
    b2f2:	8e 83       	std	Y+6, r24	; 0x06
    DstUid[5] = SrcUid[5];
    b2f4:	80 91 27 20 	lds	r24, 0x2027
    b2f8:	8f 83       	std	Y+7, r24	; 0x07
    DstUid[6] = SrcUid[6];
    b2fa:	80 91 28 20 	lds	r24, 0x2028
    b2fe:	88 87       	std	Y+8, r24	; 0x08
    DstUid[7] = SrcUid[7];
    b300:	80 91 29 20 	lds	r24, 0x2029
    b304:	89 87       	std	Y+9, r24	; 0x09
                    ISO15693CopyUid(&FrameBuf[2], MyUid);
                    ResponseByteCount = 10;
    b306:	0a e0       	ldi	r16, 0x0A	; 10
    b308:	10 e0       	ldi	r17, 0x00	; 0
    b30a:	96 c0       	rjmp	.+300    	; 0xb438 <VicinityAppProcess+0x19a>
                } else if (Command == ISO15693_CMD_STAY_QUIET) {
    b30c:	82 30       	cpi	r24, 0x02	; 2
    b30e:	79 f5       	brne	.+94     	; 0xb36e <VicinityAppProcess+0xd0>
}

INLINE
bool ISO15693Addressed(uint8_t* Buffer, uint8_t* MyUid) {
    if (Buffer[0] & ISO15693_REQ_FLAG_ADDRESS) {
    b310:	88 81       	ld	r24, Y
    b312:	85 ff       	sbrs	r24, 5
    b314:	28 c0       	rjmp	.+80     	; 0xb366 <VicinityAppProcess+0xc8>
bool ISO15693CheckCRC(void* FrameBuf, uint16_t FrameBufSize);

INLINE
bool ISO15693CompareUid(uint8_t* Uid1, uint8_t* Uid2)
{
    if (    (Uid1[0] == Uid2[0])
    b316:	9a 81       	ldd	r25, Y+2	; 0x02
    b318:	80 91 22 20 	lds	r24, 0x2022
    b31c:	98 13       	cpse	r25, r24
    b31e:	89 c0       	rjmp	.+274    	; 0xb432 <VicinityAppProcess+0x194>
        &&  (Uid1[1] == Uid2[1])
    b320:	9b 81       	ldd	r25, Y+3	; 0x03
    b322:	80 91 23 20 	lds	r24, 0x2023
    b326:	98 13       	cpse	r25, r24
    b328:	84 c0       	rjmp	.+264    	; 0xb432 <VicinityAppProcess+0x194>
        &&  (Uid1[2] == Uid2[2])
    b32a:	9c 81       	ldd	r25, Y+4	; 0x04
    b32c:	80 91 24 20 	lds	r24, 0x2024
    b330:	98 13       	cpse	r25, r24
    b332:	7f c0       	rjmp	.+254    	; 0xb432 <VicinityAppProcess+0x194>
        &&  (Uid1[3] == Uid2[3])
    b334:	9d 81       	ldd	r25, Y+5	; 0x05
    b336:	80 91 25 20 	lds	r24, 0x2025
    b33a:	98 13       	cpse	r25, r24
    b33c:	7a c0       	rjmp	.+244    	; 0xb432 <VicinityAppProcess+0x194>
        &&  (Uid1[4] == Uid2[4])
    b33e:	9e 81       	ldd	r25, Y+6	; 0x06
    b340:	80 91 26 20 	lds	r24, 0x2026
    b344:	98 13       	cpse	r25, r24
    b346:	75 c0       	rjmp	.+234    	; 0xb432 <VicinityAppProcess+0x194>
        &&  (Uid1[5] == Uid2[5])
    b348:	9f 81       	ldd	r25, Y+7	; 0x07
    b34a:	80 91 27 20 	lds	r24, 0x2027
    b34e:	98 13       	cpse	r25, r24
    b350:	70 c0       	rjmp	.+224    	; 0xb432 <VicinityAppProcess+0x194>
        &&  (Uid1[6] == Uid2[6])
    b352:	98 85       	ldd	r25, Y+8	; 0x08
    b354:	80 91 28 20 	lds	r24, 0x2028
    b358:	98 13       	cpse	r25, r24
    b35a:	6b c0       	rjmp	.+214    	; 0xb432 <VicinityAppProcess+0x194>
                    if (ISO15693Addressed(FrameBuf, MyUid)) {
    b35c:	99 85       	ldd	r25, Y+9	; 0x09
    b35e:	80 91 29 20 	lds	r24, 0x2029
    b362:	98 13       	cpse	r25, r24
    b364:	66 c0       	rjmp	.+204    	; 0xb432 <VicinityAppProcess+0x194>
                        State = STATE_QUIET;
    b366:	82 e0       	ldi	r24, 0x02	; 2
    b368:	80 93 4a 2e 	sts	0x2E4A, r24
    b36c:	62 c0       	rjmp	.+196    	; 0xb432 <VicinityAppProcess+0x194>
                    }
                } else if (Command == ISO15693_CMD_GET_SYS_INFO) {
    b36e:	8b 32       	cpi	r24, 0x2B	; 43
    b370:	09 f0       	breq	.+2      	; 0xb374 <VicinityAppProcess+0xd6>
    b372:	5f c0       	rjmp	.+190    	; 0xb432 <VicinityAppProcess+0x194>
    DstUid[7] = SrcUid[7];
}

INLINE
bool ISO15693Addressed(uint8_t* Buffer, uint8_t* MyUid) {
    if (Buffer[0] & ISO15693_REQ_FLAG_ADDRESS) {
    b374:	88 81       	ld	r24, Y
    b376:	85 ff       	sbrs	r24, 5
    b378:	ac cf       	rjmp	.-168    	; 0xb2d2 <VicinityAppProcess+0x34>
bool ISO15693CheckCRC(void* FrameBuf, uint16_t FrameBufSize);

INLINE
bool ISO15693CompareUid(uint8_t* Uid1, uint8_t* Uid2)
{
    if (    (Uid1[0] == Uid2[0])
    b37a:	9a 81       	ldd	r25, Y+2	; 0x02
    b37c:	80 91 22 20 	lds	r24, 0x2022
    b380:	98 13       	cpse	r25, r24
    b382:	57 c0       	rjmp	.+174    	; 0xb432 <VicinityAppProcess+0x194>
        &&  (Uid1[1] == Uid2[1])
    b384:	9b 81       	ldd	r25, Y+3	; 0x03
    b386:	80 91 23 20 	lds	r24, 0x2023
    b38a:	98 13       	cpse	r25, r24
    b38c:	52 c0       	rjmp	.+164    	; 0xb432 <VicinityAppProcess+0x194>
        &&  (Uid1[2] == Uid2[2])
    b38e:	9c 81       	ldd	r25, Y+4	; 0x04
    b390:	80 91 24 20 	lds	r24, 0x2024
    b394:	98 13       	cpse	r25, r24
    b396:	4d c0       	rjmp	.+154    	; 0xb432 <VicinityAppProcess+0x194>
        &&  (Uid1[3] == Uid2[3])
    b398:	9d 81       	ldd	r25, Y+5	; 0x05
    b39a:	80 91 25 20 	lds	r24, 0x2025
    b39e:	98 13       	cpse	r25, r24
    b3a0:	48 c0       	rjmp	.+144    	; 0xb432 <VicinityAppProcess+0x194>
        &&  (Uid1[4] == Uid2[4])
    b3a2:	9e 81       	ldd	r25, Y+6	; 0x06
    b3a4:	80 91 26 20 	lds	r24, 0x2026
    b3a8:	98 13       	cpse	r25, r24
    b3aa:	43 c0       	rjmp	.+134    	; 0xb432 <VicinityAppProcess+0x194>
        &&  (Uid1[5] == Uid2[5])
    b3ac:	9f 81       	ldd	r25, Y+7	; 0x07
    b3ae:	80 91 27 20 	lds	r24, 0x2027
    b3b2:	98 13       	cpse	r25, r24
    b3b4:	3e c0       	rjmp	.+124    	; 0xb432 <VicinityAppProcess+0x194>
        &&  (Uid1[6] == Uid2[6])
    b3b6:	98 85       	ldd	r25, Y+8	; 0x08
    b3b8:	80 91 28 20 	lds	r24, 0x2028
    b3bc:	98 13       	cpse	r25, r24
    b3be:	39 c0       	rjmp	.+114    	; 0xb432 <VicinityAppProcess+0x194>
        &&  (Uid1[7] == Uid2[7]) ) {
    b3c0:	99 85       	ldd	r25, Y+9	; 0x09
    b3c2:	80 91 29 20 	lds	r24, 0x2029
    b3c6:	98 13       	cpse	r25, r24
    b3c8:	34 c0       	rjmp	.+104    	; 0xb432 <VicinityAppProcess+0x194>
    b3ca:	83 cf       	rjmp	.-250    	; 0xb2d2 <VicinityAppProcess+0x34>
            case STATE_SELECTED:

                break;

            case STATE_QUIET:
                if (Command == ISO15693_CMD_RESET_TO_READY) {
    b3cc:	86 32       	cpi	r24, 0x26	; 38
    b3ce:	89 f5       	brne	.+98     	; 0xb432 <VicinityAppProcess+0x194>
    DstUid[7] = SrcUid[7];
}

INLINE
bool ISO15693Addressed(uint8_t* Buffer, uint8_t* MyUid) {
    if (Buffer[0] & ISO15693_REQ_FLAG_ADDRESS) {
    b3d0:	88 81       	ld	r24, Y
    b3d2:	85 ff       	sbrs	r24, 5
    b3d4:	28 c0       	rjmp	.+80     	; 0xb426 <VicinityAppProcess+0x188>
bool ISO15693CheckCRC(void* FrameBuf, uint16_t FrameBufSize);

INLINE
bool ISO15693CompareUid(uint8_t* Uid1, uint8_t* Uid2)
{
    if (    (Uid1[0] == Uid2[0])
    b3d6:	9a 81       	ldd	r25, Y+2	; 0x02
    b3d8:	80 91 22 20 	lds	r24, 0x2022
    b3dc:	98 13       	cpse	r25, r24
    b3de:	29 c0       	rjmp	.+82     	; 0xb432 <VicinityAppProcess+0x194>
        &&  (Uid1[1] == Uid2[1])
    b3e0:	9b 81       	ldd	r25, Y+3	; 0x03
    b3e2:	80 91 23 20 	lds	r24, 0x2023
    b3e6:	98 13       	cpse	r25, r24
    b3e8:	24 c0       	rjmp	.+72     	; 0xb432 <VicinityAppProcess+0x194>
        &&  (Uid1[2] == Uid2[2])
    b3ea:	9c 81       	ldd	r25, Y+4	; 0x04
    b3ec:	80 91 24 20 	lds	r24, 0x2024
    b3f0:	98 13       	cpse	r25, r24
    b3f2:	1f c0       	rjmp	.+62     	; 0xb432 <VicinityAppProcess+0x194>
        &&  (Uid1[3] == Uid2[3])
    b3f4:	9d 81       	ldd	r25, Y+5	; 0x05
    b3f6:	80 91 25 20 	lds	r24, 0x2025
    b3fa:	98 13       	cpse	r25, r24
    b3fc:	1a c0       	rjmp	.+52     	; 0xb432 <VicinityAppProcess+0x194>
        &&  (Uid1[4] == Uid2[4])
    b3fe:	9e 81       	ldd	r25, Y+6	; 0x06
    b400:	80 91 26 20 	lds	r24, 0x2026
    b404:	98 13       	cpse	r25, r24
    b406:	15 c0       	rjmp	.+42     	; 0xb432 <VicinityAppProcess+0x194>
        &&  (Uid1[5] == Uid2[5])
    b408:	9f 81       	ldd	r25, Y+7	; 0x07
    b40a:	80 91 27 20 	lds	r24, 0x2027
    b40e:	98 13       	cpse	r25, r24
    b410:	10 c0       	rjmp	.+32     	; 0xb432 <VicinityAppProcess+0x194>
        &&  (Uid1[6] == Uid2[6])
    b412:	98 85       	ldd	r25, Y+8	; 0x08
    b414:	80 91 28 20 	lds	r24, 0x2028
    b418:	98 13       	cpse	r25, r24
    b41a:	0b c0       	rjmp	.+22     	; 0xb432 <VicinityAppProcess+0x194>
        &&  (Uid1[7] == Uid2[7]) ) {
    b41c:	99 85       	ldd	r25, Y+9	; 0x09
    b41e:	80 91 29 20 	lds	r24, 0x2029
    b422:	98 13       	cpse	r25, r24
    b424:	06 c0       	rjmp	.+12     	; 0xb432 <VicinityAppProcess+0x194>
                    if (ISO15693Addressed(FrameBuf, MyUid)) {
                        FrameBuf[0] = 0;
    b426:	18 82       	st	Y, r1
                        ResponseByteCount = 1;
                        State = STATE_READY;
    b428:	10 92 4a 2e 	sts	0x2E4A, r1

            case STATE_QUIET:
                if (Command == ISO15693_CMD_RESET_TO_READY) {
                    if (ISO15693Addressed(FrameBuf, MyUid)) {
                        FrameBuf[0] = 0;
                        ResponseByteCount = 1;
    b42c:	01 e0       	ldi	r16, 0x01	; 1
    b42e:	10 e0       	ldi	r17, 0x00	; 0
    b430:	03 c0       	rjmp	.+6      	; 0xb438 <VicinityAppProcess+0x19a>
            }

            if (ResponseByteCount > 0) {
                /* There is data to be sent. Append CRC */
                ISO15693AppendCRC(FrameBuf, ResponseByteCount);
                ResponseByteCount += ISO15693_CRC16_SIZE;
    b432:	80 e0       	ldi	r24, 0x00	; 0
    b434:	90 e0       	ldi	r25, 0x00	; 0
    b436:	05 c0       	rjmp	.+10     	; 0xb442 <VicinityAppProcess+0x1a4>
                break;
            }

            if (ResponseByteCount > 0) {
                /* There is data to be sent. Append CRC */
                ISO15693AppendCRC(FrameBuf, ResponseByteCount);
    b438:	b8 01       	movw	r22, r16
    b43a:	ce 01       	movw	r24, r28
    b43c:	8d d3       	rcall	.+1818   	; 0xbb58 <ISO15693AppendCRC>
                ResponseByteCount += ISO15693_CRC16_SIZE;
    b43e:	c8 01       	movw	r24, r16
    b440:	02 96       	adiw	r24, 0x02	; 2
        }
    } else { // Min frame size not met
        return ISO15693_APP_NO_RESPONSE;
    }
    
}
    b442:	df 91       	pop	r29
    b444:	cf 91       	pop	r28
    b446:	1f 91       	pop	r17
    b448:	0f 91       	pop	r16
    b44a:	08 95       	ret

0000b44c <VicinityGetUid>:

void VicinityGetUid(ConfigurationUidType Uid)
{
    b44c:	dc 01       	movw	r26, r24
    memcpy(Uid, MyUid, sizeof(ConfigurationUidType));
    b44e:	90 e1       	ldi	r25, 0x10	; 16
    b450:	e2 e2       	ldi	r30, 0x22	; 34
    b452:	f0 e2       	ldi	r31, 0x20	; 32
    b454:	01 90       	ld	r0, Z+
    b456:	0d 92       	st	X+, r0
    b458:	9a 95       	dec	r25
    b45a:	e1 f7       	brne	.-8      	; 0xb454 <VicinityGetUid+0x8>
    b45c:	08 95       	ret

0000b45e <VicinitySetUid>:
}

void VicinitySetUid(ConfigurationUidType Uid)
{
    b45e:	fc 01       	movw	r30, r24
    memcpy(MyUid, Uid, sizeof(ConfigurationUidType));
    b460:	90 e1       	ldi	r25, 0x10	; 16
    b462:	a2 e2       	ldi	r26, 0x22	; 34
    b464:	b0 e2       	ldi	r27, 0x20	; 32
    b466:	01 90       	ld	r0, Z+
    b468:	0d 92       	st	X+, r0
    b46a:	9a 95       	dec	r25
    b46c:	e1 f7       	brne	.-8      	; 0xb466 <VicinitySetUid+0x8>
    b46e:	08 95       	ret

0000b470 <Sl2s2002AppInit>:
    STATE_QUIET
} State;

void Sl2s2002AppInit(void)
{
    State = STATE_READY;
    b470:	10 92 4b 2e 	sts	0x2E4B, r1
    b474:	08 95       	ret

0000b476 <Sl2s2002AppReset>:
}

void Sl2s2002AppReset(void)
{
    State = STATE_READY;
    b476:	10 92 4b 2e 	sts	0x2E4B, r1
    b47a:	08 95       	ret

0000b47c <Sl2s2002AppTask>:
}


void Sl2s2002AppTask(void)
{
    b47c:	08 95       	ret

0000b47e <Sl2s2002AppTick>:
    
}

void Sl2s2002AppTick(void)
{
    b47e:	08 95       	ret

0000b480 <Sl2s2002AppProcess>:

    
}

uint16_t Sl2s2002AppProcess(uint8_t* FrameBuf, uint16_t FrameBytes)
{
    b480:	6f 92       	push	r6
    b482:	7f 92       	push	r7
    b484:	9f 92       	push	r9
    b486:	af 92       	push	r10
    b488:	bf 92       	push	r11
    b48a:	cf 92       	push	r12
    b48c:	df 92       	push	r13
    b48e:	ef 92       	push	r14
    b490:	ff 92       	push	r15
    b492:	0f 93       	push	r16
    b494:	1f 93       	push	r17
    b496:	cf 93       	push	r28
    b498:	df 93       	push	r29
    b49a:	cd b7       	in	r28, 0x3d	; 61
    b49c:	de b7       	in	r29, 0x3e	; 62
    b49e:	2a 97       	sbiw	r28, 0x0a	; 10
    b4a0:	cd bf       	out	0x3d, r28	; 61
    b4a2:	de bf       	out	0x3e, r29	; 62
    b4a4:	8c 01       	movw	r16, r24
    if (FrameBytes >= ISO15693_MIN_FRAME_SIZE) {
    b4a6:	65 30       	cpi	r22, 0x05	; 5
    b4a8:	71 05       	cpc	r23, r1
    b4aa:	18 f4       	brcc	.+6      	; 0xb4b2 <Sl2s2002AppProcess+0x32>
        
        } else { // Invalid CRC
            return ISO15693_APP_NO_RESPONSE;
        }
    } else { // Min frame size not met
        return ISO15693_APP_NO_RESPONSE;
    b4ac:	80 e0       	ldi	r24, 0x00	; 0
    b4ae:	90 e0       	ldi	r25, 0x00	; 0
    b4b0:	c7 c1       	rjmp	.+910    	; 0xb840 <Sl2s2002AppProcess+0x3c0>
}

uint16_t Sl2s2002AppProcess(uint8_t* FrameBuf, uint16_t FrameBytes)
{
    if (FrameBytes >= ISO15693_MIN_FRAME_SIZE) {
        if(ISO15693CheckCRC(FrameBuf, FrameBytes - ISO15693_CRC16_SIZE)) {
    b4b2:	62 50       	subi	r22, 0x02	; 2
    b4b4:	71 09       	sbc	r23, r1
    b4b6:	60 d3       	rcall	.+1728   	; 0xbb78 <ISO15693CheckCRC>
    b4b8:	88 23       	and	r24, r24
    b4ba:	c1 f3       	breq	.-16     	; 0xb4ac <Sl2s2002AppProcess+0x2c>
            // At this point, we have a valid ISO15693 frame
            uint8_t Command = FrameBuf[1];
    b4bc:	f8 01       	movw	r30, r16
    b4be:	21 81       	ldd	r18, Z+1	; 0x01
            uint16_t ResponseByteCount = ISO15693_APP_NO_RESPONSE;
            uint8_t Uid[8];
            MemoryReadBlock(Uid, MEM_UID_ADDRESS, ActiveConfiguration.UidSize);
    b4c0:	40 91 6c 2f 	lds	r20, 0x2F6C
    b4c4:	50 e0       	ldi	r21, 0x00	; 0
    b4c6:	60 e0       	ldi	r22, 0x00	; 0
    b4c8:	70 e0       	ldi	r23, 0x00	; 0
    b4ca:	ce 01       	movw	r24, r28
    b4cc:	01 96       	adiw	r24, 0x01	; 1
    b4ce:	29 87       	std	Y+9, r18	; 0x09
    b4d0:	0e 94 a1 0f 	call	0x1f42	; 0x1f42 <MemoryReadBlock>
            
            switch(State) {
    b4d4:	80 91 4b 2e 	lds	r24, 0x2E4B
    b4d8:	29 85       	ldd	r18, Y+9	; 0x09
    b4da:	88 23       	and	r24, r24
    b4dc:	21 f0       	breq	.+8      	; 0xb4e6 <Sl2s2002AppProcess+0x66>
    b4de:	82 30       	cpi	r24, 0x02	; 2
    b4e0:	09 f4       	brne	.+2      	; 0xb4e4 <Sl2s2002AppProcess+0x64>
    b4e2:	74 c1       	rjmp	.+744    	; 0xb7cc <Sl2s2002AppProcess+0x34c>
    b4e4:	aa c1       	rjmp	.+852    	; 0xb83a <Sl2s2002AppProcess+0x3ba>
            case STATE_READY:
                if (Command == ISO15693_CMD_INVENTORY) {
    b4e6:	21 30       	cpi	r18, 0x01	; 1
    b4e8:	b1 f4       	brne	.+44     	; 0xb516 <Sl2s2002AppProcess+0x96>
                    FrameBuf[0] = 0x00; /* Flags */
    b4ea:	f8 01       	movw	r30, r16
    b4ec:	10 82       	st	Z, r1
                    FrameBuf[1] = 0x00; /* DSFID */
    b4ee:	11 82       	std	Z+1, r1	; 0x01
}

INLINE
void ISO15693CopyUid(uint8_t* DstUid, uint8_t* SrcUid)
{
    DstUid[0] = SrcUid[0];
    b4f0:	89 81       	ldd	r24, Y+1	; 0x01
    b4f2:	82 83       	std	Z+2, r24	; 0x02
    DstUid[1] = SrcUid[1];
    b4f4:	8a 81       	ldd	r24, Y+2	; 0x02
    b4f6:	83 83       	std	Z+3, r24	; 0x03
    DstUid[2] = SrcUid[2];
    b4f8:	8b 81       	ldd	r24, Y+3	; 0x03
    b4fa:	84 83       	std	Z+4, r24	; 0x04
    DstUid[3] = SrcUid[3];
    b4fc:	8c 81       	ldd	r24, Y+4	; 0x04
    b4fe:	85 83       	std	Z+5, r24	; 0x05
    DstUid[4] = SrcUid[4];
    b500:	8d 81       	ldd	r24, Y+5	; 0x05
    b502:	86 83       	std	Z+6, r24	; 0x06
    DstUid[5] = SrcUid[5];
    b504:	8e 81       	ldd	r24, Y+6	; 0x06
    b506:	87 83       	std	Z+7, r24	; 0x07
    DstUid[6] = SrcUid[6];
    b508:	8f 81       	ldd	r24, Y+7	; 0x07
    b50a:	80 87       	std	Z+8, r24	; 0x08
    DstUid[7] = SrcUid[7];
    b50c:	88 85       	ldd	r24, Y+8	; 0x08
    b50e:	81 87       	std	Z+9, r24	; 0x09
                    ISO15693CopyUid(&FrameBuf[2], Uid);
                    ResponseByteCount = 10;
    b510:	4a e0       	ldi	r20, 0x0A	; 10
    b512:	50 e0       	ldi	r21, 0x00	; 0
    b514:	87 c1       	rjmp	.+782    	; 0xb824 <Sl2s2002AppProcess+0x3a4>
                } else if (Command == ISO15693_CMD_STAY_QUIET) {
    b516:	22 30       	cpi	r18, 0x02	; 2
    b518:	41 f5       	brne	.+80     	; 0xb56a <Sl2s2002AppProcess+0xea>
}

INLINE
bool ISO15693Addressed(uint8_t* Buffer, uint8_t* MyUid) {
    if (Buffer[0] & ISO15693_REQ_FLAG_ADDRESS) {
    b51a:	f8 01       	movw	r30, r16
    b51c:	80 81       	ld	r24, Z
    b51e:	85 ff       	sbrs	r24, 5
    b520:	20 c0       	rjmp	.+64     	; 0xb562 <Sl2s2002AppProcess+0xe2>
bool ISO15693CheckCRC(void* FrameBuf, uint16_t FrameBufSize);

INLINE
bool ISO15693CompareUid(uint8_t* Uid1, uint8_t* Uid2)
{
    if (    (Uid1[0] == Uid2[0])
    b522:	92 81       	ldd	r25, Z+2	; 0x02
    b524:	89 81       	ldd	r24, Y+1	; 0x01
    b526:	98 13       	cpse	r25, r24
    b528:	88 c1       	rjmp	.+784    	; 0xb83a <Sl2s2002AppProcess+0x3ba>
        &&  (Uid1[1] == Uid2[1])
    b52a:	93 81       	ldd	r25, Z+3	; 0x03
    b52c:	8a 81       	ldd	r24, Y+2	; 0x02
    b52e:	98 13       	cpse	r25, r24
    b530:	84 c1       	rjmp	.+776    	; 0xb83a <Sl2s2002AppProcess+0x3ba>
        &&  (Uid1[2] == Uid2[2])
    b532:	94 81       	ldd	r25, Z+4	; 0x04
    b534:	8b 81       	ldd	r24, Y+3	; 0x03
    b536:	98 13       	cpse	r25, r24
    b538:	80 c1       	rjmp	.+768    	; 0xb83a <Sl2s2002AppProcess+0x3ba>
        &&  (Uid1[3] == Uid2[3])
    b53a:	95 81       	ldd	r25, Z+5	; 0x05
    b53c:	8c 81       	ldd	r24, Y+4	; 0x04
    b53e:	98 13       	cpse	r25, r24
    b540:	7c c1       	rjmp	.+760    	; 0xb83a <Sl2s2002AppProcess+0x3ba>
        &&  (Uid1[4] == Uid2[4])
    b542:	96 81       	ldd	r25, Z+6	; 0x06
    b544:	8d 81       	ldd	r24, Y+5	; 0x05
    b546:	98 13       	cpse	r25, r24
    b548:	78 c1       	rjmp	.+752    	; 0xb83a <Sl2s2002AppProcess+0x3ba>
        &&  (Uid1[5] == Uid2[5])
    b54a:	97 81       	ldd	r25, Z+7	; 0x07
    b54c:	8e 81       	ldd	r24, Y+6	; 0x06
    b54e:	98 13       	cpse	r25, r24
    b550:	74 c1       	rjmp	.+744    	; 0xb83a <Sl2s2002AppProcess+0x3ba>
        &&  (Uid1[6] == Uid2[6])
    b552:	90 85       	ldd	r25, Z+8	; 0x08
    b554:	8f 81       	ldd	r24, Y+7	; 0x07
    b556:	98 13       	cpse	r25, r24
    b558:	70 c1       	rjmp	.+736    	; 0xb83a <Sl2s2002AppProcess+0x3ba>
                    if (ISO15693Addressed(FrameBuf, Uid)) {
    b55a:	91 85       	ldd	r25, Z+9	; 0x09
    b55c:	88 85       	ldd	r24, Y+8	; 0x08
    b55e:	98 13       	cpse	r25, r24
    b560:	6c c1       	rjmp	.+728    	; 0xb83a <Sl2s2002AppProcess+0x3ba>
                        State = STATE_QUIET;
    b562:	82 e0       	ldi	r24, 0x02	; 2
    b564:	80 93 4b 2e 	sts	0x2E4B, r24
    b568:	68 c1       	rjmp	.+720    	; 0xb83a <Sl2s2002AppProcess+0x3ba>
                    }
                } else if (Command == ISO15693_CMD_GET_SYS_INFO) {
    b56a:	2b 32       	cpi	r18, 0x2B	; 43
    b56c:	09 f0       	breq	.+2      	; 0xb570 <Sl2s2002AppProcess+0xf0>
    b56e:	42 c0       	rjmp	.+132    	; 0xb5f4 <Sl2s2002AppProcess+0x174>
    DstUid[7] = SrcUid[7];
}

INLINE
bool ISO15693Addressed(uint8_t* Buffer, uint8_t* MyUid) {
    if (Buffer[0] & ISO15693_REQ_FLAG_ADDRESS) {
    b570:	f8 01       	movw	r30, r16
    b572:	90 81       	ld	r25, Z
    b574:	89 81       	ldd	r24, Y+1	; 0x01
    b576:	95 ff       	sbrs	r25, 5
    b578:	1f c0       	rjmp	.+62     	; 0xb5b8 <Sl2s2002AppProcess+0x138>
bool ISO15693CheckCRC(void* FrameBuf, uint16_t FrameBufSize);

INLINE
bool ISO15693CompareUid(uint8_t* Uid1, uint8_t* Uid2)
{
    if (    (Uid1[0] == Uid2[0])
    b57a:	92 81       	ldd	r25, Z+2	; 0x02
    b57c:	98 13       	cpse	r25, r24
    b57e:	5d c1       	rjmp	.+698    	; 0xb83a <Sl2s2002AppProcess+0x3ba>
        &&  (Uid1[1] == Uid2[1])
    b580:	23 81       	ldd	r18, Z+3	; 0x03
    b582:	9a 81       	ldd	r25, Y+2	; 0x02
    b584:	29 13       	cpse	r18, r25
    b586:	59 c1       	rjmp	.+690    	; 0xb83a <Sl2s2002AppProcess+0x3ba>
        &&  (Uid1[2] == Uid2[2])
    b588:	24 81       	ldd	r18, Z+4	; 0x04
    b58a:	9b 81       	ldd	r25, Y+3	; 0x03
    b58c:	29 13       	cpse	r18, r25
    b58e:	55 c1       	rjmp	.+682    	; 0xb83a <Sl2s2002AppProcess+0x3ba>
        &&  (Uid1[3] == Uid2[3])
    b590:	25 81       	ldd	r18, Z+5	; 0x05
    b592:	9c 81       	ldd	r25, Y+4	; 0x04
    b594:	29 13       	cpse	r18, r25
    b596:	51 c1       	rjmp	.+674    	; 0xb83a <Sl2s2002AppProcess+0x3ba>
        &&  (Uid1[4] == Uid2[4])
    b598:	26 81       	ldd	r18, Z+6	; 0x06
    b59a:	9d 81       	ldd	r25, Y+5	; 0x05
    b59c:	29 13       	cpse	r18, r25
    b59e:	4d c1       	rjmp	.+666    	; 0xb83a <Sl2s2002AppProcess+0x3ba>
        &&  (Uid1[5] == Uid2[5])
    b5a0:	27 81       	ldd	r18, Z+7	; 0x07
    b5a2:	9e 81       	ldd	r25, Y+6	; 0x06
    b5a4:	29 13       	cpse	r18, r25
    b5a6:	49 c1       	rjmp	.+658    	; 0xb83a <Sl2s2002AppProcess+0x3ba>
        &&  (Uid1[6] == Uid2[6])
    b5a8:	20 85       	ldd	r18, Z+8	; 0x08
    b5aa:	9f 81       	ldd	r25, Y+7	; 0x07
    b5ac:	29 13       	cpse	r18, r25
    b5ae:	45 c1       	rjmp	.+650    	; 0xb83a <Sl2s2002AppProcess+0x3ba>
        &&  (Uid1[7] == Uid2[7]) ) {
    b5b0:	21 85       	ldd	r18, Z+9	; 0x09
    b5b2:	98 85       	ldd	r25, Y+8	; 0x08
    b5b4:	29 13       	cpse	r18, r25
    b5b6:	41 c1       	rjmp	.+642    	; 0xb83a <Sl2s2002AppProcess+0x3ba>
                    if (ISO15693Addressed(FrameBuf, Uid)) {
                        FrameBuf[0] = 0; /* Flags */
    b5b8:	f8 01       	movw	r30, r16
    b5ba:	10 82       	st	Z, r1
                        FrameBuf[1] = 0x0F; /* InfoFlags */
    b5bc:	9f e0       	ldi	r25, 0x0F	; 15
    b5be:	91 83       	std	Z+1, r25	; 0x01
}

INLINE
void ISO15693CopyUid(uint8_t* DstUid, uint8_t* SrcUid)
{
    DstUid[0] = SrcUid[0];
    b5c0:	82 83       	std	Z+2, r24	; 0x02
    DstUid[1] = SrcUid[1];
    b5c2:	8a 81       	ldd	r24, Y+2	; 0x02
    b5c4:	83 83       	std	Z+3, r24	; 0x03
    DstUid[2] = SrcUid[2];
    b5c6:	8b 81       	ldd	r24, Y+3	; 0x03
    b5c8:	84 83       	std	Z+4, r24	; 0x04
    DstUid[3] = SrcUid[3];
    b5ca:	8c 81       	ldd	r24, Y+4	; 0x04
    b5cc:	85 83       	std	Z+5, r24	; 0x05
    DstUid[4] = SrcUid[4];
    b5ce:	8d 81       	ldd	r24, Y+5	; 0x05
    b5d0:	86 83       	std	Z+6, r24	; 0x06
    DstUid[5] = SrcUid[5];
    b5d2:	8e 81       	ldd	r24, Y+6	; 0x06
    b5d4:	87 83       	std	Z+7, r24	; 0x07
    DstUid[6] = SrcUid[6];
    b5d6:	8f 81       	ldd	r24, Y+7	; 0x07
    b5d8:	80 87       	std	Z+8, r24	; 0x08
    DstUid[7] = SrcUid[7];
    b5da:	88 85       	ldd	r24, Y+8	; 0x08
    b5dc:	81 87       	std	Z+9, r24	; 0x09
                        ISO15693CopyUid(&FrameBuf[2], Uid);
                        FrameBuf[10] = 0x00;
    b5de:	12 86       	std	Z+10, r1	; 0x0a
                        FrameBuf[11] = 0xC2;
    b5e0:	82 ec       	ldi	r24, 0xC2	; 194
    b5e2:	83 87       	std	Z+11, r24	; 0x0b
                        FrameBuf[12] = 0x03;
    b5e4:	83 e0       	ldi	r24, 0x03	; 3
    b5e6:	84 87       	std	Z+12, r24	; 0x0c
                        FrameBuf[13] = 0x03;
    b5e8:	85 87       	std	Z+13, r24	; 0x0d
                        FrameBuf[14] = 0x01;
    b5ea:	81 e0       	ldi	r24, 0x01	; 1
    b5ec:	86 87       	std	Z+14, r24	; 0x0e
                        ResponseByteCount = 15;
    b5ee:	4f e0       	ldi	r20, 0x0F	; 15
    b5f0:	50 e0       	ldi	r21, 0x00	; 0
    b5f2:	18 c1       	rjmp	.+560    	; 0xb824 <Sl2s2002AppProcess+0x3a4>
                    }
                } else if (Command == ISO15693_CMD_READ_SINGLE) {
    b5f4:	20 32       	cpi	r18, 0x20	; 32
    b5f6:	09 f0       	breq	.+2      	; 0xb5fa <Sl2s2002AppProcess+0x17a>
    b5f8:	45 c0       	rjmp	.+138    	; 0xb684 <Sl2s2002AppProcess+0x204>
}

INLINE
bool ISO15693Addressed(uint8_t* Buffer, uint8_t* MyUid) {
    if (Buffer[0] & ISO15693_REQ_FLAG_ADDRESS) {
    b5fa:	f8 01       	movw	r30, r16
    b5fc:	80 81       	ld	r24, Z
    b5fe:	85 ff       	sbrs	r24, 5
    b600:	20 c0       	rjmp	.+64     	; 0xb642 <Sl2s2002AppProcess+0x1c2>
bool ISO15693CheckCRC(void* FrameBuf, uint16_t FrameBufSize);

INLINE
bool ISO15693CompareUid(uint8_t* Uid1, uint8_t* Uid2)
{
    if (    (Uid1[0] == Uid2[0])
    b602:	22 81       	ldd	r18, Z+2	; 0x02
    b604:	99 81       	ldd	r25, Y+1	; 0x01
    b606:	29 13       	cpse	r18, r25
    b608:	18 c1       	rjmp	.+560    	; 0xb83a <Sl2s2002AppProcess+0x3ba>
        &&  (Uid1[1] == Uid2[1])
    b60a:	23 81       	ldd	r18, Z+3	; 0x03
    b60c:	9a 81       	ldd	r25, Y+2	; 0x02
    b60e:	29 13       	cpse	r18, r25
    b610:	14 c1       	rjmp	.+552    	; 0xb83a <Sl2s2002AppProcess+0x3ba>
        &&  (Uid1[2] == Uid2[2])
    b612:	24 81       	ldd	r18, Z+4	; 0x04
    b614:	9b 81       	ldd	r25, Y+3	; 0x03
    b616:	29 13       	cpse	r18, r25
    b618:	10 c1       	rjmp	.+544    	; 0xb83a <Sl2s2002AppProcess+0x3ba>
        &&  (Uid1[3] == Uid2[3])
    b61a:	25 81       	ldd	r18, Z+5	; 0x05
    b61c:	9c 81       	ldd	r25, Y+4	; 0x04
    b61e:	29 13       	cpse	r18, r25
    b620:	0c c1       	rjmp	.+536    	; 0xb83a <Sl2s2002AppProcess+0x3ba>
        &&  (Uid1[4] == Uid2[4])
    b622:	26 81       	ldd	r18, Z+6	; 0x06
    b624:	9d 81       	ldd	r25, Y+5	; 0x05
    b626:	29 13       	cpse	r18, r25
    b628:	08 c1       	rjmp	.+528    	; 0xb83a <Sl2s2002AppProcess+0x3ba>
        &&  (Uid1[5] == Uid2[5])
    b62a:	27 81       	ldd	r18, Z+7	; 0x07
    b62c:	9e 81       	ldd	r25, Y+6	; 0x06
    b62e:	29 13       	cpse	r18, r25
    b630:	04 c1       	rjmp	.+520    	; 0xb83a <Sl2s2002AppProcess+0x3ba>
        &&  (Uid1[6] == Uid2[6])
    b632:	20 85       	ldd	r18, Z+8	; 0x08
    b634:	9f 81       	ldd	r25, Y+7	; 0x07
    b636:	29 13       	cpse	r18, r25
    b638:	00 c1       	rjmp	.+512    	; 0xb83a <Sl2s2002AppProcess+0x3ba>
        &&  (Uid1[7] == Uid2[7]) ) {
    b63a:	21 85       	ldd	r18, Z+9	; 0x09
    b63c:	98 85       	ldd	r25, Y+8	; 0x08
    b63e:	29 13       	cpse	r18, r25
    b640:	fc c0       	rjmp	.+504    	; 0xb83a <Sl2s2002AppProcess+0x3ba>
                      if (ISO15693Addressed(FrameBuf, Uid)) {
                          uint8_t PageAddress = FrameBuf[10];
    b642:	f8 01       	movw	r30, r16
    b644:	62 85       	ldd	r22, Z+10	; 0x0a
    b646:	70 e0       	ldi	r23, 0x00	; 0
                          if (FrameBuf[0] & ISO15693_REQ_FLAG_OPTION)
    b648:	86 ff       	sbrs	r24, 6
    b64a:	0f c0       	rjmp	.+30     	; 0xb66a <Sl2s2002AppProcess+0x1ea>
                          {
                              FrameBuf[0] = 0x00; /* Flags */
    b64c:	10 82       	st	Z, r1
                              FrameBuf[1] = 0x00; /* security dummy to 0 */
    b64e:	11 82       	std	Z+1, r1	; 0x01
                              MemoryReadBlock(FrameBuf + 2, PageAddress * BYTES_PER_PAGE, BYTES_PER_PAGE);
    b650:	66 0f       	add	r22, r22
    b652:	77 1f       	adc	r23, r23
    b654:	66 0f       	add	r22, r22
    b656:	77 1f       	adc	r23, r23
    b658:	44 e0       	ldi	r20, 0x04	; 4
    b65a:	50 e0       	ldi	r21, 0x00	; 0
    b65c:	c8 01       	movw	r24, r16
    b65e:	02 96       	adiw	r24, 0x02	; 2
    b660:	0e 94 a1 0f 	call	0x1f42	; 0x1f42 <MemoryReadBlock>
                              ResponseByteCount = 6;
    b664:	46 e0       	ldi	r20, 0x06	; 6
    b666:	50 e0       	ldi	r21, 0x00	; 0
    b668:	dd c0       	rjmp	.+442    	; 0xb824 <Sl2s2002AppProcess+0x3a4>
                          } else {
                              FrameBuf[0] = 0x00; /* Flags */
    b66a:	11 92       	st	Z+, r1
    b66c:	cf 01       	movw	r24, r30
                              MemoryReadBlock(FrameBuf + 1, PageAddress * BYTES_PER_PAGE, BYTES_PER_PAGE);
    b66e:	66 0f       	add	r22, r22
    b670:	77 1f       	adc	r23, r23
    b672:	66 0f       	add	r22, r22
    b674:	77 1f       	adc	r23, r23
    b676:	44 e0       	ldi	r20, 0x04	; 4
    b678:	50 e0       	ldi	r21, 0x00	; 0
    b67a:	0e 94 a1 0f 	call	0x1f42	; 0x1f42 <MemoryReadBlock>
                              ResponseByteCount = 5;
    b67e:	45 e0       	ldi	r20, 0x05	; 5
    b680:	50 e0       	ldi	r21, 0x00	; 0
    b682:	d0 c0       	rjmp	.+416    	; 0xb824 <Sl2s2002AppProcess+0x3a4>
                          }
                      }
                } else if (Command == ISO15693_CMD_READ_MULTIPLE) {
    b684:	23 32       	cpi	r18, 0x23	; 35
    b686:	09 f0       	breq	.+2      	; 0xb68a <Sl2s2002AppProcess+0x20a>
    b688:	6a c0       	rjmp	.+212    	; 0xb75e <Sl2s2002AppProcess+0x2de>
    DstUid[7] = SrcUid[7];
}

INLINE
bool ISO15693Addressed(uint8_t* Buffer, uint8_t* MyUid) {
    if (Buffer[0] & ISO15693_REQ_FLAG_ADDRESS) {
    b68a:	f8 01       	movw	r30, r16
    b68c:	80 81       	ld	r24, Z
    b68e:	85 ff       	sbrs	r24, 5
    b690:	20 c0       	rjmp	.+64     	; 0xb6d2 <Sl2s2002AppProcess+0x252>
bool ISO15693CheckCRC(void* FrameBuf, uint16_t FrameBufSize);

INLINE
bool ISO15693CompareUid(uint8_t* Uid1, uint8_t* Uid2)
{
    if (    (Uid1[0] == Uid2[0])
    b692:	22 81       	ldd	r18, Z+2	; 0x02
    b694:	99 81       	ldd	r25, Y+1	; 0x01
    b696:	29 13       	cpse	r18, r25
    b698:	d0 c0       	rjmp	.+416    	; 0xb83a <Sl2s2002AppProcess+0x3ba>
        &&  (Uid1[1] == Uid2[1])
    b69a:	23 81       	ldd	r18, Z+3	; 0x03
    b69c:	9a 81       	ldd	r25, Y+2	; 0x02
    b69e:	29 13       	cpse	r18, r25
    b6a0:	cc c0       	rjmp	.+408    	; 0xb83a <Sl2s2002AppProcess+0x3ba>
        &&  (Uid1[2] == Uid2[2])
    b6a2:	24 81       	ldd	r18, Z+4	; 0x04
    b6a4:	9b 81       	ldd	r25, Y+3	; 0x03
    b6a6:	29 13       	cpse	r18, r25
    b6a8:	c8 c0       	rjmp	.+400    	; 0xb83a <Sl2s2002AppProcess+0x3ba>
        &&  (Uid1[3] == Uid2[3])
    b6aa:	25 81       	ldd	r18, Z+5	; 0x05
    b6ac:	9c 81       	ldd	r25, Y+4	; 0x04
    b6ae:	29 13       	cpse	r18, r25
    b6b0:	c4 c0       	rjmp	.+392    	; 0xb83a <Sl2s2002AppProcess+0x3ba>
        &&  (Uid1[4] == Uid2[4])
    b6b2:	26 81       	ldd	r18, Z+6	; 0x06
    b6b4:	9d 81       	ldd	r25, Y+5	; 0x05
    b6b6:	29 13       	cpse	r18, r25
    b6b8:	c0 c0       	rjmp	.+384    	; 0xb83a <Sl2s2002AppProcess+0x3ba>
        &&  (Uid1[5] == Uid2[5])
    b6ba:	27 81       	ldd	r18, Z+7	; 0x07
    b6bc:	9e 81       	ldd	r25, Y+6	; 0x06
    b6be:	29 13       	cpse	r18, r25
    b6c0:	bc c0       	rjmp	.+376    	; 0xb83a <Sl2s2002AppProcess+0x3ba>
        &&  (Uid1[6] == Uid2[6])
    b6c2:	20 85       	ldd	r18, Z+8	; 0x08
    b6c4:	9f 81       	ldd	r25, Y+7	; 0x07
    b6c6:	29 13       	cpse	r18, r25
    b6c8:	b8 c0       	rjmp	.+368    	; 0xb83a <Sl2s2002AppProcess+0x3ba>
                    if (ISO15693Addressed(FrameBuf, Uid)) {
    b6ca:	21 85       	ldd	r18, Z+9	; 0x09
    b6cc:	98 85       	ldd	r25, Y+8	; 0x08
    b6ce:	29 13       	cpse	r18, r25
    b6d0:	b4 c0       	rjmp	.+360    	; 0xb83a <Sl2s2002AppProcess+0x3ba>
                        uint16_t PageAddress = FrameBuf[10];
    b6d2:	f8 01       	movw	r30, r16
    b6d4:	62 85       	ldd	r22, Z+10	; 0x0a
                        uint16_t PageAddressCount = FrameBuf[11] + 1;
    b6d6:	e3 84       	ldd	r14, Z+11	; 0x0b
    b6d8:	f1 2c       	mov	r15, r1
    b6da:	ff ef       	ldi	r31, 0xFF	; 255
    b6dc:	ef 1a       	sub	r14, r31
    b6de:	ff 0a       	sbc	r15, r31

                        uint8_t * FrameBufPtr = FrameBuf + 1;
    b6e0:	58 01       	movw	r10, r16
    b6e2:	9f ef       	ldi	r25, 0xFF	; 255
    b6e4:	a9 1a       	sub	r10, r25
    b6e6:	b9 0a       	sbc	r11, r25
    b6e8:	70 e0       	ldi	r23, 0x00	; 0
                        if (FrameBuf[0] & ISO15693_REQ_FLAG_OPTION)
    b6ea:	86 ff       	sbrs	r24, 6
    b6ec:	26 c0       	rjmp	.+76     	; 0xb73a <Sl2s2002AppProcess+0x2ba>
    b6ee:	6b 01       	movw	r12, r22
    b6f0:	cc 0c       	add	r12, r12
    b6f2:	dd 1c       	adc	r13, r13
    b6f4:	cc 0c       	add	r12, r12
    b6f6:	dd 1c       	adc	r13, r13
    b6f8:	61 2c       	mov	r6, r1
    b6fa:	71 2c       	mov	r7, r1
    b6fc:	91 2c       	mov	r9, r1
                        {
                            uint8_t count;
                            for (count = 0; count < PageAddressCount; count++)
    b6fe:	89 2d       	mov	r24, r9
    b700:	90 e0       	ldi	r25, 0x00	; 0
    b702:	8e 15       	cp	r24, r14
    b704:	9f 05       	cpc	r25, r15
    b706:	90 f4       	brcc	.+36     	; 0xb72c <Sl2s2002AppProcess+0x2ac>
                            {
                                *FrameBufPtr++ = 0; // block security status = unlocked
    b708:	f5 01       	movw	r30, r10
    b70a:	11 92       	st	Z+, r1
    b70c:	cf 01       	movw	r24, r30
    b70e:	b3 01       	movw	r22, r6
    b710:	6c 0d       	add	r22, r12
    b712:	7d 1d       	adc	r23, r13
                                MemoryReadBlock(FrameBufPtr, PageAddress * BYTES_PER_PAGE, BYTES_PER_PAGE);
    b714:	44 e0       	ldi	r20, 0x04	; 4
    b716:	50 e0       	ldi	r21, 0x00	; 0
    b718:	0e 94 a1 0f 	call	0x1f42	; 0x1f42 <MemoryReadBlock>
    b71c:	f5 e0       	ldi	r31, 0x05	; 5
    b71e:	af 0e       	add	r10, r31
    b720:	b1 1c       	adc	r11, r1

                        uint8_t * FrameBufPtr = FrameBuf + 1;
                        if (FrameBuf[0] & ISO15693_REQ_FLAG_OPTION)
                        {
                            uint8_t count;
                            for (count = 0; count < PageAddressCount; count++)
    b722:	93 94       	inc	r9
    b724:	84 e0       	ldi	r24, 0x04	; 4
    b726:	68 0e       	add	r6, r24
    b728:	71 1c       	adc	r7, r1
    b72a:	e9 cf       	rjmp	.-46     	; 0xb6fe <Sl2s2002AppProcess+0x27e>
                                *FrameBufPtr++ = 0; // block security status = unlocked
                                MemoryReadBlock(FrameBufPtr, PageAddress * BYTES_PER_PAGE, BYTES_PER_PAGE);
                                FrameBufPtr += BYTES_PER_PAGE;
                                PageAddress += 1;
                            }
                            ResponseByteCount = 1 + (BYTES_PER_PAGE + 1) * PageAddressCount;
    b72c:	85 e0       	ldi	r24, 0x05	; 5
    b72e:	8e 9d       	mul	r24, r14
    b730:	a0 01       	movw	r20, r0
    b732:	8f 9d       	mul	r24, r15
    b734:	50 0d       	add	r21, r0
    b736:	11 24       	eor	r1, r1
    b738:	0d c0       	rjmp	.+26     	; 0xb754 <Sl2s2002AppProcess+0x2d4>
                        } else {
                            MemoryReadBlock(FrameBufPtr, PageAddress * BYTES_PER_PAGE, BYTES_PER_PAGE * PageAddressCount);
    b73a:	ee 0c       	add	r14, r14
    b73c:	ff 1c       	adc	r15, r15
    b73e:	ee 0c       	add	r14, r14
    b740:	ff 1c       	adc	r15, r15
    b742:	66 0f       	add	r22, r22
    b744:	77 1f       	adc	r23, r23
    b746:	66 0f       	add	r22, r22
    b748:	77 1f       	adc	r23, r23
    b74a:	a7 01       	movw	r20, r14
    b74c:	c5 01       	movw	r24, r10
    b74e:	0e 94 a1 0f 	call	0x1f42	; 0x1f42 <MemoryReadBlock>
                            ResponseByteCount = 1 + BYTES_PER_PAGE * PageAddressCount;
    b752:	a7 01       	movw	r20, r14
    b754:	4f 5f       	subi	r20, 0xFF	; 255
    b756:	5f 4f       	sbci	r21, 0xFF	; 255
                        }
                        FrameBuf[0] = 0; /* Flags */
    b758:	f8 01       	movw	r30, r16
    b75a:	10 82       	st	Z, r1
    b75c:	63 c0       	rjmp	.+198    	; 0xb824 <Sl2s2002AppProcess+0x3a4>
                    }
                } else if (Command == ISO15693_CMD_GET_BLOCK_SEC) {
    b75e:	2c 32       	cpi	r18, 0x2C	; 44
    b760:	09 f0       	breq	.+2      	; 0xb764 <Sl2s2002AppProcess+0x2e4>
    b762:	6b c0       	rjmp	.+214    	; 0xb83a <Sl2s2002AppProcess+0x3ba>
    DstUid[7] = SrcUid[7];
}

INLINE
bool ISO15693Addressed(uint8_t* Buffer, uint8_t* MyUid) {
    if (Buffer[0] & ISO15693_REQ_FLAG_ADDRESS) {
    b764:	f8 01       	movw	r30, r16
    b766:	80 81       	ld	r24, Z
    b768:	85 ff       	sbrs	r24, 5
    b76a:	20 c0       	rjmp	.+64     	; 0xb7ac <Sl2s2002AppProcess+0x32c>
bool ISO15693CheckCRC(void* FrameBuf, uint16_t FrameBufSize);

INLINE
bool ISO15693CompareUid(uint8_t* Uid1, uint8_t* Uid2)
{
    if (    (Uid1[0] == Uid2[0])
    b76c:	92 81       	ldd	r25, Z+2	; 0x02
    b76e:	89 81       	ldd	r24, Y+1	; 0x01
    b770:	98 13       	cpse	r25, r24
    b772:	63 c0       	rjmp	.+198    	; 0xb83a <Sl2s2002AppProcess+0x3ba>
        &&  (Uid1[1] == Uid2[1])
    b774:	93 81       	ldd	r25, Z+3	; 0x03
    b776:	8a 81       	ldd	r24, Y+2	; 0x02
    b778:	98 13       	cpse	r25, r24
    b77a:	5f c0       	rjmp	.+190    	; 0xb83a <Sl2s2002AppProcess+0x3ba>
        &&  (Uid1[2] == Uid2[2])
    b77c:	94 81       	ldd	r25, Z+4	; 0x04
    b77e:	8b 81       	ldd	r24, Y+3	; 0x03
    b780:	98 13       	cpse	r25, r24
    b782:	5b c0       	rjmp	.+182    	; 0xb83a <Sl2s2002AppProcess+0x3ba>
        &&  (Uid1[3] == Uid2[3])
    b784:	95 81       	ldd	r25, Z+5	; 0x05
    b786:	8c 81       	ldd	r24, Y+4	; 0x04
    b788:	98 13       	cpse	r25, r24
    b78a:	57 c0       	rjmp	.+174    	; 0xb83a <Sl2s2002AppProcess+0x3ba>
        &&  (Uid1[4] == Uid2[4])
    b78c:	96 81       	ldd	r25, Z+6	; 0x06
    b78e:	8d 81       	ldd	r24, Y+5	; 0x05
    b790:	98 13       	cpse	r25, r24
    b792:	53 c0       	rjmp	.+166    	; 0xb83a <Sl2s2002AppProcess+0x3ba>
        &&  (Uid1[5] == Uid2[5])
    b794:	97 81       	ldd	r25, Z+7	; 0x07
    b796:	8e 81       	ldd	r24, Y+6	; 0x06
    b798:	98 13       	cpse	r25, r24
    b79a:	4f c0       	rjmp	.+158    	; 0xb83a <Sl2s2002AppProcess+0x3ba>
        &&  (Uid1[6] == Uid2[6])
    b79c:	90 85       	ldd	r25, Z+8	; 0x08
    b79e:	8f 81       	ldd	r24, Y+7	; 0x07
    b7a0:	98 13       	cpse	r25, r24
    b7a2:	4b c0       	rjmp	.+150    	; 0xb83a <Sl2s2002AppProcess+0x3ba>
        &&  (Uid1[7] == Uid2[7]) ) {
    b7a4:	91 85       	ldd	r25, Z+9	; 0x09
    b7a6:	88 85       	ldd	r24, Y+8	; 0x08
    b7a8:	98 13       	cpse	r25, r24
    b7aa:	47 c0       	rjmp	.+142    	; 0xb83a <Sl2s2002AppProcess+0x3ba>
                    if (ISO15693Addressed(FrameBuf, Uid)) {
                        uint8_t PageAddressStart = FrameBuf[10];
                        uint8_t PageAddressCount = FrameBuf[11] + 1;
    b7ac:	f8 01       	movw	r30, r16
    b7ae:	43 85       	ldd	r20, Z+11	; 0x0b
    b7b0:	4f 5f       	subi	r20, 0xFF	; 255
                        FrameBuf[0] = 0; /* Flags */
    b7b2:	10 82       	st	Z, r1
    b7b4:	90 2f       	mov	r25, r16
                        for (uint8_t i = 0; i < PageAddressCount; i++) {
    b7b6:	f8 01       	movw	r30, r16
    b7b8:	8e 2f       	mov	r24, r30
    b7ba:	89 1b       	sub	r24, r25
    b7bc:	84 17       	cp	r24, r20
    b7be:	10 f4       	brcc	.+4      	; 0xb7c4 <Sl2s2002AppProcess+0x344>
                            FrameBuf[i] = 0x00;
    b7c0:	11 92       	st	Z+, r1
    b7c2:	fa cf       	rjmp	.-12     	; 0xb7b8 <Sl2s2002AppProcess+0x338>
                        }
                        ResponseByteCount = 1 + PageAddressCount;
    b7c4:	50 e0       	ldi	r21, 0x00	; 0
    b7c6:	4f 5f       	subi	r20, 0xFF	; 255
    b7c8:	5f 4f       	sbci	r21, 0xFF	; 255
    b7ca:	2c c0       	rjmp	.+88     	; 0xb824 <Sl2s2002AppProcess+0x3a4>
            case STATE_SELECTED:

                break;

            case STATE_QUIET:
                if (Command == ISO15693_CMD_RESET_TO_READY) {
    b7cc:	26 32       	cpi	r18, 0x26	; 38
    b7ce:	a9 f5       	brne	.+106    	; 0xb83a <Sl2s2002AppProcess+0x3ba>
    DstUid[7] = SrcUid[7];
}

INLINE
bool ISO15693Addressed(uint8_t* Buffer, uint8_t* MyUid) {
    if (Buffer[0] & ISO15693_REQ_FLAG_ADDRESS) {
    b7d0:	f8 01       	movw	r30, r16
    b7d2:	80 81       	ld	r24, Z
    b7d4:	85 ff       	sbrs	r24, 5
    b7d6:	20 c0       	rjmp	.+64     	; 0xb818 <Sl2s2002AppProcess+0x398>
bool ISO15693CheckCRC(void* FrameBuf, uint16_t FrameBufSize);

INLINE
bool ISO15693CompareUid(uint8_t* Uid1, uint8_t* Uid2)
{
    if (    (Uid1[0] == Uid2[0])
    b7d8:	92 81       	ldd	r25, Z+2	; 0x02
    b7da:	89 81       	ldd	r24, Y+1	; 0x01
    b7dc:	98 13       	cpse	r25, r24
    b7de:	2d c0       	rjmp	.+90     	; 0xb83a <Sl2s2002AppProcess+0x3ba>
        &&  (Uid1[1] == Uid2[1])
    b7e0:	93 81       	ldd	r25, Z+3	; 0x03
    b7e2:	8a 81       	ldd	r24, Y+2	; 0x02
    b7e4:	98 13       	cpse	r25, r24
    b7e6:	29 c0       	rjmp	.+82     	; 0xb83a <Sl2s2002AppProcess+0x3ba>
        &&  (Uid1[2] == Uid2[2])
    b7e8:	94 81       	ldd	r25, Z+4	; 0x04
    b7ea:	8b 81       	ldd	r24, Y+3	; 0x03
    b7ec:	98 13       	cpse	r25, r24
    b7ee:	25 c0       	rjmp	.+74     	; 0xb83a <Sl2s2002AppProcess+0x3ba>
        &&  (Uid1[3] == Uid2[3])
    b7f0:	95 81       	ldd	r25, Z+5	; 0x05
    b7f2:	8c 81       	ldd	r24, Y+4	; 0x04
    b7f4:	98 13       	cpse	r25, r24
    b7f6:	21 c0       	rjmp	.+66     	; 0xb83a <Sl2s2002AppProcess+0x3ba>
        &&  (Uid1[4] == Uid2[4])
    b7f8:	96 81       	ldd	r25, Z+6	; 0x06
    b7fa:	8d 81       	ldd	r24, Y+5	; 0x05
    b7fc:	98 13       	cpse	r25, r24
    b7fe:	1d c0       	rjmp	.+58     	; 0xb83a <Sl2s2002AppProcess+0x3ba>
        &&  (Uid1[5] == Uid2[5])
    b800:	97 81       	ldd	r25, Z+7	; 0x07
    b802:	8e 81       	ldd	r24, Y+6	; 0x06
    b804:	98 13       	cpse	r25, r24
    b806:	19 c0       	rjmp	.+50     	; 0xb83a <Sl2s2002AppProcess+0x3ba>
        &&  (Uid1[6] == Uid2[6])
    b808:	90 85       	ldd	r25, Z+8	; 0x08
    b80a:	8f 81       	ldd	r24, Y+7	; 0x07
    b80c:	98 13       	cpse	r25, r24
    b80e:	15 c0       	rjmp	.+42     	; 0xb83a <Sl2s2002AppProcess+0x3ba>
        &&  (Uid1[7] == Uid2[7]) ) {
    b810:	91 85       	ldd	r25, Z+9	; 0x09
    b812:	88 85       	ldd	r24, Y+8	; 0x08
    b814:	98 13       	cpse	r25, r24
    b816:	11 c0       	rjmp	.+34     	; 0xb83a <Sl2s2002AppProcess+0x3ba>
                    if (ISO15693Addressed(FrameBuf, Uid)) {
                        FrameBuf[0] = 0;
    b818:	f8 01       	movw	r30, r16
    b81a:	10 82       	st	Z, r1
                        ResponseByteCount = 1;
                        State = STATE_READY;
    b81c:	10 92 4b 2e 	sts	0x2E4B, r1

            case STATE_QUIET:
                if (Command == ISO15693_CMD_RESET_TO_READY) {
                    if (ISO15693Addressed(FrameBuf, Uid)) {
                        FrameBuf[0] = 0;
                        ResponseByteCount = 1;
    b820:	41 e0       	ldi	r20, 0x01	; 1
    b822:	50 e0       	ldi	r21, 0x00	; 0
                break;
            }

            if (ResponseByteCount > 0) {
                /* There is data to be sent. Append CRC */
                ISO15693AppendCRC(FrameBuf, ResponseByteCount);
    b824:	ba 01       	movw	r22, r20
    b826:	c8 01       	movw	r24, r16
    b828:	49 87       	std	Y+9, r20	; 0x09
    b82a:	5a 87       	std	Y+10, r21	; 0x0a
    b82c:	95 d1       	rcall	.+810    	; 0xbb58 <ISO15693AppendCRC>
                ResponseByteCount += ISO15693_CRC16_SIZE;
    b82e:	49 85       	ldd	r20, Y+9	; 0x09
    b830:	5a 85       	ldd	r21, Y+10	; 0x0a
    b832:	4e 5f       	subi	r20, 0xFE	; 254
    b834:	5f 4f       	sbci	r21, 0xFF	; 255
            }

            return ResponseByteCount;
    b836:	ca 01       	movw	r24, r20
    b838:	03 c0       	rjmp	.+6      	; 0xb840 <Sl2s2002AppProcess+0x3c0>
                } else if (Command == ISO15693_CMD_GET_BLOCK_SEC) {
                    if (ISO15693Addressed(FrameBuf, Uid)) {
                        uint8_t PageAddressStart = FrameBuf[10];
                        uint8_t PageAddressCount = FrameBuf[11] + 1;
                        FrameBuf[0] = 0; /* Flags */
                        for (uint8_t i = 0; i < PageAddressCount; i++) {
    b83a:	40 e0       	ldi	r20, 0x00	; 0
    b83c:	50 e0       	ldi	r21, 0x00	; 0
    b83e:	fb cf       	rjmp	.-10     	; 0xb836 <Sl2s2002AppProcess+0x3b6>
        }
    } else { // Min frame size not met
        return ISO15693_APP_NO_RESPONSE;
    }
    
}
    b840:	2a 96       	adiw	r28, 0x0a	; 10
    b842:	cd bf       	out	0x3d, r28	; 61
    b844:	de bf       	out	0x3e, r29	; 62
    b846:	df 91       	pop	r29
    b848:	cf 91       	pop	r28
    b84a:	1f 91       	pop	r17
    b84c:	0f 91       	pop	r16
    b84e:	ff 90       	pop	r15
    b850:	ef 90       	pop	r14
    b852:	df 90       	pop	r13
    b854:	cf 90       	pop	r12
    b856:	bf 90       	pop	r11
    b858:	af 90       	pop	r10
    b85a:	9f 90       	pop	r9
    b85c:	7f 90       	pop	r7
    b85e:	6f 90       	pop	r6
    b860:	08 95       	ret

0000b862 <Sl2s2002GetUid>:

void Sl2s2002GetUid(ConfigurationUidType Uid)
{
    MemoryReadBlock(&Uid[0], MEM_UID_ADDRESS, ActiveConfiguration.UidSize);
    b862:	40 91 6c 2f 	lds	r20, 0x2F6C
    b866:	50 e0       	ldi	r21, 0x00	; 0
    b868:	60 e0       	ldi	r22, 0x00	; 0
    b86a:	70 e0       	ldi	r23, 0x00	; 0
    b86c:	0c 94 a1 0f 	jmp	0x1f42	; 0x1f42 <MemoryReadBlock>

0000b870 <Sl2s2002SetUid>:
}

void Sl2s2002SetUid(ConfigurationUidType Uid)
{
    MemoryWriteBlock(Uid, MEM_UID_ADDRESS, ActiveConfiguration.UidSize);
    b870:	40 91 6c 2f 	lds	r20, 0x2F6C
    b874:	50 e0       	ldi	r21, 0x00	; 0
    b876:	60 e0       	ldi	r22, 0x00	; 0
    b878:	70 e0       	ldi	r23, 0x00	; 0
    b87a:	0c 94 ef 0f 	jmp	0x1fde	; 0x1fde <MemoryWriteBlock>

0000b87e <TITagitstandardAppInit>:
//0xC0 0xC1 = "Tagitstandard" 0xC4 or 0xC5 "TagitPro" 0x00 or 0x01 or 0x80 or 0x81 "Tagitplus"


void TITagitstandardAppInit(void)
{
    State = STATE_READY;
    b87e:	10 92 4c 2e 	sts	0x2E4C, r1
    b882:	08 95       	ret

0000b884 <TITagitstandardAppReset>:
}

void TITagitstandardAppReset(void)
{
    State = STATE_READY;
    b884:	10 92 4c 2e 	sts	0x2E4C, r1
    b888:	08 95       	ret

0000b88a <TITagitstandardAppTask>:
}


void TITagitstandardAppTask(void)
{
    b88a:	08 95       	ret

0000b88c <TITagitstandardAppTick>:
    
}

void TITagitstandardAppTick(void)
{
    b88c:	08 95       	ret

0000b88e <TITagitstandardAppProcess>:
//     snprintf(buf,16, "%02x",val);
//     TerminalSendString(buf);
// }

uint16_t TITagitstandardAppProcess(uint8_t* FrameBuf, uint16_t FrameBytes)
{
    b88e:	ef 92       	push	r14
    b890:	ff 92       	push	r15
    b892:	0f 93       	push	r16
    b894:	1f 93       	push	r17
    b896:	cf 93       	push	r28
    b898:	df 93       	push	r29
    b89a:	cd b7       	in	r28, 0x3d	; 61
    b89c:	de b7       	in	r29, 0x3e	; 62
    b89e:	29 97       	sbiw	r28, 0x09	; 9
    b8a0:	cd bf       	out	0x3d, r28	; 61
    b8a2:	de bf       	out	0x3e, r29	; 62
    
    

    if (FrameBytes >= ISO15693_MIN_FRAME_SIZE) {
    b8a4:	65 30       	cpi	r22, 0x05	; 5
    b8a6:	71 05       	cpc	r23, r1
    b8a8:	18 f4       	brcc	.+6      	; 0xb8b0 <TITagitstandardAppProcess+0x22>
        
        } else { // Invalid CRC
            return ISO15693_APP_NO_RESPONSE;
        }
    } else { // Min frame size not met
        return ISO15693_APP_NO_RESPONSE;
    b8aa:	80 e0       	ldi	r24, 0x00	; 0
    b8ac:	90 e0       	ldi	r25, 0x00	; 0
    b8ae:	1d c1       	rjmp	.+570    	; 0xbaea <TITagitstandardAppProcess+0x25c>
    b8b0:	8c 01       	movw	r16, r24
{
    
    

    if (FrameBytes >= ISO15693_MIN_FRAME_SIZE) {
        if(ISO15693CheckCRC(FrameBuf, FrameBytes - ISO15693_CRC16_SIZE)) {
    b8b2:	62 50       	subi	r22, 0x02	; 2
    b8b4:	71 09       	sbc	r23, r1
    b8b6:	60 d1       	rcall	.+704    	; 0xbb78 <ISO15693CheckCRC>
    b8b8:	88 23       	and	r24, r24
    b8ba:	b9 f3       	breq	.-18     	; 0xb8aa <TITagitstandardAppProcess+0x1c>
            // At this point, we have a valid ISO15693 frame
            uint8_t Command = FrameBuf[1];
    b8bc:	f8 01       	movw	r30, r16
    b8be:	21 81       	ldd	r18, Z+1	; 0x01
            uint16_t ResponseByteCount = ISO15693_APP_NO_RESPONSE;
            uint8_t Uid[8];

	    //MemoryReadBlock(actualTagIt, 0, 44); // read the whole tag from FRAM
            MemoryReadBlock(Uid, MEM_UID_ADDRESS, ActiveConfiguration.UidSize);
    b8c0:	40 91 6c 2f 	lds	r20, 0x2F6C
    b8c4:	50 e0       	ldi	r21, 0x00	; 0
    b8c6:	60 e2       	ldi	r22, 0x20	; 32
    b8c8:	70 e0       	ldi	r23, 0x00	; 0
    b8ca:	ce 01       	movw	r24, r28
    b8cc:	01 96       	adiw	r24, 0x01	; 1
    b8ce:	29 87       	std	Y+9, r18	; 0x09
    b8d0:	0e 94 a1 0f 	call	0x1f42	; 0x1f42 <MemoryReadBlock>
	                                      
            //for (j==0 ; j < ActiveConfiguration.UidSize; j++) Uid[j] = actualTagIt[MEM_UID_ADDRESS + j] ;

            switch(State) {
    b8d4:	80 91 4c 2e 	lds	r24, 0x2E4C
    b8d8:	29 85       	ldd	r18, Y+9	; 0x09
    b8da:	88 23       	and	r24, r24
    b8dc:	21 f0       	breq	.+8      	; 0xb8e6 <TITagitstandardAppProcess+0x58>
    b8de:	82 30       	cpi	r24, 0x02	; 2
    b8e0:	09 f4       	brne	.+2      	; 0xb8e4 <TITagitstandardAppProcess+0x56>
    b8e2:	c2 c0       	rjmp	.+388    	; 0xba68 <TITagitstandardAppProcess+0x1da>
    b8e4:	f7 c0       	rjmp	.+494    	; 0xbad4 <TITagitstandardAppProcess+0x246>
            case STATE_READY:
                if (Command == ISO15693_CMD_INVENTORY) {
    b8e6:	21 30       	cpi	r18, 0x01	; 1
    b8e8:	b9 f4       	brne	.+46     	; 0xb918 <TITagitstandardAppProcess+0x8a>
                    FrameBuf[0] = 0x00; /* Flags */
    b8ea:	f8 01       	movw	r30, r16
    b8ec:	10 82       	st	Z, r1
                    FrameBuf[1] = 0x00; /* DSFID */		    
    b8ee:	11 82       	std	Z+1, r1	; 0x01
}

INLINE
void ISO15693CopyUid(uint8_t* DstUid, uint8_t* SrcUid)
{
    DstUid[0] = SrcUid[0];
    b8f0:	89 81       	ldd	r24, Y+1	; 0x01
    b8f2:	82 83       	std	Z+2, r24	; 0x02
    DstUid[1] = SrcUid[1];
    b8f4:	8a 81       	ldd	r24, Y+2	; 0x02
    b8f6:	83 83       	std	Z+3, r24	; 0x03
    DstUid[2] = SrcUid[2];
    b8f8:	8b 81       	ldd	r24, Y+3	; 0x03
    b8fa:	84 83       	std	Z+4, r24	; 0x04
    DstUid[3] = SrcUid[3];
    b8fc:	8c 81       	ldd	r24, Y+4	; 0x04
    b8fe:	85 83       	std	Z+5, r24	; 0x05
    DstUid[4] = SrcUid[4];
    b900:	8d 81       	ldd	r24, Y+5	; 0x05
    b902:	86 83       	std	Z+6, r24	; 0x06
    DstUid[5] = SrcUid[5];
    b904:	8e 81       	ldd	r24, Y+6	; 0x06
    b906:	87 83       	std	Z+7, r24	; 0x07
    DstUid[6] = SrcUid[6];
    b908:	8f 81       	ldd	r24, Y+7	; 0x07
    b90a:	80 87       	std	Z+8, r24	; 0x08
    DstUid[7] = SrcUid[7];
    b90c:	88 85       	ldd	r24, Y+8	; 0x08
    b90e:	81 87       	std	Z+9, r24	; 0x09
                    ISO15693CopyUid(&FrameBuf[2], Uid);
		    
                    ResponseByteCount = 10;
    b910:	4a e0       	ldi	r20, 0x0A	; 10
    b912:	e4 2e       	mov	r14, r20
    b914:	f1 2c       	mov	r15, r1
    b916:	e2 c0       	rjmp	.+452    	; 0xbadc <TITagitstandardAppProcess+0x24e>
		    

                } else if (Command == ISO15693_CMD_STAY_QUIET) {
    b918:	22 30       	cpi	r18, 0x02	; 2
    b91a:	41 f5       	brne	.+80     	; 0xb96c <TITagitstandardAppProcess+0xde>
}

INLINE
bool ISO15693Addressed(uint8_t* Buffer, uint8_t* MyUid) {
    if (Buffer[0] & ISO15693_REQ_FLAG_ADDRESS) {
    b91c:	f8 01       	movw	r30, r16
    b91e:	80 81       	ld	r24, Z
    b920:	85 ff       	sbrs	r24, 5
    b922:	20 c0       	rjmp	.+64     	; 0xb964 <TITagitstandardAppProcess+0xd6>
bool ISO15693CheckCRC(void* FrameBuf, uint16_t FrameBufSize);

INLINE
bool ISO15693CompareUid(uint8_t* Uid1, uint8_t* Uid2)
{
    if (    (Uid1[0] == Uid2[0])
    b924:	92 81       	ldd	r25, Z+2	; 0x02
    b926:	89 81       	ldd	r24, Y+1	; 0x01
    b928:	98 13       	cpse	r25, r24
    b92a:	d4 c0       	rjmp	.+424    	; 0xbad4 <TITagitstandardAppProcess+0x246>
        &&  (Uid1[1] == Uid2[1])
    b92c:	93 81       	ldd	r25, Z+3	; 0x03
    b92e:	8a 81       	ldd	r24, Y+2	; 0x02
    b930:	98 13       	cpse	r25, r24
    b932:	d0 c0       	rjmp	.+416    	; 0xbad4 <TITagitstandardAppProcess+0x246>
        &&  (Uid1[2] == Uid2[2])
    b934:	94 81       	ldd	r25, Z+4	; 0x04
    b936:	8b 81       	ldd	r24, Y+3	; 0x03
    b938:	98 13       	cpse	r25, r24
    b93a:	cc c0       	rjmp	.+408    	; 0xbad4 <TITagitstandardAppProcess+0x246>
        &&  (Uid1[3] == Uid2[3])
    b93c:	95 81       	ldd	r25, Z+5	; 0x05
    b93e:	8c 81       	ldd	r24, Y+4	; 0x04
    b940:	98 13       	cpse	r25, r24
    b942:	c8 c0       	rjmp	.+400    	; 0xbad4 <TITagitstandardAppProcess+0x246>
        &&  (Uid1[4] == Uid2[4])
    b944:	96 81       	ldd	r25, Z+6	; 0x06
    b946:	8d 81       	ldd	r24, Y+5	; 0x05
    b948:	98 13       	cpse	r25, r24
    b94a:	c4 c0       	rjmp	.+392    	; 0xbad4 <TITagitstandardAppProcess+0x246>
        &&  (Uid1[5] == Uid2[5])
    b94c:	97 81       	ldd	r25, Z+7	; 0x07
    b94e:	8e 81       	ldd	r24, Y+6	; 0x06
    b950:	98 13       	cpse	r25, r24
    b952:	c0 c0       	rjmp	.+384    	; 0xbad4 <TITagitstandardAppProcess+0x246>
        &&  (Uid1[6] == Uid2[6])
    b954:	90 85       	ldd	r25, Z+8	; 0x08
    b956:	8f 81       	ldd	r24, Y+7	; 0x07
    b958:	98 13       	cpse	r25, r24
    b95a:	bc c0       	rjmp	.+376    	; 0xbad4 <TITagitstandardAppProcess+0x246>
                    if (ISO15693Addressed(FrameBuf,Uid)) {
    b95c:	91 85       	ldd	r25, Z+9	; 0x09
    b95e:	88 85       	ldd	r24, Y+8	; 0x08
    b960:	98 13       	cpse	r25, r24
    b962:	b8 c0       	rjmp	.+368    	; 0xbad4 <TITagitstandardAppProcess+0x246>
                        State = STATE_QUIET;
    b964:	82 e0       	ldi	r24, 0x02	; 2
    b966:	80 93 4c 2e 	sts	0x2E4C, r24
    b96a:	b4 c0       	rjmp	.+360    	; 0xbad4 <TITagitstandardAppProcess+0x246>

                    }

                } else if (Command == ISO15693_CMD_READ_SINGLE) {
    b96c:	20 32       	cpi	r18, 0x20	; 32
    b96e:	09 f0       	breq	.+2      	; 0xb972 <TITagitstandardAppProcess+0xe4>
    b970:	47 c0       	rjmp	.+142    	; 0xba00 <TITagitstandardAppProcess+0x172>
		      uint8_t *FramePtr ;	
                      uint8_t PageAddress ;
     	
	
                      if ((FrameBuf[0] & ISO15693_REQ_FLAG_ADDRESS) && ISO15693CompareUid(&FrameBuf[2], Uid) )
    b972:	f8 01       	movw	r30, r16
    b974:	80 81       	ld	r24, Z
    b976:	62 81       	ldd	r22, Z+2	; 0x02
    b978:	85 ff       	sbrs	r24, 5
    b97a:	20 c0       	rjmp	.+64     	; 0xb9bc <TITagitstandardAppProcess+0x12e>
bool ISO15693CheckCRC(void* FrameBuf, uint16_t FrameBufSize);

INLINE
bool ISO15693CompareUid(uint8_t* Uid1, uint8_t* Uid2)
{
    if (    (Uid1[0] == Uid2[0])
    b97c:	99 81       	ldd	r25, Y+1	; 0x01
    b97e:	69 13       	cpse	r22, r25
    b980:	1d c0       	rjmp	.+58     	; 0xb9bc <TITagitstandardAppProcess+0x12e>
        &&  (Uid1[1] == Uid2[1])
    b982:	23 81       	ldd	r18, Z+3	; 0x03
    b984:	9a 81       	ldd	r25, Y+2	; 0x02
    b986:	29 13       	cpse	r18, r25
    b988:	19 c0       	rjmp	.+50     	; 0xb9bc <TITagitstandardAppProcess+0x12e>
        &&  (Uid1[2] == Uid2[2])
    b98a:	24 81       	ldd	r18, Z+4	; 0x04
    b98c:	9b 81       	ldd	r25, Y+3	; 0x03
    b98e:	29 13       	cpse	r18, r25
    b990:	15 c0       	rjmp	.+42     	; 0xb9bc <TITagitstandardAppProcess+0x12e>
        &&  (Uid1[3] == Uid2[3])
    b992:	25 81       	ldd	r18, Z+5	; 0x05
    b994:	9c 81       	ldd	r25, Y+4	; 0x04
    b996:	29 13       	cpse	r18, r25
    b998:	11 c0       	rjmp	.+34     	; 0xb9bc <TITagitstandardAppProcess+0x12e>
        &&  (Uid1[4] == Uid2[4])
    b99a:	26 81       	ldd	r18, Z+6	; 0x06
    b99c:	9d 81       	ldd	r25, Y+5	; 0x05
    b99e:	29 13       	cpse	r18, r25
    b9a0:	0d c0       	rjmp	.+26     	; 0xb9bc <TITagitstandardAppProcess+0x12e>
        &&  (Uid1[5] == Uid2[5])
    b9a2:	27 81       	ldd	r18, Z+7	; 0x07
    b9a4:	9e 81       	ldd	r25, Y+6	; 0x06
    b9a6:	29 13       	cpse	r18, r25
    b9a8:	09 c0       	rjmp	.+18     	; 0xb9bc <TITagitstandardAppProcess+0x12e>
        &&  (Uid1[6] == Uid2[6])
    b9aa:	20 85       	ldd	r18, Z+8	; 0x08
    b9ac:	9f 81       	ldd	r25, Y+7	; 0x07
    b9ae:	29 13       	cpse	r18, r25
    b9b0:	05 c0       	rjmp	.+10     	; 0xb9bc <TITagitstandardAppProcess+0x12e>
        &&  (Uid1[7] == Uid2[7]) ) {
    b9b2:	21 85       	ldd	r18, Z+9	; 0x09
    b9b4:	98 85       	ldd	r25, Y+8	; 0x08
    b9b6:	29 17       	cp	r18, r25
    b9b8:	09 f4       	brne	.+2      	; 0xb9bc <TITagitstandardAppProcess+0x12e>
    b9ba:	84 c0       	rjmp	.+264    	; 0xbac4 <TITagitstandardAppProcess+0x236>
			  PageAddress = FrameBuf[10]; /*when receiving anaddressed request pick block number from the 10th byte in the request*/
		      else
			  PageAddress = FrameBuf[2];
			  				      
 		
                      if (FrameBuf[0] & ISO15693_REQ_FLAG_OPTION)
    b9bc:	86 ff       	sbrs	r24, 6
    b9be:	11 c0       	rjmp	.+34     	; 0xb9e2 <TITagitstandardAppProcess+0x154>
                          { /*request with option flag set */
                              FrameBuf[0] = 0x00; /* Flags */	                      
    b9c0:	f8 01       	movw	r30, r16
    b9c2:	10 82       	st	Z, r1
                              FrameBuf[1] = ( PageAddress == 8 || PageAddress == 9) ? 0x02 : 0x00; /* block security status:when request has the option flag set*/	                      
    b9c4:	88 ef       	ldi	r24, 0xF8	; 248
    b9c6:	86 0f       	add	r24, r22
    b9c8:	82 30       	cpi	r24, 0x02	; 2
    b9ca:	10 f0       	brcs	.+4      	; 0xb9d0 <TITagitstandardAppProcess+0x142>
    b9cc:	80 e0       	ldi	r24, 0x00	; 0
    b9ce:	01 c0       	rjmp	.+2      	; 0xb9d2 <TITagitstandardAppProcess+0x144>
    b9d0:	82 e0       	ldi	r24, 0x02	; 2
    b9d2:	f8 01       	movw	r30, r16
    b9d4:	81 83       	std	Z+1, r24	; 0x01
			      FramePtr = FrameBuf + 2;				      
    b9d6:	c8 01       	movw	r24, r16
    b9d8:	02 96       	adiw	r24, 0x02	; 2
                              ResponseByteCount = 6;
    b9da:	36 e0       	ldi	r19, 0x06	; 6
    b9dc:	e3 2e       	mov	r14, r19
    b9de:	f1 2c       	mov	r15, r1
    b9e0:	06 c0       	rjmp	.+12     	; 0xb9ee <TITagitstandardAppProcess+0x160>

                          } else { /*request with option flag not set*/
                              FrameBuf[0] = 0x00; /* Flags */			                                    
    b9e2:	f8 01       	movw	r30, r16
    b9e4:	11 92       	st	Z+, r1
    b9e6:	cf 01       	movw	r24, r30
			      FramePtr = FrameBuf + 1 ;			  
                              ResponseByteCount = 5;
    b9e8:	25 e0       	ldi	r18, 0x05	; 5
    b9ea:	e2 2e       	mov	r14, r18
    b9ec:	f1 2c       	mov	r15, r1
                         }

		       MemoryReadBlock(FramePtr, PageAddress * BYTES_PER_PAGE, BYTES_PER_PAGE);		       
    b9ee:	f4 e0       	ldi	r31, 0x04	; 4
    b9f0:	6f 9f       	mul	r22, r31
    b9f2:	b0 01       	movw	r22, r0
    b9f4:	11 24       	eor	r1, r1
    b9f6:	44 e0       	ldi	r20, 0x04	; 4
    b9f8:	50 e0       	ldi	r21, 0x00	; 0
    b9fa:	0e 94 a1 0f 	call	0x1f42	; 0x1f42 <MemoryReadBlock>
    b9fe:	6e c0       	rjmp	.+220    	; 0xbadc <TITagitstandardAppProcess+0x24e>

                    }
 
                else if (Command ==ISO15693_CMD_WRITE_SINGLE){
    ba00:	21 32       	cpi	r18, 0x21	; 33
    ba02:	09 f0       	breq	.+2      	; 0xba06 <TITagitstandardAppProcess+0x178>
    ba04:	67 c0       	rjmp	.+206    	; 0xbad4 <TITagitstandardAppProcess+0x246>
		     uint8_t* Dataptr;
		     uint8_t PageAddress ;
	
			
                      if ((FrameBuf[0] & ISO15693_REQ_FLAG_ADDRESS) && ISO15693CompareUid(&FrameBuf[2], Uid) ){			 
    ba06:	f8 01       	movw	r30, r16
    ba08:	80 81       	ld	r24, Z
    ba0a:	62 81       	ldd	r22, Z+2	; 0x02
    ba0c:	85 ff       	sbrs	r24, 5
    ba0e:	1f c0       	rjmp	.+62     	; 0xba4e <TITagitstandardAppProcess+0x1c0>
bool ISO15693CheckCRC(void* FrameBuf, uint16_t FrameBufSize);

INLINE
bool ISO15693CompareUid(uint8_t* Uid1, uint8_t* Uid2)
{
    if (    (Uid1[0] == Uid2[0])
    ba10:	89 81       	ldd	r24, Y+1	; 0x01
    ba12:	68 13       	cpse	r22, r24
    ba14:	1c c0       	rjmp	.+56     	; 0xba4e <TITagitstandardAppProcess+0x1c0>
        &&  (Uid1[1] == Uid2[1])
    ba16:	93 81       	ldd	r25, Z+3	; 0x03
    ba18:	8a 81       	ldd	r24, Y+2	; 0x02
    ba1a:	98 13       	cpse	r25, r24
    ba1c:	18 c0       	rjmp	.+48     	; 0xba4e <TITagitstandardAppProcess+0x1c0>
        &&  (Uid1[2] == Uid2[2])
    ba1e:	94 81       	ldd	r25, Z+4	; 0x04
    ba20:	8b 81       	ldd	r24, Y+3	; 0x03
    ba22:	98 13       	cpse	r25, r24
    ba24:	14 c0       	rjmp	.+40     	; 0xba4e <TITagitstandardAppProcess+0x1c0>
        &&  (Uid1[3] == Uid2[3])
    ba26:	95 81       	ldd	r25, Z+5	; 0x05
    ba28:	8c 81       	ldd	r24, Y+4	; 0x04
    ba2a:	98 13       	cpse	r25, r24
    ba2c:	10 c0       	rjmp	.+32     	; 0xba4e <TITagitstandardAppProcess+0x1c0>
        &&  (Uid1[4] == Uid2[4])
    ba2e:	96 81       	ldd	r25, Z+6	; 0x06
    ba30:	8d 81       	ldd	r24, Y+5	; 0x05
    ba32:	98 13       	cpse	r25, r24
    ba34:	0c c0       	rjmp	.+24     	; 0xba4e <TITagitstandardAppProcess+0x1c0>
        &&  (Uid1[5] == Uid2[5])
    ba36:	97 81       	ldd	r25, Z+7	; 0x07
    ba38:	8e 81       	ldd	r24, Y+6	; 0x06
    ba3a:	98 13       	cpse	r25, r24
    ba3c:	08 c0       	rjmp	.+16     	; 0xba4e <TITagitstandardAppProcess+0x1c0>
        &&  (Uid1[6] == Uid2[6])
    ba3e:	90 85       	ldd	r25, Z+8	; 0x08
    ba40:	8f 81       	ldd	r24, Y+7	; 0x07
    ba42:	98 13       	cpse	r25, r24
    ba44:	04 c0       	rjmp	.+8      	; 0xba4e <TITagitstandardAppProcess+0x1c0>
        &&  (Uid1[7] == Uid2[7]) ) {
    ba46:	91 85       	ldd	r25, Z+9	; 0x09
    ba48:	88 85       	ldd	r24, Y+8	; 0x08
    ba4a:	98 17       	cp	r25, r24
    ba4c:	f1 f1       	breq	.+124    	; 0xbaca <TITagitstandardAppProcess+0x23c>
			  Dataptr     = &FrameBuf[11];
		      }	
		      else {
	
			  PageAddress =  FrameBuf[2];/*when receiving an unanaddressed request pick block number from 2nd byte in the request*/
			  Dataptr     = &FrameBuf[3];
    ba4e:	c8 01       	movw	r24, r16
    ba50:	03 96       	adiw	r24, 0x03	; 3
			
		      }			 
			  				      
	  	      MemoryWriteBlock( Dataptr , PageAddress * BYTES_PER_PAGE, BYTES_PER_PAGE);
    ba52:	f4 e0       	ldi	r31, 0x04	; 4
    ba54:	6f 9f       	mul	r22, r31
    ba56:	b0 01       	movw	r22, r0
    ba58:	11 24       	eor	r1, r1
    ba5a:	44 e0       	ldi	r20, 0x04	; 4
    ba5c:	50 e0       	ldi	r21, 0x00	; 0
    ba5e:	0e 94 ef 0f 	call	0x1fde	; 0x1fde <MemoryWriteBlock>
		      FrameBuf[0] = 0x00;
    ba62:	f8 01       	movw	r30, r16
    ba64:	10 82       	st	Z, r1
    ba66:	2a c0       	rjmp	.+84     	; 0xbabc <TITagitstandardAppProcess+0x22e>
            case STATE_SELECTED:

                break;

            case STATE_QUIET:
                if (Command == ISO15693_CMD_RESET_TO_READY) {
    ba68:	26 32       	cpi	r18, 0x26	; 38
    ba6a:	a1 f5       	brne	.+104    	; 0xbad4 <TITagitstandardAppProcess+0x246>
    DstUid[7] = SrcUid[7];
}

INLINE
bool ISO15693Addressed(uint8_t* Buffer, uint8_t* MyUid) {
    if (Buffer[0] & ISO15693_REQ_FLAG_ADDRESS) {
    ba6c:	f8 01       	movw	r30, r16
    ba6e:	80 81       	ld	r24, Z
    ba70:	85 ff       	sbrs	r24, 5
    ba72:	20 c0       	rjmp	.+64     	; 0xbab4 <TITagitstandardAppProcess+0x226>
bool ISO15693CheckCRC(void* FrameBuf, uint16_t FrameBufSize);

INLINE
bool ISO15693CompareUid(uint8_t* Uid1, uint8_t* Uid2)
{
    if (    (Uid1[0] == Uid2[0])
    ba74:	92 81       	ldd	r25, Z+2	; 0x02
    ba76:	89 81       	ldd	r24, Y+1	; 0x01
    ba78:	98 13       	cpse	r25, r24
    ba7a:	2c c0       	rjmp	.+88     	; 0xbad4 <TITagitstandardAppProcess+0x246>
        &&  (Uid1[1] == Uid2[1])
    ba7c:	93 81       	ldd	r25, Z+3	; 0x03
    ba7e:	8a 81       	ldd	r24, Y+2	; 0x02
    ba80:	98 13       	cpse	r25, r24
    ba82:	28 c0       	rjmp	.+80     	; 0xbad4 <TITagitstandardAppProcess+0x246>
        &&  (Uid1[2] == Uid2[2])
    ba84:	94 81       	ldd	r25, Z+4	; 0x04
    ba86:	8b 81       	ldd	r24, Y+3	; 0x03
    ba88:	98 13       	cpse	r25, r24
    ba8a:	24 c0       	rjmp	.+72     	; 0xbad4 <TITagitstandardAppProcess+0x246>
        &&  (Uid1[3] == Uid2[3])
    ba8c:	95 81       	ldd	r25, Z+5	; 0x05
    ba8e:	8c 81       	ldd	r24, Y+4	; 0x04
    ba90:	98 13       	cpse	r25, r24
    ba92:	20 c0       	rjmp	.+64     	; 0xbad4 <TITagitstandardAppProcess+0x246>
        &&  (Uid1[4] == Uid2[4])
    ba94:	96 81       	ldd	r25, Z+6	; 0x06
    ba96:	8d 81       	ldd	r24, Y+5	; 0x05
    ba98:	98 13       	cpse	r25, r24
    ba9a:	1c c0       	rjmp	.+56     	; 0xbad4 <TITagitstandardAppProcess+0x246>
        &&  (Uid1[5] == Uid2[5])
    ba9c:	97 81       	ldd	r25, Z+7	; 0x07
    ba9e:	8e 81       	ldd	r24, Y+6	; 0x06
    baa0:	98 13       	cpse	r25, r24
    baa2:	18 c0       	rjmp	.+48     	; 0xbad4 <TITagitstandardAppProcess+0x246>
        &&  (Uid1[6] == Uid2[6])
    baa4:	90 85       	ldd	r25, Z+8	; 0x08
    baa6:	8f 81       	ldd	r24, Y+7	; 0x07
    baa8:	98 13       	cpse	r25, r24
    baaa:	14 c0       	rjmp	.+40     	; 0xbad4 <TITagitstandardAppProcess+0x246>
        &&  (Uid1[7] == Uid2[7]) ) {
    baac:	91 85       	ldd	r25, Z+9	; 0x09
    baae:	88 85       	ldd	r24, Y+8	; 0x08
    bab0:	98 13       	cpse	r25, r24
    bab2:	10 c0       	rjmp	.+32     	; 0xbad4 <TITagitstandardAppProcess+0x246>
                    if (ISO15693Addressed(FrameBuf,Uid)) {
                        FrameBuf[0] = 0;
    bab4:	f8 01       	movw	r30, r16
    bab6:	10 82       	st	Z, r1
                        ResponseByteCount = 1;
                        State = STATE_READY;
    bab8:	10 92 4c 2e 	sts	0x2E4C, r1

            case STATE_QUIET:
                if (Command == ISO15693_CMD_RESET_TO_READY) {
                    if (ISO15693Addressed(FrameBuf,Uid)) {
                        FrameBuf[0] = 0;
                        ResponseByteCount = 1;
    babc:	ee 24       	eor	r14, r14
    babe:	e3 94       	inc	r14
    bac0:	f1 2c       	mov	r15, r1
    bac2:	0c c0       	rjmp	.+24     	; 0xbadc <TITagitstandardAppProcess+0x24e>
		      uint8_t *FramePtr ;	
                      uint8_t PageAddress ;
     	
	
                      if ((FrameBuf[0] & ISO15693_REQ_FLAG_ADDRESS) && ISO15693CompareUid(&FrameBuf[2], Uid) )
			  PageAddress = FrameBuf[10]; /*when receiving anaddressed request pick block number from the 10th byte in the request*/
    bac4:	f8 01       	movw	r30, r16
    bac6:	62 85       	ldd	r22, Z+10	; 0x0a
    bac8:	79 cf       	rjmp	.-270    	; 0xb9bc <TITagitstandardAppProcess+0x12e>
		     uint8_t* Dataptr;
		     uint8_t PageAddress ;
	
			
                      if ((FrameBuf[0] & ISO15693_REQ_FLAG_ADDRESS) && ISO15693CompareUid(&FrameBuf[2], Uid) ){			 
			  PageAddress =  FrameBuf[10]; /*when receiving anaddressed request pick block number from 10th byte in the request*/
    baca:	f8 01       	movw	r30, r16
    bacc:	62 85       	ldd	r22, Z+10	; 0x0a
			  Dataptr     = &FrameBuf[11];
    bace:	c8 01       	movw	r24, r16
    bad0:	0b 96       	adiw	r24, 0x0b	; 11
    bad2:	bf cf       	rjmp	.-130    	; 0xba52 <TITagitstandardAppProcess+0x1c4>
                              ResponseByteCount = 6;

                          } else { /*request with option flag not set*/
                              FrameBuf[0] = 0x00; /* Flags */			                                    
			      FramePtr = FrameBuf + 1 ;			  
                              ResponseByteCount = 5;
    bad4:	e1 2c       	mov	r14, r1
    bad6:	f1 2c       	mov	r15, r1
                /* There is data to be sent. Append CRC */
                ISO15693AppendCRC(FrameBuf, ResponseByteCount);
                ResponseByteCount += ISO15693_CRC16_SIZE;
            }

            return ResponseByteCount;
    bad8:	c7 01       	movw	r24, r14
    bada:	07 c0       	rjmp	.+14     	; 0xbaea <TITagitstandardAppProcess+0x25c>
                break;
            }

            if (ResponseByteCount > 0) {
                /* There is data to be sent. Append CRC */
                ISO15693AppendCRC(FrameBuf, ResponseByteCount);
    badc:	b7 01       	movw	r22, r14
    bade:	c8 01       	movw	r24, r16
    bae0:	3b d0       	rcall	.+118    	; 0xbb58 <ISO15693AppendCRC>
                ResponseByteCount += ISO15693_CRC16_SIZE;
    bae2:	f2 e0       	ldi	r31, 0x02	; 2
    bae4:	ef 0e       	add	r14, r31
    bae6:	f1 1c       	adc	r15, r1
    bae8:	f7 cf       	rjmp	.-18     	; 0xbad8 <TITagitstandardAppProcess+0x24a>
        }
    } else { // Min frame size not met
        return ISO15693_APP_NO_RESPONSE;
    }
    
}
    baea:	29 96       	adiw	r28, 0x09	; 9
    baec:	cd bf       	out	0x3d, r28	; 61
    baee:	de bf       	out	0x3e, r29	; 62
    baf0:	df 91       	pop	r29
    baf2:	cf 91       	pop	r28
    baf4:	1f 91       	pop	r17
    baf6:	0f 91       	pop	r16
    baf8:	ff 90       	pop	r15
    bafa:	ef 90       	pop	r14
    bafc:	08 95       	ret

0000bafe <TITagitstandardGetUid>:

void TITagitstandardGetUid(ConfigurationUidType Uid)
{
    MemoryReadBlock(&Uid[0], MEM_UID_ADDRESS, ActiveConfiguration.UidSize);
    bafe:	40 91 6c 2f 	lds	r20, 0x2F6C
    bb02:	50 e0       	ldi	r21, 0x00	; 0
    bb04:	60 e2       	ldi	r22, 0x20	; 32
    bb06:	70 e0       	ldi	r23, 0x00	; 0
    bb08:	0c 94 a1 0f 	jmp	0x1f42	; 0x1f42 <MemoryReadBlock>

0000bb0c <TITagitstandardSetUid>:
}

void TITagitstandardSetUid(ConfigurationUidType Uid)
{
    MemoryWriteBlock(Uid, MEM_UID_ADDRESS, ActiveConfiguration.UidSize);
    bb0c:	40 91 6c 2f 	lds	r20, 0x2F6C
    bb10:	50 e0       	ldi	r21, 0x00	; 0
    bb12:	60 e2       	ldi	r22, 0x20	; 32
    bb14:	70 e0       	ldi	r23, 0x00	; 0
    bb16:	0c 94 ef 0f 	jmp	0x1fde	; 0x1fde <MemoryWriteBlock>

0000bb1a <calculateCRC>:
#include "../Common.h"
#include <util/crc16.h>

//Refer to ISO/IEC 15693-3:2001 page 41
uint16_t calculateCRC(void* FrameBuf, uint16_t FrameBufSize) 
{
    bb1a:	a8 2f       	mov	r26, r24
    uint16_t reg = ISO15693_CRC16_PRESET;
    uint8_t i, j;

    uint8_t *DataPtr = (uint8_t *)FrameBuf;

    for(i = 0; i < FrameBufSize; i++) {
    bb1c:	fc 01       	movw	r30, r24
#include <util/crc16.h>

//Refer to ISO/IEC 15693-3:2001 page 41
uint16_t calculateCRC(void* FrameBuf, uint16_t FrameBufSize) 
{
    uint16_t reg = ISO15693_CRC16_PRESET;
    bb1e:	8f ef       	ldi	r24, 0xFF	; 255
    bb20:	9f ef       	ldi	r25, 0xFF	; 255
    bb22:	2e 2f       	mov	r18, r30
    bb24:	2a 1b       	sub	r18, r26
    uint8_t i, j;

    uint8_t *DataPtr = (uint8_t *)FrameBuf;

    for(i = 0; i < FrameBufSize; i++) {
    bb26:	30 e0       	ldi	r19, 0x00	; 0
    bb28:	26 17       	cp	r18, r22
    bb2a:	37 07       	cpc	r19, r23
    bb2c:	90 f4       	brcc	.+36     	; 0xbb52 <calculateCRC+0x38>
        reg = reg ^ *DataPtr++;
    bb2e:	21 91       	ld	r18, Z+
    bb30:	82 27       	eor	r24, r18
    bb32:	28 e0       	ldi	r18, 0x08	; 8
    bb34:	ac 01       	movw	r20, r24
    bb36:	56 95       	lsr	r21
    bb38:	47 95       	ror	r20
        for (j = 0; j < 8; j++) {
            if (reg & 0x0001) {
    bb3a:	80 ff       	sbrs	r24, 0
    bb3c:	06 c0       	rjmp	.+12     	; 0xbb4a <calculateCRC+0x30>
                reg = (reg >> 1) ^ ISO15693_CRC16_POLYNORMAL;
    bb3e:	ca 01       	movw	r24, r20
    bb40:	38 e0       	ldi	r19, 0x08	; 8
    bb42:	83 27       	eor	r24, r19
    bb44:	34 e8       	ldi	r19, 0x84	; 132
    bb46:	93 27       	eor	r25, r19
    bb48:	01 c0       	rjmp	.+2      	; 0xbb4c <calculateCRC+0x32>
            } else {
                reg = (reg >> 1);
    bb4a:	ca 01       	movw	r24, r20
    bb4c:	21 50       	subi	r18, 0x01	; 1

    uint8_t *DataPtr = (uint8_t *)FrameBuf;

    for(i = 0; i < FrameBufSize; i++) {
        reg = reg ^ *DataPtr++;
        for (j = 0; j < 8; j++) {
    bb4e:	91 f7       	brne	.-28     	; 0xbb34 <calculateCRC+0x1a>
    bb50:	e8 cf       	rjmp	.-48     	; 0xbb22 <calculateCRC+0x8>
            }
        }
    }

    return ~reg;  
}
    bb52:	80 95       	com	r24
    bb54:	90 95       	com	r25
    bb56:	08 95       	ret

0000bb58 <ISO15693AppendCRC>:

void ISO15693AppendCRC(uint8_t* FrameBuf, uint16_t FrameBufSize)
{
    bb58:	0f 93       	push	r16
    bb5a:	1f 93       	push	r17
    bb5c:	cf 93       	push	r28
    bb5e:	df 93       	push	r29
    bb60:	8c 01       	movw	r16, r24
    bb62:	eb 01       	movw	r28, r22
    uint16_t crc;
    
    crc = calculateCRC(FrameBuf, FrameBufSize);
    bb64:	da df       	rcall	.-76     	; 0xbb1a <calculateCRC>

    uint8_t crcLb = crc & 0xFF;
    uint8_t crcHb = crc >> 8;


    FrameBuf[FrameBufSize] = crcLb;
    bb66:	c0 0f       	add	r28, r16
    bb68:	d1 1f       	adc	r29, r17
{
    uint16_t crc;
    
    crc = calculateCRC(FrameBuf, FrameBufSize);

    uint8_t crcLb = crc & 0xFF;
    bb6a:	88 83       	st	Y, r24
    uint8_t crcHb = crc >> 8;
    bb6c:	99 83       	std	Y+1, r25	; 0x01


    FrameBuf[FrameBufSize] = crcLb;
    FrameBuf[FrameBufSize + 1] = crcHb;    
}
    bb6e:	df 91       	pop	r29
    bb70:	cf 91       	pop	r28
    bb72:	1f 91       	pop	r17
    bb74:	0f 91       	pop	r16
    bb76:	08 95       	ret

0000bb78 <ISO15693CheckCRC>:

bool ISO15693CheckCRC(void* FrameBuf, uint16_t FrameBufSize)
{
    bb78:	0f 93       	push	r16
    bb7a:	1f 93       	push	r17
    bb7c:	cf 93       	push	r28
    bb7e:	df 93       	push	r29
    bb80:	8c 01       	movw	r16, r24
    bb82:	eb 01       	movw	r28, r22
    uint16_t crc;
    uint8_t *DataPtr = (uint8_t *)FrameBuf;
    
    crc = calculateCRC(DataPtr, FrameBufSize);
    bb84:	ca df       	rcall	.-108    	; 0xbb1a <calculateCRC>
    
    uint8_t crcLb = crc & 0xFF;
    uint8_t crcHb = crc >> 8;
    
    return (DataPtr[FrameBufSize] == crcLb && DataPtr[FrameBufSize + 1] == crcHb);
    bb86:	c0 0f       	add	r28, r16
    bb88:	d1 1f       	adc	r29, r17
    bb8a:	28 81       	ld	r18, Y
    bb8c:	28 13       	cpse	r18, r24
    bb8e:	03 c0       	rjmp	.+6      	; 0xbb96 <ISO15693CheckCRC+0x1e>
    bb90:	81 e0       	ldi	r24, 0x01	; 1
    bb92:	29 81       	ldd	r18, Y+1	; 0x01
    bb94:	29 13       	cpse	r18, r25
    bb96:	80 e0       	ldi	r24, 0x00	; 0
}
    bb98:	81 70       	andi	r24, 0x01	; 1
    bb9a:	df 91       	pop	r29
    bb9c:	cf 91       	pop	r28
    bb9e:	1f 91       	pop	r17
    bba0:	0f 91       	pop	r16
    bba2:	08 95       	ret

0000bba4 <USB_Device_ProcessControlRequest>:
#if !defined(NO_DEVICE_REMOTE_WAKEUP)
bool    USB_Device_RemoteWakeupEnabled;
#endif

void USB_Device_ProcessControlRequest(void)
{
    bba4:	ff 92       	push	r15
    bba6:	0f 93       	push	r16
    bba8:	1f 93       	push	r17
    bbaa:	cf 93       	push	r28
    bbac:	df 93       	push	r29
    bbae:	cd b7       	in	r28, 0x3d	; 61
    bbb0:	de b7       	in	r29, 0x3e	; 62
    bbb2:	ea 97       	sbiw	r28, 0x3a	; 58
    bbb4:	cd bf       	out	0x3d, r28	; 61
    bbb6:	de bf       	out	0x3e, r29	; 62
    bbb8:	08 ed       	ldi	r16, 0xD8	; 216
    bbba:	13 e3       	ldi	r17, 0x33	; 51
    bbbc:	88 e0       	ldi	r24, 0x08	; 8
    bbbe:	f8 2e       	mov	r15, r24
    bbc0:	f0 0e       	add	r15, r16
	USB_ControlRequest.wLength       = Endpoint_Read_16_LE();
	#else
	uint8_t* RequestHeader = (uint8_t*)&USB_ControlRequest;

	for (uint8_t RequestHeaderByte = 0; RequestHeaderByte < sizeof(USB_Request_Header_t); RequestHeaderByte++)
	  *(RequestHeader++) = Endpoint_Read_8();
    bbc2:	91 d2       	rcall	.+1314   	; 0xc0e6 <Endpoint_Read_8>
    bbc4:	f8 01       	movw	r30, r16
    bbc6:	81 93       	st	Z+, r24
    bbc8:	8f 01       	movw	r16, r30
	USB_ControlRequest.wIndex        = Endpoint_Read_16_LE();
	USB_ControlRequest.wLength       = Endpoint_Read_16_LE();
	#else
	uint8_t* RequestHeader = (uint8_t*)&USB_ControlRequest;

	for (uint8_t RequestHeaderByte = 0; RequestHeaderByte < sizeof(USB_Request_Header_t); RequestHeaderByte++)
    bbca:	fe 12       	cpse	r15, r30
    bbcc:	fa cf       	rjmp	.-12     	; 0xbbc2 <USB_Device_ProcessControlRequest+0x1e>
	  *(RequestHeader++) = Endpoint_Read_8();
	#endif

	EVENT_USB_Device_ControlRequest();
    bbce:	0e 94 58 1a 	call	0x34b0	; 0x34b0 <EVENT_USB_Device_ControlRequest>

	if (Endpoint_IsSETUPReceived())
    bbd2:	04 d3       	rcall	.+1544   	; 0xc1dc <Endpoint_IsSETUPReceived>
    bbd4:	88 23       	and	r24, r24
    bbd6:	09 f4       	brne	.+2      	; 0xbbda <USB_Device_ProcessControlRequest+0x36>
    bbd8:	f7 c0       	rjmp	.+494    	; 0xbdc8 <USB_Device_ProcessControlRequest+0x224>
	{
		uint8_t bmRequestType = USB_ControlRequest.bmRequestType;
    bbda:	80 91 d8 33 	lds	r24, 0x33D8

		switch (USB_ControlRequest.bRequest)
    bbde:	90 91 d9 33 	lds	r25, 0x33D9
    bbe2:	95 30       	cpi	r25, 0x05	; 5
    bbe4:	09 f4       	brne	.+2      	; 0xbbe8 <USB_Device_ProcessControlRequest+0x44>
    bbe6:	6f c0       	rjmp	.+222    	; 0xbcc6 <USB_Device_ProcessControlRequest+0x122>
    bbe8:	30 f4       	brcc	.+12     	; 0xbbf6 <USB_Device_ProcessControlRequest+0x52>
    bbea:	91 30       	cpi	r25, 0x01	; 1
    bbec:	69 f1       	breq	.+90     	; 0xbc48 <USB_Device_ProcessControlRequest+0xa4>
    bbee:	68 f0       	brcs	.+26     	; 0xbc0a <USB_Device_ProcessControlRequest+0x66>
    bbf0:	93 30       	cpi	r25, 0x03	; 3
    bbf2:	51 f1       	breq	.+84     	; 0xbc48 <USB_Device_ProcessControlRequest+0xa4>
    bbf4:	e9 c0       	rjmp	.+466    	; 0xbdc8 <USB_Device_ProcessControlRequest+0x224>
    bbf6:	98 30       	cpi	r25, 0x08	; 8
    bbf8:	09 f4       	brne	.+2      	; 0xbbfc <USB_Device_ProcessControlRequest+0x58>
    bbfa:	c2 c0       	rjmp	.+388    	; 0xbd80 <USB_Device_ProcessControlRequest+0x1dc>
    bbfc:	99 30       	cpi	r25, 0x09	; 9
    bbfe:	09 f4       	brne	.+2      	; 0xbc02 <USB_Device_ProcessControlRequest+0x5e>
    bc00:	c8 c0       	rjmp	.+400    	; 0xbd92 <USB_Device_ProcessControlRequest+0x1ee>
    bc02:	96 30       	cpi	r25, 0x06	; 6
    bc04:	09 f0       	breq	.+2      	; 0xbc08 <USB_Device_ProcessControlRequest+0x64>
    bc06:	e0 c0       	rjmp	.+448    	; 0xbdc8 <USB_Device_ProcessControlRequest+0x224>
    bc08:	72 c0       	rjmp	.+228    	; 0xbcee <USB_Device_ProcessControlRequest+0x14a>
		{
			case REQ_GetStatus:
				if ((bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    bc0a:	80 38       	cpi	r24, 0x80	; 128
    bc0c:	91 f0       	breq	.+36     	; 0xbc32 <USB_Device_ProcessControlRequest+0x8e>
    bc0e:	82 38       	cpi	r24, 0x82	; 130
    bc10:	09 f0       	breq	.+2      	; 0xbc14 <USB_Device_ProcessControlRequest+0x70>
    bc12:	da c0       	rjmp	.+436    	; 0xbdc8 <USB_Device_ProcessControlRequest+0x224>
			  CurrentStatus |= FEATURE_REMOTE_WAKEUP_ENABLED;
			#endif
			break;
		case (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_ENDPOINT):
			#if !defined(CONTROL_ONLY_DEVICE)
			Endpoint_SelectEndpoint((uint8_t)USB_ControlRequest.wIndex & ENDPOINT_EPNUM_MASK);
    bc14:	80 91 dc 33 	lds	r24, 0x33DC
    bc18:	8f 70       	andi	r24, 0x0F	; 15
    bc1a:	85 d2       	rcall	.+1290   	; 0xc126 <Endpoint_SelectEndpoint>
			 *  \return Boolean \c true if the currently selected endpoint is stalled, \c false otherwise.
			 */
			static inline bool Endpoint_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsStalled(void)
			{
				return ((USB_Endpoint_SelectedHandle->CTRL & USB_EP_STALL_bm) ? true : false);
    bc1c:	e0 91 e2 33 	lds	r30, 0x33E2
    bc20:	f0 91 e3 33 	lds	r31, 0x33E3
    bc24:	11 81       	ldd	r17, Z+1	; 0x01
    bc26:	12 fb       	bst	r17, 2
    bc28:	11 27       	eor	r17, r17
    bc2a:	10 f9       	bld	r17, 0

			CurrentStatus = Endpoint_IsStalled();

			Endpoint_SelectEndpoint(ENDPOINT_CONTROLEP);
    bc2c:	80 e0       	ldi	r24, 0x00	; 0
    bc2e:	7b d2       	rcall	.+1270   	; 0xc126 <Endpoint_SelectEndpoint>
    bc30:	06 c0       	rjmp	.+12     	; 0xbc3e <USB_Device_ProcessControlRequest+0x9a>
	Endpoint_ClearOUT();
}

static void USB_Device_GetStatus(void)
{
	uint8_t CurrentStatus = 0;
    bc32:	10 91 d4 33 	lds	r17, 0x33D4
			if (USB_Device_CurrentlySelfPowered)
			  CurrentStatus |= FEATURE_SELFPOWERED_ENABLED;
			#endif

			#if !defined(NO_DEVICE_REMOTE_WAKEUP)
			if (USB_Device_RemoteWakeupEnabled)
    bc36:	80 91 d5 33 	lds	r24, 0x33D5
    bc3a:	81 11       	cpse	r24, r1
			  CurrentStatus |= FEATURE_REMOTE_WAKEUP_ENABLED;
    bc3c:	12 60       	ori	r17, 0x02	; 2
			break;
		default:
			return;
	}

	Endpoint_ClearSETUP();
    bc3e:	e8 d2       	rcall	.+1488   	; 0xc210 <Endpoint_ClearSETUP>
			 *  \param[in] Data  Data to write to the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_16_LE(const uint16_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_16_LE(const uint16_t Data)
			{
				Endpoint_Write_8(Data & 0xFF);
    bc40:	81 2f       	mov	r24, r17
    bc42:	61 d2       	rcall	.+1218   	; 0xc106 <Endpoint_Write_8>
				Endpoint_Write_8(Data >> 8);
    bc44:	80 e0       	ldi	r24, 0x00	; 0
    bc46:	a1 c0       	rjmp	.+322    	; 0xbd8a <USB_Device_ProcessControlRequest+0x1e6>
				}

				break;
			case REQ_ClearFeature:
			case REQ_SetFeature:
				if ((bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    bc48:	28 2f       	mov	r18, r24
    bc4a:	2d 7f       	andi	r18, 0xFD	; 253
    bc4c:	09 f0       	breq	.+2      	; 0xbc50 <USB_Device_ProcessControlRequest+0xac>
    bc4e:	bc c0       	rjmp	.+376    	; 0xbdc8 <USB_Device_ProcessControlRequest+0x224>
	Endpoint_ClearStatusStage();
}

static void USB_Device_ClearSetFeature(void)
{
	switch (USB_ControlRequest.bmRequestType & CONTROL_REQTYPE_RECIPIENT)
    bc50:	88 23       	and	r24, r24
    bc52:	19 f0       	breq	.+6      	; 0xbc5a <USB_Device_ProcessControlRequest+0xb6>
    bc54:	82 30       	cpi	r24, 0x02	; 2
    bc56:	61 f0       	breq	.+24     	; 0xbc70 <USB_Device_ProcessControlRequest+0xcc>
    bc58:	b7 c0       	rjmp	.+366    	; 0xbdc8 <USB_Device_ProcessControlRequest+0x224>
	{
		#if !defined(NO_DEVICE_REMOTE_WAKEUP)
		case REQREC_DEVICE:
			if ((uint8_t)USB_ControlRequest.wValue == FEATURE_SEL_DeviceRemoteWakeup)
    bc5a:	80 91 da 33 	lds	r24, 0x33DA
    bc5e:	81 30       	cpi	r24, 0x01	; 1
    bc60:	09 f0       	breq	.+2      	; 0xbc64 <USB_Device_ProcessControlRequest+0xc0>
    bc62:	b2 c0       	rjmp	.+356    	; 0xbdc8 <USB_Device_ProcessControlRequest+0x224>
			  USB_Device_RemoteWakeupEnabled = (USB_ControlRequest.bRequest == REQ_SetFeature);
    bc64:	93 30       	cpi	r25, 0x03	; 3
    bc66:	09 f0       	breq	.+2      	; 0xbc6a <USB_Device_ProcessControlRequest+0xc6>
    bc68:	80 e0       	ldi	r24, 0x00	; 0
    bc6a:	80 93 d5 33 	sts	0x33D5, r24
    bc6e:	27 c0       	rjmp	.+78     	; 0xbcbe <USB_Device_ProcessControlRequest+0x11a>

			break;
		#endif
		#if !defined(CONTROL_ONLY_DEVICE)
		case REQREC_ENDPOINT:
			if ((uint8_t)USB_ControlRequest.wValue == FEATURE_SEL_EndpointHalt)
    bc70:	80 91 da 33 	lds	r24, 0x33DA
    bc74:	81 11       	cpse	r24, r1
    bc76:	23 c0       	rjmp	.+70     	; 0xbcbe <USB_Device_ProcessControlRequest+0x11a>
			{
				uint8_t EndpointIndex = ((uint8_t)USB_ControlRequest.wIndex & ENDPOINT_EPNUM_MASK);
    bc78:	e0 91 dc 33 	lds	r30, 0x33DC
    bc7c:	1e 2f       	mov	r17, r30
    bc7e:	1f 70       	andi	r17, 0x0F	; 15

				if (EndpointIndex == ENDPOINT_CONTROLEP)
    bc80:	09 f4       	brne	.+2      	; 0xbc84 <USB_Device_ProcessControlRequest+0xe0>
    bc82:	a2 c0       	rjmp	.+324    	; 0xbdc8 <USB_Device_ProcessControlRequest+0x224>
				  return;

				Endpoint_SelectEndpoint(EndpointIndex);
    bc84:	81 2f       	mov	r24, r17
    bc86:	4f d2       	rcall	.+1182   	; 0xc126 <Endpoint_SelectEndpoint>

				if (Endpoint_IsEnabled())
				{
					if (USB_ControlRequest.bRequest == REQ_SetFeature)
    bc88:	80 91 d9 33 	lds	r24, 0x33D9
    bc8c:	83 30       	cpi	r24, 0x03	; 3
    bc8e:	11 f4       	brne	.+4      	; 0xbc94 <USB_Device_ProcessControlRequest+0xf0>
					{
						Endpoint_StallTransaction();
    bc90:	eb d2       	rcall	.+1494   	; 0xc268 <Endpoint_StallTransaction>
    bc92:	15 c0       	rjmp	.+42     	; 0xbcbe <USB_Device_ProcessControlRequest+0x11a>
			 *  \ingroup Group_EndpointPacketManagement_XMEGA
			 */
			static inline void Endpoint_ClearStall(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearStall(void)
			{
				USB_Endpoint_SelectedHandle->CTRL &= ~USB_EP_STALL_bm;
    bc94:	e0 91 e2 33 	lds	r30, 0x33E2
    bc98:	f0 91 e3 33 	lds	r31, 0x33E3
    bc9c:	81 81       	ldd	r24, Z+1	; 0x01
    bc9e:	8b 7f       	andi	r24, 0xFB	; 251
    bca0:	81 83       	std	Z+1, r24	; 0x01
			static inline void Endpoint_ResetEndpoint(const uint8_t Address)
			{
				if (Address & ENDPOINT_DIR_IN)
				  USB_Endpoint_FIFOs[Address & ENDPOINT_EPNUM_MASK].IN.Position  = 0;
				else
				  USB_Endpoint_FIFOs[Address & ENDPOINT_EPNUM_MASK].OUT.Position = 0;
    bca2:	24 e8       	ldi	r18, 0x84	; 132
    bca4:	12 9f       	mul	r17, r18
    bca6:	f0 01       	movw	r30, r0
    bca8:	11 24       	eor	r1, r1
    bcaa:	ea 5d       	subi	r30, 0xDA	; 218
    bcac:	fb 4c       	sbci	r31, 0xCB	; 203
    bcae:	10 82       	st	Z, r1

			/** Resets the data toggle of the currently selected endpoint. */
			static inline void Endpoint_ResetDataToggle(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetDataToggle(void)
			{
				USB_Endpoint_SelectedHandle->STATUS &= ~USB_EP_TOGGLE_bm;
    bcb0:	e0 91 e2 33 	lds	r30, 0x33E2
    bcb4:	f0 91 e3 33 	lds	r31, 0x33E3
    bcb8:	80 81       	ld	r24, Z
    bcba:	8e 7f       	andi	r24, 0xFE	; 254
    bcbc:	80 83       	st	Z, r24
		#endif
		default:
			return;
	}

	Endpoint_SelectEndpoint(ENDPOINT_CONTROLEP);
    bcbe:	80 e0       	ldi	r24, 0x00	; 0
    bcc0:	32 d2       	rcall	.+1124   	; 0xc126 <Endpoint_SelectEndpoint>

	Endpoint_ClearSETUP();
    bcc2:	a6 d2       	rcall	.+1356   	; 0xc210 <Endpoint_ClearSETUP>
    bcc4:	64 c0       	rjmp	.+200    	; 0xbd8e <USB_Device_ProcessControlRequest+0x1ea>
					USB_Device_ClearSetFeature();
				}

				break;
			case REQ_SetAddress:
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
    bcc6:	81 11       	cpse	r24, r1
    bcc8:	7f c0       	rjmp	.+254    	; 0xbdc8 <USB_Device_ProcessControlRequest+0x224>
	}
}

static void USB_Device_SetAddress(void)
{
	uint8_t DeviceAddress = (USB_ControlRequest.wValue & 0x7F);
    bcca:	10 91 da 33 	lds	r17, 0x33DA
    bcce:	1f 77       	andi	r17, 0x7F	; 127

	USB_Device_SetDeviceAddress(DeviceAddress);

	Endpoint_ClearSETUP();
    bcd0:	9f d2       	rcall	.+1342   	; 0xc210 <Endpoint_ClearSETUP>

	Endpoint_ClearStatusStage();
    bcd2:	a1 d3       	rcall	.+1858   	; 0xc416 <Endpoint_ClearStatusStage>

	while (!(Endpoint_IsINReady()));
    bcd4:	5d d2       	rcall	.+1210   	; 0xc190 <Endpoint_IsINReady>
    bcd6:	88 23       	and	r24, r24
    bcd8:	e9 f3       	breq	.-6      	; 0xbcd4 <USB_Device_ProcessControlRequest+0x130>
			}

			static inline void USB_Device_EnableDeviceAddress(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void USB_Device_EnableDeviceAddress(const uint8_t Address)
			{
				USB.ADDR = Address;
    bcda:	10 93 c3 04 	sts	0x04C3, r17

	USB_Device_EnableDeviceAddress(DeviceAddress);

	USB_DeviceState = (DeviceAddress) ? DEVICE_STATE_Addressed : DEVICE_STATE_Default;
    bcde:	11 11       	cpse	r17, r1
    bce0:	02 c0       	rjmp	.+4      	; 0xbce6 <USB_Device_ProcessControlRequest+0x142>
    bce2:	82 e0       	ldi	r24, 0x02	; 2
    bce4:	01 c0       	rjmp	.+2      	; 0xbce8 <USB_Device_ProcessControlRequest+0x144>
    bce6:	83 e0       	ldi	r24, 0x03	; 3
    bce8:	80 93 d7 33 	sts	0x33D7, r24
    bcec:	6d c0       	rjmp	.+218    	; 0xbdc8 <USB_Device_ProcessControlRequest+0x224>
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
				  USB_Device_SetAddress();

				break;
			case REQ_GetDescriptor:
				if ((bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    bcee:	80 58       	subi	r24, 0x80	; 128
    bcf0:	82 30       	cpi	r24, 0x02	; 2
    bcf2:	08 f0       	brcs	.+2      	; 0xbcf6 <USB_Device_ProcessControlRequest+0x152>
    bcf4:	69 c0       	rjmp	.+210    	; 0xbdc8 <USB_Device_ProcessControlRequest+0x224>
	    !(defined(USE_FLASH_DESCRIPTORS) || defined(USE_EEPROM_DESCRIPTORS) || defined(USE_RAM_DESCRIPTORS))
	uint8_t DescriptorAddressSpace;
	#endif

	#if !defined(NO_INTERNAL_SERIAL) && (USE_INTERNAL_SERIAL != NO_DESCRIPTOR)
	if (USB_ControlRequest.wValue == ((DTYPE_String << 8) | USE_INTERNAL_SERIAL))
    bcf6:	80 91 da 33 	lds	r24, 0x33DA
    bcfa:	90 91 db 33 	lds	r25, 0x33DB
    bcfe:	8c 3d       	cpi	r24, 0xDC	; 220
    bd00:	e3 e0       	ldi	r30, 0x03	; 3
    bd02:	9e 07       	cpc	r25, r30
    bd04:	61 f5       	brne	.+88     	; 0xbd5e <USB_Device_ProcessControlRequest+0x1ba>
	{
		USB_Descriptor_Header_t Header;
		uint16_t                UnicodeString[INTERNAL_SERIAL_LENGTH_BITS / 4];
	} SignatureDescriptor;

	SignatureDescriptor.Header.Type = DTYPE_String;
    bd06:	83 e0       	ldi	r24, 0x03	; 3
    bd08:	8a 83       	std	Y+2, r24	; 0x02
	SignatureDescriptor.Header.Size = USB_STRING_LEN(INTERNAL_SERIAL_LENGTH_BITS / 4);
    bd0a:	8a e3       	ldi	r24, 0x3A	; 58
    bd0c:	89 83       	std	Y+1, r24	; 0x01
				#if (ARCH == ARCH_AVR8)
				return SREG;
				#elif (ARCH == ARCH_UC3)
				return __builtin_mfsr(AVR32_SR);
				#elif (ARCH == ARCH_XMEGA)
				return SREG;
    bd0e:	4f b7       	in	r20, 0x3f	; 63
				#if (ARCH == ARCH_AVR8)
				cli();
				#elif (ARCH == ARCH_UC3)
				__builtin_ssrf(AVR32_SR_GM_OFFSET);
				#elif (ARCH == ARCH_XMEGA)
				cli();
    bd10:	f8 94       	cli
				#endif

				GCC_MEMORY_BARRIER();
    bd12:	de 01       	movw	r26, r28
    bd14:	13 96       	adiw	r26, 0x03	; 3
				uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
				GlobalInterruptDisable();

				uint8_t SigReadAddress = INTERNAL_SERIAL_START_ADDRESS;

				for (uint8_t SerialCharNum = 0; SerialCharNum < (INTERNAL_SERIAL_LENGTH_BITS / 4); SerialCharNum++)
    bd16:	20 e0       	ldi	r18, 0x00	; 0
			static inline void USB_Device_GetSerialString(uint16_t* const UnicodeString)
			{
				uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
				GlobalInterruptDisable();

				uint8_t SigReadAddress = INTERNAL_SERIAL_START_ADDRESS;
    bd18:	38 e0       	ldi	r19, 0x08	; 8

				for (uint8_t SerialCharNum = 0; SerialCharNum < (INTERNAL_SERIAL_LENGTH_BITS / 4); SerialCharNum++)
				{
					uint8_t SerialByte;

					NVM.CMD    = NVM_CMD_READ_CALIB_ROW_gc;
    bd1a:	52 e0       	ldi	r21, 0x02	; 2
    bd1c:	50 93 ca 01 	sts	0x01CA, r21
					SerialByte = pgm_read_byte(SigReadAddress);
    bd20:	e3 2f       	mov	r30, r19
    bd22:	f0 e0       	ldi	r31, 0x00	; 0
    bd24:	e4 91       	lpm	r30, Z
					NVM.CMD    = 0;
    bd26:	10 92 ca 01 	sts	0x01CA, r1

					if (SerialCharNum & 0x01)
    bd2a:	20 ff       	sbrs	r18, 0
    bd2c:	03 c0       	rjmp	.+6      	; 0xbd34 <USB_Device_ProcessControlRequest+0x190>
					{
						SerialByte >>= 4;
    bd2e:	e2 95       	swap	r30
    bd30:	ef 70       	andi	r30, 0x0F	; 15
						SigReadAddress++;
    bd32:	3f 5f       	subi	r19, 0xFF	; 255
					}

					SerialByte &= 0x0F;
    bd34:	ef 70       	andi	r30, 0x0F	; 15
    bd36:	8e 2f       	mov	r24, r30
    bd38:	90 e0       	ldi	r25, 0x00	; 0

					UnicodeString[SerialCharNum] = cpu_to_le16((SerialByte >= 10) ?
    bd3a:	ea 30       	cpi	r30, 0x0A	; 10
    bd3c:	10 f0       	brcs	.+4      	; 0xbd42 <USB_Device_ProcessControlRequest+0x19e>
    bd3e:	c7 96       	adiw	r24, 0x37	; 55
    bd40:	01 c0       	rjmp	.+2      	; 0xbd44 <USB_Device_ProcessControlRequest+0x1a0>
    bd42:	c0 96       	adiw	r24, 0x30	; 48
    bd44:	8d 93       	st	X+, r24
    bd46:	9d 93       	st	X+, r25
				uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
				GlobalInterruptDisable();

				uint8_t SigReadAddress = INTERNAL_SERIAL_START_ADDRESS;

				for (uint8_t SerialCharNum = 0; SerialCharNum < (INTERNAL_SERIAL_LENGTH_BITS / 4); SerialCharNum++)
    bd48:	2f 5f       	subi	r18, 0xFF	; 255
    bd4a:	2c 31       	cpi	r18, 0x1C	; 28
    bd4c:	39 f7       	brne	.-50     	; 0xbd1c <USB_Device_ProcessControlRequest+0x178>
				if (GlobalIntState & AVR32_SR_GM)
				  __builtin_ssrf(AVR32_SR_GM_OFFSET);
				else
				  __builtin_csrf(AVR32_SR_GM_OFFSET);
				#elif (ARCH == ARCH_XMEGA)
				SREG = GlobalIntState;
    bd4e:	4f bf       	out	0x3f, r20	; 63

	USB_Device_GetSerialString(SignatureDescriptor.UnicodeString);

	Endpoint_ClearSETUP();
    bd50:	5f d2       	rcall	.+1214   	; 0xc210 <Endpoint_ClearSETUP>

	Endpoint_Write_Control_Stream_LE(&SignatureDescriptor, sizeof(SignatureDescriptor));
    bd52:	6a e3       	ldi	r22, 0x3A	; 58
    bd54:	70 e0       	ldi	r23, 0x00	; 0
    bd56:	ce 01       	movw	r24, r28
    bd58:	01 96       	adiw	r24, 0x01	; 1
    bd5a:	a3 d0       	rcall	.+326    	; 0xbea2 <Endpoint_Write_Control_Stream_LE>
    bd5c:	0f c0       	rjmp	.+30     	; 0xbd7c <USB_Device_ProcessControlRequest+0x1d8>
		USB_Device_GetInternalSerialDescriptor();
		return;
	}
	#endif

	if ((DescriptorSize = CALLBACK_USB_GetDescriptor(USB_ControlRequest.wValue, USB_ControlRequest.wIndex,
    bd5e:	ae 01       	movw	r20, r28
    bd60:	4f 5f       	subi	r20, 0xFF	; 255
    bd62:	5f 4f       	sbci	r21, 0xFF	; 255
    bd64:	60 91 dc 33 	lds	r22, 0x33DC
    bd68:	0e 94 64 0d 	call	0x1ac8	; 0x1ac8 <CALLBACK_USB_GetDescriptor>
    bd6c:	8c 01       	movw	r16, r24
    bd6e:	89 2b       	or	r24, r25
    bd70:	59 f1       	breq	.+86     	; 0xbdc8 <USB_Device_ProcessControlRequest+0x224>
													 )) == NO_DESCRIPTOR)
	{
		return;
	}

	Endpoint_ClearSETUP();
    bd72:	4e d2       	rcall	.+1180   	; 0xc210 <Endpoint_ClearSETUP>
	#if defined(USE_RAM_DESCRIPTORS) || !defined(ARCH_HAS_MULTI_ADDRESS_SPACE)
	Endpoint_Write_Control_Stream_LE(DescriptorPointer, DescriptorSize);
	#elif defined(USE_EEPROM_DESCRIPTORS)
	Endpoint_Write_Control_EStream_LE(DescriptorPointer, DescriptorSize);
	#elif defined(USE_FLASH_DESCRIPTORS)
	Endpoint_Write_Control_PStream_LE(DescriptorPointer, DescriptorSize);
    bd74:	b8 01       	movw	r22, r16
    bd76:	89 81       	ldd	r24, Y+1	; 0x01
    bd78:	9a 81       	ldd	r25, Y+2	; 0x02
    bd7a:	0f d1       	rcall	.+542    	; 0xbf9a <Endpoint_Write_Control_PStream_LE>
	  Endpoint_Write_Control_EStream_LE(DescriptorPointer, DescriptorSize);
	else
	  Endpoint_Write_Control_Stream_LE(DescriptorPointer, DescriptorSize);
	#endif

	Endpoint_ClearOUT();
    bd7c:	a5 d1       	rcall	.+842    	; 0xc0c8 <Endpoint_ClearOUT>
    bd7e:	24 c0       	rjmp	.+72     	; 0xbdc8 <USB_Device_ProcessControlRequest+0x224>
					USB_Device_GetDescriptor();
				}

				break;
			case REQ_GetConfiguration:
				if (bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE))
    bd80:	80 38       	cpi	r24, 0x80	; 128
    bd82:	11 f5       	brne	.+68     	; 0xbdc8 <USB_Device_ProcessControlRequest+0x224>
	EVENT_USB_Device_ConfigurationChanged();
}

static void USB_Device_GetConfiguration(void)
{
	Endpoint_ClearSETUP();
    bd84:	45 d2       	rcall	.+1162   	; 0xc210 <Endpoint_ClearSETUP>

	Endpoint_Write_8(USB_Device_ConfigurationNumber);
    bd86:	80 91 d3 33 	lds	r24, 0x33D3
    bd8a:	bd d1       	rcall	.+890    	; 0xc106 <Endpoint_Write_8>
	Endpoint_ClearIN();
    bd8c:	84 d1       	rcall	.+776    	; 0xc096 <Endpoint_ClearIN>

	Endpoint_ClearStatusStage();
    bd8e:	43 d3       	rcall	.+1670   	; 0xc416 <Endpoint_ClearStatusStage>
    bd90:	1b c0       	rjmp	.+54     	; 0xbdc8 <USB_Device_ProcessControlRequest+0x224>
				if (bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE))
				  USB_Device_GetConfiguration();

				break;
			case REQ_SetConfiguration:
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
    bd92:	81 11       	cpse	r24, r1
    bd94:	19 c0       	rjmp	.+50     	; 0xbdc8 <USB_Device_ProcessControlRequest+0x224>
}

static void USB_Device_SetConfiguration(void)
{
	#if defined(FIXED_NUM_CONFIGURATIONS)
	if ((uint8_t)USB_ControlRequest.wValue > FIXED_NUM_CONFIGURATIONS)
    bd96:	80 91 da 33 	lds	r24, 0x33DA
    bd9a:	82 30       	cpi	r24, 0x02	; 2
    bd9c:	a8 f4       	brcc	.+42     	; 0xbdc8 <USB_Device_ProcessControlRequest+0x224>
	if ((uint8_t)USB_ControlRequest.wValue > DevDescriptorPtr->NumberOfConfigurations)
	  return;
	#endif
	#endif

	Endpoint_ClearSETUP();
    bd9e:	38 d2       	rcall	.+1136   	; 0xc210 <Endpoint_ClearSETUP>

	USB_Device_ConfigurationNumber = (uint8_t)USB_ControlRequest.wValue;
    bda0:	80 91 da 33 	lds	r24, 0x33DA
    bda4:	80 93 d3 33 	sts	0x33D3, r24

	Endpoint_ClearStatusStage();
    bda8:	36 d3       	rcall	.+1644   	; 0xc416 <Endpoint_ClearStatusStage>

	if (USB_Device_ConfigurationNumber)
    bdaa:	80 91 d3 33 	lds	r24, 0x33D3
    bdae:	81 11       	cpse	r24, r1
    bdb0:	06 c0       	rjmp	.+12     	; 0xbdbe <USB_Device_ProcessControlRequest+0x21a>
			}

			static inline bool USB_Device_IsAddressSet(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline bool USB_Device_IsAddressSet(void)
			{
				return ((USB.ADDR != 0) ? true : false);
    bdb2:	80 91 c3 04 	lds	r24, 0x04C3
	  USB_DeviceState = DEVICE_STATE_Configured;
	else
	  USB_DeviceState = (USB_Device_IsAddressSet()) ? DEVICE_STATE_Configured : DEVICE_STATE_Powered;
    bdb6:	81 11       	cpse	r24, r1
    bdb8:	02 c0       	rjmp	.+4      	; 0xbdbe <USB_Device_ProcessControlRequest+0x21a>
    bdba:	81 e0       	ldi	r24, 0x01	; 1
    bdbc:	01 c0       	rjmp	.+2      	; 0xbdc0 <USB_Device_ProcessControlRequest+0x21c>
    bdbe:	84 e0       	ldi	r24, 0x04	; 4
    bdc0:	80 93 d7 33 	sts	0x33D7, r24

	EVENT_USB_Device_ConfigurationChanged();
    bdc4:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <EVENT_USB_Device_ConfigurationChanged>
			default:
				break;
		}
	}

	if (Endpoint_IsSETUPReceived())
    bdc8:	09 d2       	rcall	.+1042   	; 0xc1dc <Endpoint_IsSETUPReceived>
    bdca:	88 23       	and	r24, r24
    bdcc:	11 f0       	breq	.+4      	; 0xbdd2 <USB_Device_ProcessControlRequest+0x22e>
	{
		Endpoint_ClearSETUP();
    bdce:	20 d2       	rcall	.+1088   	; 0xc210 <Endpoint_ClearSETUP>
		Endpoint_StallTransaction();
    bdd0:	4b d2       	rcall	.+1174   	; 0xc268 <Endpoint_StallTransaction>
	}
}
    bdd2:	ea 96       	adiw	r28, 0x3a	; 58
    bdd4:	cd bf       	out	0x3d, r28	; 61
    bdd6:	de bf       	out	0x3e, r29	; 62
    bdd8:	df 91       	pop	r29
    bdda:	cf 91       	pop	r28
    bddc:	1f 91       	pop	r17
    bdde:	0f 91       	pop	r16
    bde0:	ff 90       	pop	r15
    bde2:	08 95       	ret

0000bde4 <USB_Event_Stub>:
#define  __INCLUDE_FROM_EVENTS_C
#define  __INCLUDE_FROM_USB_DRIVER
#include "Events.h"

void USB_Event_Stub(void)
{
    bde4:	08 95       	ret

0000bde6 <USB_USBTask>:
#if defined(USB_CAN_BE_DEVICE) && !defined(DEVICE_STATE_AS_GPIOR)
volatile uint8_t     USB_DeviceState;
#endif

void USB_USBTask(void)
{
    bde6:	cf 93       	push	r28
}

#if defined(USB_CAN_BE_DEVICE)
static void USB_DeviceTask(void)
{
	if (USB_DeviceState == DEVICE_STATE_Unattached)
    bde8:	80 91 d7 33 	lds	r24, 0x33D7
    bdec:	88 23       	and	r24, r24
    bdee:	51 f0       	breq	.+20     	; 0xbe04 <USB_USBTask+0x1e>
			 *  \return Index of the currently selected endpoint.
			 */
			static inline uint8_t Endpoint_GetCurrentEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetCurrentEndpoint(void)
			{
				return USB_Endpoint_SelectedEndpoint;
    bdf0:	c0 91 e4 33 	lds	r28, 0x33E4
	  return;

	uint8_t PrevEndpoint = Endpoint_GetCurrentEndpoint();

	Endpoint_SelectEndpoint(ENDPOINT_CONTROLEP);
    bdf4:	80 e0       	ldi	r24, 0x00	; 0
    bdf6:	97 d1       	rcall	.+814    	; 0xc126 <Endpoint_SelectEndpoint>

	if (Endpoint_IsSETUPReceived())
    bdf8:	f1 d1       	rcall	.+994    	; 0xc1dc <Endpoint_IsSETUPReceived>
    bdfa:	81 11       	cpse	r24, r1
	  USB_Device_ProcessControlRequest();
    bdfc:	d3 de       	rcall	.-602    	; 0xbba4 <USB_Device_ProcessControlRequest>

	Endpoint_SelectEndpoint(PrevEndpoint);
    bdfe:	8c 2f       	mov	r24, r28
	#elif defined(USB_CAN_BE_HOST)
		USB_HostTask();
	#elif defined(USB_CAN_BE_DEVICE)
		USB_DeviceTask();
	#endif
}
    be00:	cf 91       	pop	r28
	Endpoint_SelectEndpoint(ENDPOINT_CONTROLEP);

	if (Endpoint_IsSETUPReceived())
	  USB_Device_ProcessControlRequest();

	Endpoint_SelectEndpoint(PrevEndpoint);
    be02:	91 c1       	rjmp	.+802    	; 0xc126 <Endpoint_SelectEndpoint>
	#elif defined(USB_CAN_BE_HOST)
		USB_HostTask();
	#elif defined(USB_CAN_BE_DEVICE)
		USB_DeviceTask();
	#endif
}
    be04:	cf 91       	pop	r28
    be06:	08 95       	ret

0000be08 <Endpoint_Write_Stream_LE>:
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
	}

	return ENDPOINT_RWCSTREAM_NoError;
}
    be08:	cf 92       	push	r12
    be0a:	df 92       	push	r13
    be0c:	ef 92       	push	r14
    be0e:	ff 92       	push	r15
    be10:	0f 93       	push	r16
    be12:	1f 93       	push	r17
    be14:	cf 93       	push	r28
    be16:	df 93       	push	r29
    be18:	ec 01       	movw	r28, r24
    be1a:	8b 01       	movw	r16, r22
    be1c:	7a 01       	movw	r14, r20
    be1e:	11 d3       	rcall	.+1570   	; 0xc442 <Endpoint_WaitUntilReady>
    be20:	81 11       	cpse	r24, r1
    be22:	36 c0       	rjmp	.+108    	; 0xbe90 <Endpoint_Write_Stream_LE+0x88>
    be24:	e1 14       	cp	r14, r1
    be26:	f1 04       	cpc	r15, r1
    be28:	39 f0       	breq	.+14     	; 0xbe38 <Endpoint_Write_Stream_LE+0x30>
    be2a:	f7 01       	movw	r30, r14
    be2c:	80 81       	ld	r24, Z
    be2e:	91 81       	ldd	r25, Z+1	; 0x01
    be30:	08 1b       	sub	r16, r24
    be32:	19 0b       	sbc	r17, r25
    be34:	c8 0f       	add	r28, r24
    be36:	d9 1f       	adc	r29, r25
    be38:	c1 2c       	mov	r12, r1
    be3a:	d1 2c       	mov	r13, r1
    be3c:	01 15       	cp	r16, r1
    be3e:	11 05       	cpc	r17, r1
    be40:	31 f1       	breq	.+76     	; 0xbe8e <Endpoint_Write_Stream_LE+0x86>
    be42:	80 91 e0 33 	lds	r24, 0x33E0
    be46:	90 91 e1 33 	lds	r25, 0x33E1
    be4a:	fc 01       	movw	r30, r24
    be4c:	ef 5b       	subi	r30, 0xBF	; 191
    be4e:	ff 4f       	sbci	r31, 0xFF	; 255
    be50:	20 81       	ld	r18, Z
    be52:	31 97       	sbiw	r30, 0x01	; 1
    be54:	80 81       	ld	r24, Z
    be56:	28 17       	cp	r18, r24
    be58:	90 f0       	brcs	.+36     	; 0xbe7e <Endpoint_Write_Stream_LE+0x76>
    be5a:	1d d1       	rcall	.+570    	; 0xc096 <Endpoint_ClearIN>
    be5c:	c4 df       	rcall	.-120    	; 0xbde6 <USB_USBTask>
    be5e:	e1 14       	cp	r14, r1
    be60:	f1 04       	cpc	r15, r1
    be62:	49 f0       	breq	.+18     	; 0xbe76 <Endpoint_Write_Stream_LE+0x6e>
    be64:	f7 01       	movw	r30, r14
    be66:	80 81       	ld	r24, Z
    be68:	91 81       	ldd	r25, Z+1	; 0x01
    be6a:	c8 0e       	add	r12, r24
    be6c:	d9 1e       	adc	r13, r25
    be6e:	c0 82       	st	Z, r12
    be70:	d1 82       	std	Z+1, r13	; 0x01
    be72:	85 e0       	ldi	r24, 0x05	; 5
    be74:	0d c0       	rjmp	.+26     	; 0xbe90 <Endpoint_Write_Stream_LE+0x88>
    be76:	e5 d2       	rcall	.+1482   	; 0xc442 <Endpoint_WaitUntilReady>
    be78:	88 23       	and	r24, r24
    be7a:	01 f3       	breq	.-64     	; 0xbe3c <Endpoint_Write_Stream_LE+0x34>
    be7c:	09 c0       	rjmp	.+18     	; 0xbe90 <Endpoint_Write_Stream_LE+0x88>
    be7e:	89 91       	ld	r24, Y+
    be80:	42 d1       	rcall	.+644    	; 0xc106 <Endpoint_Write_8>
    be82:	01 50       	subi	r16, 0x01	; 1
    be84:	11 09       	sbc	r17, r1
    be86:	ff ef       	ldi	r31, 0xFF	; 255
    be88:	cf 1a       	sub	r12, r31
    be8a:	df 0a       	sbc	r13, r31
    be8c:	d7 cf       	rjmp	.-82     	; 0xbe3c <Endpoint_Write_Stream_LE+0x34>
    be8e:	80 e0       	ldi	r24, 0x00	; 0
    be90:	df 91       	pop	r29
    be92:	cf 91       	pop	r28
    be94:	1f 91       	pop	r17
    be96:	0f 91       	pop	r16
    be98:	ff 90       	pop	r15
    be9a:	ef 90       	pop	r14
    be9c:	df 90       	pop	r13
    be9e:	cf 90       	pop	r12
    bea0:	08 95       	ret

0000bea2 <Endpoint_Write_Control_Stream_LE>:
    bea2:	df 92       	push	r13
    bea4:	ef 92       	push	r14
    bea6:	ff 92       	push	r15
    bea8:	0f 93       	push	r16
    beaa:	1f 93       	push	r17
    beac:	cf 93       	push	r28
    beae:	df 93       	push	r29
    beb0:	d8 2f       	mov	r29, r24
    beb2:	c9 2f       	mov	r28, r25
    beb4:	8b 01       	movw	r16, r22
    beb6:	80 91 e4 33 	lds	r24, 0x33E4
    beba:	80 68       	ori	r24, 0x80	; 128
    bebc:	34 d1       	rcall	.+616    	; 0xc126 <Endpoint_SelectEndpoint>
    bebe:	20 91 de 33 	lds	r18, 0x33DE
    bec2:	30 91 df 33 	lds	r19, 0x33DF
    bec6:	20 17       	cp	r18, r16
    bec8:	31 07       	cpc	r19, r17
    beca:	28 f0       	brcs	.+10     	; 0xbed6 <Endpoint_Write_Control_Stream_LE+0x34>
    becc:	01 15       	cp	r16, r1
    bece:	11 05       	cpc	r17, r1
    bed0:	19 f4       	brne	.+6      	; 0xbed8 <Endpoint_Write_Control_Stream_LE+0x36>
    bed2:	e1 d0       	rcall	.+450    	; 0xc096 <Endpoint_ClearIN>
    bed4:	01 c0       	rjmp	.+2      	; 0xbed8 <Endpoint_Write_Control_Stream_LE+0x36>
    bed6:	89 01       	movw	r16, r18
    bed8:	ed 2e       	mov	r14, r29
    beda:	fc 2e       	mov	r15, r28
    bedc:	d1 2c       	mov	r13, r1
    bede:	01 15       	cp	r16, r1
    bee0:	11 05       	cpc	r17, r1
    bee2:	09 f4       	brne	.+2      	; 0xbee6 <Endpoint_Write_Control_Stream_LE+0x44>
    bee4:	40 c0       	rjmp	.+128    	; 0xbf66 <Endpoint_Write_Control_Stream_LE+0xc4>
    bee6:	80 91 d7 33 	lds	r24, 0x33D7
    beea:	81 11       	cpse	r24, r1
    beec:	02 c0       	rjmp	.+4      	; 0xbef2 <Endpoint_Write_Control_Stream_LE+0x50>
    beee:	82 e0       	ldi	r24, 0x02	; 2
    bef0:	4c c0       	rjmp	.+152    	; 0xbf8a <Endpoint_Write_Control_Stream_LE+0xe8>
    bef2:	85 30       	cpi	r24, 0x05	; 5
    bef4:	11 f4       	brne	.+4      	; 0xbefa <Endpoint_Write_Control_Stream_LE+0x58>
    bef6:	83 e0       	ldi	r24, 0x03	; 3
    bef8:	48 c0       	rjmp	.+144    	; 0xbf8a <Endpoint_Write_Control_Stream_LE+0xe8>
    befa:	70 d1       	rcall	.+736    	; 0xc1dc <Endpoint_IsSETUPReceived>
    befc:	88 23       	and	r24, r24
    befe:	11 f0       	breq	.+4      	; 0xbf04 <Endpoint_Write_Control_Stream_LE+0x62>
    bf00:	81 e0       	ldi	r24, 0x01	; 1
    bf02:	43 c0       	rjmp	.+134    	; 0xbf8a <Endpoint_Write_Control_Stream_LE+0xe8>
    bf04:	51 d1       	rcall	.+674    	; 0xc1a8 <Endpoint_IsOUTReceived>
    bf06:	81 11       	cpse	r24, r1
    bf08:	3c c0       	rjmp	.+120    	; 0xbf82 <Endpoint_Write_Control_Stream_LE+0xe0>
    bf0a:	42 d1       	rcall	.+644    	; 0xc190 <Endpoint_IsINReady>
    bf0c:	88 23       	and	r24, r24
    bf0e:	39 f3       	breq	.-50     	; 0xbede <Endpoint_Write_Control_Stream_LE+0x3c>
    bf10:	20 91 e4 33 	lds	r18, 0x33E4
    bf14:	80 91 e0 33 	lds	r24, 0x33E0
    bf18:	90 91 e1 33 	lds	r25, 0x33E1
    bf1c:	fc 01       	movw	r30, r24
    bf1e:	27 ff       	sbrs	r18, 7
    bf20:	05 c0       	rjmp	.+10     	; 0xbf2c <Endpoint_Write_Control_Stream_LE+0x8a>
    bf22:	ef 5b       	subi	r30, 0xBF	; 191
    bf24:	ff 4f       	sbci	r31, 0xFF	; 255
    bf26:	c0 81       	ld	r28, Z
    bf28:	d0 e0       	ldi	r29, 0x00	; 0
    bf2a:	13 c0       	rjmp	.+38     	; 0xbf52 <Endpoint_Write_Control_Stream_LE+0xb0>
    bf2c:	e0 5c       	subi	r30, 0xC0	; 192
    bf2e:	ff 4f       	sbci	r31, 0xFF	; 255
    bf30:	c0 81       	ld	r28, Z
    bf32:	31 96       	adiw	r30, 0x01	; 1
    bf34:	80 81       	ld	r24, Z
    bf36:	d0 e0       	ldi	r29, 0x00	; 0
    bf38:	c8 1b       	sub	r28, r24
    bf3a:	d1 09       	sbc	r29, r1
    bf3c:	0a c0       	rjmp	.+20     	; 0xbf52 <Endpoint_Write_Control_Stream_LE+0xb0>
    bf3e:	c8 30       	cpi	r28, 0x08	; 8
    bf40:	d1 05       	cpc	r29, r1
    bf42:	50 f4       	brcc	.+20     	; 0xbf58 <Endpoint_Write_Control_Stream_LE+0xb6>
    bf44:	f7 01       	movw	r30, r14
    bf46:	81 91       	ld	r24, Z+
    bf48:	7f 01       	movw	r14, r30
    bf4a:	dd d0       	rcall	.+442    	; 0xc106 <Endpoint_Write_8>
    bf4c:	01 50       	subi	r16, 0x01	; 1
    bf4e:	11 09       	sbc	r17, r1
    bf50:	21 96       	adiw	r28, 0x01	; 1
    bf52:	01 15       	cp	r16, r1
    bf54:	11 05       	cpc	r17, r1
    bf56:	99 f7       	brne	.-26     	; 0xbf3e <Endpoint_Write_Control_Stream_LE+0x9c>
    bf58:	dd 24       	eor	r13, r13
    bf5a:	d3 94       	inc	r13
    bf5c:	28 97       	sbiw	r28, 0x08	; 8
    bf5e:	09 f0       	breq	.+2      	; 0xbf62 <Endpoint_Write_Control_Stream_LE+0xc0>
    bf60:	d1 2c       	mov	r13, r1
    bf62:	99 d0       	rcall	.+306    	; 0xc096 <Endpoint_ClearIN>
    bf64:	bc cf       	rjmp	.-136    	; 0xbede <Endpoint_Write_Control_Stream_LE+0x3c>
    bf66:	d1 10       	cpse	r13, r1
    bf68:	be cf       	rjmp	.-132    	; 0xbee6 <Endpoint_Write_Control_Stream_LE+0x44>
    bf6a:	0b c0       	rjmp	.+22     	; 0xbf82 <Endpoint_Write_Control_Stream_LE+0xe0>
    bf6c:	80 91 d7 33 	lds	r24, 0x33D7
    bf70:	88 23       	and	r24, r24
    bf72:	09 f4       	brne	.+2      	; 0xbf76 <Endpoint_Write_Control_Stream_LE+0xd4>
    bf74:	bc cf       	rjmp	.-136    	; 0xbeee <Endpoint_Write_Control_Stream_LE+0x4c>
    bf76:	85 30       	cpi	r24, 0x05	; 5
    bf78:	09 f4       	brne	.+2      	; 0xbf7c <Endpoint_Write_Control_Stream_LE+0xda>
    bf7a:	bd cf       	rjmp	.-134    	; 0xbef6 <Endpoint_Write_Control_Stream_LE+0x54>
    bf7c:	2f d1       	rcall	.+606    	; 0xc1dc <Endpoint_IsSETUPReceived>
    bf7e:	81 11       	cpse	r24, r1
    bf80:	bf cf       	rjmp	.-130    	; 0xbf00 <Endpoint_Write_Control_Stream_LE+0x5e>
    bf82:	12 d1       	rcall	.+548    	; 0xc1a8 <Endpoint_IsOUTReceived>
    bf84:	88 23       	and	r24, r24
    bf86:	91 f3       	breq	.-28     	; 0xbf6c <Endpoint_Write_Control_Stream_LE+0xca>
    bf88:	80 e0       	ldi	r24, 0x00	; 0
    bf8a:	df 91       	pop	r29
    bf8c:	cf 91       	pop	r28
    bf8e:	1f 91       	pop	r17
    bf90:	0f 91       	pop	r16
    bf92:	ff 90       	pop	r15
    bf94:	ef 90       	pop	r14
    bf96:	df 90       	pop	r13
    bf98:	08 95       	ret

0000bf9a <Endpoint_Write_Control_PStream_LE>:

#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (const void* const Buffer,
                            uint16_t Length)
{
    bf9a:	df 92       	push	r13
    bf9c:	ef 92       	push	r14
    bf9e:	ff 92       	push	r15
    bfa0:	0f 93       	push	r16
    bfa2:	1f 93       	push	r17
    bfa4:	cf 93       	push	r28
    bfa6:	df 93       	push	r29
    bfa8:	d8 2f       	mov	r29, r24
    bfaa:	c9 2f       	mov	r28, r25
    bfac:	8b 01       	movw	r16, r22
	uint8_t* DataStream     = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	bool     LastPacketFull = false;

	Endpoint_SelectEndpoint(USB_Endpoint_SelectedEndpoint | ENDPOINT_DIR_IN);
    bfae:	80 91 e4 33 	lds	r24, 0x33E4
    bfb2:	80 68       	ori	r24, 0x80	; 128
    bfb4:	b8 d0       	rcall	.+368    	; 0xc126 <Endpoint_SelectEndpoint>

	if (Length > USB_ControlRequest.wLength)
    bfb6:	20 91 de 33 	lds	r18, 0x33DE
    bfba:	30 91 df 33 	lds	r19, 0x33DF
    bfbe:	20 17       	cp	r18, r16
    bfc0:	31 07       	cpc	r19, r17
    bfc2:	28 f0       	brcs	.+10     	; 0xbfce <Endpoint_Write_Control_PStream_LE+0x34>
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
    bfc4:	01 15       	cp	r16, r1
    bfc6:	11 05       	cpc	r17, r1
    bfc8:	19 f4       	brne	.+6      	; 0xbfd0 <Endpoint_Write_Control_PStream_LE+0x36>
	  Endpoint_ClearIN();
    bfca:	65 d0       	rcall	.+202    	; 0xc096 <Endpoint_ClearIN>
    bfcc:	01 c0       	rjmp	.+2      	; 0xbfd0 <Endpoint_Write_Control_PStream_LE+0x36>
    bfce:	89 01       	movw	r16, r18
    bfd0:	ed 2e       	mov	r14, r29
    bfd2:	fc 2e       	mov	r15, r28
    bfd4:	d1 2c       	mov	r13, r1

	while (Length || LastPacketFull)
    bfd6:	01 15       	cp	r16, r1
    bfd8:	11 05       	cpc	r17, r1
    bfda:	09 f4       	brne	.+2      	; 0xbfde <Endpoint_Write_Control_PStream_LE+0x44>
    bfdc:	42 c0       	rjmp	.+132    	; 0xc062 <Endpoint_Write_Control_PStream_LE+0xc8>
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    bfde:	80 91 d7 33 	lds	r24, 0x33D7

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    bfe2:	81 11       	cpse	r24, r1
    bfe4:	02 c0       	rjmp	.+4      	; 0xbfea <Endpoint_Write_Control_PStream_LE+0x50>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
    bfe6:	82 e0       	ldi	r24, 0x02	; 2
    bfe8:	4e c0       	rjmp	.+156    	; 0xc086 <Endpoint_Write_Control_PStream_LE+0xec>
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    bfea:	85 30       	cpi	r24, 0x05	; 5
    bfec:	11 f4       	brne	.+4      	; 0xbff2 <Endpoint_Write_Control_PStream_LE+0x58>
		  return ENDPOINT_RWCSTREAM_BusSuspended;
    bfee:	83 e0       	ldi	r24, 0x03	; 3
    bff0:	4a c0       	rjmp	.+148    	; 0xc086 <Endpoint_Write_Control_PStream_LE+0xec>
		else if (Endpoint_IsSETUPReceived())
    bff2:	f4 d0       	rcall	.+488    	; 0xc1dc <Endpoint_IsSETUPReceived>
    bff4:	88 23       	and	r24, r24
    bff6:	11 f0       	breq	.+4      	; 0xbffc <Endpoint_Write_Control_PStream_LE+0x62>
		  return ENDPOINT_RWCSTREAM_HostAborted;
    bff8:	81 e0       	ldi	r24, 0x01	; 1
    bffa:	45 c0       	rjmp	.+138    	; 0xc086 <Endpoint_Write_Control_PStream_LE+0xec>
		else if (Endpoint_IsOUTReceived())
    bffc:	d5 d0       	rcall	.+426    	; 0xc1a8 <Endpoint_IsOUTReceived>
    bffe:	81 11       	cpse	r24, r1
    c000:	3e c0       	rjmp	.+124    	; 0xc07e <Endpoint_Write_Control_PStream_LE+0xe4>
		  break;

		if (Endpoint_IsINReady())
    c002:	c6 d0       	rcall	.+396    	; 0xc190 <Endpoint_IsINReady>
    c004:	88 23       	and	r24, r24
    c006:	39 f3       	breq	.-50     	; 0xbfd6 <Endpoint_Write_Control_PStream_LE+0x3c>
			 *  \return Total number of bytes in the currently selected Endpoint's FIFO buffer.
			 */
			static inline uint16_t Endpoint_BytesInEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Endpoint_BytesInEndpoint(void)
			{
				if (USB_Endpoint_SelectedEndpoint & ENDPOINT_DIR_IN)
    c008:	20 91 e4 33 	lds	r18, 0x33E4
    c00c:	80 91 e0 33 	lds	r24, 0x33E0
    c010:	90 91 e1 33 	lds	r25, 0x33E1
				  return USB_Endpoint_SelectedFIFO->Position;
    c014:	fc 01       	movw	r30, r24
			 *  \return Total number of bytes in the currently selected Endpoint's FIFO buffer.
			 */
			static inline uint16_t Endpoint_BytesInEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Endpoint_BytesInEndpoint(void)
			{
				if (USB_Endpoint_SelectedEndpoint & ENDPOINT_DIR_IN)
    c016:	27 ff       	sbrs	r18, 7
    c018:	05 c0       	rjmp	.+10     	; 0xc024 <Endpoint_Write_Control_PStream_LE+0x8a>
				  return USB_Endpoint_SelectedFIFO->Position;
    c01a:	ef 5b       	subi	r30, 0xBF	; 191
    c01c:	ff 4f       	sbci	r31, 0xFF	; 255
    c01e:	c0 81       	ld	r28, Z
    c020:	d0 e0       	ldi	r29, 0x00	; 0
    c022:	15 c0       	rjmp	.+42     	; 0xc04e <Endpoint_Write_Control_PStream_LE+0xb4>
				else
				  return (USB_Endpoint_SelectedFIFO->Length - USB_Endpoint_SelectedFIFO->Position);
    c024:	e0 5c       	subi	r30, 0xC0	; 192
    c026:	ff 4f       	sbci	r31, 0xFF	; 255
    c028:	c0 81       	ld	r28, Z
    c02a:	31 96       	adiw	r30, 0x01	; 1
    c02c:	80 81       	ld	r24, Z
    c02e:	d0 e0       	ldi	r29, 0x00	; 0
    c030:	c8 1b       	sub	r28, r24
    c032:	d1 09       	sbc	r29, r1
    c034:	0c c0       	rjmp	.+24     	; 0xc04e <Endpoint_Write_Control_PStream_LE+0xb4>
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_Device_ControlEndpointSize))
    c036:	c8 30       	cpi	r28, 0x08	; 8
    c038:	d1 05       	cpc	r29, r1
    c03a:	60 f4       	brcc	.+24     	; 0xc054 <Endpoint_Write_Control_PStream_LE+0xba>
			{
				TEMPLATE_TRANSFER_BYTE(DataStream);
    c03c:	f7 01       	movw	r30, r14
    c03e:	84 91       	lpm	r24, Z
    c040:	62 d0       	rcall	.+196    	; 0xc106 <Endpoint_Write_8>
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
    c042:	ff ef       	ldi	r31, 0xFF	; 255
    c044:	ef 1a       	sub	r14, r31
    c046:	ff 0a       	sbc	r15, r31
				Length--;
    c048:	01 50       	subi	r16, 0x01	; 1
    c04a:	11 09       	sbc	r17, r1
				BytesInEndpoint++;
    c04c:	21 96       	adiw	r28, 0x01	; 1

		if (Endpoint_IsINReady())
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_Device_ControlEndpointSize))
    c04e:	01 15       	cp	r16, r1
    c050:	11 05       	cpc	r17, r1
    c052:	89 f7       	brne	.-30     	; 0xc036 <Endpoint_Write_Control_PStream_LE+0x9c>
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
				Length--;
				BytesInEndpoint++;
			}

			LastPacketFull = (BytesInEndpoint == USB_Device_ControlEndpointSize);
    c054:	dd 24       	eor	r13, r13
    c056:	d3 94       	inc	r13
    c058:	28 97       	sbiw	r28, 0x08	; 8
    c05a:	09 f0       	breq	.+2      	; 0xc05e <Endpoint_Write_Control_PStream_LE+0xc4>
    c05c:	d1 2c       	mov	r13, r1
			Endpoint_ClearIN();
    c05e:	1b d0       	rcall	.+54     	; 0xc096 <Endpoint_ClearIN>
    c060:	ba cf       	rjmp	.-140    	; 0xbfd6 <Endpoint_Write_Control_PStream_LE+0x3c>
	if (Length > USB_ControlRequest.wLength)
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
    c062:	d1 10       	cpse	r13, r1
    c064:	bc cf       	rjmp	.-136    	; 0xbfde <Endpoint_Write_Control_PStream_LE+0x44>
    c066:	0b c0       	rjmp	.+22     	; 0xc07e <Endpoint_Write_Control_PStream_LE+0xe4>
		}
	}

	while (!(Endpoint_IsOUTReceived()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    c068:	80 91 d7 33 	lds	r24, 0x33D7

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    c06c:	88 23       	and	r24, r24
    c06e:	09 f4       	brne	.+2      	; 0xc072 <Endpoint_Write_Control_PStream_LE+0xd8>
    c070:	ba cf       	rjmp	.-140    	; 0xbfe6 <Endpoint_Write_Control_PStream_LE+0x4c>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    c072:	85 30       	cpi	r24, 0x05	; 5
    c074:	09 f4       	brne	.+2      	; 0xc078 <Endpoint_Write_Control_PStream_LE+0xde>
    c076:	bb cf       	rjmp	.-138    	; 0xbfee <Endpoint_Write_Control_PStream_LE+0x54>
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
    c078:	b1 d0       	rcall	.+354    	; 0xc1dc <Endpoint_IsSETUPReceived>
    c07a:	81 11       	cpse	r24, r1
    c07c:	bd cf       	rjmp	.-134    	; 0xbff8 <Endpoint_Write_Control_PStream_LE+0x5e>
			LastPacketFull = (BytesInEndpoint == USB_Device_ControlEndpointSize);
			Endpoint_ClearIN();
		}
	}

	while (!(Endpoint_IsOUTReceived()))
    c07e:	94 d0       	rcall	.+296    	; 0xc1a8 <Endpoint_IsOUTReceived>
    c080:	88 23       	and	r24, r24
    c082:	91 f3       	breq	.-28     	; 0xc068 <Endpoint_Write_Control_PStream_LE+0xce>
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;
	}

	return ENDPOINT_RWCSTREAM_NoError;
    c084:	80 e0       	ldi	r24, 0x00	; 0
}
    c086:	df 91       	pop	r29
    c088:	cf 91       	pop	r28
    c08a:	1f 91       	pop	r17
    c08c:	0f 91       	pop	r16
    c08e:	ff 90       	pop	r15
    c090:	ef 90       	pop	r14
    c092:	df 90       	pop	r13
    c094:	08 95       	ret

0000c096 <Endpoint_ClearIN>:
	USB_Endpoint_SelectedFIFO->Position  = 0;
}

void Endpoint_ClearIN(void)
{
	USB_Endpoint_SelectedHandle->CNT     = USB_Endpoint_SelectedFIFO->Position;
    c096:	e0 91 e2 33 	lds	r30, 0x33E2
    c09a:	f0 91 e3 33 	lds	r31, 0x33E3
    c09e:	a0 91 e0 33 	lds	r26, 0x33E0
    c0a2:	b0 91 e1 33 	lds	r27, 0x33E1
    c0a6:	af 5b       	subi	r26, 0xBF	; 191
    c0a8:	bf 4f       	sbci	r27, 0xFF	; 255
    c0aa:	8c 91       	ld	r24, X
    c0ac:	90 e0       	ldi	r25, 0x00	; 0
    c0ae:	82 83       	std	Z+2, r24	; 0x02
    c0b0:	93 83       	std	Z+3, r25	; 0x03
	USB_Endpoint_SelectedHandle->STATUS &= ~(USB_EP_TRNCOMPL0_bm | USB_EP_BUSNACK0_bm | USB_EP_OVF_bm);
    c0b2:	80 81       	ld	r24, Z
    c0b4:	8d 79       	andi	r24, 0x9D	; 157
    c0b6:	80 83       	st	Z, r24
	USB_Endpoint_SelectedFIFO->Position  = 0;
    c0b8:	e0 91 e0 33 	lds	r30, 0x33E0
    c0bc:	f0 91 e1 33 	lds	r31, 0x33E1
    c0c0:	ef 5b       	subi	r30, 0xBF	; 191
    c0c2:	ff 4f       	sbci	r31, 0xFF	; 255
    c0c4:	10 82       	st	Z, r1
    c0c6:	08 95       	ret

0000c0c8 <Endpoint_ClearOUT>:
}

void Endpoint_ClearOUT(void)
{
	USB_Endpoint_SelectedHandle->STATUS &= ~(USB_EP_TRNCOMPL0_bm | USB_EP_BUSNACK0_bm | USB_EP_OVF_bm);
    c0c8:	e0 91 e2 33 	lds	r30, 0x33E2
    c0cc:	f0 91 e3 33 	lds	r31, 0x33E3
    c0d0:	80 81       	ld	r24, Z
    c0d2:	8d 79       	andi	r24, 0x9D	; 157
    c0d4:	80 83       	st	Z, r24
	USB_Endpoint_SelectedFIFO->Position  = 0;
    c0d6:	e0 91 e0 33 	lds	r30, 0x33E0
    c0da:	f0 91 e1 33 	lds	r31, 0x33E1
    c0de:	ef 5b       	subi	r30, 0xBF	; 191
    c0e0:	ff 4f       	sbci	r31, 0xFF	; 255
    c0e2:	10 82       	st	Z, r1
    c0e4:	08 95       	ret

0000c0e6 <Endpoint_Read_8>:
	}
}

uint8_t Endpoint_Read_8(void)
{
	return USB_Endpoint_SelectedFIFO->Data[USB_Endpoint_SelectedFIFO->Position++];
    c0e6:	80 91 e0 33 	lds	r24, 0x33E0
    c0ea:	90 91 e1 33 	lds	r25, 0x33E1
    c0ee:	fc 01       	movw	r30, r24
    c0f0:	ef 5b       	subi	r30, 0xBF	; 191
    c0f2:	ff 4f       	sbci	r31, 0xFF	; 255
    c0f4:	20 81       	ld	r18, Z
    c0f6:	31 e0       	ldi	r19, 0x01	; 1
    c0f8:	32 0f       	add	r19, r18
    c0fa:	30 83       	st	Z, r19
    c0fc:	fc 01       	movw	r30, r24
    c0fe:	e2 0f       	add	r30, r18
    c100:	f1 1d       	adc	r31, r1
    c102:	80 81       	ld	r24, Z
}
    c104:	08 95       	ret

0000c106 <Endpoint_Write_8>:

void Endpoint_Write_8(const uint8_t Data)
{
	USB_Endpoint_SelectedFIFO->Data[USB_Endpoint_SelectedFIFO->Position++] = Data;
    c106:	20 91 e0 33 	lds	r18, 0x33E0
    c10a:	30 91 e1 33 	lds	r19, 0x33E1
    c10e:	f9 01       	movw	r30, r18
    c110:	ef 5b       	subi	r30, 0xBF	; 191
    c112:	ff 4f       	sbci	r31, 0xFF	; 255
    c114:	90 81       	ld	r25, Z
    c116:	41 e0       	ldi	r20, 0x01	; 1
    c118:	49 0f       	add	r20, r25
    c11a:	40 83       	st	Z, r20
    c11c:	f9 01       	movw	r30, r18
    c11e:	e9 0f       	add	r30, r25
    c120:	f1 1d       	adc	r31, r1
    c122:	80 83       	st	Z, r24
    c124:	08 95       	ret

0000c126 <Endpoint_SelectEndpoint>:

void Endpoint_SelectEndpoint(const uint8_t Address)
{
	uint8_t EndpointNumber = (Address & ENDPOINT_EPNUM_MASK);

	USB_Endpoint_SelectedEndpoint = Address;
    c126:	80 93 e4 33 	sts	0x33E4, r24
	USB_Endpoint_SelectedFIFO->Data[USB_Endpoint_SelectedFIFO->Position++] = Data;
}

void Endpoint_SelectEndpoint(const uint8_t Address)
{
	uint8_t EndpointNumber = (Address & ENDPOINT_EPNUM_MASK);
    c12a:	48 2f       	mov	r20, r24
    c12c:	4f 70       	andi	r20, 0x0F	; 15

	USB_Endpoint_SelectedEndpoint = Address;

	Endpoint_FIFOPair_t* EndpointFIFOPair = &USB_Endpoint_FIFOs[EndpointNumber];
    c12e:	50 e0       	ldi	r21, 0x00	; 0
	USB_EndpointTable_t* EndpointTable    = (USB_EndpointTable_t*)USB.EPPTR;
    c130:	60 91 c6 04 	lds	r22, 0x04C6
    c134:	70 91 c7 04 	lds	r23, 0x04C7
    c138:	9a 01       	movw	r18, r20
    c13a:	94 e0       	ldi	r25, 0x04	; 4
    c13c:	22 0f       	add	r18, r18
    c13e:	33 1f       	adc	r19, r19
    c140:	9a 95       	dec	r25
    c142:	e1 f7       	brne	.-8      	; 0xc13c <Endpoint_SelectEndpoint+0x16>

	if (Address & ENDPOINT_DIR_IN)
	{
		USB_Endpoint_SelectedFIFO   = &EndpointFIFOPair->IN;
    c144:	e4 e8       	ldi	r30, 0x84	; 132
	USB_Endpoint_SelectedEndpoint = Address;

	Endpoint_FIFOPair_t* EndpointFIFOPair = &USB_Endpoint_FIFOs[EndpointNumber];
	USB_EndpointTable_t* EndpointTable    = (USB_EndpointTable_t*)USB.EPPTR;

	if (Address & ENDPOINT_DIR_IN)
    c146:	87 ff       	sbrs	r24, 7
    c148:	11 c0       	rjmp	.+34     	; 0xc16c <Endpoint_SelectEndpoint+0x46>
	{
		USB_Endpoint_SelectedFIFO   = &EndpointFIFOPair->IN;
    c14a:	e4 9f       	mul	r30, r20
    c14c:	c0 01       	movw	r24, r0
    c14e:	e5 9f       	mul	r30, r21
    c150:	90 0d       	add	r25, r0
    c152:	11 24       	eor	r1, r1
    c154:	89 5d       	subi	r24, 0xD9	; 217
    c156:	9b 4c       	sbci	r25, 0xCB	; 203
    c158:	80 93 e0 33 	sts	0x33E0, r24
    c15c:	90 93 e1 33 	sts	0x33E1, r25
		USB_Endpoint_SelectedHandle = &EndpointTable->Endpoints[EndpointNumber].IN;
    c160:	c9 01       	movw	r24, r18
    c162:	08 96       	adiw	r24, 0x08	; 8
    c164:	9b 01       	movw	r18, r22
    c166:	28 0f       	add	r18, r24
    c168:	39 1f       	adc	r19, r25
    c16a:	0d c0       	rjmp	.+26     	; 0xc186 <Endpoint_SelectEndpoint+0x60>
	}
	else
	{
		USB_Endpoint_SelectedFIFO   = &EndpointFIFOPair->OUT;
    c16c:	e4 9f       	mul	r30, r20
    c16e:	c0 01       	movw	r24, r0
    c170:	e5 9f       	mul	r30, r21
    c172:	90 0d       	add	r25, r0
    c174:	11 24       	eor	r1, r1
    c176:	8b 51       	subi	r24, 0x1B	; 27
    c178:	9c 4c       	sbci	r25, 0xCC	; 204
    c17a:	80 93 e0 33 	sts	0x33E0, r24
    c17e:	90 93 e1 33 	sts	0x33E1, r25
		USB_Endpoint_SelectedHandle = &EndpointTable->Endpoints[EndpointNumber].OUT;
    c182:	26 0f       	add	r18, r22
    c184:	37 1f       	adc	r19, r23
    c186:	20 93 e2 33 	sts	0x33E2, r18
    c18a:	30 93 e3 33 	sts	0x33E3, r19
    c18e:	08 95       	ret

0000c190 <Endpoint_IsINReady>:
volatile USB_EP_t*        USB_Endpoint_SelectedHandle;
volatile Endpoint_FIFO_t* USB_Endpoint_SelectedFIFO;

bool Endpoint_IsINReady(void)
{
	Endpoint_SelectEndpoint(USB_Endpoint_SelectedEndpoint | ENDPOINT_DIR_IN);
    c190:	80 91 e4 33 	lds	r24, 0x33E4
    c194:	80 68       	ori	r24, 0x80	; 128
    c196:	c7 df       	rcall	.-114    	; 0xc126 <Endpoint_SelectEndpoint>

	return ((USB_Endpoint_SelectedHandle->STATUS & USB_EP_BUSNACK0_bm) ? true : false);
    c198:	e0 91 e2 33 	lds	r30, 0x33E2
    c19c:	f0 91 e3 33 	lds	r31, 0x33E3
    c1a0:	80 81       	ld	r24, Z
}
    c1a2:	86 95       	lsr	r24
    c1a4:	81 70       	andi	r24, 0x01	; 1
    c1a6:	08 95       	ret

0000c1a8 <Endpoint_IsOUTReceived>:

bool Endpoint_IsOUTReceived(void)
{
	Endpoint_SelectEndpoint(USB_Endpoint_SelectedEndpoint & ~ENDPOINT_DIR_IN);
    c1a8:	80 91 e4 33 	lds	r24, 0x33E4
    c1ac:	8f 77       	andi	r24, 0x7F	; 127
    c1ae:	bb df       	rcall	.-138    	; 0xc126 <Endpoint_SelectEndpoint>

	if (USB_Endpoint_SelectedHandle->STATUS & USB_EP_TRNCOMPL0_bm)
    c1b0:	a0 91 e2 33 	lds	r26, 0x33E2
    c1b4:	b0 91 e3 33 	lds	r27, 0x33E3
    c1b8:	8c 91       	ld	r24, X
    c1ba:	85 ff       	sbrs	r24, 5
    c1bc:	0d c0       	rjmp	.+26     	; 0xc1d8 <Endpoint_IsOUTReceived+0x30>
	{
		USB_Endpoint_SelectedFIFO->Length = USB_Endpoint_SelectedHandle->CNT;
    c1be:	e0 91 e0 33 	lds	r30, 0x33E0
    c1c2:	f0 91 e1 33 	lds	r31, 0x33E1
    c1c6:	12 96       	adiw	r26, 0x02	; 2
    c1c8:	8d 91       	ld	r24, X+
    c1ca:	9c 91       	ld	r25, X
    c1cc:	13 97       	sbiw	r26, 0x03	; 3
    c1ce:	e0 5c       	subi	r30, 0xC0	; 192
    c1d0:	ff 4f       	sbci	r31, 0xFF	; 255
    c1d2:	80 83       	st	Z, r24
		return true;
    c1d4:	81 e0       	ldi	r24, 0x01	; 1
    c1d6:	08 95       	ret
	}

	return false;
    c1d8:	80 e0       	ldi	r24, 0x00	; 0
}
    c1da:	08 95       	ret

0000c1dc <Endpoint_IsSETUPReceived>:

bool Endpoint_IsSETUPReceived(void)
{
	Endpoint_SelectEndpoint(USB_Endpoint_SelectedEndpoint & ~ENDPOINT_DIR_IN);
    c1dc:	80 91 e4 33 	lds	r24, 0x33E4
    c1e0:	8f 77       	andi	r24, 0x7F	; 127
    c1e2:	a1 df       	rcall	.-190    	; 0xc126 <Endpoint_SelectEndpoint>

	if (USB_Endpoint_SelectedHandle->STATUS & USB_EP_SETUP_bm)
    c1e4:	a0 91 e2 33 	lds	r26, 0x33E2
    c1e8:	b0 91 e3 33 	lds	r27, 0x33E3
    c1ec:	8c 91       	ld	r24, X
    c1ee:	84 ff       	sbrs	r24, 4
    c1f0:	0d c0       	rjmp	.+26     	; 0xc20c <Endpoint_IsSETUPReceived+0x30>
	{
		USB_Endpoint_SelectedFIFO->Length = USB_Endpoint_SelectedHandle->CNT;
    c1f2:	e0 91 e0 33 	lds	r30, 0x33E0
    c1f6:	f0 91 e1 33 	lds	r31, 0x33E1
    c1fa:	12 96       	adiw	r26, 0x02	; 2
    c1fc:	8d 91       	ld	r24, X+
    c1fe:	9c 91       	ld	r25, X
    c200:	13 97       	sbiw	r26, 0x03	; 3
    c202:	e0 5c       	subi	r30, 0xC0	; 192
    c204:	ff 4f       	sbci	r31, 0xFF	; 255
    c206:	80 83       	st	Z, r24
		return true;
    c208:	81 e0       	ldi	r24, 0x01	; 1
    c20a:	08 95       	ret
	}

	return false;
    c20c:	80 e0       	ldi	r24, 0x00	; 0
}
    c20e:	08 95       	ret

0000c210 <Endpoint_ClearSETUP>:

void Endpoint_ClearSETUP(void)
{
	Endpoint_SelectEndpoint(USB_Endpoint_SelectedEndpoint & ~ENDPOINT_DIR_IN);
    c210:	80 91 e4 33 	lds	r24, 0x33E4
    c214:	8f 77       	andi	r24, 0x7F	; 127
    c216:	87 df       	rcall	.-242    	; 0xc126 <Endpoint_SelectEndpoint>
	USB_Endpoint_SelectedHandle->STATUS &= ~(USB_EP_SETUP_bm | USB_EP_TRNCOMPL0_bm | USB_EP_BUSNACK0_bm | USB_EP_OVF_bm);
    c218:	e0 91 e2 33 	lds	r30, 0x33E2
    c21c:	f0 91 e3 33 	lds	r31, 0x33E3
    c220:	80 81       	ld	r24, Z
    c222:	8d 78       	andi	r24, 0x8D	; 141
    c224:	80 83       	st	Z, r24
	USB_Endpoint_SelectedHandle->STATUS |= USB_EP_TOGGLE_bm;
    c226:	e0 91 e2 33 	lds	r30, 0x33E2
    c22a:	f0 91 e3 33 	lds	r31, 0x33E3
    c22e:	80 81       	ld	r24, Z
    c230:	81 60       	ori	r24, 0x01	; 1
    c232:	80 83       	st	Z, r24
	USB_Endpoint_SelectedFIFO->Position  = 0;
    c234:	e0 91 e0 33 	lds	r30, 0x33E0
    c238:	f0 91 e1 33 	lds	r31, 0x33E1
    c23c:	ef 5b       	subi	r30, 0xBF	; 191
    c23e:	ff 4f       	sbci	r31, 0xFF	; 255
    c240:	10 82       	st	Z, r1

	Endpoint_SelectEndpoint(USB_Endpoint_SelectedEndpoint | ENDPOINT_DIR_IN);
    c242:	80 91 e4 33 	lds	r24, 0x33E4
    c246:	80 68       	ori	r24, 0x80	; 128
    c248:	6e df       	rcall	.-292    	; 0xc126 <Endpoint_SelectEndpoint>
	USB_Endpoint_SelectedHandle->STATUS |= USB_EP_TOGGLE_bm;
    c24a:	e0 91 e2 33 	lds	r30, 0x33E2
    c24e:	f0 91 e3 33 	lds	r31, 0x33E3
    c252:	80 81       	ld	r24, Z
    c254:	81 60       	ori	r24, 0x01	; 1
    c256:	80 83       	st	Z, r24
	USB_Endpoint_SelectedFIFO->Position  = 0;
    c258:	e0 91 e0 33 	lds	r30, 0x33E0
    c25c:	f0 91 e1 33 	lds	r31, 0x33E1
    c260:	ef 5b       	subi	r30, 0xBF	; 191
    c262:	ff 4f       	sbci	r31, 0xFF	; 255
    c264:	10 82       	st	Z, r1
    c266:	08 95       	ret

0000c268 <Endpoint_StallTransaction>:
	USB_Endpoint_SelectedFIFO->Position  = 0;
}

void Endpoint_StallTransaction(void)
{
	USB_Endpoint_SelectedHandle->CTRL |= USB_EP_STALL_bm;
    c268:	e0 91 e2 33 	lds	r30, 0x33E2
    c26c:	f0 91 e3 33 	lds	r31, 0x33E3
    c270:	81 81       	ldd	r24, Z+1	; 0x01
    c272:	84 60       	ori	r24, 0x04	; 4
    c274:	81 83       	std	Z+1, r24	; 0x01

	if ((USB_Endpoint_SelectedHandle->CTRL & USB_EP_TYPE_gm) == USB_EP_TYPE_CONTROL_gc)
    c276:	e0 91 e2 33 	lds	r30, 0x33E2
    c27a:	f0 91 e3 33 	lds	r31, 0x33E3
    c27e:	81 81       	ldd	r24, Z+1	; 0x01
    c280:	80 7c       	andi	r24, 0xC0	; 192
    c282:	80 34       	cpi	r24, 0x40	; 64
    c284:	59 f4       	brne	.+22     	; 0xc29c <Endpoint_StallTransaction+0x34>
	{
		Endpoint_SelectEndpoint(USB_Endpoint_SelectedEndpoint ^ ENDPOINT_DIR_IN);
    c286:	80 91 e4 33 	lds	r24, 0x33E4
    c28a:	80 58       	subi	r24, 0x80	; 128
    c28c:	4c df       	rcall	.-360    	; 0xc126 <Endpoint_SelectEndpoint>
		USB_Endpoint_SelectedHandle->CTRL |= USB_EP_STALL_bm;
    c28e:	e0 91 e2 33 	lds	r30, 0x33E2
    c292:	f0 91 e3 33 	lds	r31, 0x33E3
    c296:	81 81       	ldd	r24, Z+1	; 0x01
    c298:	84 60       	ori	r24, 0x04	; 4
    c29a:	81 83       	std	Z+1, r24	; 0x01
    c29c:	08 95       	ret

0000c29e <Endpoint_ConfigureEndpoint_PRV>:
}

bool Endpoint_ConfigureEndpoint_PRV(const uint8_t Address,
                                    const uint8_t Config,
                                    const uint8_t Size)
{
    c29e:	1f 93       	push	r17
    c2a0:	cf 93       	push	r28
    c2a2:	df 93       	push	r29
    c2a4:	1f 92       	push	r1
    c2a6:	1f 92       	push	r1
    c2a8:	cd b7       	in	r28, 0x3d	; 61
    c2aa:	de b7       	in	r29, 0x3e	; 62
    c2ac:	18 2f       	mov	r17, r24
	Endpoint_SelectEndpoint(Address);
    c2ae:	4a 83       	std	Y+2, r20	; 0x02
    c2b0:	69 83       	std	Y+1, r22	; 0x01
    c2b2:	39 df       	rcall	.-398    	; 0xc126 <Endpoint_SelectEndpoint>

	USB_Endpoint_SelectedHandle->CTRL    = 0;
    c2b4:	e0 91 e2 33 	lds	r30, 0x33E2
    c2b8:	f0 91 e3 33 	lds	r31, 0x33E3
    c2bc:	11 82       	std	Z+1, r1	; 0x01
	USB_Endpoint_SelectedHandle->STATUS  = (Address & ENDPOINT_DIR_IN) ? USB_EP_BUSNACK0_bm : 0;
    c2be:	e0 91 e2 33 	lds	r30, 0x33E2
    c2c2:	f0 91 e3 33 	lds	r31, 0x33E3
    c2c6:	81 2f       	mov	r24, r17
    c2c8:	88 1f       	adc	r24, r24
    c2ca:	88 27       	eor	r24, r24
    c2cc:	88 1f       	adc	r24, r24
    c2ce:	88 0f       	add	r24, r24
    c2d0:	80 83       	st	Z, r24
	USB_Endpoint_SelectedHandle->CTRL    = Config;
    c2d2:	e0 91 e2 33 	lds	r30, 0x33E2
    c2d6:	f0 91 e3 33 	lds	r31, 0x33E3
    c2da:	69 81       	ldd	r22, Y+1	; 0x01
    c2dc:	61 83       	std	Z+1, r22	; 0x01
	USB_Endpoint_SelectedHandle->CNT     = 0;
    c2de:	e0 91 e2 33 	lds	r30, 0x33E2
    c2e2:	f0 91 e3 33 	lds	r31, 0x33E3
    c2e6:	12 82       	std	Z+2, r1	; 0x02
    c2e8:	13 82       	std	Z+3, r1	; 0x03
	USB_Endpoint_SelectedHandle->DATAPTR = (intptr_t)USB_Endpoint_SelectedFIFO->Data;
    c2ea:	20 91 e0 33 	lds	r18, 0x33E0
    c2ee:	30 91 e1 33 	lds	r19, 0x33E1
    c2f2:	24 83       	std	Z+4, r18	; 0x04
    c2f4:	35 83       	std	Z+5, r19	; 0x05

	USB_Endpoint_SelectedFIFO->Length    = (Address & ENDPOINT_DIR_IN) ? Size : 0;
    c2f6:	11 0f       	add	r17, r17
    c2f8:	11 0b       	sbc	r17, r17
    c2fa:	4a 81       	ldd	r20, Y+2	; 0x02
    c2fc:	41 23       	and	r20, r17
    c2fe:	f9 01       	movw	r30, r18
    c300:	e0 5c       	subi	r30, 0xC0	; 192
    c302:	ff 4f       	sbci	r31, 0xFF	; 255
    c304:	40 83       	st	Z, r20
	USB_Endpoint_SelectedFIFO->Position  = 0;
    c306:	31 96       	adiw	r30, 0x01	; 1
    c308:	10 82       	st	Z, r1

	return true;
}
    c30a:	81 e0       	ldi	r24, 0x01	; 1
    c30c:	0f 90       	pop	r0
    c30e:	0f 90       	pop	r0
    c310:	df 91       	pop	r29
    c312:	cf 91       	pop	r28
    c314:	1f 91       	pop	r17
    c316:	08 95       	ret

0000c318 <Endpoint_ConfigureEndpointTable>:
	}
}

bool Endpoint_ConfigureEndpointTable(const USB_Endpoint_Table_t* const Table,
                                     const uint8_t Entries)
{
    c318:	af 92       	push	r10
    c31a:	bf 92       	push	r11
    c31c:	cf 92       	push	r12
    c31e:	df 92       	push	r13
    c320:	ef 92       	push	r14
    c322:	ff 92       	push	r15
    c324:	0f 93       	push	r16
    c326:	1f 93       	push	r17
    c328:	cf 93       	push	r28
    c32a:	df 93       	push	r29
    c32c:	a6 2e       	mov	r10, r22
    c32e:	8c 01       	movw	r16, r24
    c330:	7c 01       	movw	r14, r24
    c332:	84 e0       	ldi	r24, 0x04	; 4
    c334:	e8 0e       	add	r14, r24
    c336:	f1 1c       	adc	r15, r1
	for (uint8_t i = 0; i < Entries; i++)
    c338:	b1 2c       	mov	r11, r1
    c33a:	ba 14       	cp	r11, r10
    c33c:	09 f4       	brne	.+2      	; 0xc340 <Endpoint_ConfigureEndpointTable+0x28>
    c33e:	43 c0       	rjmp	.+134    	; 0xc3c6 <Endpoint_ConfigureEndpointTable+0xae>
	{
		if (!(Table[i].Address))
    c340:	f8 01       	movw	r30, r16
    c342:	d0 81       	ld	r29, Z
    c344:	dd 23       	and	r29, r29
    c346:	c1 f1       	breq	.+112    	; 0xc3b8 <Endpoint_ConfigureEndpointTable+0xa0>
		  continue;

		if (!(Endpoint_ConfigureEndpoint(Table[i].Address, Table[i].Type, Table[i].Size, Table[i].Banks)))
    c348:	c1 80       	ldd	r12, Z+1	; 0x01
    c34a:	d2 80       	ldd	r13, Z+2	; 0x02
    c34c:	f7 01       	movw	r30, r14
    c34e:	31 97       	sbiw	r30, 0x01	; 1
    c350:	80 81       	ld	r24, Z
			static inline bool Endpoint_ConfigureEndpoint(const uint8_t Address,
			                                              const uint8_t Type,
			                                              const uint16_t Size,
			                                              const uint8_t Banks)
			{
				uint8_t EPConfigMask = (USB_EP_INTDSBL_bm | ((Banks > 1) ? USB_EP_PINGPONG_bm : 0) | Endpoint_BytesToEPSizeMask(Size));
    c352:	f7 01       	movw	r30, r14
    c354:	90 81       	ld	r25, Z
    c356:	92 30       	cpi	r25, 0x02	; 2
    c358:	10 f4       	brcc	.+4      	; 0xc35e <Endpoint_ConfigureEndpointTable+0x46>
    c35a:	98 e0       	ldi	r25, 0x08	; 8
    c35c:	01 c0       	rjmp	.+2      	; 0xc360 <Endpoint_ConfigureEndpointTable+0x48>
    c35e:	98 e1       	ldi	r25, 0x18	; 24
			static inline uint8_t Endpoint_BytesToEPSizeMask(const uint16_t Bytes) ATTR_WARN_UNUSED_RESULT ATTR_CONST
			                                                                       ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_BytesToEPSizeMask(const uint16_t Bytes)
			{
				uint8_t  MaskVal    = 0;
				uint16_t CheckBytes = 8;
    c360:	28 e0       	ldi	r18, 0x08	; 8
    c362:	30 e0       	ldi	r19, 0x00	; 0
		/* Inline Functions: */
			static inline uint8_t Endpoint_BytesToEPSizeMask(const uint16_t Bytes) ATTR_WARN_UNUSED_RESULT ATTR_CONST
			                                                                       ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_BytesToEPSizeMask(const uint16_t Bytes)
			{
				uint8_t  MaskVal    = 0;
    c364:	c0 e0       	ldi	r28, 0x00	; 0
				uint16_t CheckBytes = 8;

				while (CheckBytes < Bytes)
    c366:	2c 15       	cp	r18, r12
    c368:	3d 05       	cpc	r19, r13
    c36a:	20 f4       	brcc	.+8      	; 0xc374 <Endpoint_ConfigureEndpointTable+0x5c>
				{
					MaskVal++;
    c36c:	cf 5f       	subi	r28, 0xFF	; 255
					CheckBytes <<= 1;
    c36e:	22 0f       	add	r18, r18
    c370:	33 1f       	adc	r19, r19
    c372:	f9 cf       	rjmp	.-14     	; 0xc366 <Endpoint_ConfigureEndpointTable+0x4e>
			static inline bool Endpoint_ConfigureEndpoint(const uint8_t Address,
			                                              const uint8_t Type,
			                                              const uint16_t Size,
			                                              const uint8_t Banks)
			{
				uint8_t EPConfigMask = (USB_EP_INTDSBL_bm | ((Banks > 1) ? USB_EP_PINGPONG_bm : 0) | Endpoint_BytesToEPSizeMask(Size));
    c374:	c9 2b       	or	r28, r25

				if ((Address & ENDPOINT_EPNUM_MASK) >= ENDPOINT_TOTAL_ENDPOINTS)
    c376:	9d 2f       	mov	r25, r29
    c378:	9f 70       	andi	r25, 0x0F	; 15
    c37a:	96 30       	cpi	r25, 0x06	; 6
    c37c:	10 f0       	brcs	.+4      	; 0xc382 <Endpoint_ConfigureEndpointTable+0x6a>
		{
			return false;
    c37e:	80 e0       	ldi	r24, 0x00	; 0
    c380:	23 c0       	rjmp	.+70     	; 0xc3c8 <Endpoint_ConfigureEndpointTable+0xb0>
				  return false;

				// TODO - Fix once limitations are lifted
				EPConfigMask &= ~USB_EP_PINGPONG_bm;
    c382:	cf 7e       	andi	r28, 0xEF	; 239
				if (Size > 64)
    c384:	f1 e4       	ldi	r31, 0x41	; 65
    c386:	cf 16       	cp	r12, r31
    c388:	d1 04       	cpc	r13, r1
    c38a:	c8 f7       	brcc	.-14     	; 0xc37e <Endpoint_ConfigureEndpointTable+0x66>
				  return false;

				switch (Type)
    c38c:	88 23       	and	r24, r24
    c38e:	21 f0       	breq	.+8      	; 0xc398 <Endpoint_ConfigureEndpointTable+0x80>
    c390:	81 30       	cpi	r24, 0x01	; 1
    c392:	21 f4       	brne	.+8      	; 0xc39c <Endpoint_ConfigureEndpointTable+0x84>
				{
					case EP_TYPE_CONTROL:
						EPConfigMask |= USB_EP_TYPE_CONTROL_gc;
						break;
					case EP_TYPE_ISOCHRONOUS:
						EPConfigMask |= USB_EP_TYPE_ISOCHRONOUS_gc;
    c394:	c0 6c       	ori	r28, 0xC0	; 192
    c396:	0a c0       	rjmp	.+20     	; 0xc3ac <Endpoint_ConfigureEndpointTable+0x94>
				  return false;

				switch (Type)
				{
					case EP_TYPE_CONTROL:
						EPConfigMask |= USB_EP_TYPE_CONTROL_gc;
    c398:	c0 64       	ori	r28, 0x40	; 64
    c39a:	03 c0       	rjmp	.+6      	; 0xc3a2 <Endpoint_ConfigureEndpointTable+0x8a>
						break;
					case EP_TYPE_ISOCHRONOUS:
						EPConfigMask |= USB_EP_TYPE_ISOCHRONOUS_gc;
						break;
					default:
						EPConfigMask |= USB_EP_TYPE_BULK_gc;
    c39c:	c0 68       	ori	r28, 0x80	; 128
						break;
				}

				if (Type == EP_TYPE_CONTROL)
    c39e:	81 11       	cpse	r24, r1
    c3a0:	05 c0       	rjmp	.+10     	; 0xc3ac <Endpoint_ConfigureEndpointTable+0x94>
				  Endpoint_ConfigureEndpoint_PRV(Address ^ ENDPOINT_DIR_IN, EPConfigMask, Size);
    c3a2:	4c 2d       	mov	r20, r12
    c3a4:	6c 2f       	mov	r22, r28
    c3a6:	80 e8       	ldi	r24, 0x80	; 128
    c3a8:	8d 0f       	add	r24, r29
    c3aa:	79 df       	rcall	.-270    	; 0xc29e <Endpoint_ConfigureEndpoint_PRV>

				return Endpoint_ConfigureEndpoint_PRV(Address, EPConfigMask, Size);
    c3ac:	4c 2d       	mov	r20, r12
    c3ae:	6c 2f       	mov	r22, r28
    c3b0:	8d 2f       	mov	r24, r29
    c3b2:	75 df       	rcall	.-278    	; 0xc29e <Endpoint_ConfigureEndpoint_PRV>
	for (uint8_t i = 0; i < Entries; i++)
	{
		if (!(Table[i].Address))
		  continue;

		if (!(Endpoint_ConfigureEndpoint(Table[i].Address, Table[i].Type, Table[i].Size, Table[i].Banks)))
    c3b4:	88 23       	and	r24, r24
    c3b6:	19 f3       	breq	.-58     	; 0xc37e <Endpoint_ConfigureEndpointTable+0x66>
}

bool Endpoint_ConfigureEndpointTable(const USB_Endpoint_Table_t* const Table,
                                     const uint8_t Entries)
{
	for (uint8_t i = 0; i < Entries; i++)
    c3b8:	b3 94       	inc	r11
    c3ba:	0b 5f       	subi	r16, 0xFB	; 251
    c3bc:	1f 4f       	sbci	r17, 0xFF	; 255
    c3be:	85 e0       	ldi	r24, 0x05	; 5
    c3c0:	e8 0e       	add	r14, r24
    c3c2:	f1 1c       	adc	r15, r1
    c3c4:	ba cf       	rjmp	.-140    	; 0xc33a <Endpoint_ConfigureEndpointTable+0x22>
		{
			return false;
		}
	}

	return true;
    c3c6:	81 e0       	ldi	r24, 0x01	; 1
}
    c3c8:	df 91       	pop	r29
    c3ca:	cf 91       	pop	r28
    c3cc:	1f 91       	pop	r17
    c3ce:	0f 91       	pop	r16
    c3d0:	ff 90       	pop	r15
    c3d2:	ef 90       	pop	r14
    c3d4:	df 90       	pop	r13
    c3d6:	cf 90       	pop	r12
    c3d8:	bf 90       	pop	r11
    c3da:	af 90       	pop	r10
    c3dc:	08 95       	ret

0000c3de <Endpoint_ClearEndpoints>:

	return true;
}

void Endpoint_ClearEndpoints(void)
{
    c3de:	80 e0       	ldi	r24, 0x00	; 0
    c3e0:	90 e0       	ldi	r25, 0x00	; 0
	for (uint8_t EPNum = 0; EPNum < ENDPOINT_TOTAL_ENDPOINTS; EPNum++)
	{
		((USB_EndpointTable_t*)USB.EPPTR)->Endpoints[EPNum].IN.CTRL  = 0;
    c3e2:	e0 91 c6 04 	lds	r30, 0x04C6
    c3e6:	f0 91 c7 04 	lds	r31, 0x04C7
    c3ea:	9c 01       	movw	r18, r24
    c3ec:	44 e0       	ldi	r20, 0x04	; 4
    c3ee:	22 0f       	add	r18, r18
    c3f0:	33 1f       	adc	r19, r19
    c3f2:	4a 95       	dec	r20
    c3f4:	e1 f7       	brne	.-8      	; 0xc3ee <Endpoint_ClearEndpoints+0x10>
    c3f6:	e2 0f       	add	r30, r18
    c3f8:	f3 1f       	adc	r31, r19
    c3fa:	11 86       	std	Z+9, r1	; 0x09
		((USB_EndpointTable_t*)USB.EPPTR)->Endpoints[EPNum].OUT.CTRL = 0;
    c3fc:	40 91 c6 04 	lds	r20, 0x04C6
    c400:	50 91 c7 04 	lds	r21, 0x04C7
    c404:	fa 01       	movw	r30, r20
    c406:	e2 0f       	add	r30, r18
    c408:	f3 1f       	adc	r31, r19
    c40a:	11 82       	std	Z+1, r1	; 0x01
    c40c:	01 96       	adiw	r24, 0x01	; 1
	return true;
}

void Endpoint_ClearEndpoints(void)
{
	for (uint8_t EPNum = 0; EPNum < ENDPOINT_TOTAL_ENDPOINTS; EPNum++)
    c40e:	86 30       	cpi	r24, 0x06	; 6
    c410:	91 05       	cpc	r25, r1
    c412:	39 f7       	brne	.-50     	; 0xc3e2 <Endpoint_ClearEndpoints+0x4>
	{
		((USB_EndpointTable_t*)USB.EPPTR)->Endpoints[EPNum].IN.CTRL  = 0;
		((USB_EndpointTable_t*)USB.EPPTR)->Endpoints[EPNum].OUT.CTRL = 0;
	}
}
    c414:	08 95       	ret

0000c416 <Endpoint_ClearStatusStage>:

void Endpoint_ClearStatusStage(void)
{
	if (USB_ControlRequest.bmRequestType & REQDIR_DEVICETOHOST)
    c416:	80 91 d8 33 	lds	r24, 0x33D8
    c41a:	87 ff       	sbrs	r24, 7
    c41c:	0d c0       	rjmp	.+26     	; 0xc438 <Endpoint_ClearStatusStage+0x22>
	{
		while (!(Endpoint_IsOUTReceived()))
    c41e:	c4 de       	rcall	.-632    	; 0xc1a8 <Endpoint_IsOUTReceived>
    c420:	81 11       	cpse	r24, r1
    c422:	05 c0       	rjmp	.+10     	; 0xc42e <Endpoint_ClearStatusStage+0x18>
		{
			if (USB_DeviceState == DEVICE_STATE_Unattached)
    c424:	80 91 d7 33 	lds	r24, 0x33D7
    c428:	81 11       	cpse	r24, r1
    c42a:	f9 cf       	rjmp	.-14     	; 0xc41e <Endpoint_ClearStatusStage+0x8>
    c42c:	09 c0       	rjmp	.+18     	; 0xc440 <Endpoint_ClearStatusStage+0x2a>
			  return;
		}

		Endpoint_ClearOUT();
    c42e:	4c ce       	rjmp	.-872    	; 0xc0c8 <Endpoint_ClearOUT>
	}
	else
	{
		while (!(Endpoint_IsINReady()))
		{
			if (USB_DeviceState == DEVICE_STATE_Unattached)
    c430:	80 91 d7 33 	lds	r24, 0x33D7
    c434:	88 23       	and	r24, r24
    c436:	21 f0       	breq	.+8      	; 0xc440 <Endpoint_ClearStatusStage+0x2a>

		Endpoint_ClearOUT();
	}
	else
	{
		while (!(Endpoint_IsINReady()))
    c438:	ab de       	rcall	.-682    	; 0xc190 <Endpoint_IsINReady>
    c43a:	88 23       	and	r24, r24
    c43c:	c9 f3       	breq	.-14     	; 0xc430 <Endpoint_ClearStatusStage+0x1a>
		{
			if (USB_DeviceState == DEVICE_STATE_Unattached)
			  return;
		}

		Endpoint_ClearIN();
    c43e:	2b ce       	rjmp	.-938    	; 0xc096 <Endpoint_ClearIN>
    c440:	08 95       	ret

0000c442 <Endpoint_WaitUntilReady>:
	}
}

#if !defined(CONTROL_ONLY_DEVICE)
uint8_t Endpoint_WaitUntilReady(void)
{
    c442:	0f 93       	push	r16
    c444:	1f 93       	push	r17
    c446:	cf 93       	push	r28
			 *  \return Current USB frame number from the USB controller.
			 */
			static inline uint16_t USB_Device_GetFrameNumber(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint16_t USB_Device_GetFrameNumber(void)
			{
				return ((USB_EndpointTable_t*)USB.EPPTR)->FrameNum;
    c448:	e0 91 c6 04 	lds	r30, 0x04C6
    c44c:	f0 91 c7 04 	lds	r31, 0x04C7
    c450:	e0 5a       	subi	r30, 0xA0	; 160
    c452:	ff 4f       	sbci	r31, 0xFF	; 255
    c454:	00 81       	ld	r16, Z
    c456:	11 81       	ldd	r17, Z+1	; 0x01
	#if (USB_STREAM_TIMEOUT_MS < 0xFF)
	uint8_t  TimeoutMSRem = USB_STREAM_TIMEOUT_MS;
    c458:	c4 e6       	ldi	r28, 0x64	; 100
			 *  \return The currently selected endpoint's direction, as a \c ENDPOINT_DIR_* mask.
			 */
			static inline uint8_t Endpoint_GetEndpointDirection(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetEndpointDirection(void)
			{
				return (USB_Endpoint_SelectedEndpoint & ENDPOINT_DIR_IN);
    c45a:	80 91 e4 33 	lds	r24, 0x33E4

	uint16_t PreviousFrameNumber = USB_Device_GetFrameNumber();

	for (;;)
	{
		if (Endpoint_GetEndpointDirection() == ENDPOINT_DIR_IN)
    c45e:	87 ff       	sbrs	r24, 7
    c460:	0a c0       	rjmp	.+20     	; 0xc476 <Endpoint_WaitUntilReady+0x34>
		{
			if (Endpoint_IsINReady())
    c462:	96 de       	rcall	.-724    	; 0xc190 <Endpoint_IsINReady>
    c464:	81 11       	cpse	r24, r1
    c466:	05 c0       	rjmp	.+10     	; 0xc472 <Endpoint_WaitUntilReady+0x30>
		{
			if (Endpoint_IsOUTReceived())
			  return ENDPOINT_READYWAIT_NoError;
		}

		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    c468:	80 91 d7 33 	lds	r24, 0x33D7

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    c46c:	81 11       	cpse	r24, r1
    c46e:	05 c0       	rjmp	.+10     	; 0xc47a <Endpoint_WaitUntilReady+0x38>
    c470:	21 c0       	rjmp	.+66     	; 0xc4b4 <Endpoint_WaitUntilReady+0x72>
	for (;;)
	{
		if (Endpoint_GetEndpointDirection() == ENDPOINT_DIR_IN)
		{
			if (Endpoint_IsINReady())
			  return ENDPOINT_READYWAIT_NoError;
    c472:	80 e0       	ldi	r24, 0x00	; 0
    c474:	24 c0       	rjmp	.+72     	; 0xc4be <Endpoint_WaitUntilReady+0x7c>
		}
		else
		{
			if (Endpoint_IsOUTReceived())
    c476:	98 de       	rcall	.-720    	; 0xc1a8 <Endpoint_IsOUTReceived>
    c478:	f5 cf       	rjmp	.-22     	; 0xc464 <Endpoint_WaitUntilReady+0x22>

		uint8_t USB_DeviceState_LCL = USB_DeviceState;

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_READYWAIT_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    c47a:	85 30       	cpi	r24, 0x05	; 5
    c47c:	e9 f0       	breq	.+58     	; 0xc4b8 <Endpoint_WaitUntilReady+0x76>
			 *  \return Boolean \c true if the currently selected endpoint is stalled, \c false otherwise.
			 */
			static inline bool Endpoint_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsStalled(void)
			{
				return ((USB_Endpoint_SelectedHandle->CTRL & USB_EP_STALL_bm) ? true : false);
    c47e:	e0 91 e2 33 	lds	r30, 0x33E2
    c482:	f0 91 e3 33 	lds	r31, 0x33E3
    c486:	81 81       	ldd	r24, Z+1	; 0x01
		  return ENDPOINT_READYWAIT_BusSuspended;
		else if (Endpoint_IsStalled())
    c488:	82 fd       	sbrc	r24, 2
    c48a:	18 c0       	rjmp	.+48     	; 0xc4bc <Endpoint_WaitUntilReady+0x7a>
    c48c:	e0 91 c6 04 	lds	r30, 0x04C6
    c490:	f0 91 c7 04 	lds	r31, 0x04C7
    c494:	e0 5a       	subi	r30, 0xA0	; 160
    c496:	ff 4f       	sbci	r31, 0xFF	; 255
    c498:	80 81       	ld	r24, Z
    c49a:	91 81       	ldd	r25, Z+1	; 0x01
		  return ENDPOINT_READYWAIT_EndpointStalled;

		uint16_t CurrentFrameNumber = USB_Device_GetFrameNumber();

		if (CurrentFrameNumber != PreviousFrameNumber)
    c49c:	80 17       	cp	r24, r16
    c49e:	91 07       	cpc	r25, r17
    c4a0:	e1 f2       	breq	.-72     	; 0xc45a <Endpoint_WaitUntilReady+0x18>
		{
			PreviousFrameNumber = CurrentFrameNumber;

			if (!(TimeoutMSRem--))
    c4a2:	2f ef       	ldi	r18, 0xFF	; 255
    c4a4:	2c 0f       	add	r18, r28
    c4a6:	cc 23       	and	r28, r28
    c4a8:	19 f0       	breq	.+6      	; 0xc4b0 <Endpoint_WaitUntilReady+0x6e>
    c4aa:	8c 01       	movw	r16, r24
    c4ac:	c2 2f       	mov	r28, r18
    c4ae:	d5 cf       	rjmp	.-86     	; 0xc45a <Endpoint_WaitUntilReady+0x18>
			  return ENDPOINT_READYWAIT_Timeout;
    c4b0:	84 e0       	ldi	r24, 0x04	; 4
    c4b2:	05 c0       	rjmp	.+10     	; 0xc4be <Endpoint_WaitUntilReady+0x7c>
		}

		uint8_t USB_DeviceState_LCL = USB_DeviceState;

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_READYWAIT_DeviceDisconnected;
    c4b4:	82 e0       	ldi	r24, 0x02	; 2
    c4b6:	03 c0       	rjmp	.+6      	; 0xc4be <Endpoint_WaitUntilReady+0x7c>
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_READYWAIT_BusSuspended;
    c4b8:	83 e0       	ldi	r24, 0x03	; 3
    c4ba:	01 c0       	rjmp	.+2      	; 0xc4be <Endpoint_WaitUntilReady+0x7c>
		else if (Endpoint_IsStalled())
		  return ENDPOINT_READYWAIT_EndpointStalled;
    c4bc:	81 e0       	ldi	r24, 0x01	; 1

			if (!(TimeoutMSRem--))
			  return ENDPOINT_READYWAIT_Timeout;
		}
	}
}
    c4be:	cf 91       	pop	r28
    c4c0:	1f 91       	pop	r17
    c4c2:	0f 91       	pop	r16
    c4c4:	08 95       	ret

0000c4c6 <USB_Disable>:
	USB_ResetInterface();
}

void USB_Disable(void)
{
	USB_INT_DisableAllInterrupts();
    c4c6:	63 d0       	rcall	.+198    	; 0xc58e <USB_INT_DisableAllInterrupts>
	USB_INT_ClearAllInterrupts();
    c4c8:	69 d0       	rcall	.+210    	; 0xc59c <USB_INT_ClearAllInterrupts>
			 *  enumerating the device once attached until \ref USB_Attach() is called.
			 */
			static inline void USB_Detach(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Detach(void)
			{
				USB.CTRLB &= ~USB_ATTACH_bm;
    c4ca:	e0 ec       	ldi	r30, 0xC0	; 192
    c4cc:	f4 e0       	ldi	r31, 0x04	; 4
    c4ce:	81 81       	ldd	r24, Z+1	; 0x01
    c4d0:	8e 7f       	andi	r24, 0xFE	; 254
    c4d2:	81 83       	std	Z+1, r24	; 0x01
			}

			static inline void USB_Controller_Disable(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Controller_Disable(void)
			{
				USB.CTRLA &= ~USB_ENABLE_bm;
    c4d4:	80 81       	ld	r24, Z
    c4d6:	8f 77       	andi	r24, 0x7F	; 127
    c4d8:	80 83       	st	Z, r24

	USB_Detach();
	USB_Controller_Disable();

	USB_IsInitialized = false;
    c4da:	10 92 d6 33 	sts	0x33D6, r1
    c4de:	08 95       	ret

0000c4e0 <USB_ResetInterface>:
}

void USB_ResetInterface(void)
{
    c4e0:	cf 93       	push	r28
    c4e2:	df 93       	push	r29
	{
		DividerIndex++;
		PrescalerNeeded >>= 1;
	}

	CLK.USBCTRL = (DividerIndex - 1) << CLK_USBPSDIV_gp;
    c4e4:	e0 e4       	ldi	r30, 0x40	; 64
    c4e6:	f0 e0       	ldi	r31, 0x00	; 0
    c4e8:	14 82       	std	Z+4, r1	; 0x04

	if (USB_Options & USB_OPT_PLLCLKSRC)
	  CLK.USBCTRL |= (CLK_USBSRC_PLL_gc   | CLK_USBSEN_bm);
	else
	  CLK.USBCTRL |= (CLK_USBSRC_RC32M_gc | CLK_USBSEN_bm);
    c4ea:	84 81       	ldd	r24, Z+4	; 0x04
    c4ec:	83 60       	ori	r24, 0x03	; 3
    c4ee:	84 83       	std	Z+4, r24	; 0x04

	USB_Device_SetDeviceAddress(0);

	USB_INT_DisableAllInterrupts();
    c4f0:	4e d0       	rcall	.+156    	; 0xc58e <USB_INT_DisableAllInterrupts>
	USB_INT_ClearAllInterrupts();
    c4f2:	54 d0       	rcall	.+168    	; 0xc59c <USB_INT_ClearAllInterrupts>
			}

			static inline void USB_Controller_Reset(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Controller_Reset(void)
			{
				USB.CTRLA &= ~USB_ENABLE_bm;
    c4f4:	c0 ec       	ldi	r28, 0xC0	; 192
    c4f6:	d4 e0       	ldi	r29, 0x04	; 4
    c4f8:	88 81       	ld	r24, Y
    c4fa:	8f 77       	andi	r24, 0x7F	; 127
    c4fc:	88 83       	st	Y, r24
				USB.CTRLA |=  USB_ENABLE_bm;
    c4fe:	88 81       	ld	r24, Y
    c500:	80 68       	ori	r24, 0x80	; 128
    c502:	88 83       	st	Y, r24
}

#if defined(USB_CAN_BE_DEVICE)
static void USB_Init_Device(void)
{
	USB_DeviceState                 = DEVICE_STATE_Unattached;
    c504:	10 92 d7 33 	sts	0x33D7, r1
	USB_Device_ConfigurationNumber  = 0;
    c508:	10 92 d3 33 	sts	0x33D3, r1

	#if !defined(NO_DEVICE_REMOTE_WAKEUP)
	USB_Device_RemoteWakeupEnabled  = false;
    c50c:	10 92 d5 33 	sts	0x33D5, r1
	#endif

	#if !defined(NO_DEVICE_SELF_POWER)
	USB_Device_CurrentlySelfPowered = false;
    c510:	10 92 d4 33 	sts	0x33D4, r1
			}

			static inline void USB_Device_SetFullSpeed(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Device_SetFullSpeed(void)
			{
				USB.CTRLA |=  USB_SPEED_bm;
    c514:	88 81       	ld	r24, Y
    c516:	80 64       	ori	r24, 0x40	; 64
    c518:	88 83       	st	Y, r24
						EPConfigMask |= USB_EP_TYPE_BULK_gc;
						break;
				}

				if (Type == EP_TYPE_CONTROL)
				  Endpoint_ConfigureEndpoint_PRV(Address ^ ENDPOINT_DIR_IN, EPConfigMask, Size);
    c51a:	48 e0       	ldi	r20, 0x08	; 8
    c51c:	68 e4       	ldi	r22, 0x48	; 72
    c51e:	80 e8       	ldi	r24, 0x80	; 128
    c520:	be de       	rcall	.-644    	; 0xc29e <Endpoint_ConfigureEndpoint_PRV>

				return Endpoint_ConfigureEndpoint_PRV(Address, EPConfigMask, Size);
    c522:	48 e0       	ldi	r20, 0x08	; 8
    c524:	68 e4       	ldi	r22, 0x48	; 72
    c526:	80 e0       	ldi	r24, 0x00	; 0
    c528:	ba de       	rcall	.-652    	; 0xc29e <Endpoint_ConfigureEndpoint_PRV>
			static inline void USB_INT_Enable(const uint8_t Interrupt)
			{
				switch (Interrupt)
				{
					case USB_INT_BUSEVENTI:
						USB.INTCTRLA |= USB_BUSEVIE_bm;
    c52a:	88 85       	ldd	r24, Y+8	; 0x08
    c52c:	80 64       	ori	r24, 0x40	; 64
    c52e:	88 87       	std	Y+8, r24	; 0x08
			 *  register and despite the datasheet making no mention of its requirement in host mode.
			 */
			static inline void USB_Attach(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Attach(void)
			{
				USB.CTRLB |= USB_ATTACH_bm;
    c530:	89 81       	ldd	r24, Y+1	; 0x01
    c532:	81 60       	ori	r24, 0x01	; 1
    c534:	89 83       	std	Y+1, r24	; 0x01
	USB_INT_DisableAllInterrupts();
	USB_INT_ClearAllInterrupts();

	USB_Controller_Reset();
	USB_Init_Device();
}
    c536:	df 91       	pop	r29
    c538:	cf 91       	pop	r28
    c53a:	08 95       	ret

0000c53c <USB_Init>:

               #if !defined(USE_STATIC_OPTIONS)
               const uint8_t Options
               #endif
               )
{
    c53c:	cf 93       	push	r28
    c53e:	df 93       	push	r29
				#if (ARCH == ARCH_AVR8)
				return SREG;
				#elif (ARCH == ARCH_UC3)
				return __builtin_mfsr(AVR32_SR);
				#elif (ARCH == ARCH_XMEGA)
				return SREG;
    c540:	3f b7       	in	r19, 0x3f	; 63
				#if (ARCH == ARCH_AVR8)
				cli();
				#elif (ARCH == ARCH_UC3)
				__builtin_ssrf(AVR32_SR_GM_OFFSET);
				#elif (ARCH == ARCH_XMEGA)
				cli();
    c542:	f8 94       	cli
	#endif

	uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
	GlobalInterruptDisable();

	NVM.CMD  = NVM_CMD_READ_CALIB_ROW_gc;
    c544:	c0 ec       	ldi	r28, 0xC0	; 192
    c546:	d1 e0       	ldi	r29, 0x01	; 1
    c548:	22 e0       	ldi	r18, 0x02	; 2
    c54a:	2a 87       	std	Y+10, r18	; 0x0a
	USB.CAL0 = pgm_read_byte(offsetof(NVM_PROD_SIGNATURES_t, USBCAL0));
    c54c:	ea e1       	ldi	r30, 0x1A	; 26
    c54e:	f0 e0       	ldi	r31, 0x00	; 0
    c550:	e4 91       	lpm	r30, Z
    c552:	a0 ec       	ldi	r26, 0xC0	; 192
    c554:	b4 e0       	ldi	r27, 0x04	; 4
    c556:	da 96       	adiw	r26, 0x3a	; 58
    c558:	ec 93       	st	X, r30
    c55a:	da 97       	sbiw	r26, 0x3a	; 58
	USB.CAL1 = pgm_read_byte(offsetof(NVM_PROD_SIGNATURES_t, USBCAL1));
    c55c:	eb e1       	ldi	r30, 0x1B	; 27
    c55e:	f0 e0       	ldi	r31, 0x00	; 0
    c560:	e4 91       	lpm	r30, Z
    c562:	db 96       	adiw	r26, 0x3b	; 59
    c564:	ec 93       	st	X, r30
    c566:	db 97       	sbiw	r26, 0x3b	; 59
	NVM.CMD  = NVM_CMD_NO_OPERATION_gc;
    c568:	1a 86       	std	Y+10, r1	; 0x0a

	/* Ugly workaround to ensure an aligned table, since __BIGGEST_ALIGNMENT__ == 1 for the 8-bit AVR-GCC toolchain */
	USB.EPPTR = ((intptr_t)&USB_EndpointTable[1] & ~(1 << 0));
    c56a:	8e ef       	ldi	r24, 0xFE	; 254
    c56c:	96 e3       	ldi	r25, 0x36	; 54
    c56e:	8e 7f       	andi	r24, 0xFE	; 254
    c570:	16 96       	adiw	r26, 0x06	; 6
    c572:	8d 93       	st	X+, r24
    c574:	9c 93       	st	X, r25
    c576:	17 97       	sbiw	r26, 0x07	; 7
	USB.CTRLA = (USB_STFRNUM_bm | ((ENDPOINT_TOTAL_ENDPOINTS - 1) << USB_MAXEP_gp));
    c578:	85 e1       	ldi	r24, 0x15	; 21
    c57a:	8c 93       	st	X, r24

	if ((USB_Options & USB_OPT_BUSEVENT_PRIHIGH) == USB_OPT_BUSEVENT_PRIHIGH)
	  USB.INTCTRLA = (3 << USB_INTLVL_gp);
	else if ((USB_Options & USB_OPT_BUSEVENT_PRIMED) == USB_OPT_BUSEVENT_PRIMED)
	  USB.INTCTRLA = (2 << USB_INTLVL_gp);
    c57c:	18 96       	adiw	r26, 0x08	; 8
    c57e:	2c 93       	st	X, r18
				if (GlobalIntState & AVR32_SR_GM)
				  __builtin_ssrf(AVR32_SR_GM_OFFSET);
				else
				  __builtin_csrf(AVR32_SR_GM_OFFSET);
				#elif (ARCH == ARCH_XMEGA)
				SREG = GlobalIntState;
    c580:	3f bf       	out	0x3f, r19	; 63

	#if defined(USB_CAN_BE_BOTH)
	USB_CurrentMode = Mode;
	#endif

	USB_IsInitialized = true;
    c582:	81 e0       	ldi	r24, 0x01	; 1
    c584:	80 93 d6 33 	sts	0x33D6, r24

	USB_ResetInterface();
}
    c588:	df 91       	pop	r29
    c58a:	cf 91       	pop	r28
	USB_CurrentMode = Mode;
	#endif

	USB_IsInitialized = true;

	USB_ResetInterface();
    c58c:	a9 cf       	rjmp	.-174    	; 0xc4e0 <USB_ResetInterface>

0000c58e <USB_INT_DisableAllInterrupts>:
#define  __INCLUDE_FROM_USB_DRIVER
#include "../USBInterrupt.h"

void USB_INT_DisableAllInterrupts(void)
{
	USB.INTCTRLA    &= USB_INTLVL_gm;
    c58e:	e0 ec       	ldi	r30, 0xC0	; 192
    c590:	f4 e0       	ldi	r31, 0x04	; 4
    c592:	80 85       	ldd	r24, Z+8	; 0x08
    c594:	83 70       	andi	r24, 0x03	; 3
    c596:	80 87       	std	Z+8, r24	; 0x08
	USB.INTCTRLB     = 0;
    c598:	11 86       	std	Z+9, r1	; 0x09
    c59a:	08 95       	ret

0000c59c <USB_INT_ClearAllInterrupts>:
}

void USB_INT_ClearAllInterrupts(void)
{
	USB.INTFLAGSACLR = 0xFF;
    c59c:	e0 ec       	ldi	r30, 0xC0	; 192
    c59e:	f4 e0       	ldi	r31, 0x04	; 4
    c5a0:	8f ef       	ldi	r24, 0xFF	; 255
    c5a2:	82 87       	std	Z+10, r24	; 0x0a
	USB.INTFLAGSBCLR = 0xFF;
    c5a4:	84 87       	std	Z+12, r24	; 0x0c
    c5a6:	08 95       	ret

0000c5a8 <__vector_125>:
}

ISR(USB_BUSEVENT_vect)
{
    c5a8:	1f 92       	push	r1
    c5aa:	0f 92       	push	r0
    c5ac:	0f b6       	in	r0, 0x3f	; 63
    c5ae:	0f 92       	push	r0
    c5b0:	11 24       	eor	r1, r1
    c5b2:	08 b6       	in	r0, 0x38	; 56
    c5b4:	0f 92       	push	r0
    c5b6:	18 be       	out	0x38, r1	; 56
    c5b8:	09 b6       	in	r0, 0x39	; 57
    c5ba:	0f 92       	push	r0
    c5bc:	19 be       	out	0x39, r1	; 57
    c5be:	0b b6       	in	r0, 0x3b	; 59
    c5c0:	0f 92       	push	r0
    c5c2:	1b be       	out	0x3b, r1	; 59
    c5c4:	2f 93       	push	r18
    c5c6:	3f 93       	push	r19
    c5c8:	4f 93       	push	r20
    c5ca:	5f 93       	push	r21
    c5cc:	6f 93       	push	r22
    c5ce:	7f 93       	push	r23
    c5d0:	8f 93       	push	r24
    c5d2:	9f 93       	push	r25
    c5d4:	af 93       	push	r26
    c5d6:	bf 93       	push	r27
    c5d8:	ef 93       	push	r30
    c5da:	ff 93       	push	r31
					case USB_INT_BUSEVENTI_Resume:
						return ((USB.INTFLAGSACLR & USB_RESUMEIF_bm) ? true : false);
					case USB_INT_BUSEVENTI_Reset:
						return ((USB.INTFLAGSACLR & USB_RSTIF_bm) ? true : false);
					case USB_INT_SOFI:
						return ((USB.INTFLAGSACLR & USB_SOFIF_bm) ? true : false);
    c5dc:	80 91 ca 04 	lds	r24, 0x04CA
	#if !defined(NO_SOF_EVENTS)
	if (USB_INT_HasOccurred(USB_INT_SOFI) && USB_INT_IsEnabled(USB_INT_SOFI))
    c5e0:	87 ff       	sbrs	r24, 7
    c5e2:	08 c0       	rjmp	.+16     	; 0xc5f4 <__vector_125+0x4c>
				switch (Interrupt)
				{
					case USB_INT_BUSEVENTI:
						return ((USB.INTCTRLA & USB_BUSEVIE_bm) ? true : false);
					case USB_INT_SOFI:
						return ((USB.INTCTRLA & USB_SOFIE_bm) ? true : false);
    c5e4:	80 91 c8 04 	lds	r24, 0x04C8
    c5e8:	87 ff       	sbrs	r24, 7
    c5ea:	04 c0       	rjmp	.+8      	; 0xc5f4 <__vector_125+0x4c>
						break;
					case USB_INT_BUSEVENTI_Reset:
						USB.INTFLAGSACLR = USB_RSTIF_bm;
						break;
					case USB_INT_SOFI:
						USB.INTFLAGSACLR = USB_SOFIF_bm;
    c5ec:	80 e8       	ldi	r24, 0x80	; 128
    c5ee:	80 93 ca 04 	sts	0x04CA, r24
	{
		USB_INT_Clear(USB_INT_SOFI);

		EVENT_USB_Device_StartOfFrame();
    c5f2:	f8 db       	rcall	.-2064   	; 0xbde4 <USB_Event_Stub>
			static inline bool USB_INT_HasOccurred(const uint8_t Interrupt)
			{
				switch (Interrupt)
				{
					case USB_INT_BUSEVENTI_Suspend:
						return ((USB.INTFLAGSACLR & USB_SUSPENDIF_bm) ? true : false);
    c5f4:	80 91 ca 04 	lds	r24, 0x04CA
	}
	#endif

	if (USB_INT_HasOccurred(USB_INT_BUSEVENTI_Suspend))
    c5f8:	86 ff       	sbrs	r24, 6
    c5fa:	07 c0       	rjmp	.+14     	; 0xc60a <__vector_125+0x62>
			static inline void USB_INT_Clear(const uint8_t Interrupt)
			{
				switch (Interrupt)
				{
					case USB_INT_BUSEVENTI_Suspend:
						USB.INTFLAGSACLR = USB_SUSPENDIF_bm;
    c5fc:	80 e4       	ldi	r24, 0x40	; 64
    c5fe:	80 93 ca 04 	sts	0x04CA, r24
	{
		USB_INT_Clear(USB_INT_BUSEVENTI_Suspend);

		#if !defined(NO_LIMITED_CONTROLLER_CONNECT)
		USB_DeviceState = DEVICE_STATE_Unattached;
    c602:	10 92 d7 33 	sts	0x33D7, r1
		EVENT_USB_Device_Disconnect();
    c606:	0e 94 43 1a 	call	0x3486	; 0x3486 <EVENT_USB_Device_Disconnect>
				switch (Interrupt)
				{
					case USB_INT_BUSEVENTI_Suspend:
						return ((USB.INTFLAGSACLR & USB_SUSPENDIF_bm) ? true : false);
					case USB_INT_BUSEVENTI_Resume:
						return ((USB.INTFLAGSACLR & USB_RESUMEIF_bm) ? true : false);
    c60a:	80 91 ca 04 	lds	r24, 0x04CA
		USB_DeviceState = DEVICE_STATE_Suspended;
		EVENT_USB_Device_Suspend();
		#endif
	}

	if (USB_INT_HasOccurred(USB_INT_BUSEVENTI_Resume))
    c60e:	85 ff       	sbrs	r24, 5
    c610:	14 c0       	rjmp	.+40     	; 0xc63a <__vector_125+0x92>
				{
					case USB_INT_BUSEVENTI_Suspend:
						USB.INTFLAGSACLR = USB_SUSPENDIF_bm;
						break;
					case USB_INT_BUSEVENTI_Resume:
						USB.INTFLAGSACLR = USB_RESUMEIF_bm;
    c612:	80 e2       	ldi	r24, 0x20	; 32
    c614:	80 93 ca 04 	sts	0x04CA, r24
	{
		USB_INT_Clear(USB_INT_BUSEVENTI_Resume);

		if (USB_Device_ConfigurationNumber)
    c618:	80 91 d3 33 	lds	r24, 0x33D3
    c61c:	88 23       	and	r24, r24
    c61e:	11 f0       	breq	.+4      	; 0xc624 <__vector_125+0x7c>
		  USB_DeviceState = DEVICE_STATE_Configured;
    c620:	84 e0       	ldi	r24, 0x04	; 4
    c622:	07 c0       	rjmp	.+14     	; 0xc632 <__vector_125+0x8a>
			}

			static inline bool USB_Device_IsAddressSet(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline bool USB_Device_IsAddressSet(void)
			{
				return ((USB.ADDR != 0) ? true : false);
    c624:	80 91 c3 04 	lds	r24, 0x04C3
		else
		  USB_DeviceState = (USB_Device_IsAddressSet()) ? DEVICE_STATE_Addressed : DEVICE_STATE_Powered;
    c628:	81 11       	cpse	r24, r1
    c62a:	02 c0       	rjmp	.+4      	; 0xc630 <__vector_125+0x88>
    c62c:	81 e0       	ldi	r24, 0x01	; 1
    c62e:	01 c0       	rjmp	.+2      	; 0xc632 <__vector_125+0x8a>
    c630:	83 e0       	ldi	r24, 0x03	; 3
    c632:	80 93 d7 33 	sts	0x33D7, r24

		#if !defined(NO_LIMITED_CONTROLLER_CONNECT)
		EVENT_USB_Device_Connect();
    c636:	0e 94 32 1a 	call	0x3464	; 0x3464 <EVENT_USB_Device_Connect>
					case USB_INT_BUSEVENTI_Suspend:
						return ((USB.INTFLAGSACLR & USB_SUSPENDIF_bm) ? true : false);
					case USB_INT_BUSEVENTI_Resume:
						return ((USB.INTFLAGSACLR & USB_RESUMEIF_bm) ? true : false);
					case USB_INT_BUSEVENTI_Reset:
						return ((USB.INTFLAGSACLR & USB_RSTIF_bm) ? true : false);
    c63a:	80 91 ca 04 	lds	r24, 0x04CA
		#else
		EVENT_USB_Device_WakeUp();
		#endif
	}

	if (USB_INT_HasOccurred(USB_INT_BUSEVENTI_Reset))
    c63e:	84 ff       	sbrs	r24, 4
    c640:	14 c0       	rjmp	.+40     	; 0xc66a <__vector_125+0xc2>
						break;
					case USB_INT_BUSEVENTI_Resume:
						USB.INTFLAGSACLR = USB_RESUMEIF_bm;
						break;
					case USB_INT_BUSEVENTI_Reset:
						USB.INTFLAGSACLR = USB_RSTIF_bm;
    c642:	80 e1       	ldi	r24, 0x10	; 16
    c644:	80 93 ca 04 	sts	0x04CA, r24
	{
		USB_INT_Clear(USB_INT_BUSEVENTI_Reset);

		USB_DeviceState                = DEVICE_STATE_Default;
    c648:	82 e0       	ldi	r24, 0x02	; 2
    c64a:	80 93 d7 33 	sts	0x33D7, r24
		USB_Device_ConfigurationNumber = 0;
    c64e:	10 92 d3 33 	sts	0x33D3, r1
			}

			static inline void USB_Device_EnableDeviceAddress(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void USB_Device_EnableDeviceAddress(const uint8_t Address)
			{
				USB.ADDR = Address;
    c652:	10 92 c3 04 	sts	0x04C3, r1

		USB_Device_EnableDeviceAddress(0);

		Endpoint_ClearEndpoints();
    c656:	c3 de       	rcall	.-634    	; 0xc3de <Endpoint_ClearEndpoints>
						EPConfigMask |= USB_EP_TYPE_BULK_gc;
						break;
				}

				if (Type == EP_TYPE_CONTROL)
				  Endpoint_ConfigureEndpoint_PRV(Address ^ ENDPOINT_DIR_IN, EPConfigMask, Size);
    c658:	48 e0       	ldi	r20, 0x08	; 8
    c65a:	68 e4       	ldi	r22, 0x48	; 72
    c65c:	80 e8       	ldi	r24, 0x80	; 128
    c65e:	1f de       	rcall	.-962    	; 0xc29e <Endpoint_ConfigureEndpoint_PRV>

				return Endpoint_ConfigureEndpoint_PRV(Address, EPConfigMask, Size);
    c660:	48 e0       	ldi	r20, 0x08	; 8
    c662:	68 e4       	ldi	r22, 0x48	; 72
    c664:	80 e0       	ldi	r24, 0x00	; 0
    c666:	1b de       	rcall	.-970    	; 0xc29e <Endpoint_ConfigureEndpoint_PRV>
		Endpoint_ConfigureEndpoint(ENDPOINT_CONTROLEP, EP_TYPE_CONTROL,
		                           USB_Device_ControlEndpointSize, 1);

		EVENT_USB_Device_Reset();
    c668:	bd db       	rcall	.-2182   	; 0xbde4 <USB_Event_Stub>
	}
}
    c66a:	ff 91       	pop	r31
    c66c:	ef 91       	pop	r30
    c66e:	bf 91       	pop	r27
    c670:	af 91       	pop	r26
    c672:	9f 91       	pop	r25
    c674:	8f 91       	pop	r24
    c676:	7f 91       	pop	r23
    c678:	6f 91       	pop	r22
    c67a:	5f 91       	pop	r21
    c67c:	4f 91       	pop	r20
    c67e:	3f 91       	pop	r19
    c680:	2f 91       	pop	r18
    c682:	0f 90       	pop	r0
    c684:	0b be       	out	0x3b, r0	; 59
    c686:	0f 90       	pop	r0
    c688:	09 be       	out	0x39, r0	; 57
    c68a:	0f 90       	pop	r0
    c68c:	08 be       	out	0x38, r0	; 56
    c68e:	0f 90       	pop	r0
    c690:	0f be       	out	0x3f, r0	; 63
    c692:	0f 90       	pop	r0
    c694:	1f 90       	pop	r1
    c696:	18 95       	reti

0000c698 <CDC_Device_ConfigureEndpoints>:

void CDC_Device_CreateBlockingStream(USB_ClassInfo_CDC_Device_t* const CDCInterfaceInfo,
                                     FILE* const Stream)
{
	*Stream = (FILE)FDEV_SETUP_STREAM(CDC_Device_putchar, CDC_Device_getchar_Blocking, _FDEV_SETUP_RW);
	fdev_set_udata(Stream, CDCInterfaceInfo);
    c698:	cf 93       	push	r28
    c69a:	df 93       	push	r29
    c69c:	ec 01       	movw	r28, r24
    c69e:	fc 01       	movw	r30, r24
    c6a0:	70 96       	adiw	r30, 0x10	; 16
    c6a2:	8b e0       	ldi	r24, 0x0B	; 11
    c6a4:	df 01       	movw	r26, r30
    c6a6:	1d 92       	st	X+, r1
    c6a8:	8a 95       	dec	r24
    c6aa:	e9 f7       	brne	.-6      	; 0xc6a6 <CDC_Device_ConfigureEndpoints+0xe>
    c6ac:	82 e0       	ldi	r24, 0x02	; 2
    c6ae:	8c 83       	std	Y+4, r24	; 0x04
    c6b0:	89 87       	std	Y+9, r24	; 0x09
    c6b2:	83 e0       	ldi	r24, 0x03	; 3
    c6b4:	8e 87       	std	Y+14, r24	; 0x0e
    c6b6:	61 e0       	ldi	r22, 0x01	; 1
    c6b8:	ce 01       	movw	r24, r28
    c6ba:	01 96       	adiw	r24, 0x01	; 1
    c6bc:	2d de       	rcall	.-934    	; 0xc318 <Endpoint_ConfigureEndpointTable>
    c6be:	88 23       	and	r24, r24
    c6c0:	61 f0       	breq	.+24     	; 0xc6da <CDC_Device_ConfigureEndpoints+0x42>
    c6c2:	61 e0       	ldi	r22, 0x01	; 1
    c6c4:	ce 01       	movw	r24, r28
    c6c6:	06 96       	adiw	r24, 0x06	; 6
    c6c8:	27 de       	rcall	.-946    	; 0xc318 <Endpoint_ConfigureEndpointTable>
    c6ca:	88 23       	and	r24, r24
    c6cc:	31 f0       	breq	.+12     	; 0xc6da <CDC_Device_ConfigureEndpoints+0x42>
    c6ce:	61 e0       	ldi	r22, 0x01	; 1
    c6d0:	ce 01       	movw	r24, r28
    c6d2:	0b 96       	adiw	r24, 0x0b	; 11
    c6d4:	df 91       	pop	r29
    c6d6:	cf 91       	pop	r28
    c6d8:	1f ce       	rjmp	.-962    	; 0xc318 <Endpoint_ConfigureEndpointTable>
    c6da:	80 e0       	ldi	r24, 0x00	; 0
    c6dc:	df 91       	pop	r29
    c6de:	cf 91       	pop	r28
    c6e0:	08 95       	ret

0000c6e2 <CDC_Device_SendString>:
    c6e2:	0f 93       	push	r16
    c6e4:	1f 93       	push	r17
    c6e6:	cf 93       	push	r28
    c6e8:	df 93       	push	r29
    c6ea:	20 91 d7 33 	lds	r18, 0x33D7
    c6ee:	24 30       	cpi	r18, 0x04	; 4
    c6f0:	e1 f4       	brne	.+56     	; 0xc72a <CDC_Device_SendString+0x48>
    c6f2:	fc 01       	movw	r30, r24
    c6f4:	04 89       	ldd	r16, Z+20	; 0x14
    c6f6:	15 89       	ldd	r17, Z+21	; 0x15
    c6f8:	26 89       	ldd	r18, Z+22	; 0x16
    c6fa:	37 89       	ldd	r19, Z+23	; 0x17
    c6fc:	01 2b       	or	r16, r17
    c6fe:	02 2b       	or	r16, r18
    c700:	03 2b       	or	r16, r19
    c702:	99 f0       	breq	.+38     	; 0xc72a <CDC_Device_SendString+0x48>
    c704:	eb 01       	movw	r28, r22
    c706:	81 81       	ldd	r24, Z+1	; 0x01
    c708:	0e dd       	rcall	.-1508   	; 0xc126 <Endpoint_SelectEndpoint>
    c70a:	fe 01       	movw	r30, r28
    c70c:	01 90       	ld	r0, Z+
    c70e:	00 20       	and	r0, r0
    c710:	e9 f7       	brne	.-6      	; 0xc70c <CDC_Device_SendString+0x2a>
    c712:	31 97       	sbiw	r30, 0x01	; 1
    c714:	bf 01       	movw	r22, r30
    c716:	6c 1b       	sub	r22, r28
    c718:	7d 0b       	sbc	r23, r29
    c71a:	40 e0       	ldi	r20, 0x00	; 0
    c71c:	50 e0       	ldi	r21, 0x00	; 0
    c71e:	ce 01       	movw	r24, r28
    c720:	df 91       	pop	r29
    c722:	cf 91       	pop	r28
    c724:	1f 91       	pop	r17
    c726:	0f 91       	pop	r16
    c728:	6f cb       	rjmp	.-2338   	; 0xbe08 <Endpoint_Write_Stream_LE>
    c72a:	82 e0       	ldi	r24, 0x02	; 2
    c72c:	df 91       	pop	r29
    c72e:	cf 91       	pop	r28
    c730:	1f 91       	pop	r17
    c732:	0f 91       	pop	r16
    c734:	08 95       	ret

0000c736 <CDC_Device_SendData>:
    c736:	0f 93       	push	r16
    c738:	1f 93       	push	r17
    c73a:	cf 93       	push	r28
    c73c:	df 93       	push	r29
    c73e:	fc 01       	movw	r30, r24
    c740:	80 91 d7 33 	lds	r24, 0x33D7
    c744:	84 30       	cpi	r24, 0x04	; 4
    c746:	a9 f4       	brne	.+42     	; 0xc772 <CDC_Device_SendData+0x3c>
    c748:	84 89       	ldd	r24, Z+20	; 0x14
    c74a:	95 89       	ldd	r25, Z+21	; 0x15
    c74c:	a6 89       	ldd	r26, Z+22	; 0x16
    c74e:	b7 89       	ldd	r27, Z+23	; 0x17
    c750:	89 2b       	or	r24, r25
    c752:	8a 2b       	or	r24, r26
    c754:	8b 2b       	or	r24, r27
    c756:	69 f0       	breq	.+26     	; 0xc772 <CDC_Device_SendData+0x3c>
    c758:	8a 01       	movw	r16, r20
    c75a:	eb 01       	movw	r28, r22
    c75c:	81 81       	ldd	r24, Z+1	; 0x01
    c75e:	e3 dc       	rcall	.-1594   	; 0xc126 <Endpoint_SelectEndpoint>
    c760:	40 e0       	ldi	r20, 0x00	; 0
    c762:	50 e0       	ldi	r21, 0x00	; 0
    c764:	b8 01       	movw	r22, r16
    c766:	ce 01       	movw	r24, r28
    c768:	df 91       	pop	r29
    c76a:	cf 91       	pop	r28
    c76c:	1f 91       	pop	r17
    c76e:	0f 91       	pop	r16
    c770:	4b cb       	rjmp	.-2410   	; 0xbe08 <Endpoint_Write_Stream_LE>
    c772:	82 e0       	ldi	r24, 0x02	; 2
    c774:	df 91       	pop	r29
    c776:	cf 91       	pop	r28
    c778:	1f 91       	pop	r17
    c77a:	0f 91       	pop	r16
    c77c:	08 95       	ret

0000c77e <CDC_Device_SendByte>:
    c77e:	cf 93       	push	r28
    c780:	fc 01       	movw	r30, r24
    c782:	80 91 d7 33 	lds	r24, 0x33D7
    c786:	84 30       	cpi	r24, 0x04	; 4
    c788:	01 f5       	brne	.+64     	; 0xc7ca <CDC_Device_SendByte+0x4c>
    c78a:	84 89       	ldd	r24, Z+20	; 0x14
    c78c:	95 89       	ldd	r25, Z+21	; 0x15
    c78e:	a6 89       	ldd	r26, Z+22	; 0x16
    c790:	b7 89       	ldd	r27, Z+23	; 0x17
    c792:	89 2b       	or	r24, r25
    c794:	8a 2b       	or	r24, r26
    c796:	8b 2b       	or	r24, r27
    c798:	c1 f0       	breq	.+48     	; 0xc7ca <CDC_Device_SendByte+0x4c>
    c79a:	c6 2f       	mov	r28, r22
    c79c:	81 81       	ldd	r24, Z+1	; 0x01
    c79e:	c3 dc       	rcall	.-1658   	; 0xc126 <Endpoint_SelectEndpoint>
    c7a0:	20 91 e0 33 	lds	r18, 0x33E0
    c7a4:	30 91 e1 33 	lds	r19, 0x33E1
    c7a8:	f9 01       	movw	r30, r18
    c7aa:	ef 5b       	subi	r30, 0xBF	; 191
    c7ac:	ff 4f       	sbci	r31, 0xFF	; 255
    c7ae:	90 81       	ld	r25, Z
    c7b0:	31 97       	sbiw	r30, 0x01	; 1
    c7b2:	80 81       	ld	r24, Z
    c7b4:	98 17       	cp	r25, r24
    c7b6:	20 f4       	brcc	.+8      	; 0xc7c0 <CDC_Device_SendByte+0x42>
    c7b8:	8c 2f       	mov	r24, r28
    c7ba:	a5 dc       	rcall	.-1718   	; 0xc106 <Endpoint_Write_8>
    c7bc:	80 e0       	ldi	r24, 0x00	; 0
    c7be:	06 c0       	rjmp	.+12     	; 0xc7cc <CDC_Device_SendByte+0x4e>
    c7c0:	6a dc       	rcall	.-1836   	; 0xc096 <Endpoint_ClearIN>
    c7c2:	3f de       	rcall	.-898    	; 0xc442 <Endpoint_WaitUntilReady>
    c7c4:	88 23       	and	r24, r24
    c7c6:	c1 f3       	breq	.-16     	; 0xc7b8 <CDC_Device_SendByte+0x3a>
    c7c8:	01 c0       	rjmp	.+2      	; 0xc7cc <CDC_Device_SendByte+0x4e>
    c7ca:	82 e0       	ldi	r24, 0x02	; 2
    c7cc:	cf 91       	pop	r28
    c7ce:	08 95       	ret

0000c7d0 <CDC_Device_Flush>:
    c7d0:	cf 93       	push	r28
    c7d2:	df 93       	push	r29
    c7d4:	20 91 d7 33 	lds	r18, 0x33D7
    c7d8:	24 30       	cpi	r18, 0x04	; 4
    c7da:	91 f5       	brne	.+100    	; 0xc840 <CDC_Device_Flush+0x70>
    c7dc:	fc 01       	movw	r30, r24
    c7de:	44 89       	ldd	r20, Z+20	; 0x14
    c7e0:	55 89       	ldd	r21, Z+21	; 0x15
    c7e2:	66 89       	ldd	r22, Z+22	; 0x16
    c7e4:	77 89       	ldd	r23, Z+23	; 0x17
    c7e6:	45 2b       	or	r20, r21
    c7e8:	46 2b       	or	r20, r22
    c7ea:	47 2b       	or	r20, r23
    c7ec:	49 f1       	breq	.+82     	; 0xc840 <CDC_Device_Flush+0x70>
    c7ee:	81 81       	ldd	r24, Z+1	; 0x01
    c7f0:	9a dc       	rcall	.-1740   	; 0xc126 <Endpoint_SelectEndpoint>
    c7f2:	80 91 e4 33 	lds	r24, 0x33E4
    c7f6:	20 91 e0 33 	lds	r18, 0x33E0
    c7fa:	30 91 e1 33 	lds	r19, 0x33E1
    c7fe:	f9 01       	movw	r30, r18
    c800:	87 ff       	sbrs	r24, 7
    c802:	05 c0       	rjmp	.+10     	; 0xc80e <CDC_Device_Flush+0x3e>
    c804:	ef 5b       	subi	r30, 0xBF	; 191
    c806:	ff 4f       	sbci	r31, 0xFF	; 255
    c808:	80 81       	ld	r24, Z
    c80a:	90 e0       	ldi	r25, 0x00	; 0
    c80c:	08 c0       	rjmp	.+16     	; 0xc81e <CDC_Device_Flush+0x4e>
    c80e:	e0 5c       	subi	r30, 0xC0	; 192
    c810:	ff 4f       	sbci	r31, 0xFF	; 255
    c812:	80 81       	ld	r24, Z
    c814:	31 96       	adiw	r30, 0x01	; 1
    c816:	40 81       	ld	r20, Z
    c818:	90 e0       	ldi	r25, 0x00	; 0
    c81a:	84 1b       	sub	r24, r20
    c81c:	91 09       	sbc	r25, r1
    c81e:	89 2b       	or	r24, r25
    c820:	69 f0       	breq	.+26     	; 0xc83c <CDC_Device_Flush+0x6c>
    c822:	f9 01       	movw	r30, r18
    c824:	ef 5b       	subi	r30, 0xBF	; 191
    c826:	ff 4f       	sbci	r31, 0xFF	; 255
    c828:	d0 81       	ld	r29, Z
    c82a:	31 97       	sbiw	r30, 0x01	; 1
    c82c:	c0 81       	ld	r28, Z
    c82e:	33 dc       	rcall	.-1946   	; 0xc096 <Endpoint_ClearIN>
    c830:	dc 17       	cp	r29, r28
    c832:	20 f0       	brcs	.+8      	; 0xc83c <CDC_Device_Flush+0x6c>
    c834:	06 de       	rcall	.-1012   	; 0xc442 <Endpoint_WaitUntilReady>
    c836:	81 11       	cpse	r24, r1
    c838:	04 c0       	rjmp	.+8      	; 0xc842 <CDC_Device_Flush+0x72>
    c83a:	2d dc       	rcall	.-1958   	; 0xc096 <Endpoint_ClearIN>
    c83c:	80 e0       	ldi	r24, 0x00	; 0
    c83e:	01 c0       	rjmp	.+2      	; 0xc842 <CDC_Device_Flush+0x72>
    c840:	82 e0       	ldi	r24, 0x02	; 2
    c842:	df 91       	pop	r29
    c844:	cf 91       	pop	r28
    c846:	08 95       	ret

0000c848 <CDC_Device_USBTask>:
    c848:	cf 93       	push	r28
    c84a:	df 93       	push	r29
    c84c:	20 91 d7 33 	lds	r18, 0x33D7
    c850:	24 30       	cpi	r18, 0x04	; 4
    c852:	99 f4       	brne	.+38     	; 0xc87a <CDC_Device_USBTask+0x32>
    c854:	fc 01       	movw	r30, r24
    c856:	44 89       	ldd	r20, Z+20	; 0x14
    c858:	55 89       	ldd	r21, Z+21	; 0x15
    c85a:	66 89       	ldd	r22, Z+22	; 0x16
    c85c:	77 89       	ldd	r23, Z+23	; 0x17
    c85e:	45 2b       	or	r20, r21
    c860:	46 2b       	or	r20, r22
    c862:	47 2b       	or	r20, r23
    c864:	51 f0       	breq	.+20     	; 0xc87a <CDC_Device_USBTask+0x32>
    c866:	ec 01       	movw	r28, r24
    c868:	81 81       	ldd	r24, Z+1	; 0x01
    c86a:	5d dc       	rcall	.-1862   	; 0xc126 <Endpoint_SelectEndpoint>
    c86c:	91 dc       	rcall	.-1758   	; 0xc190 <Endpoint_IsINReady>
    c86e:	88 23       	and	r24, r24
    c870:	21 f0       	breq	.+8      	; 0xc87a <CDC_Device_USBTask+0x32>
    c872:	ce 01       	movw	r24, r28
    c874:	df 91       	pop	r29
    c876:	cf 91       	pop	r28
    c878:	ab cf       	rjmp	.-170    	; 0xc7d0 <CDC_Device_Flush>
    c87a:	df 91       	pop	r29
    c87c:	cf 91       	pop	r28
    c87e:	08 95       	ret

0000c880 <CDC_Device_ReceiveByte>:
    c880:	cf 93       	push	r28
    c882:	df 93       	push	r29
    c884:	20 91 d7 33 	lds	r18, 0x33D7
    c888:	24 30       	cpi	r18, 0x04	; 4
    c88a:	19 f0       	breq	.+6      	; 0xc892 <CDC_Device_ReceiveByte+0x12>
    c88c:	8f ef       	ldi	r24, 0xFF	; 255
    c88e:	9f ef       	ldi	r25, 0xFF	; 255
    c890:	46 c0       	rjmp	.+140    	; 0xc91e <CDC_Device_ReceiveByte+0x9e>
    c892:	fc 01       	movw	r30, r24
    c894:	44 89       	ldd	r20, Z+20	; 0x14
    c896:	55 89       	ldd	r21, Z+21	; 0x15
    c898:	66 89       	ldd	r22, Z+22	; 0x16
    c89a:	77 89       	ldd	r23, Z+23	; 0x17
    c89c:	45 2b       	or	r20, r21
    c89e:	46 2b       	or	r20, r22
    c8a0:	47 2b       	or	r20, r23
    c8a2:	a1 f3       	breq	.-24     	; 0xc88c <CDC_Device_ReceiveByte+0xc>
    c8a4:	86 81       	ldd	r24, Z+6	; 0x06
    c8a6:	3f dc       	rcall	.-1922   	; 0xc126 <Endpoint_SelectEndpoint>
    c8a8:	7f dc       	rcall	.-1794   	; 0xc1a8 <Endpoint_IsOUTReceived>
    c8aa:	88 23       	and	r24, r24
    c8ac:	79 f3       	breq	.-34     	; 0xc88c <CDC_Device_ReceiveByte+0xc>
    c8ae:	80 91 e4 33 	lds	r24, 0x33E4
    c8b2:	20 91 e0 33 	lds	r18, 0x33E0
    c8b6:	30 91 e1 33 	lds	r19, 0x33E1
    c8ba:	f9 01       	movw	r30, r18
    c8bc:	87 ff       	sbrs	r24, 7
    c8be:	05 c0       	rjmp	.+10     	; 0xc8ca <CDC_Device_ReceiveByte+0x4a>
    c8c0:	ef 5b       	subi	r30, 0xBF	; 191
    c8c2:	ff 4f       	sbci	r31, 0xFF	; 255
    c8c4:	80 81       	ld	r24, Z
    c8c6:	90 e0       	ldi	r25, 0x00	; 0
    c8c8:	08 c0       	rjmp	.+16     	; 0xc8da <CDC_Device_ReceiveByte+0x5a>
    c8ca:	e0 5c       	subi	r30, 0xC0	; 192
    c8cc:	ff 4f       	sbci	r31, 0xFF	; 255
    c8ce:	80 81       	ld	r24, Z
    c8d0:	31 96       	adiw	r30, 0x01	; 1
    c8d2:	20 81       	ld	r18, Z
    c8d4:	90 e0       	ldi	r25, 0x00	; 0
    c8d6:	82 1b       	sub	r24, r18
    c8d8:	91 09       	sbc	r25, r1
    c8da:	89 2b       	or	r24, r25
    c8dc:	21 f0       	breq	.+8      	; 0xc8e6 <CDC_Device_ReceiveByte+0x66>
    c8de:	03 dc       	rcall	.-2042   	; 0xc0e6 <Endpoint_Read_8>
    c8e0:	c8 2f       	mov	r28, r24
    c8e2:	d0 e0       	ldi	r29, 0x00	; 0
    c8e4:	02 c0       	rjmp	.+4      	; 0xc8ea <CDC_Device_ReceiveByte+0x6a>
    c8e6:	cf ef       	ldi	r28, 0xFF	; 255
    c8e8:	df ef       	ldi	r29, 0xFF	; 255
    c8ea:	20 91 e4 33 	lds	r18, 0x33E4
    c8ee:	80 91 e0 33 	lds	r24, 0x33E0
    c8f2:	90 91 e1 33 	lds	r25, 0x33E1
    c8f6:	fc 01       	movw	r30, r24
    c8f8:	27 ff       	sbrs	r18, 7
    c8fa:	05 c0       	rjmp	.+10     	; 0xc906 <CDC_Device_ReceiveByte+0x86>
    c8fc:	ef 5b       	subi	r30, 0xBF	; 191
    c8fe:	ff 4f       	sbci	r31, 0xFF	; 255
    c900:	20 81       	ld	r18, Z
    c902:	30 e0       	ldi	r19, 0x00	; 0
    c904:	08 c0       	rjmp	.+16     	; 0xc916 <CDC_Device_ReceiveByte+0x96>
    c906:	e0 5c       	subi	r30, 0xC0	; 192
    c908:	ff 4f       	sbci	r31, 0xFF	; 255
    c90a:	20 81       	ld	r18, Z
    c90c:	31 96       	adiw	r30, 0x01	; 1
    c90e:	80 81       	ld	r24, Z
    c910:	30 e0       	ldi	r19, 0x00	; 0
    c912:	28 1b       	sub	r18, r24
    c914:	31 09       	sbc	r19, r1
    c916:	23 2b       	or	r18, r19
    c918:	09 f4       	brne	.+2      	; 0xc91c <CDC_Device_ReceiveByte+0x9c>
    c91a:	d6 db       	rcall	.-2132   	; 0xc0c8 <Endpoint_ClearOUT>
    c91c:	ce 01       	movw	r24, r28
    c91e:	df 91       	pop	r29
    c920:	cf 91       	pop	r28
    c922:	08 95       	ret

0000c924 <CDC_Device_Event_Stub>:
	return ReceivedByte;
}
#endif

void CDC_Device_Event_Stub(void)
{
    c924:	08 95       	ret

0000c926 <CDC_Device_ProcessControlRequest>:
#define  __INCLUDE_FROM_CDC_DRIVER
#define  __INCLUDE_FROM_CDC_DEVICE_C
#include "CDCClassDevice.h"

void CDC_Device_ProcessControlRequest(USB_ClassInfo_CDC_Device_t* const CDCInterfaceInfo)
{
    c926:	ff 92       	push	r15
    c928:	0f 93       	push	r16
    c92a:	1f 93       	push	r17
    c92c:	cf 93       	push	r28
    c92e:	df 93       	push	r29
    c930:	ec 01       	movw	r28, r24
	if (!(Endpoint_IsSETUPReceived()))
    c932:	54 dc       	rcall	.-1880   	; 0xc1dc <Endpoint_IsSETUPReceived>
    c934:	88 23       	and	r24, r24
    c936:	09 f4       	brne	.+2      	; 0xc93a <CDC_Device_ProcessControlRequest+0x14>
    c938:	8e c0       	rjmp	.+284    	; 0xca56 <CDC_Device_ProcessControlRequest+0x130>
	  return;

	if (USB_ControlRequest.wIndex != CDCInterfaceInfo->Config.ControlInterfaceNumber)
    c93a:	88 81       	ld	r24, Y
    c93c:	90 e0       	ldi	r25, 0x00	; 0
    c93e:	20 91 dc 33 	lds	r18, 0x33DC
    c942:	30 91 dd 33 	lds	r19, 0x33DD
    c946:	28 17       	cp	r18, r24
    c948:	39 07       	cpc	r19, r25
    c94a:	09 f0       	breq	.+2      	; 0xc94e <CDC_Device_ProcessControlRequest+0x28>
    c94c:	84 c0       	rjmp	.+264    	; 0xca56 <CDC_Device_ProcessControlRequest+0x130>
	  return;

	switch (USB_ControlRequest.bRequest)
    c94e:	80 91 d9 33 	lds	r24, 0x33D9
    c952:	81 32       	cpi	r24, 0x21	; 33
    c954:	59 f0       	breq	.+22     	; 0xc96c <CDC_Device_ProcessControlRequest+0x46>
    c956:	18 f4       	brcc	.+6      	; 0xc95e <CDC_Device_ProcessControlRequest+0x38>
    c958:	80 32       	cpi	r24, 0x20	; 32
    c95a:	49 f1       	breq	.+82     	; 0xc9ae <CDC_Device_ProcessControlRequest+0x88>
    c95c:	7c c0       	rjmp	.+248    	; 0xca56 <CDC_Device_ProcessControlRequest+0x130>
    c95e:	82 32       	cpi	r24, 0x22	; 34
    c960:	09 f4       	brne	.+2      	; 0xc964 <CDC_Device_ProcessControlRequest+0x3e>
    c962:	57 c0       	rjmp	.+174    	; 0xca12 <CDC_Device_ProcessControlRequest+0xec>
    c964:	83 32       	cpi	r24, 0x23	; 35
    c966:	09 f4       	brne	.+2      	; 0xc96a <CDC_Device_ProcessControlRequest+0x44>
    c968:	67 c0       	rjmp	.+206    	; 0xca38 <CDC_Device_ProcessControlRequest+0x112>
    c96a:	75 c0       	rjmp	.+234    	; 0xca56 <CDC_Device_ProcessControlRequest+0x130>
	{
		case CDC_REQ_GetLineEncoding:
			if (USB_ControlRequest.bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE))
    c96c:	80 91 d8 33 	lds	r24, 0x33D8
    c970:	81 3a       	cpi	r24, 0xA1	; 161
    c972:	09 f0       	breq	.+2      	; 0xc976 <CDC_Device_ProcessControlRequest+0x50>
    c974:	70 c0       	rjmp	.+224    	; 0xca56 <CDC_Device_ProcessControlRequest+0x130>
			{
				Endpoint_ClearSETUP();
    c976:	4c dc       	rcall	.-1896   	; 0xc210 <Endpoint_ClearSETUP>

				while (!(Endpoint_IsINReady()));
    c978:	0b dc       	rcall	.-2026   	; 0xc190 <Endpoint_IsINReady>
    c97a:	88 23       	and	r24, r24
    c97c:	e9 f3       	breq	.-6      	; 0xc978 <CDC_Device_ProcessControlRequest+0x52>

				Endpoint_Write_32_LE(CDCInterfaceInfo->State.LineEncoding.BaudRateBPS);
    c97e:	8c 89       	ldd	r24, Y+20	; 0x14
    c980:	fd 88       	ldd	r15, Y+21	; 0x15
    c982:	0e 89       	ldd	r16, Y+22	; 0x16
    c984:	1f 89       	ldd	r17, Y+23	; 0x17
			 *  \param[in] Data  Data to write to the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_32_LE(const uint32_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_32_LE(const uint32_t Data)
			{
				Endpoint_Write_8(Data & 0xFF);
    c986:	bf db       	rcall	.-2178   	; 0xc106 <Endpoint_Write_8>
				Endpoint_Write_8(Data >> 8);
    c988:	8f 2d       	mov	r24, r15
    c98a:	bd db       	rcall	.-2182   	; 0xc106 <Endpoint_Write_8>
				Endpoint_Write_8(Data >> 16);
    c98c:	80 2f       	mov	r24, r16
    c98e:	bb db       	rcall	.-2186   	; 0xc106 <Endpoint_Write_8>
				Endpoint_Write_8(Data >> 24);
    c990:	81 2f       	mov	r24, r17
    c992:	b9 db       	rcall	.-2190   	; 0xc106 <Endpoint_Write_8>
				Endpoint_Write_8(CDCInterfaceInfo->State.LineEncoding.CharFormat);
    c994:	88 8d       	ldd	r24, Y+24	; 0x18
    c996:	b7 db       	rcall	.-2194   	; 0xc106 <Endpoint_Write_8>
				Endpoint_Write_8(CDCInterfaceInfo->State.LineEncoding.ParityType);
    c998:	89 8d       	ldd	r24, Y+25	; 0x19
    c99a:	b5 db       	rcall	.-2198   	; 0xc106 <Endpoint_Write_8>
				Endpoint_Write_8(CDCInterfaceInfo->State.LineEncoding.DataBits);
    c99c:	8a 8d       	ldd	r24, Y+26	; 0x1a
    c99e:	b3 db       	rcall	.-2202   	; 0xc106 <Endpoint_Write_8>

				Endpoint_ClearIN();
    c9a0:	7a db       	rcall	.-2316   	; 0xc096 <Endpoint_ClearIN>
				EVENT_CDC_Device_BreakSent(CDCInterfaceInfo, (uint8_t)USB_ControlRequest.wValue);
			}

			break;
	}
}
    c9a2:	df 91       	pop	r29
    c9a4:	cf 91       	pop	r28
    c9a6:	1f 91       	pop	r17
    c9a8:	0f 91       	pop	r16
    c9aa:	ff 90       	pop	r15
				Endpoint_Write_8(CDCInterfaceInfo->State.LineEncoding.CharFormat);
				Endpoint_Write_8(CDCInterfaceInfo->State.LineEncoding.ParityType);
				Endpoint_Write_8(CDCInterfaceInfo->State.LineEncoding.DataBits);

				Endpoint_ClearIN();
				Endpoint_ClearStatusStage();
    c9ac:	34 cd       	rjmp	.-1432   	; 0xc416 <Endpoint_ClearStatusStage>
			}

			break;
		case CDC_REQ_SetLineEncoding:
			if (USB_ControlRequest.bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE))
    c9ae:	80 91 d8 33 	lds	r24, 0x33D8
    c9b2:	81 32       	cpi	r24, 0x21	; 33
    c9b4:	09 f0       	breq	.+2      	; 0xc9b8 <CDC_Device_ProcessControlRequest+0x92>
    c9b6:	4f c0       	rjmp	.+158    	; 0xca56 <CDC_Device_ProcessControlRequest+0x130>
			{
				Endpoint_ClearSETUP();
    c9b8:	2b dc       	rcall	.-1962   	; 0xc210 <Endpoint_ClearSETUP>

				while (!(Endpoint_IsOUTReceived()))
    c9ba:	f6 db       	rcall	.-2068   	; 0xc1a8 <Endpoint_IsOUTReceived>
    c9bc:	81 11       	cpse	r24, r1
    c9be:	05 c0       	rjmp	.+10     	; 0xc9ca <CDC_Device_ProcessControlRequest+0xa4>
				{
					if (USB_DeviceState == DEVICE_STATE_Unattached)
    c9c0:	80 91 d7 33 	lds	r24, 0x33D7
    c9c4:	81 11       	cpse	r24, r1
    c9c6:	f9 cf       	rjmp	.-14     	; 0xc9ba <CDC_Device_ProcessControlRequest+0x94>
    c9c8:	46 c0       	rjmp	.+140    	; 0xca56 <CDC_Device_ProcessControlRequest+0x130>
			 *  \return Next four bytes in the currently selected endpoint's FIFO buffer.
			 */
			static inline uint32_t Endpoint_Read_32_LE(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint32_t Endpoint_Read_32_LE(void)
			{
				uint32_t Byte0 = Endpoint_Read_8();
    c9ca:	8d db       	rcall	.-2278   	; 0xc0e6 <Endpoint_Read_8>
    c9cc:	08 2f       	mov	r16, r24
				uint32_t Byte1 = Endpoint_Read_8();
    c9ce:	8b db       	rcall	.-2282   	; 0xc0e6 <Endpoint_Read_8>
    c9d0:	18 2f       	mov	r17, r24
				uint32_t Byte2 = Endpoint_Read_8();
    c9d2:	89 db       	rcall	.-2286   	; 0xc0e6 <Endpoint_Read_8>
    c9d4:	f8 2e       	mov	r15, r24
				uint32_t Byte3 = Endpoint_Read_8();
    c9d6:	87 db       	rcall	.-2290   	; 0xc0e6 <Endpoint_Read_8>
			static inline uint32_t Endpoint_Read_32_LE(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint32_t Endpoint_Read_32_LE(void)
			{
				uint32_t Byte0 = Endpoint_Read_8();
				uint32_t Byte1 = Endpoint_Read_8();
				uint32_t Byte2 = Endpoint_Read_8();
    c9d8:	4f 2d       	mov	r20, r15
    c9da:	50 e0       	ldi	r21, 0x00	; 0
    c9dc:	60 e0       	ldi	r22, 0x00	; 0
    c9de:	70 e0       	ldi	r23, 0x00	; 0
				uint32_t Byte3 = Endpoint_Read_8();

				return ((Byte3 << 24) | (Byte2 << 16) | (Byte1 << 8) | Byte0);
    c9e0:	ba 01       	movw	r22, r20
    c9e2:	55 27       	eor	r21, r21
    c9e4:	44 27       	eor	r20, r20
    c9e6:	78 2b       	or	r23, r24
    c9e8:	40 2b       	or	r20, r16
    c9ea:	51 2b       	or	r21, r17
					  return;
				}

				CDCInterfaceInfo->State.LineEncoding.BaudRateBPS = Endpoint_Read_32_LE();
    c9ec:	4c 8b       	std	Y+20, r20	; 0x14
    c9ee:	5d 8b       	std	Y+21, r21	; 0x15
    c9f0:	6e 8b       	std	Y+22, r22	; 0x16
    c9f2:	7f 8b       	std	Y+23, r23	; 0x17
				CDCInterfaceInfo->State.LineEncoding.CharFormat  = Endpoint_Read_8();
    c9f4:	78 db       	rcall	.-2320   	; 0xc0e6 <Endpoint_Read_8>
    c9f6:	88 8f       	std	Y+24, r24	; 0x18
				CDCInterfaceInfo->State.LineEncoding.ParityType  = Endpoint_Read_8();
    c9f8:	76 db       	rcall	.-2324   	; 0xc0e6 <Endpoint_Read_8>
    c9fa:	89 8f       	std	Y+25, r24	; 0x19
				CDCInterfaceInfo->State.LineEncoding.DataBits    = Endpoint_Read_8();
    c9fc:	74 db       	rcall	.-2328   	; 0xc0e6 <Endpoint_Read_8>
    c9fe:	8a 8f       	std	Y+26, r24	; 0x1a

				Endpoint_ClearOUT();
    ca00:	63 db       	rcall	.-2362   	; 0xc0c8 <Endpoint_ClearOUT>
				Endpoint_ClearStatusStage();
    ca02:	09 dd       	rcall	.-1518   	; 0xc416 <Endpoint_ClearStatusStage>

				EVENT_CDC_Device_LineEncodingChanged(CDCInterfaceInfo);
    ca04:	ce 01       	movw	r24, r28
				EVENT_CDC_Device_BreakSent(CDCInterfaceInfo, (uint8_t)USB_ControlRequest.wValue);
			}

			break;
	}
}
    ca06:	df 91       	pop	r29
    ca08:	cf 91       	pop	r28
    ca0a:	1f 91       	pop	r17
    ca0c:	0f 91       	pop	r16
    ca0e:	ff 90       	pop	r15
				CDCInterfaceInfo->State.LineEncoding.DataBits    = Endpoint_Read_8();

				Endpoint_ClearOUT();
				Endpoint_ClearStatusStage();

				EVENT_CDC_Device_LineEncodingChanged(CDCInterfaceInfo);
    ca10:	89 cf       	rjmp	.-238    	; 0xc924 <CDC_Device_Event_Stub>
			}

			break;
		case CDC_REQ_SetControlLineState:
			if (USB_ControlRequest.bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE))
    ca12:	80 91 d8 33 	lds	r24, 0x33D8
    ca16:	81 32       	cpi	r24, 0x21	; 33
    ca18:	f1 f4       	brne	.+60     	; 0xca56 <CDC_Device_ProcessControlRequest+0x130>
			{
				Endpoint_ClearSETUP();
    ca1a:	fa db       	rcall	.-2060   	; 0xc210 <Endpoint_ClearSETUP>
				Endpoint_ClearStatusStage();
    ca1c:	fc dc       	rcall	.-1544   	; 0xc416 <Endpoint_ClearStatusStage>

				CDCInterfaceInfo->State.ControlLineStates.HostToDevice = USB_ControlRequest.wValue;
    ca1e:	80 91 da 33 	lds	r24, 0x33DA
    ca22:	90 91 db 33 	lds	r25, 0x33DB
    ca26:	88 8b       	std	Y+16, r24	; 0x10
    ca28:	99 8b       	std	Y+17, r25	; 0x11

				EVENT_CDC_Device_ControLineStateChanged(CDCInterfaceInfo);
    ca2a:	ce 01       	movw	r24, r28
				EVENT_CDC_Device_BreakSent(CDCInterfaceInfo, (uint8_t)USB_ControlRequest.wValue);
			}

			break;
	}
}
    ca2c:	df 91       	pop	r29
    ca2e:	cf 91       	pop	r28
    ca30:	1f 91       	pop	r17
    ca32:	0f 91       	pop	r16
    ca34:	ff 90       	pop	r15
				Endpoint_ClearSETUP();
				Endpoint_ClearStatusStage();

				CDCInterfaceInfo->State.ControlLineStates.HostToDevice = USB_ControlRequest.wValue;

				EVENT_CDC_Device_ControLineStateChanged(CDCInterfaceInfo);
    ca36:	76 cf       	rjmp	.-276    	; 0xc924 <CDC_Device_Event_Stub>
			}

			break;
		case CDC_REQ_SendBreak:
			if (USB_ControlRequest.bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE))
    ca38:	80 91 d8 33 	lds	r24, 0x33D8
    ca3c:	81 32       	cpi	r24, 0x21	; 33
    ca3e:	59 f4       	brne	.+22     	; 0xca56 <CDC_Device_ProcessControlRequest+0x130>
			{
				Endpoint_ClearSETUP();
    ca40:	e7 db       	rcall	.-2098   	; 0xc210 <Endpoint_ClearSETUP>
				Endpoint_ClearStatusStage();
    ca42:	e9 dc       	rcall	.-1582   	; 0xc416 <Endpoint_ClearStatusStage>

				EVENT_CDC_Device_BreakSent(CDCInterfaceInfo, (uint8_t)USB_ControlRequest.wValue);
    ca44:	60 91 da 33 	lds	r22, 0x33DA
    ca48:	ce 01       	movw	r24, r28
			}

			break;
	}
}
    ca4a:	df 91       	pop	r29
    ca4c:	cf 91       	pop	r28
    ca4e:	1f 91       	pop	r17
    ca50:	0f 91       	pop	r16
    ca52:	ff 90       	pop	r15
			if (USB_ControlRequest.bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE))
			{
				Endpoint_ClearSETUP();
				Endpoint_ClearStatusStage();

				EVENT_CDC_Device_BreakSent(CDCInterfaceInfo, (uint8_t)USB_ControlRequest.wValue);
    ca54:	67 cf       	rjmp	.-306    	; 0xc924 <CDC_Device_Event_Stub>
			}

			break;
	}
}
    ca56:	df 91       	pop	r29
    ca58:	cf 91       	pop	r28
    ca5a:	1f 91       	pop	r17
    ca5c:	0f 91       	pop	r16
    ca5e:	ff 90       	pop	r15
    ca60:	08 95       	ret

0000ca62 <__udivmodhi4>:
    ca62:	aa 1b       	sub	r26, r26
    ca64:	bb 1b       	sub	r27, r27
    ca66:	51 e1       	ldi	r21, 0x11	; 17
    ca68:	07 c0       	rjmp	.+14     	; 0xca78 <__udivmodhi4_ep>

0000ca6a <__udivmodhi4_loop>:
    ca6a:	aa 1f       	adc	r26, r26
    ca6c:	bb 1f       	adc	r27, r27
    ca6e:	a6 17       	cp	r26, r22
    ca70:	b7 07       	cpc	r27, r23
    ca72:	10 f0       	brcs	.+4      	; 0xca78 <__udivmodhi4_ep>
    ca74:	a6 1b       	sub	r26, r22
    ca76:	b7 0b       	sbc	r27, r23

0000ca78 <__udivmodhi4_ep>:
    ca78:	88 1f       	adc	r24, r24
    ca7a:	99 1f       	adc	r25, r25
    ca7c:	5a 95       	dec	r21
    ca7e:	a9 f7       	brne	.-22     	; 0xca6a <__udivmodhi4_loop>
    ca80:	80 95       	com	r24
    ca82:	90 95       	com	r25
    ca84:	bc 01       	movw	r22, r24
    ca86:	cd 01       	movw	r24, r26
    ca88:	08 95       	ret

0000ca8a <__mulshisi3>:
    ca8a:	b7 ff       	sbrs	r27, 7
    ca8c:	04 c0       	rjmp	.+8      	; 0xca96 <__muluhisi3>

0000ca8e <__mulohisi3>:
    ca8e:	03 d0       	rcall	.+6      	; 0xca96 <__muluhisi3>
    ca90:	82 1b       	sub	r24, r18
    ca92:	93 0b       	sbc	r25, r19
    ca94:	08 95       	ret

0000ca96 <__muluhisi3>:
    ca96:	09 d0       	rcall	.+18     	; 0xcaaa <__umulhisi3>
    ca98:	a5 9f       	mul	r26, r21
    ca9a:	90 0d       	add	r25, r0
    ca9c:	b4 9f       	mul	r27, r20
    ca9e:	90 0d       	add	r25, r0
    caa0:	a4 9f       	mul	r26, r20
    caa2:	80 0d       	add	r24, r0
    caa4:	91 1d       	adc	r25, r1
    caa6:	11 24       	eor	r1, r1
    caa8:	08 95       	ret

0000caaa <__umulhisi3>:
    caaa:	a2 9f       	mul	r26, r18
    caac:	b0 01       	movw	r22, r0
    caae:	b3 9f       	mul	r27, r19
    cab0:	c0 01       	movw	r24, r0
    cab2:	a3 9f       	mul	r26, r19
    cab4:	70 0d       	add	r23, r0
    cab6:	81 1d       	adc	r24, r1
    cab8:	11 24       	eor	r1, r1
    caba:	91 1d       	adc	r25, r1
    cabc:	b2 9f       	mul	r27, r18
    cabe:	70 0d       	add	r23, r0
    cac0:	81 1d       	adc	r24, r1
    cac2:	11 24       	eor	r1, r1
    cac4:	91 1d       	adc	r25, r1
    cac6:	08 95       	ret

0000cac8 <do_rand>:
    cac8:	8f 92       	push	r8
    caca:	9f 92       	push	r9
    cacc:	af 92       	push	r10
    cace:	bf 92       	push	r11
    cad0:	cf 92       	push	r12
    cad2:	df 92       	push	r13
    cad4:	ef 92       	push	r14
    cad6:	ff 92       	push	r15
    cad8:	cf 93       	push	r28
    cada:	df 93       	push	r29
    cadc:	ec 01       	movw	r28, r24
    cade:	68 81       	ld	r22, Y
    cae0:	79 81       	ldd	r23, Y+1	; 0x01
    cae2:	8a 81       	ldd	r24, Y+2	; 0x02
    cae4:	9b 81       	ldd	r25, Y+3	; 0x03
    cae6:	61 15       	cp	r22, r1
    cae8:	71 05       	cpc	r23, r1
    caea:	81 05       	cpc	r24, r1
    caec:	91 05       	cpc	r25, r1
    caee:	21 f4       	brne	.+8      	; 0xcaf8 <do_rand+0x30>
    caf0:	64 e2       	ldi	r22, 0x24	; 36
    caf2:	79 ed       	ldi	r23, 0xD9	; 217
    caf4:	8b e5       	ldi	r24, 0x5B	; 91
    caf6:	97 e0       	ldi	r25, 0x07	; 7
    caf8:	2d e1       	ldi	r18, 0x1D	; 29
    cafa:	33 ef       	ldi	r19, 0xF3	; 243
    cafc:	41 e0       	ldi	r20, 0x01	; 1
    cafe:	50 e0       	ldi	r21, 0x00	; 0
    cb00:	22 d7       	rcall	.+3652   	; 0xd946 <__divmodsi4>
    cb02:	49 01       	movw	r8, r18
    cb04:	5a 01       	movw	r10, r20
    cb06:	9b 01       	movw	r18, r22
    cb08:	ac 01       	movw	r20, r24
    cb0a:	a7 ea       	ldi	r26, 0xA7	; 167
    cb0c:	b1 e4       	ldi	r27, 0x41	; 65
    cb0e:	c3 df       	rcall	.-122    	; 0xca96 <__muluhisi3>
    cb10:	6b 01       	movw	r12, r22
    cb12:	7c 01       	movw	r14, r24
    cb14:	ac ee       	ldi	r26, 0xEC	; 236
    cb16:	b4 ef       	ldi	r27, 0xF4	; 244
    cb18:	a5 01       	movw	r20, r10
    cb1a:	94 01       	movw	r18, r8
    cb1c:	b8 df       	rcall	.-144    	; 0xca8e <__mulohisi3>
    cb1e:	dc 01       	movw	r26, r24
    cb20:	cb 01       	movw	r24, r22
    cb22:	8c 0d       	add	r24, r12
    cb24:	9d 1d       	adc	r25, r13
    cb26:	ae 1d       	adc	r26, r14
    cb28:	bf 1d       	adc	r27, r15
    cb2a:	b7 ff       	sbrs	r27, 7
    cb2c:	03 c0       	rjmp	.+6      	; 0xcb34 <do_rand+0x6c>
    cb2e:	01 97       	sbiw	r24, 0x01	; 1
    cb30:	a1 09       	sbc	r26, r1
    cb32:	b0 48       	sbci	r27, 0x80	; 128
    cb34:	88 83       	st	Y, r24
    cb36:	99 83       	std	Y+1, r25	; 0x01
    cb38:	aa 83       	std	Y+2, r26	; 0x02
    cb3a:	bb 83       	std	Y+3, r27	; 0x03
    cb3c:	9f 77       	andi	r25, 0x7F	; 127
    cb3e:	df 91       	pop	r29
    cb40:	cf 91       	pop	r28
    cb42:	ff 90       	pop	r15
    cb44:	ef 90       	pop	r14
    cb46:	df 90       	pop	r13
    cb48:	cf 90       	pop	r12
    cb4a:	bf 90       	pop	r11
    cb4c:	af 90       	pop	r10
    cb4e:	9f 90       	pop	r9
    cb50:	8f 90       	pop	r8
    cb52:	08 95       	ret

0000cb54 <rand_r>:
    cb54:	b9 cf       	rjmp	.-142    	; 0xcac8 <do_rand>

0000cb56 <rand>:
    cb56:	8a e2       	ldi	r24, 0x2A	; 42
    cb58:	90 e2       	ldi	r25, 0x20	; 32
    cb5a:	b6 cf       	rjmp	.-148    	; 0xcac8 <do_rand>

0000cb5c <srand>:
    cb5c:	a0 e0       	ldi	r26, 0x00	; 0
    cb5e:	b0 e0       	ldi	r27, 0x00	; 0
    cb60:	80 93 2a 20 	sts	0x202A, r24
    cb64:	90 93 2b 20 	sts	0x202B, r25
    cb68:	a0 93 2c 20 	sts	0x202C, r26
    cb6c:	b0 93 2d 20 	sts	0x202D, r27
    cb70:	08 95       	ret

0000cb72 <memcpy_P>:
    cb72:	fb 01       	movw	r30, r22
    cb74:	dc 01       	movw	r26, r24
    cb76:	02 c0       	rjmp	.+4      	; 0xcb7c <memcpy_P+0xa>
    cb78:	05 90       	lpm	r0, Z+
    cb7a:	0d 92       	st	X+, r0
    cb7c:	41 50       	subi	r20, 0x01	; 1
    cb7e:	50 40       	sbci	r21, 0x00	; 0
    cb80:	d8 f7       	brcc	.-10     	; 0xcb78 <memcpy_P+0x6>
    cb82:	08 95       	ret

0000cb84 <strcmp_P>:
    cb84:	fb 01       	movw	r30, r22
    cb86:	dc 01       	movw	r26, r24
    cb88:	8d 91       	ld	r24, X+
    cb8a:	05 90       	lpm	r0, Z+
    cb8c:	80 19       	sub	r24, r0
    cb8e:	01 10       	cpse	r0, r1
    cb90:	d9 f3       	breq	.-10     	; 0xcb88 <strcmp_P+0x4>
    cb92:	99 0b       	sbc	r25, r25
    cb94:	08 95       	ret

0000cb96 <strncpy_P>:
    cb96:	fb 01       	movw	r30, r22
    cb98:	dc 01       	movw	r26, r24
    cb9a:	41 50       	subi	r20, 0x01	; 1
    cb9c:	50 40       	sbci	r21, 0x00	; 0
    cb9e:	48 f0       	brcs	.+18     	; 0xcbb2 <strncpy_P+0x1c>
    cba0:	05 90       	lpm	r0, Z+
    cba2:	0d 92       	st	X+, r0
    cba4:	00 20       	and	r0, r0
    cba6:	c9 f7       	brne	.-14     	; 0xcb9a <strncpy_P+0x4>
    cba8:	01 c0       	rjmp	.+2      	; 0xcbac <strncpy_P+0x16>
    cbaa:	1d 92       	st	X+, r1
    cbac:	41 50       	subi	r20, 0x01	; 1
    cbae:	50 40       	sbci	r21, 0x00	; 0
    cbb0:	e0 f7       	brcc	.-8      	; 0xcbaa <strncpy_P+0x14>
    cbb2:	08 95       	ret

0000cbb4 <memcmp>:
    cbb4:	fb 01       	movw	r30, r22
    cbb6:	dc 01       	movw	r26, r24
    cbb8:	04 c0       	rjmp	.+8      	; 0xcbc2 <memcmp+0xe>
    cbba:	8d 91       	ld	r24, X+
    cbbc:	01 90       	ld	r0, Z+
    cbbe:	80 19       	sub	r24, r0
    cbc0:	21 f4       	brne	.+8      	; 0xcbca <memcmp+0x16>
    cbc2:	41 50       	subi	r20, 0x01	; 1
    cbc4:	50 40       	sbci	r21, 0x00	; 0
    cbc6:	c8 f7       	brcc	.-14     	; 0xcbba <memcmp+0x6>
    cbc8:	88 1b       	sub	r24, r24
    cbca:	99 0b       	sbc	r25, r25
    cbcc:	08 95       	ret

0000cbce <memcpy>:
    cbce:	fb 01       	movw	r30, r22
    cbd0:	dc 01       	movw	r26, r24
    cbd2:	02 c0       	rjmp	.+4      	; 0xcbd8 <memcpy+0xa>
    cbd4:	01 90       	ld	r0, Z+
    cbd6:	0d 92       	st	X+, r0
    cbd8:	41 50       	subi	r20, 0x01	; 1
    cbda:	50 40       	sbci	r21, 0x00	; 0
    cbdc:	d8 f7       	brcc	.-10     	; 0xcbd4 <memcpy+0x6>
    cbde:	08 95       	ret

0000cbe0 <memmove>:
    cbe0:	68 17       	cp	r22, r24
    cbe2:	79 07       	cpc	r23, r25
    cbe4:	68 f4       	brcc	.+26     	; 0xcc00 <memmove+0x20>
    cbe6:	fb 01       	movw	r30, r22
    cbe8:	dc 01       	movw	r26, r24
    cbea:	e4 0f       	add	r30, r20
    cbec:	f5 1f       	adc	r31, r21
    cbee:	a4 0f       	add	r26, r20
    cbf0:	b5 1f       	adc	r27, r21
    cbf2:	02 c0       	rjmp	.+4      	; 0xcbf8 <memmove+0x18>
    cbf4:	02 90       	ld	r0, -Z
    cbf6:	0e 92       	st	-X, r0
    cbf8:	41 50       	subi	r20, 0x01	; 1
    cbfa:	50 40       	sbci	r21, 0x00	; 0
    cbfc:	d8 f7       	brcc	.-10     	; 0xcbf4 <memmove+0x14>
    cbfe:	08 95       	ret
    cc00:	e6 cf       	rjmp	.-52     	; 0xcbce <memcpy>

0000cc02 <memset>:
    cc02:	dc 01       	movw	r26, r24
    cc04:	01 c0       	rjmp	.+2      	; 0xcc08 <memset+0x6>
    cc06:	6d 93       	st	X+, r22
    cc08:	41 50       	subi	r20, 0x01	; 1
    cc0a:	50 40       	sbci	r21, 0x00	; 0
    cc0c:	e0 f7       	brcc	.-8      	; 0xcc06 <memset+0x4>
    cc0e:	08 95       	ret

0000cc10 <strchr>:
    cc10:	fc 01       	movw	r30, r24
    cc12:	81 91       	ld	r24, Z+
    cc14:	86 17       	cp	r24, r22
    cc16:	21 f0       	breq	.+8      	; 0xcc20 <strchr+0x10>
    cc18:	88 23       	and	r24, r24
    cc1a:	d9 f7       	brne	.-10     	; 0xcc12 <strchr+0x2>
    cc1c:	99 27       	eor	r25, r25
    cc1e:	08 95       	ret
    cc20:	31 97       	sbiw	r30, 0x01	; 1
    cc22:	cf 01       	movw	r24, r30
    cc24:	08 95       	ret

0000cc26 <strcpy>:
    cc26:	fb 01       	movw	r30, r22
    cc28:	dc 01       	movw	r26, r24
    cc2a:	01 90       	ld	r0, Z+
    cc2c:	0d 92       	st	X+, r0
    cc2e:	00 20       	and	r0, r0
    cc30:	e1 f7       	brne	.-8      	; 0xcc2a <strcpy+0x4>
    cc32:	08 95       	ret

0000cc34 <snprintf>:
    cc34:	0f 93       	push	r16
    cc36:	1f 93       	push	r17
    cc38:	cf 93       	push	r28
    cc3a:	df 93       	push	r29
    cc3c:	cd b7       	in	r28, 0x3d	; 61
    cc3e:	de b7       	in	r29, 0x3e	; 62
    cc40:	2e 97       	sbiw	r28, 0x0e	; 14
    cc42:	cd bf       	out	0x3d, r28	; 61
    cc44:	de bf       	out	0x3e, r29	; 62
    cc46:	0e 89       	ldd	r16, Y+22	; 0x16
    cc48:	1f 89       	ldd	r17, Y+23	; 0x17
    cc4a:	88 8d       	ldd	r24, Y+24	; 0x18
    cc4c:	99 8d       	ldd	r25, Y+25	; 0x19
    cc4e:	26 e0       	ldi	r18, 0x06	; 6
    cc50:	2c 83       	std	Y+4, r18	; 0x04
    cc52:	09 83       	std	Y+1, r16	; 0x01
    cc54:	1a 83       	std	Y+2, r17	; 0x02
    cc56:	97 ff       	sbrs	r25, 7
    cc58:	02 c0       	rjmp	.+4      	; 0xcc5e <snprintf+0x2a>
    cc5a:	80 e0       	ldi	r24, 0x00	; 0
    cc5c:	90 e8       	ldi	r25, 0x80	; 128
    cc5e:	01 97       	sbiw	r24, 0x01	; 1
    cc60:	8d 83       	std	Y+5, r24	; 0x05
    cc62:	9e 83       	std	Y+6, r25	; 0x06
    cc64:	ae 01       	movw	r20, r28
    cc66:	44 5e       	subi	r20, 0xE4	; 228
    cc68:	5f 4f       	sbci	r21, 0xFF	; 255
    cc6a:	6a 8d       	ldd	r22, Y+26	; 0x1a
    cc6c:	7b 8d       	ldd	r23, Y+27	; 0x1b
    cc6e:	ce 01       	movw	r24, r28
    cc70:	01 96       	adiw	r24, 0x01	; 1
    cc72:	67 d0       	rcall	.+206    	; 0xcd42 <vfprintf>
    cc74:	4d 81       	ldd	r20, Y+5	; 0x05
    cc76:	5e 81       	ldd	r21, Y+6	; 0x06
    cc78:	57 fd       	sbrc	r21, 7
    cc7a:	0a c0       	rjmp	.+20     	; 0xcc90 <snprintf+0x5c>
    cc7c:	2f 81       	ldd	r18, Y+7	; 0x07
    cc7e:	38 85       	ldd	r19, Y+8	; 0x08
    cc80:	42 17       	cp	r20, r18
    cc82:	53 07       	cpc	r21, r19
    cc84:	0c f4       	brge	.+2      	; 0xcc88 <snprintf+0x54>
    cc86:	9a 01       	movw	r18, r20
    cc88:	f8 01       	movw	r30, r16
    cc8a:	e2 0f       	add	r30, r18
    cc8c:	f3 1f       	adc	r31, r19
    cc8e:	10 82       	st	Z, r1
    cc90:	2e 96       	adiw	r28, 0x0e	; 14
    cc92:	cd bf       	out	0x3d, r28	; 61
    cc94:	de bf       	out	0x3e, r29	; 62
    cc96:	df 91       	pop	r29
    cc98:	cf 91       	pop	r28
    cc9a:	1f 91       	pop	r17
    cc9c:	0f 91       	pop	r16
    cc9e:	08 95       	ret

0000cca0 <snprintf_P>:
    cca0:	0f 93       	push	r16
    cca2:	1f 93       	push	r17
    cca4:	cf 93       	push	r28
    cca6:	df 93       	push	r29
    cca8:	cd b7       	in	r28, 0x3d	; 61
    ccaa:	de b7       	in	r29, 0x3e	; 62
    ccac:	2e 97       	sbiw	r28, 0x0e	; 14
    ccae:	cd bf       	out	0x3d, r28	; 61
    ccb0:	de bf       	out	0x3e, r29	; 62
    ccb2:	0e 89       	ldd	r16, Y+22	; 0x16
    ccb4:	1f 89       	ldd	r17, Y+23	; 0x17
    ccb6:	88 8d       	ldd	r24, Y+24	; 0x18
    ccb8:	99 8d       	ldd	r25, Y+25	; 0x19
    ccba:	2e e0       	ldi	r18, 0x0E	; 14
    ccbc:	2c 83       	std	Y+4, r18	; 0x04
    ccbe:	09 83       	std	Y+1, r16	; 0x01
    ccc0:	1a 83       	std	Y+2, r17	; 0x02
    ccc2:	97 ff       	sbrs	r25, 7
    ccc4:	02 c0       	rjmp	.+4      	; 0xccca <snprintf_P+0x2a>
    ccc6:	80 e0       	ldi	r24, 0x00	; 0
    ccc8:	90 e8       	ldi	r25, 0x80	; 128
    ccca:	01 97       	sbiw	r24, 0x01	; 1
    cccc:	8d 83       	std	Y+5, r24	; 0x05
    ccce:	9e 83       	std	Y+6, r25	; 0x06
    ccd0:	ae 01       	movw	r20, r28
    ccd2:	44 5e       	subi	r20, 0xE4	; 228
    ccd4:	5f 4f       	sbci	r21, 0xFF	; 255
    ccd6:	6a 8d       	ldd	r22, Y+26	; 0x1a
    ccd8:	7b 8d       	ldd	r23, Y+27	; 0x1b
    ccda:	ce 01       	movw	r24, r28
    ccdc:	01 96       	adiw	r24, 0x01	; 1
    ccde:	31 d0       	rcall	.+98     	; 0xcd42 <vfprintf>
    cce0:	4d 81       	ldd	r20, Y+5	; 0x05
    cce2:	5e 81       	ldd	r21, Y+6	; 0x06
    cce4:	57 fd       	sbrc	r21, 7
    cce6:	0a c0       	rjmp	.+20     	; 0xccfc <snprintf_P+0x5c>
    cce8:	2f 81       	ldd	r18, Y+7	; 0x07
    ccea:	38 85       	ldd	r19, Y+8	; 0x08
    ccec:	42 17       	cp	r20, r18
    ccee:	53 07       	cpc	r21, r19
    ccf0:	0c f4       	brge	.+2      	; 0xccf4 <snprintf_P+0x54>
    ccf2:	9a 01       	movw	r18, r20
    ccf4:	f8 01       	movw	r30, r16
    ccf6:	e2 0f       	add	r30, r18
    ccf8:	f3 1f       	adc	r31, r19
    ccfa:	10 82       	st	Z, r1
    ccfc:	2e 96       	adiw	r28, 0x0e	; 14
    ccfe:	cd bf       	out	0x3d, r28	; 61
    cd00:	de bf       	out	0x3e, r29	; 62
    cd02:	df 91       	pop	r29
    cd04:	cf 91       	pop	r28
    cd06:	1f 91       	pop	r17
    cd08:	0f 91       	pop	r16
    cd0a:	08 95       	ret

0000cd0c <sscanf_P>:
    cd0c:	cf 93       	push	r28
    cd0e:	df 93       	push	r29
    cd10:	cd b7       	in	r28, 0x3d	; 61
    cd12:	de b7       	in	r29, 0x3e	; 62
    cd14:	2e 97       	sbiw	r28, 0x0e	; 14
    cd16:	cd bf       	out	0x3d, r28	; 61
    cd18:	de bf       	out	0x3e, r29	; 62
    cd1a:	8d e0       	ldi	r24, 0x0D	; 13
    cd1c:	8c 83       	std	Y+4, r24	; 0x04
    cd1e:	8c 89       	ldd	r24, Y+20	; 0x14
    cd20:	9d 89       	ldd	r25, Y+21	; 0x15
    cd22:	89 83       	std	Y+1, r24	; 0x01
    cd24:	9a 83       	std	Y+2, r25	; 0x02
    cd26:	ae 01       	movw	r20, r28
    cd28:	48 5e       	subi	r20, 0xE8	; 232
    cd2a:	5f 4f       	sbci	r21, 0xFF	; 255
    cd2c:	6e 89       	ldd	r22, Y+22	; 0x16
    cd2e:	7f 89       	ldd	r23, Y+23	; 0x17
    cd30:	ce 01       	movw	r24, r28
    cd32:	01 96       	adiw	r24, 0x01	; 1
    cd34:	8f d3       	rcall	.+1822   	; 0xd454 <vfscanf>
    cd36:	2e 96       	adiw	r28, 0x0e	; 14
    cd38:	cd bf       	out	0x3d, r28	; 61
    cd3a:	de bf       	out	0x3e, r29	; 62
    cd3c:	df 91       	pop	r29
    cd3e:	cf 91       	pop	r28
    cd40:	08 95       	ret

0000cd42 <vfprintf>:
    cd42:	2f 92       	push	r2
    cd44:	3f 92       	push	r3
    cd46:	4f 92       	push	r4
    cd48:	5f 92       	push	r5
    cd4a:	6f 92       	push	r6
    cd4c:	7f 92       	push	r7
    cd4e:	8f 92       	push	r8
    cd50:	9f 92       	push	r9
    cd52:	af 92       	push	r10
    cd54:	bf 92       	push	r11
    cd56:	cf 92       	push	r12
    cd58:	df 92       	push	r13
    cd5a:	ef 92       	push	r14
    cd5c:	ff 92       	push	r15
    cd5e:	0f 93       	push	r16
    cd60:	1f 93       	push	r17
    cd62:	cf 93       	push	r28
    cd64:	df 93       	push	r29
    cd66:	cd b7       	in	r28, 0x3d	; 61
    cd68:	de b7       	in	r29, 0x3e	; 62
    cd6a:	2c 97       	sbiw	r28, 0x0c	; 12
    cd6c:	cd bf       	out	0x3d, r28	; 61
    cd6e:	de bf       	out	0x3e, r29	; 62
    cd70:	7c 01       	movw	r14, r24
    cd72:	6b 01       	movw	r12, r22
    cd74:	8a 01       	movw	r16, r20
    cd76:	fc 01       	movw	r30, r24
    cd78:	16 82       	std	Z+6, r1	; 0x06
    cd7a:	17 82       	std	Z+7, r1	; 0x07
    cd7c:	83 81       	ldd	r24, Z+3	; 0x03
    cd7e:	81 ff       	sbrs	r24, 1
    cd80:	b0 c1       	rjmp	.+864    	; 0xd0e2 <vfprintf+0x3a0>
    cd82:	ce 01       	movw	r24, r28
    cd84:	01 96       	adiw	r24, 0x01	; 1
    cd86:	4c 01       	movw	r8, r24
    cd88:	f7 01       	movw	r30, r14
    cd8a:	93 81       	ldd	r25, Z+3	; 0x03
    cd8c:	f6 01       	movw	r30, r12
    cd8e:	93 fd       	sbrc	r25, 3
    cd90:	85 91       	lpm	r24, Z+
    cd92:	93 ff       	sbrs	r25, 3
    cd94:	81 91       	ld	r24, Z+
    cd96:	6f 01       	movw	r12, r30
    cd98:	88 23       	and	r24, r24
    cd9a:	09 f4       	brne	.+2      	; 0xcd9e <vfprintf+0x5c>
    cd9c:	9e c1       	rjmp	.+828    	; 0xd0da <vfprintf+0x398>
    cd9e:	85 32       	cpi	r24, 0x25	; 37
    cda0:	39 f4       	brne	.+14     	; 0xcdb0 <vfprintf+0x6e>
    cda2:	93 fd       	sbrc	r25, 3
    cda4:	85 91       	lpm	r24, Z+
    cda6:	93 ff       	sbrs	r25, 3
    cda8:	81 91       	ld	r24, Z+
    cdaa:	6f 01       	movw	r12, r30
    cdac:	85 32       	cpi	r24, 0x25	; 37
    cdae:	21 f4       	brne	.+8      	; 0xcdb8 <vfprintf+0x76>
    cdb0:	b7 01       	movw	r22, r14
    cdb2:	90 e0       	ldi	r25, 0x00	; 0
    cdb4:	d6 d4       	rcall	.+2476   	; 0xd762 <fputc>
    cdb6:	e8 cf       	rjmp	.-48     	; 0xcd88 <vfprintf+0x46>
    cdb8:	51 2c       	mov	r5, r1
    cdba:	31 2c       	mov	r3, r1
    cdbc:	20 e0       	ldi	r18, 0x00	; 0
    cdbe:	20 32       	cpi	r18, 0x20	; 32
    cdc0:	a0 f4       	brcc	.+40     	; 0xcdea <vfprintf+0xa8>
    cdc2:	8b 32       	cpi	r24, 0x2B	; 43
    cdc4:	69 f0       	breq	.+26     	; 0xcde0 <vfprintf+0x9e>
    cdc6:	30 f4       	brcc	.+12     	; 0xcdd4 <vfprintf+0x92>
    cdc8:	80 32       	cpi	r24, 0x20	; 32
    cdca:	59 f0       	breq	.+22     	; 0xcde2 <vfprintf+0xa0>
    cdcc:	83 32       	cpi	r24, 0x23	; 35
    cdce:	69 f4       	brne	.+26     	; 0xcdea <vfprintf+0xa8>
    cdd0:	20 61       	ori	r18, 0x10	; 16
    cdd2:	2c c0       	rjmp	.+88     	; 0xce2c <vfprintf+0xea>
    cdd4:	8d 32       	cpi	r24, 0x2D	; 45
    cdd6:	39 f0       	breq	.+14     	; 0xcde6 <vfprintf+0xa4>
    cdd8:	80 33       	cpi	r24, 0x30	; 48
    cdda:	39 f4       	brne	.+14     	; 0xcdea <vfprintf+0xa8>
    cddc:	21 60       	ori	r18, 0x01	; 1
    cdde:	26 c0       	rjmp	.+76     	; 0xce2c <vfprintf+0xea>
    cde0:	22 60       	ori	r18, 0x02	; 2
    cde2:	24 60       	ori	r18, 0x04	; 4
    cde4:	23 c0       	rjmp	.+70     	; 0xce2c <vfprintf+0xea>
    cde6:	28 60       	ori	r18, 0x08	; 8
    cde8:	21 c0       	rjmp	.+66     	; 0xce2c <vfprintf+0xea>
    cdea:	27 fd       	sbrc	r18, 7
    cdec:	27 c0       	rjmp	.+78     	; 0xce3c <vfprintf+0xfa>
    cdee:	30 ed       	ldi	r19, 0xD0	; 208
    cdf0:	38 0f       	add	r19, r24
    cdf2:	3a 30       	cpi	r19, 0x0A	; 10
    cdf4:	78 f4       	brcc	.+30     	; 0xce14 <vfprintf+0xd2>
    cdf6:	26 ff       	sbrs	r18, 6
    cdf8:	06 c0       	rjmp	.+12     	; 0xce06 <vfprintf+0xc4>
    cdfa:	fa e0       	ldi	r31, 0x0A	; 10
    cdfc:	5f 9e       	mul	r5, r31
    cdfe:	30 0d       	add	r19, r0
    ce00:	11 24       	eor	r1, r1
    ce02:	53 2e       	mov	r5, r19
    ce04:	13 c0       	rjmp	.+38     	; 0xce2c <vfprintf+0xea>
    ce06:	8a e0       	ldi	r24, 0x0A	; 10
    ce08:	38 9e       	mul	r3, r24
    ce0a:	30 0d       	add	r19, r0
    ce0c:	11 24       	eor	r1, r1
    ce0e:	33 2e       	mov	r3, r19
    ce10:	20 62       	ori	r18, 0x20	; 32
    ce12:	0c c0       	rjmp	.+24     	; 0xce2c <vfprintf+0xea>
    ce14:	8e 32       	cpi	r24, 0x2E	; 46
    ce16:	21 f4       	brne	.+8      	; 0xce20 <vfprintf+0xde>
    ce18:	26 fd       	sbrc	r18, 6
    ce1a:	5f c1       	rjmp	.+702    	; 0xd0da <vfprintf+0x398>
    ce1c:	20 64       	ori	r18, 0x40	; 64
    ce1e:	06 c0       	rjmp	.+12     	; 0xce2c <vfprintf+0xea>
    ce20:	8c 36       	cpi	r24, 0x6C	; 108
    ce22:	11 f4       	brne	.+4      	; 0xce28 <vfprintf+0xe6>
    ce24:	20 68       	ori	r18, 0x80	; 128
    ce26:	02 c0       	rjmp	.+4      	; 0xce2c <vfprintf+0xea>
    ce28:	88 36       	cpi	r24, 0x68	; 104
    ce2a:	41 f4       	brne	.+16     	; 0xce3c <vfprintf+0xfa>
    ce2c:	f6 01       	movw	r30, r12
    ce2e:	93 fd       	sbrc	r25, 3
    ce30:	85 91       	lpm	r24, Z+
    ce32:	93 ff       	sbrs	r25, 3
    ce34:	81 91       	ld	r24, Z+
    ce36:	6f 01       	movw	r12, r30
    ce38:	81 11       	cpse	r24, r1
    ce3a:	c1 cf       	rjmp	.-126    	; 0xcdbe <vfprintf+0x7c>
    ce3c:	98 2f       	mov	r25, r24
    ce3e:	9f 7d       	andi	r25, 0xDF	; 223
    ce40:	95 54       	subi	r25, 0x45	; 69
    ce42:	93 30       	cpi	r25, 0x03	; 3
    ce44:	28 f4       	brcc	.+10     	; 0xce50 <vfprintf+0x10e>
    ce46:	0c 5f       	subi	r16, 0xFC	; 252
    ce48:	1f 4f       	sbci	r17, 0xFF	; 255
    ce4a:	ff e3       	ldi	r31, 0x3F	; 63
    ce4c:	f9 83       	std	Y+1, r31	; 0x01
    ce4e:	0d c0       	rjmp	.+26     	; 0xce6a <vfprintf+0x128>
    ce50:	83 36       	cpi	r24, 0x63	; 99
    ce52:	31 f0       	breq	.+12     	; 0xce60 <vfprintf+0x11e>
    ce54:	83 37       	cpi	r24, 0x73	; 115
    ce56:	71 f0       	breq	.+28     	; 0xce74 <vfprintf+0x132>
    ce58:	83 35       	cpi	r24, 0x53	; 83
    ce5a:	09 f0       	breq	.+2      	; 0xce5e <vfprintf+0x11c>
    ce5c:	57 c0       	rjmp	.+174    	; 0xcf0c <vfprintf+0x1ca>
    ce5e:	21 c0       	rjmp	.+66     	; 0xcea2 <vfprintf+0x160>
    ce60:	f8 01       	movw	r30, r16
    ce62:	80 81       	ld	r24, Z
    ce64:	89 83       	std	Y+1, r24	; 0x01
    ce66:	0e 5f       	subi	r16, 0xFE	; 254
    ce68:	1f 4f       	sbci	r17, 0xFF	; 255
    ce6a:	44 24       	eor	r4, r4
    ce6c:	43 94       	inc	r4
    ce6e:	51 2c       	mov	r5, r1
    ce70:	54 01       	movw	r10, r8
    ce72:	14 c0       	rjmp	.+40     	; 0xce9c <vfprintf+0x15a>
    ce74:	38 01       	movw	r6, r16
    ce76:	f2 e0       	ldi	r31, 0x02	; 2
    ce78:	6f 0e       	add	r6, r31
    ce7a:	71 1c       	adc	r7, r1
    ce7c:	f8 01       	movw	r30, r16
    ce7e:	a0 80       	ld	r10, Z
    ce80:	b1 80       	ldd	r11, Z+1	; 0x01
    ce82:	26 ff       	sbrs	r18, 6
    ce84:	03 c0       	rjmp	.+6      	; 0xce8c <vfprintf+0x14a>
    ce86:	65 2d       	mov	r22, r5
    ce88:	70 e0       	ldi	r23, 0x00	; 0
    ce8a:	02 c0       	rjmp	.+4      	; 0xce90 <vfprintf+0x14e>
    ce8c:	6f ef       	ldi	r22, 0xFF	; 255
    ce8e:	7f ef       	ldi	r23, 0xFF	; 255
    ce90:	c5 01       	movw	r24, r10
    ce92:	2c 87       	std	Y+12, r18	; 0x0c
    ce94:	1d d4       	rcall	.+2106   	; 0xd6d0 <strnlen>
    ce96:	2c 01       	movw	r4, r24
    ce98:	83 01       	movw	r16, r6
    ce9a:	2c 85       	ldd	r18, Y+12	; 0x0c
    ce9c:	2f 77       	andi	r18, 0x7F	; 127
    ce9e:	22 2e       	mov	r2, r18
    cea0:	16 c0       	rjmp	.+44     	; 0xcece <vfprintf+0x18c>
    cea2:	38 01       	movw	r6, r16
    cea4:	f2 e0       	ldi	r31, 0x02	; 2
    cea6:	6f 0e       	add	r6, r31
    cea8:	71 1c       	adc	r7, r1
    ceaa:	f8 01       	movw	r30, r16
    ceac:	a0 80       	ld	r10, Z
    ceae:	b1 80       	ldd	r11, Z+1	; 0x01
    ceb0:	26 ff       	sbrs	r18, 6
    ceb2:	03 c0       	rjmp	.+6      	; 0xceba <vfprintf+0x178>
    ceb4:	65 2d       	mov	r22, r5
    ceb6:	70 e0       	ldi	r23, 0x00	; 0
    ceb8:	02 c0       	rjmp	.+4      	; 0xcebe <vfprintf+0x17c>
    ceba:	6f ef       	ldi	r22, 0xFF	; 255
    cebc:	7f ef       	ldi	r23, 0xFF	; 255
    cebe:	c5 01       	movw	r24, r10
    cec0:	2c 87       	std	Y+12, r18	; 0x0c
    cec2:	fb d3       	rcall	.+2038   	; 0xd6ba <strnlen_P>
    cec4:	2c 01       	movw	r4, r24
    cec6:	2c 85       	ldd	r18, Y+12	; 0x0c
    cec8:	20 68       	ori	r18, 0x80	; 128
    ceca:	22 2e       	mov	r2, r18
    cecc:	83 01       	movw	r16, r6
    cece:	23 fc       	sbrc	r2, 3
    ced0:	19 c0       	rjmp	.+50     	; 0xcf04 <vfprintf+0x1c2>
    ced2:	83 2d       	mov	r24, r3
    ced4:	90 e0       	ldi	r25, 0x00	; 0
    ced6:	48 16       	cp	r4, r24
    ced8:	59 06       	cpc	r5, r25
    ceda:	a0 f4       	brcc	.+40     	; 0xcf04 <vfprintf+0x1c2>
    cedc:	b7 01       	movw	r22, r14
    cede:	80 e2       	ldi	r24, 0x20	; 32
    cee0:	90 e0       	ldi	r25, 0x00	; 0
    cee2:	3f d4       	rcall	.+2174   	; 0xd762 <fputc>
    cee4:	3a 94       	dec	r3
    cee6:	f5 cf       	rjmp	.-22     	; 0xced2 <vfprintf+0x190>
    cee8:	f5 01       	movw	r30, r10
    ceea:	27 fc       	sbrc	r2, 7
    ceec:	85 91       	lpm	r24, Z+
    ceee:	27 fe       	sbrs	r2, 7
    cef0:	81 91       	ld	r24, Z+
    cef2:	5f 01       	movw	r10, r30
    cef4:	b7 01       	movw	r22, r14
    cef6:	90 e0       	ldi	r25, 0x00	; 0
    cef8:	34 d4       	rcall	.+2152   	; 0xd762 <fputc>
    cefa:	31 10       	cpse	r3, r1
    cefc:	3a 94       	dec	r3
    cefe:	f1 e0       	ldi	r31, 0x01	; 1
    cf00:	4f 1a       	sub	r4, r31
    cf02:	51 08       	sbc	r5, r1
    cf04:	41 14       	cp	r4, r1
    cf06:	51 04       	cpc	r5, r1
    cf08:	79 f7       	brne	.-34     	; 0xcee8 <vfprintf+0x1a6>
    cf0a:	de c0       	rjmp	.+444    	; 0xd0c8 <vfprintf+0x386>
    cf0c:	84 36       	cpi	r24, 0x64	; 100
    cf0e:	11 f0       	breq	.+4      	; 0xcf14 <vfprintf+0x1d2>
    cf10:	89 36       	cpi	r24, 0x69	; 105
    cf12:	31 f5       	brne	.+76     	; 0xcf60 <vfprintf+0x21e>
    cf14:	f8 01       	movw	r30, r16
    cf16:	27 ff       	sbrs	r18, 7
    cf18:	07 c0       	rjmp	.+14     	; 0xcf28 <vfprintf+0x1e6>
    cf1a:	60 81       	ld	r22, Z
    cf1c:	71 81       	ldd	r23, Z+1	; 0x01
    cf1e:	82 81       	ldd	r24, Z+2	; 0x02
    cf20:	93 81       	ldd	r25, Z+3	; 0x03
    cf22:	0c 5f       	subi	r16, 0xFC	; 252
    cf24:	1f 4f       	sbci	r17, 0xFF	; 255
    cf26:	08 c0       	rjmp	.+16     	; 0xcf38 <vfprintf+0x1f6>
    cf28:	60 81       	ld	r22, Z
    cf2a:	71 81       	ldd	r23, Z+1	; 0x01
    cf2c:	07 2e       	mov	r0, r23
    cf2e:	00 0c       	add	r0, r0
    cf30:	88 0b       	sbc	r24, r24
    cf32:	99 0b       	sbc	r25, r25
    cf34:	0e 5f       	subi	r16, 0xFE	; 254
    cf36:	1f 4f       	sbci	r17, 0xFF	; 255
    cf38:	2f 76       	andi	r18, 0x6F	; 111
    cf3a:	72 2e       	mov	r7, r18
    cf3c:	97 ff       	sbrs	r25, 7
    cf3e:	09 c0       	rjmp	.+18     	; 0xcf52 <vfprintf+0x210>
    cf40:	90 95       	com	r25
    cf42:	80 95       	com	r24
    cf44:	70 95       	com	r23
    cf46:	61 95       	neg	r22
    cf48:	7f 4f       	sbci	r23, 0xFF	; 255
    cf4a:	8f 4f       	sbci	r24, 0xFF	; 255
    cf4c:	9f 4f       	sbci	r25, 0xFF	; 255
    cf4e:	20 68       	ori	r18, 0x80	; 128
    cf50:	72 2e       	mov	r7, r18
    cf52:	2a e0       	ldi	r18, 0x0A	; 10
    cf54:	30 e0       	ldi	r19, 0x00	; 0
    cf56:	a4 01       	movw	r20, r8
    cf58:	55 d4       	rcall	.+2218   	; 0xd804 <__ultoa_invert>
    cf5a:	a8 2e       	mov	r10, r24
    cf5c:	a8 18       	sub	r10, r8
    cf5e:	43 c0       	rjmp	.+134    	; 0xcfe6 <vfprintf+0x2a4>
    cf60:	85 37       	cpi	r24, 0x75	; 117
    cf62:	29 f4       	brne	.+10     	; 0xcf6e <vfprintf+0x22c>
    cf64:	2f 7e       	andi	r18, 0xEF	; 239
    cf66:	b2 2e       	mov	r11, r18
    cf68:	2a e0       	ldi	r18, 0x0A	; 10
    cf6a:	30 e0       	ldi	r19, 0x00	; 0
    cf6c:	25 c0       	rjmp	.+74     	; 0xcfb8 <vfprintf+0x276>
    cf6e:	f2 2f       	mov	r31, r18
    cf70:	f9 7f       	andi	r31, 0xF9	; 249
    cf72:	bf 2e       	mov	r11, r31
    cf74:	8f 36       	cpi	r24, 0x6F	; 111
    cf76:	c1 f0       	breq	.+48     	; 0xcfa8 <vfprintf+0x266>
    cf78:	18 f4       	brcc	.+6      	; 0xcf80 <vfprintf+0x23e>
    cf7a:	88 35       	cpi	r24, 0x58	; 88
    cf7c:	79 f0       	breq	.+30     	; 0xcf9c <vfprintf+0x25a>
    cf7e:	ad c0       	rjmp	.+346    	; 0xd0da <vfprintf+0x398>
    cf80:	80 37       	cpi	r24, 0x70	; 112
    cf82:	19 f0       	breq	.+6      	; 0xcf8a <vfprintf+0x248>
    cf84:	88 37       	cpi	r24, 0x78	; 120
    cf86:	21 f0       	breq	.+8      	; 0xcf90 <vfprintf+0x24e>
    cf88:	a8 c0       	rjmp	.+336    	; 0xd0da <vfprintf+0x398>
    cf8a:	2f 2f       	mov	r18, r31
    cf8c:	20 61       	ori	r18, 0x10	; 16
    cf8e:	b2 2e       	mov	r11, r18
    cf90:	b4 fe       	sbrs	r11, 4
    cf92:	0d c0       	rjmp	.+26     	; 0xcfae <vfprintf+0x26c>
    cf94:	8b 2d       	mov	r24, r11
    cf96:	84 60       	ori	r24, 0x04	; 4
    cf98:	b8 2e       	mov	r11, r24
    cf9a:	09 c0       	rjmp	.+18     	; 0xcfae <vfprintf+0x26c>
    cf9c:	24 ff       	sbrs	r18, 4
    cf9e:	0a c0       	rjmp	.+20     	; 0xcfb4 <vfprintf+0x272>
    cfa0:	9f 2f       	mov	r25, r31
    cfa2:	96 60       	ori	r25, 0x06	; 6
    cfa4:	b9 2e       	mov	r11, r25
    cfa6:	06 c0       	rjmp	.+12     	; 0xcfb4 <vfprintf+0x272>
    cfa8:	28 e0       	ldi	r18, 0x08	; 8
    cfaa:	30 e0       	ldi	r19, 0x00	; 0
    cfac:	05 c0       	rjmp	.+10     	; 0xcfb8 <vfprintf+0x276>
    cfae:	20 e1       	ldi	r18, 0x10	; 16
    cfb0:	30 e0       	ldi	r19, 0x00	; 0
    cfb2:	02 c0       	rjmp	.+4      	; 0xcfb8 <vfprintf+0x276>
    cfb4:	20 e1       	ldi	r18, 0x10	; 16
    cfb6:	32 e0       	ldi	r19, 0x02	; 2
    cfb8:	f8 01       	movw	r30, r16
    cfba:	b7 fe       	sbrs	r11, 7
    cfbc:	07 c0       	rjmp	.+14     	; 0xcfcc <vfprintf+0x28a>
    cfbe:	60 81       	ld	r22, Z
    cfc0:	71 81       	ldd	r23, Z+1	; 0x01
    cfc2:	82 81       	ldd	r24, Z+2	; 0x02
    cfc4:	93 81       	ldd	r25, Z+3	; 0x03
    cfc6:	0c 5f       	subi	r16, 0xFC	; 252
    cfc8:	1f 4f       	sbci	r17, 0xFF	; 255
    cfca:	06 c0       	rjmp	.+12     	; 0xcfd8 <vfprintf+0x296>
    cfcc:	60 81       	ld	r22, Z
    cfce:	71 81       	ldd	r23, Z+1	; 0x01
    cfd0:	80 e0       	ldi	r24, 0x00	; 0
    cfd2:	90 e0       	ldi	r25, 0x00	; 0
    cfd4:	0e 5f       	subi	r16, 0xFE	; 254
    cfd6:	1f 4f       	sbci	r17, 0xFF	; 255
    cfd8:	a4 01       	movw	r20, r8
    cfda:	14 d4       	rcall	.+2088   	; 0xd804 <__ultoa_invert>
    cfdc:	a8 2e       	mov	r10, r24
    cfde:	a8 18       	sub	r10, r8
    cfe0:	fb 2d       	mov	r31, r11
    cfe2:	ff 77       	andi	r31, 0x7F	; 127
    cfe4:	7f 2e       	mov	r7, r31
    cfe6:	76 fe       	sbrs	r7, 6
    cfe8:	0b c0       	rjmp	.+22     	; 0xd000 <vfprintf+0x2be>
    cfea:	37 2d       	mov	r19, r7
    cfec:	3e 7f       	andi	r19, 0xFE	; 254
    cfee:	a5 14       	cp	r10, r5
    cff0:	50 f4       	brcc	.+20     	; 0xd006 <vfprintf+0x2c4>
    cff2:	74 fe       	sbrs	r7, 4
    cff4:	0a c0       	rjmp	.+20     	; 0xd00a <vfprintf+0x2c8>
    cff6:	72 fc       	sbrc	r7, 2
    cff8:	08 c0       	rjmp	.+16     	; 0xd00a <vfprintf+0x2c8>
    cffa:	37 2d       	mov	r19, r7
    cffc:	3e 7e       	andi	r19, 0xEE	; 238
    cffe:	05 c0       	rjmp	.+10     	; 0xd00a <vfprintf+0x2c8>
    d000:	ba 2c       	mov	r11, r10
    d002:	37 2d       	mov	r19, r7
    d004:	03 c0       	rjmp	.+6      	; 0xd00c <vfprintf+0x2ca>
    d006:	ba 2c       	mov	r11, r10
    d008:	01 c0       	rjmp	.+2      	; 0xd00c <vfprintf+0x2ca>
    d00a:	b5 2c       	mov	r11, r5
    d00c:	34 ff       	sbrs	r19, 4
    d00e:	0d c0       	rjmp	.+26     	; 0xd02a <vfprintf+0x2e8>
    d010:	fe 01       	movw	r30, r28
    d012:	ea 0d       	add	r30, r10
    d014:	f1 1d       	adc	r31, r1
    d016:	80 81       	ld	r24, Z
    d018:	80 33       	cpi	r24, 0x30	; 48
    d01a:	11 f4       	brne	.+4      	; 0xd020 <vfprintf+0x2de>
    d01c:	39 7e       	andi	r19, 0xE9	; 233
    d01e:	09 c0       	rjmp	.+18     	; 0xd032 <vfprintf+0x2f0>
    d020:	32 ff       	sbrs	r19, 2
    d022:	06 c0       	rjmp	.+12     	; 0xd030 <vfprintf+0x2ee>
    d024:	b3 94       	inc	r11
    d026:	b3 94       	inc	r11
    d028:	04 c0       	rjmp	.+8      	; 0xd032 <vfprintf+0x2f0>
    d02a:	83 2f       	mov	r24, r19
    d02c:	86 78       	andi	r24, 0x86	; 134
    d02e:	09 f0       	breq	.+2      	; 0xd032 <vfprintf+0x2f0>
    d030:	b3 94       	inc	r11
    d032:	33 fd       	sbrc	r19, 3
    d034:	12 c0       	rjmp	.+36     	; 0xd05a <vfprintf+0x318>
    d036:	30 ff       	sbrs	r19, 0
    d038:	06 c0       	rjmp	.+12     	; 0xd046 <vfprintf+0x304>
    d03a:	5a 2c       	mov	r5, r10
    d03c:	b3 14       	cp	r11, r3
    d03e:	18 f4       	brcc	.+6      	; 0xd046 <vfprintf+0x304>
    d040:	53 0c       	add	r5, r3
    d042:	5b 18       	sub	r5, r11
    d044:	b3 2c       	mov	r11, r3
    d046:	b3 14       	cp	r11, r3
    d048:	60 f4       	brcc	.+24     	; 0xd062 <vfprintf+0x320>
    d04a:	b7 01       	movw	r22, r14
    d04c:	80 e2       	ldi	r24, 0x20	; 32
    d04e:	90 e0       	ldi	r25, 0x00	; 0
    d050:	3c 87       	std	Y+12, r19	; 0x0c
    d052:	87 d3       	rcall	.+1806   	; 0xd762 <fputc>
    d054:	b3 94       	inc	r11
    d056:	3c 85       	ldd	r19, Y+12	; 0x0c
    d058:	f6 cf       	rjmp	.-20     	; 0xd046 <vfprintf+0x304>
    d05a:	b3 14       	cp	r11, r3
    d05c:	10 f4       	brcc	.+4      	; 0xd062 <vfprintf+0x320>
    d05e:	3b 18       	sub	r3, r11
    d060:	01 c0       	rjmp	.+2      	; 0xd064 <vfprintf+0x322>
    d062:	31 2c       	mov	r3, r1
    d064:	34 ff       	sbrs	r19, 4
    d066:	11 c0       	rjmp	.+34     	; 0xd08a <vfprintf+0x348>
    d068:	b7 01       	movw	r22, r14
    d06a:	80 e3       	ldi	r24, 0x30	; 48
    d06c:	90 e0       	ldi	r25, 0x00	; 0
    d06e:	3c 87       	std	Y+12, r19	; 0x0c
    d070:	78 d3       	rcall	.+1776   	; 0xd762 <fputc>
    d072:	3c 85       	ldd	r19, Y+12	; 0x0c
    d074:	32 ff       	sbrs	r19, 2
    d076:	16 c0       	rjmp	.+44     	; 0xd0a4 <vfprintf+0x362>
    d078:	31 fd       	sbrc	r19, 1
    d07a:	03 c0       	rjmp	.+6      	; 0xd082 <vfprintf+0x340>
    d07c:	88 e7       	ldi	r24, 0x78	; 120
    d07e:	90 e0       	ldi	r25, 0x00	; 0
    d080:	02 c0       	rjmp	.+4      	; 0xd086 <vfprintf+0x344>
    d082:	88 e5       	ldi	r24, 0x58	; 88
    d084:	90 e0       	ldi	r25, 0x00	; 0
    d086:	b7 01       	movw	r22, r14
    d088:	0c c0       	rjmp	.+24     	; 0xd0a2 <vfprintf+0x360>
    d08a:	83 2f       	mov	r24, r19
    d08c:	86 78       	andi	r24, 0x86	; 134
    d08e:	51 f0       	breq	.+20     	; 0xd0a4 <vfprintf+0x362>
    d090:	31 ff       	sbrs	r19, 1
    d092:	02 c0       	rjmp	.+4      	; 0xd098 <vfprintf+0x356>
    d094:	8b e2       	ldi	r24, 0x2B	; 43
    d096:	01 c0       	rjmp	.+2      	; 0xd09a <vfprintf+0x358>
    d098:	80 e2       	ldi	r24, 0x20	; 32
    d09a:	37 fd       	sbrc	r19, 7
    d09c:	8d e2       	ldi	r24, 0x2D	; 45
    d09e:	b7 01       	movw	r22, r14
    d0a0:	90 e0       	ldi	r25, 0x00	; 0
    d0a2:	5f d3       	rcall	.+1726   	; 0xd762 <fputc>
    d0a4:	a5 14       	cp	r10, r5
    d0a6:	30 f4       	brcc	.+12     	; 0xd0b4 <vfprintf+0x372>
    d0a8:	b7 01       	movw	r22, r14
    d0aa:	80 e3       	ldi	r24, 0x30	; 48
    d0ac:	90 e0       	ldi	r25, 0x00	; 0
    d0ae:	59 d3       	rcall	.+1714   	; 0xd762 <fputc>
    d0b0:	5a 94       	dec	r5
    d0b2:	f8 cf       	rjmp	.-16     	; 0xd0a4 <vfprintf+0x362>
    d0b4:	aa 94       	dec	r10
    d0b6:	f4 01       	movw	r30, r8
    d0b8:	ea 0d       	add	r30, r10
    d0ba:	f1 1d       	adc	r31, r1
    d0bc:	80 81       	ld	r24, Z
    d0be:	b7 01       	movw	r22, r14
    d0c0:	90 e0       	ldi	r25, 0x00	; 0
    d0c2:	4f d3       	rcall	.+1694   	; 0xd762 <fputc>
    d0c4:	a1 10       	cpse	r10, r1
    d0c6:	f6 cf       	rjmp	.-20     	; 0xd0b4 <vfprintf+0x372>
    d0c8:	33 20       	and	r3, r3
    d0ca:	09 f4       	brne	.+2      	; 0xd0ce <vfprintf+0x38c>
    d0cc:	5d ce       	rjmp	.-838    	; 0xcd88 <vfprintf+0x46>
    d0ce:	b7 01       	movw	r22, r14
    d0d0:	80 e2       	ldi	r24, 0x20	; 32
    d0d2:	90 e0       	ldi	r25, 0x00	; 0
    d0d4:	46 d3       	rcall	.+1676   	; 0xd762 <fputc>
    d0d6:	3a 94       	dec	r3
    d0d8:	f7 cf       	rjmp	.-18     	; 0xd0c8 <vfprintf+0x386>
    d0da:	f7 01       	movw	r30, r14
    d0dc:	86 81       	ldd	r24, Z+6	; 0x06
    d0de:	97 81       	ldd	r25, Z+7	; 0x07
    d0e0:	02 c0       	rjmp	.+4      	; 0xd0e6 <vfprintf+0x3a4>
    d0e2:	8f ef       	ldi	r24, 0xFF	; 255
    d0e4:	9f ef       	ldi	r25, 0xFF	; 255
    d0e6:	2c 96       	adiw	r28, 0x0c	; 12
    d0e8:	cd bf       	out	0x3d, r28	; 61
    d0ea:	de bf       	out	0x3e, r29	; 62
    d0ec:	df 91       	pop	r29
    d0ee:	cf 91       	pop	r28
    d0f0:	1f 91       	pop	r17
    d0f2:	0f 91       	pop	r16
    d0f4:	ff 90       	pop	r15
    d0f6:	ef 90       	pop	r14
    d0f8:	df 90       	pop	r13
    d0fa:	cf 90       	pop	r12
    d0fc:	bf 90       	pop	r11
    d0fe:	af 90       	pop	r10
    d100:	9f 90       	pop	r9
    d102:	8f 90       	pop	r8
    d104:	7f 90       	pop	r7
    d106:	6f 90       	pop	r6
    d108:	5f 90       	pop	r5
    d10a:	4f 90       	pop	r4
    d10c:	3f 90       	pop	r3
    d10e:	2f 90       	pop	r2
    d110:	08 95       	ret

0000d112 <putval>:
    d112:	20 fd       	sbrc	r18, 0
    d114:	09 c0       	rjmp	.+18     	; 0xd128 <putval+0x16>
    d116:	fc 01       	movw	r30, r24
    d118:	23 fd       	sbrc	r18, 3
    d11a:	05 c0       	rjmp	.+10     	; 0xd126 <putval+0x14>
    d11c:	22 ff       	sbrs	r18, 2
    d11e:	02 c0       	rjmp	.+4      	; 0xd124 <putval+0x12>
    d120:	73 83       	std	Z+3, r23	; 0x03
    d122:	62 83       	std	Z+2, r22	; 0x02
    d124:	51 83       	std	Z+1, r21	; 0x01
    d126:	40 83       	st	Z, r20
    d128:	08 95       	ret

0000d12a <mulacc>:
    d12a:	44 fd       	sbrc	r20, 4
    d12c:	10 c0       	rjmp	.+32     	; 0xd14e <mulacc+0x24>
    d12e:	46 fd       	sbrc	r20, 6
    d130:	10 c0       	rjmp	.+32     	; 0xd152 <mulacc+0x28>
    d132:	db 01       	movw	r26, r22
    d134:	fc 01       	movw	r30, r24
    d136:	aa 0f       	add	r26, r26
    d138:	bb 1f       	adc	r27, r27
    d13a:	ee 1f       	adc	r30, r30
    d13c:	ff 1f       	adc	r31, r31
    d13e:	10 94       	com	r1
    d140:	d1 f7       	brne	.-12     	; 0xd136 <mulacc+0xc>
    d142:	6a 0f       	add	r22, r26
    d144:	7b 1f       	adc	r23, r27
    d146:	8e 1f       	adc	r24, r30
    d148:	9f 1f       	adc	r25, r31
    d14a:	31 e0       	ldi	r19, 0x01	; 1
    d14c:	03 c0       	rjmp	.+6      	; 0xd154 <mulacc+0x2a>
    d14e:	33 e0       	ldi	r19, 0x03	; 3
    d150:	01 c0       	rjmp	.+2      	; 0xd154 <mulacc+0x2a>
    d152:	34 e0       	ldi	r19, 0x04	; 4
    d154:	66 0f       	add	r22, r22
    d156:	77 1f       	adc	r23, r23
    d158:	88 1f       	adc	r24, r24
    d15a:	99 1f       	adc	r25, r25
    d15c:	31 50       	subi	r19, 0x01	; 1
    d15e:	d1 f7       	brne	.-12     	; 0xd154 <mulacc+0x2a>
    d160:	62 0f       	add	r22, r18
    d162:	71 1d       	adc	r23, r1
    d164:	81 1d       	adc	r24, r1
    d166:	91 1d       	adc	r25, r1
    d168:	08 95       	ret

0000d16a <skip_spaces>:
    d16a:	0f 93       	push	r16
    d16c:	1f 93       	push	r17
    d16e:	cf 93       	push	r28
    d170:	df 93       	push	r29
    d172:	8c 01       	movw	r16, r24
    d174:	c8 01       	movw	r24, r16
    d176:	b7 d2       	rcall	.+1390   	; 0xd6e6 <fgetc>
    d178:	ec 01       	movw	r28, r24
    d17a:	97 fd       	sbrc	r25, 7
    d17c:	06 c0       	rjmp	.+12     	; 0xd18a <skip_spaces+0x20>
    d17e:	8a d2       	rcall	.+1300   	; 0xd694 <isspace>
    d180:	89 2b       	or	r24, r25
    d182:	c1 f7       	brne	.-16     	; 0xd174 <skip_spaces+0xa>
    d184:	b8 01       	movw	r22, r16
    d186:	ce 01       	movw	r24, r28
    d188:	24 d3       	rcall	.+1608   	; 0xd7d2 <ungetc>
    d18a:	ce 01       	movw	r24, r28
    d18c:	df 91       	pop	r29
    d18e:	cf 91       	pop	r28
    d190:	1f 91       	pop	r17
    d192:	0f 91       	pop	r16
    d194:	08 95       	ret

0000d196 <conv_int>:
    d196:	8f 92       	push	r8
    d198:	9f 92       	push	r9
    d19a:	af 92       	push	r10
    d19c:	bf 92       	push	r11
    d19e:	cf 92       	push	r12
    d1a0:	df 92       	push	r13
    d1a2:	ef 92       	push	r14
    d1a4:	ff 92       	push	r15
    d1a6:	0f 93       	push	r16
    d1a8:	1f 93       	push	r17
    d1aa:	cf 93       	push	r28
    d1ac:	df 93       	push	r29
    d1ae:	1f 92       	push	r1
    d1b0:	cd b7       	in	r28, 0x3d	; 61
    d1b2:	de b7       	in	r29, 0x3e	; 62
    d1b4:	8c 01       	movw	r16, r24
    d1b6:	c6 2e       	mov	r12, r22
    d1b8:	7a 01       	movw	r14, r20
    d1ba:	29 83       	std	Y+1, r18	; 0x01
    d1bc:	94 d2       	rcall	.+1320   	; 0xd6e6 <fgetc>
    d1be:	ac 01       	movw	r20, r24
    d1c0:	55 27       	eor	r21, r21
    d1c2:	29 81       	ldd	r18, Y+1	; 0x01
    d1c4:	4b 32       	cpi	r20, 0x2B	; 43
    d1c6:	51 05       	cpc	r21, r1
    d1c8:	21 f0       	breq	.+8      	; 0xd1d2 <conv_int+0x3c>
    d1ca:	4d 32       	cpi	r20, 0x2D	; 45
    d1cc:	51 05       	cpc	r21, r1
    d1ce:	61 f4       	brne	.+24     	; 0xd1e8 <conv_int+0x52>
    d1d0:	20 68       	ori	r18, 0x80	; 128
    d1d2:	ca 94       	dec	r12
    d1d4:	c1 10       	cpse	r12, r1
    d1d6:	02 c0       	rjmp	.+4      	; 0xd1dc <conv_int+0x46>
    d1d8:	80 e0       	ldi	r24, 0x00	; 0
    d1da:	6f c0       	rjmp	.+222    	; 0xd2ba <conv_int+0x124>
    d1dc:	c8 01       	movw	r24, r16
    d1de:	29 83       	std	Y+1, r18	; 0x01
    d1e0:	82 d2       	rcall	.+1284   	; 0xd6e6 <fgetc>
    d1e2:	29 81       	ldd	r18, Y+1	; 0x01
    d1e4:	97 fd       	sbrc	r25, 7
    d1e6:	f8 cf       	rjmp	.-16     	; 0xd1d8 <conv_int+0x42>
    d1e8:	32 2f       	mov	r19, r18
    d1ea:	3d 7f       	andi	r19, 0xFD	; 253
    d1ec:	d3 2e       	mov	r13, r19
    d1ee:	32 2f       	mov	r19, r18
    d1f0:	30 73       	andi	r19, 0x30	; 48
    d1f2:	39 f5       	brne	.+78     	; 0xd242 <conv_int+0xac>
    d1f4:	80 33       	cpi	r24, 0x30	; 48
    d1f6:	29 f5       	brne	.+74     	; 0xd242 <conv_int+0xac>
    d1f8:	bb 24       	eor	r11, r11
    d1fa:	ba 94       	dec	r11
    d1fc:	bc 0c       	add	r11, r12
    d1fe:	09 f4       	brne	.+2      	; 0xd202 <conv_int+0x6c>
    d200:	49 c0       	rjmp	.+146    	; 0xd294 <conv_int+0xfe>
    d202:	c8 01       	movw	r24, r16
    d204:	29 83       	std	Y+1, r18	; 0x01
    d206:	6f d2       	rcall	.+1246   	; 0xd6e6 <fgetc>
    d208:	29 81       	ldd	r18, Y+1	; 0x01
    d20a:	97 fd       	sbrc	r25, 7
    d20c:	43 c0       	rjmp	.+134    	; 0xd294 <conv_int+0xfe>
    d20e:	38 2f       	mov	r19, r24
    d210:	3f 7d       	andi	r19, 0xDF	; 223
    d212:	38 35       	cpi	r19, 0x58	; 88
    d214:	61 f4       	brne	.+24     	; 0xd22e <conv_int+0x98>
    d216:	8d 2d       	mov	r24, r13
    d218:	82 64       	ori	r24, 0x42	; 66
    d21a:	d8 2e       	mov	r13, r24
    d21c:	ca 94       	dec	r12
    d21e:	ca 94       	dec	r12
    d220:	cc 20       	and	r12, r12
    d222:	c1 f1       	breq	.+112    	; 0xd294 <conv_int+0xfe>
    d224:	c8 01       	movw	r24, r16
    d226:	5f d2       	rcall	.+1214   	; 0xd6e6 <fgetc>
    d228:	97 ff       	sbrs	r25, 7
    d22a:	0b c0       	rjmp	.+22     	; 0xd242 <conv_int+0xac>
    d22c:	33 c0       	rjmp	.+102    	; 0xd294 <conv_int+0xfe>
    d22e:	26 ff       	sbrs	r18, 6
    d230:	04 c0       	rjmp	.+8      	; 0xd23a <conv_int+0xa4>
    d232:	2d 2d       	mov	r18, r13
    d234:	22 60       	ori	r18, 0x02	; 2
    d236:	d2 2e       	mov	r13, r18
    d238:	03 c0       	rjmp	.+6      	; 0xd240 <conv_int+0xaa>
    d23a:	3d 2d       	mov	r19, r13
    d23c:	32 61       	ori	r19, 0x12	; 18
    d23e:	d3 2e       	mov	r13, r19
    d240:	cb 2c       	mov	r12, r11
    d242:	81 2c       	mov	r8, r1
    d244:	91 2c       	mov	r9, r1
    d246:	54 01       	movw	r10, r8
    d248:	20 ed       	ldi	r18, 0xD0	; 208
    d24a:	28 0f       	add	r18, r24
    d24c:	28 30       	cpi	r18, 0x08	; 8
    d24e:	78 f0       	brcs	.+30     	; 0xd26e <conv_int+0xd8>
    d250:	d4 fe       	sbrs	r13, 4
    d252:	03 c0       	rjmp	.+6      	; 0xd25a <conv_int+0xc4>
    d254:	b8 01       	movw	r22, r16
    d256:	bd d2       	rcall	.+1402   	; 0xd7d2 <ungetc>
    d258:	1a c0       	rjmp	.+52     	; 0xd28e <conv_int+0xf8>
    d25a:	2a 30       	cpi	r18, 0x0A	; 10
    d25c:	40 f0       	brcs	.+16     	; 0xd26e <conv_int+0xd8>
    d25e:	d6 fe       	sbrs	r13, 6
    d260:	f9 cf       	rjmp	.-14     	; 0xd254 <conv_int+0xbe>
    d262:	2f 7d       	andi	r18, 0xDF	; 223
    d264:	3f ee       	ldi	r19, 0xEF	; 239
    d266:	32 0f       	add	r19, r18
    d268:	36 30       	cpi	r19, 0x06	; 6
    d26a:	a0 f7       	brcc	.-24     	; 0xd254 <conv_int+0xbe>
    d26c:	27 50       	subi	r18, 0x07	; 7
    d26e:	4d 2d       	mov	r20, r13
    d270:	c5 01       	movw	r24, r10
    d272:	b4 01       	movw	r22, r8
    d274:	5a df       	rcall	.-332    	; 0xd12a <mulacc>
    d276:	4b 01       	movw	r8, r22
    d278:	5c 01       	movw	r10, r24
    d27a:	8d 2d       	mov	r24, r13
    d27c:	82 60       	ori	r24, 0x02	; 2
    d27e:	d8 2e       	mov	r13, r24
    d280:	ca 94       	dec	r12
    d282:	cc 20       	and	r12, r12
    d284:	51 f0       	breq	.+20     	; 0xd29a <conv_int+0x104>
    d286:	c8 01       	movw	r24, r16
    d288:	2e d2       	rcall	.+1116   	; 0xd6e6 <fgetc>
    d28a:	97 ff       	sbrs	r25, 7
    d28c:	dd cf       	rjmp	.-70     	; 0xd248 <conv_int+0xb2>
    d28e:	d1 fc       	sbrc	r13, 1
    d290:	04 c0       	rjmp	.+8      	; 0xd29a <conv_int+0x104>
    d292:	a2 cf       	rjmp	.-188    	; 0xd1d8 <conv_int+0x42>
    d294:	81 2c       	mov	r8, r1
    d296:	91 2c       	mov	r9, r1
    d298:	54 01       	movw	r10, r8
    d29a:	d7 fe       	sbrs	r13, 7
    d29c:	08 c0       	rjmp	.+16     	; 0xd2ae <conv_int+0x118>
    d29e:	b0 94       	com	r11
    d2a0:	a0 94       	com	r10
    d2a2:	90 94       	com	r9
    d2a4:	80 94       	com	r8
    d2a6:	81 1c       	adc	r8, r1
    d2a8:	91 1c       	adc	r9, r1
    d2aa:	a1 1c       	adc	r10, r1
    d2ac:	b1 1c       	adc	r11, r1
    d2ae:	2d 2d       	mov	r18, r13
    d2b0:	b5 01       	movw	r22, r10
    d2b2:	a4 01       	movw	r20, r8
    d2b4:	c7 01       	movw	r24, r14
    d2b6:	2d df       	rcall	.-422    	; 0xd112 <putval>
    d2b8:	81 e0       	ldi	r24, 0x01	; 1
    d2ba:	0f 90       	pop	r0
    d2bc:	df 91       	pop	r29
    d2be:	cf 91       	pop	r28
    d2c0:	1f 91       	pop	r17
    d2c2:	0f 91       	pop	r16
    d2c4:	ff 90       	pop	r15
    d2c6:	ef 90       	pop	r14
    d2c8:	df 90       	pop	r13
    d2ca:	cf 90       	pop	r12
    d2cc:	bf 90       	pop	r11
    d2ce:	af 90       	pop	r10
    d2d0:	9f 90       	pop	r9
    d2d2:	8f 90       	pop	r8
    d2d4:	08 95       	ret

0000d2d6 <conv_brk>:
    d2d6:	6f 92       	push	r6
    d2d8:	7f 92       	push	r7
    d2da:	8f 92       	push	r8
    d2dc:	9f 92       	push	r9
    d2de:	af 92       	push	r10
    d2e0:	bf 92       	push	r11
    d2e2:	cf 92       	push	r12
    d2e4:	df 92       	push	r13
    d2e6:	ef 92       	push	r14
    d2e8:	ff 92       	push	r15
    d2ea:	0f 93       	push	r16
    d2ec:	1f 93       	push	r17
    d2ee:	cf 93       	push	r28
    d2f0:	df 93       	push	r29
    d2f2:	cd b7       	in	r28, 0x3d	; 61
    d2f4:	de b7       	in	r29, 0x3e	; 62
    d2f6:	a1 97       	sbiw	r28, 0x21	; 33
    d2f8:	cd bf       	out	0x3d, r28	; 61
    d2fa:	de bf       	out	0x3e, r29	; 62
    d2fc:	5c 01       	movw	r10, r24
    d2fe:	7a 01       	movw	r14, r20
    d300:	ce 01       	movw	r24, r28
    d302:	01 96       	adiw	r24, 0x01	; 1
    d304:	6c 01       	movw	r12, r24
    d306:	80 e2       	ldi	r24, 0x20	; 32
    d308:	f6 01       	movw	r30, r12
    d30a:	11 92       	st	Z+, r1
    d30c:	8a 95       	dec	r24
    d30e:	e9 f7       	brne	.-6      	; 0xd30a <conv_brk+0x34>
    d310:	f5 01       	movw	r30, r10
    d312:	83 80       	ldd	r8, Z+3	; 0x03
    d314:	40 e0       	ldi	r20, 0x00	; 0
    d316:	50 e0       	ldi	r21, 0x00	; 0
    d318:	91 2c       	mov	r9, r1
    d31a:	71 2c       	mov	r7, r1
    d31c:	70 e0       	ldi	r23, 0x00	; 0
    d31e:	a1 e0       	ldi	r26, 0x01	; 1
    d320:	b0 e0       	ldi	r27, 0x00	; 0
    d322:	f9 01       	movw	r30, r18
    d324:	83 fc       	sbrc	r8, 3
    d326:	85 91       	lpm	r24, Z+
    d328:	83 fe       	sbrs	r8, 3
    d32a:	81 91       	ld	r24, Z+
    d32c:	8f 01       	movw	r16, r30
    d32e:	98 2f       	mov	r25, r24
    d330:	9f 01       	movw	r18, r30
    d332:	81 11       	cpse	r24, r1
    d334:	03 c0       	rjmp	.+6      	; 0xd33c <conv_brk+0x66>
    d336:	80 e0       	ldi	r24, 0x00	; 0
    d338:	90 e0       	ldi	r25, 0x00	; 0
    d33a:	7a c0       	rjmp	.+244    	; 0xd430 <conv_brk+0x15a>
    d33c:	8e 35       	cpi	r24, 0x5E	; 94
    d33e:	19 f4       	brne	.+6      	; 0xd346 <conv_brk+0x70>
    d340:	41 15       	cp	r20, r1
    d342:	51 05       	cpc	r21, r1
    d344:	49 f1       	breq	.+82     	; 0xd398 <conv_brk+0xc2>
    d346:	e7 2f       	mov	r30, r23
    d348:	f0 e0       	ldi	r31, 0x00	; 0
    d34a:	e4 17       	cp	r30, r20
    d34c:	f5 07       	cpc	r31, r21
    d34e:	3c f4       	brge	.+14     	; 0xd35e <conv_brk+0x88>
    d350:	8d 35       	cpi	r24, 0x5D	; 93
    d352:	59 f1       	breq	.+86     	; 0xd3aa <conv_brk+0xd4>
    d354:	8d 32       	cpi	r24, 0x2D	; 45
    d356:	19 f4       	brne	.+6      	; 0xd35e <conv_brk+0x88>
    d358:	77 20       	and	r7, r7
    d35a:	01 f1       	breq	.+64     	; 0xd39c <conv_brk+0xc6>
    d35c:	03 c0       	rjmp	.+6      	; 0xd364 <conv_brk+0x8e>
    d35e:	71 10       	cpse	r7, r1
    d360:	01 c0       	rjmp	.+2      	; 0xd364 <conv_brk+0x8e>
    d362:	98 2e       	mov	r9, r24
    d364:	89 2f       	mov	r24, r25
    d366:	86 95       	lsr	r24
    d368:	86 95       	lsr	r24
    d36a:	86 95       	lsr	r24
    d36c:	86 01       	movw	r16, r12
    d36e:	08 0f       	add	r16, r24
    d370:	11 1d       	adc	r17, r1
    d372:	89 2f       	mov	r24, r25
    d374:	87 70       	andi	r24, 0x07	; 7
    d376:	3d 01       	movw	r6, r26
    d378:	01 c0       	rjmp	.+2      	; 0xd37c <conv_brk+0xa6>
    d37a:	66 0c       	add	r6, r6
    d37c:	8a 95       	dec	r24
    d37e:	ea f7       	brpl	.-6      	; 0xd37a <conv_brk+0xa4>
    d380:	f8 01       	movw	r30, r16
    d382:	80 81       	ld	r24, Z
    d384:	86 29       	or	r24, r6
    d386:	80 83       	st	Z, r24
    d388:	99 15       	cp	r25, r9
    d38a:	59 f0       	breq	.+22     	; 0xd3a2 <conv_brk+0xcc>
    d38c:	99 15       	cp	r25, r9
    d38e:	10 f4       	brcc	.+4      	; 0xd394 <conv_brk+0xbe>
    d390:	9f 5f       	subi	r25, 0xFF	; 255
    d392:	e8 cf       	rjmp	.-48     	; 0xd364 <conv_brk+0x8e>
    d394:	91 50       	subi	r25, 0x01	; 1
    d396:	e6 cf       	rjmp	.-52     	; 0xd364 <conv_brk+0x8e>
    d398:	71 e0       	ldi	r23, 0x01	; 1
    d39a:	04 c0       	rjmp	.+8      	; 0xd3a4 <conv_brk+0xce>
    d39c:	77 24       	eor	r7, r7
    d39e:	73 94       	inc	r7
    d3a0:	01 c0       	rjmp	.+2      	; 0xd3a4 <conv_brk+0xce>
    d3a2:	71 2c       	mov	r7, r1
    d3a4:	4f 5f       	subi	r20, 0xFF	; 255
    d3a6:	5f 4f       	sbci	r21, 0xFF	; 255
    d3a8:	bc cf       	rjmp	.-136    	; 0xd322 <conv_brk+0x4c>
    d3aa:	77 20       	and	r7, r7
    d3ac:	19 f0       	breq	.+6      	; 0xd3b4 <conv_brk+0xde>
    d3ae:	8e 81       	ldd	r24, Y+6	; 0x06
    d3b0:	80 62       	ori	r24, 0x20	; 32
    d3b2:	8e 83       	std	Y+6, r24	; 0x06
    d3b4:	71 11       	cpse	r23, r1
    d3b6:	03 c0       	rjmp	.+6      	; 0xd3be <conv_brk+0xe8>
    d3b8:	99 24       	eor	r9, r9
    d3ba:	93 94       	inc	r9
    d3bc:	16 c0       	rjmp	.+44     	; 0xd3ea <conv_brk+0x114>
    d3be:	f6 01       	movw	r30, r12
    d3c0:	9e 01       	movw	r18, r28
    d3c2:	2f 5d       	subi	r18, 0xDF	; 223
    d3c4:	3f 4f       	sbci	r19, 0xFF	; 255
    d3c6:	80 81       	ld	r24, Z
    d3c8:	80 95       	com	r24
    d3ca:	81 93       	st	Z+, r24
    d3cc:	e2 17       	cp	r30, r18
    d3ce:	f3 07       	cpc	r31, r19
    d3d0:	d1 f7       	brne	.-12     	; 0xd3c6 <conv_brk+0xf0>
    d3d2:	f2 cf       	rjmp	.-28     	; 0xd3b8 <conv_brk+0xe2>
    d3d4:	e1 14       	cp	r14, r1
    d3d6:	f1 04       	cpc	r15, r1
    d3d8:	29 f0       	breq	.+10     	; 0xd3e4 <conv_brk+0x10e>
    d3da:	f7 01       	movw	r30, r14
    d3dc:	80 83       	st	Z, r24
    d3de:	c7 01       	movw	r24, r14
    d3e0:	01 96       	adiw	r24, 0x01	; 1
    d3e2:	7c 01       	movw	r14, r24
    d3e4:	61 50       	subi	r22, 0x01	; 1
    d3e6:	91 2c       	mov	r9, r1
    d3e8:	e9 f0       	breq	.+58     	; 0xd424 <conv_brk+0x14e>
    d3ea:	c5 01       	movw	r24, r10
    d3ec:	69 a3       	std	Y+33, r22	; 0x21
    d3ee:	7b d1       	rcall	.+758    	; 0xd6e6 <fgetc>
    d3f0:	69 a1       	ldd	r22, Y+33	; 0x21
    d3f2:	97 fd       	sbrc	r25, 7
    d3f4:	15 c0       	rjmp	.+42     	; 0xd420 <conv_brk+0x14a>
    d3f6:	28 2f       	mov	r18, r24
    d3f8:	26 95       	lsr	r18
    d3fa:	26 95       	lsr	r18
    d3fc:	26 95       	lsr	r18
    d3fe:	f6 01       	movw	r30, r12
    d400:	e2 0f       	add	r30, r18
    d402:	f1 1d       	adc	r31, r1
    d404:	20 81       	ld	r18, Z
    d406:	30 e0       	ldi	r19, 0x00	; 0
    d408:	ac 01       	movw	r20, r24
    d40a:	47 70       	andi	r20, 0x07	; 7
    d40c:	55 27       	eor	r21, r21
    d40e:	02 c0       	rjmp	.+4      	; 0xd414 <conv_brk+0x13e>
    d410:	35 95       	asr	r19
    d412:	27 95       	ror	r18
    d414:	4a 95       	dec	r20
    d416:	e2 f7       	brpl	.-8      	; 0xd410 <conv_brk+0x13a>
    d418:	20 fd       	sbrc	r18, 0
    d41a:	dc cf       	rjmp	.-72     	; 0xd3d4 <conv_brk+0xfe>
    d41c:	b5 01       	movw	r22, r10
    d41e:	d9 d1       	rcall	.+946    	; 0xd7d2 <ungetc>
    d420:	91 10       	cpse	r9, r1
    d422:	89 cf       	rjmp	.-238    	; 0xd336 <conv_brk+0x60>
    d424:	e1 14       	cp	r14, r1
    d426:	f1 04       	cpc	r15, r1
    d428:	11 f0       	breq	.+4      	; 0xd42e <conv_brk+0x158>
    d42a:	f7 01       	movw	r30, r14
    d42c:	10 82       	st	Z, r1
    d42e:	c8 01       	movw	r24, r16
    d430:	a1 96       	adiw	r28, 0x21	; 33
    d432:	cd bf       	out	0x3d, r28	; 61
    d434:	de bf       	out	0x3e, r29	; 62
    d436:	df 91       	pop	r29
    d438:	cf 91       	pop	r28
    d43a:	1f 91       	pop	r17
    d43c:	0f 91       	pop	r16
    d43e:	ff 90       	pop	r15
    d440:	ef 90       	pop	r14
    d442:	df 90       	pop	r13
    d444:	cf 90       	pop	r12
    d446:	bf 90       	pop	r11
    d448:	af 90       	pop	r10
    d44a:	9f 90       	pop	r9
    d44c:	8f 90       	pop	r8
    d44e:	7f 90       	pop	r7
    d450:	6f 90       	pop	r6
    d452:	08 95       	ret

0000d454 <vfscanf>:
    d454:	4f 92       	push	r4
    d456:	5f 92       	push	r5
    d458:	7f 92       	push	r7
    d45a:	8f 92       	push	r8
    d45c:	9f 92       	push	r9
    d45e:	af 92       	push	r10
    d460:	bf 92       	push	r11
    d462:	cf 92       	push	r12
    d464:	df 92       	push	r13
    d466:	ef 92       	push	r14
    d468:	ff 92       	push	r15
    d46a:	0f 93       	push	r16
    d46c:	1f 93       	push	r17
    d46e:	cf 93       	push	r28
    d470:	df 93       	push	r29
    d472:	1f 92       	push	r1
    d474:	cd b7       	in	r28, 0x3d	; 61
    d476:	de b7       	in	r29, 0x3e	; 62
    d478:	6c 01       	movw	r12, r24
    d47a:	2b 01       	movw	r4, r22
    d47c:	5a 01       	movw	r10, r20
    d47e:	fc 01       	movw	r30, r24
    d480:	16 82       	std	Z+6, r1	; 0x06
    d482:	17 82       	std	Z+7, r1	; 0x07
    d484:	71 2c       	mov	r7, r1
    d486:	f6 01       	movw	r30, r12
    d488:	f3 80       	ldd	r15, Z+3	; 0x03
    d48a:	f2 01       	movw	r30, r4
    d48c:	f3 fc       	sbrc	r15, 3
    d48e:	85 91       	lpm	r24, Z+
    d490:	f3 fe       	sbrs	r15, 3
    d492:	81 91       	ld	r24, Z+
    d494:	38 2f       	mov	r19, r24
    d496:	2f 01       	movw	r4, r30
    d498:	88 23       	and	r24, r24
    d49a:	09 f4       	brne	.+2      	; 0xd49e <vfscanf+0x4a>
    d49c:	e5 c0       	rjmp	.+458    	; 0xd668 <vfscanf+0x214>
    d49e:	90 e0       	ldi	r25, 0x00	; 0
    d4a0:	39 83       	std	Y+1, r19	; 0x01
    d4a2:	f8 d0       	rcall	.+496    	; 0xd694 <isspace>
    d4a4:	39 81       	ldd	r19, Y+1	; 0x01
    d4a6:	89 2b       	or	r24, r25
    d4a8:	19 f0       	breq	.+6      	; 0xd4b0 <vfscanf+0x5c>
    d4aa:	c6 01       	movw	r24, r12
    d4ac:	5e de       	rcall	.-836    	; 0xd16a <skip_spaces>
    d4ae:	eb cf       	rjmp	.-42     	; 0xd486 <vfscanf+0x32>
    d4b0:	35 32       	cpi	r19, 0x25	; 37
    d4b2:	41 f4       	brne	.+16     	; 0xd4c4 <vfscanf+0x70>
    d4b4:	f2 01       	movw	r30, r4
    d4b6:	f3 fc       	sbrc	r15, 3
    d4b8:	35 91       	lpm	r19, Z+
    d4ba:	f3 fe       	sbrs	r15, 3
    d4bc:	31 91       	ld	r19, Z+
    d4be:	2f 01       	movw	r4, r30
    d4c0:	35 32       	cpi	r19, 0x25	; 37
    d4c2:	59 f4       	brne	.+22     	; 0xd4da <vfscanf+0x86>
    d4c4:	c6 01       	movw	r24, r12
    d4c6:	39 83       	std	Y+1, r19	; 0x01
    d4c8:	0e d1       	rcall	.+540    	; 0xd6e6 <fgetc>
    d4ca:	39 81       	ldd	r19, Y+1	; 0x01
    d4cc:	97 fd       	sbrc	r25, 7
    d4ce:	ca c0       	rjmp	.+404    	; 0xd664 <vfscanf+0x210>
    d4d0:	38 17       	cp	r19, r24
    d4d2:	c9 f2       	breq	.-78     	; 0xd486 <vfscanf+0x32>
    d4d4:	b6 01       	movw	r22, r12
    d4d6:	7d d1       	rcall	.+762    	; 0xd7d2 <ungetc>
    d4d8:	c7 c0       	rjmp	.+398    	; 0xd668 <vfscanf+0x214>
    d4da:	3a 32       	cpi	r19, 0x2A	; 42
    d4dc:	39 f4       	brne	.+14     	; 0xd4ec <vfscanf+0x98>
    d4de:	f3 fc       	sbrc	r15, 3
    d4e0:	35 91       	lpm	r19, Z+
    d4e2:	f3 fe       	sbrs	r15, 3
    d4e4:	31 91       	ld	r19, Z+
    d4e6:	2f 01       	movw	r4, r30
    d4e8:	51 e0       	ldi	r21, 0x01	; 1
    d4ea:	01 c0       	rjmp	.+2      	; 0xd4ee <vfscanf+0x9a>
    d4ec:	50 e0       	ldi	r21, 0x00	; 0
    d4ee:	42 01       	movw	r8, r4
    d4f0:	10 e0       	ldi	r17, 0x00	; 0
    d4f2:	20 ed       	ldi	r18, 0xD0	; 208
    d4f4:	23 0f       	add	r18, r19
    d4f6:	2a 30       	cpi	r18, 0x0A	; 10
    d4f8:	88 f4       	brcc	.+34     	; 0xd51c <vfscanf+0xc8>
    d4fa:	52 60       	ori	r21, 0x02	; 2
    d4fc:	61 2f       	mov	r22, r17
    d4fe:	70 e0       	ldi	r23, 0x00	; 0
    d500:	80 e0       	ldi	r24, 0x00	; 0
    d502:	90 e0       	ldi	r25, 0x00	; 0
    d504:	40 e2       	ldi	r20, 0x20	; 32
    d506:	59 83       	std	Y+1, r21	; 0x01
    d508:	10 de       	rcall	.-992    	; 0xd12a <mulacc>
    d50a:	16 2f       	mov	r17, r22
    d50c:	f4 01       	movw	r30, r8
    d50e:	f3 fc       	sbrc	r15, 3
    d510:	35 91       	lpm	r19, Z+
    d512:	f3 fe       	sbrs	r15, 3
    d514:	31 91       	ld	r19, Z+
    d516:	4f 01       	movw	r8, r30
    d518:	59 81       	ldd	r21, Y+1	; 0x01
    d51a:	eb cf       	rjmp	.-42     	; 0xd4f2 <vfscanf+0x9e>
    d51c:	05 2f       	mov	r16, r21
    d51e:	23 2f       	mov	r18, r19
    d520:	24 01       	movw	r4, r8
    d522:	51 ff       	sbrs	r21, 1
    d524:	03 c0       	rjmp	.+6      	; 0xd52c <vfscanf+0xd8>
    d526:	11 11       	cpse	r17, r1
    d528:	02 c0       	rjmp	.+4      	; 0xd52e <vfscanf+0xda>
    d52a:	9e c0       	rjmp	.+316    	; 0xd668 <vfscanf+0x214>
    d52c:	1f ef       	ldi	r17, 0xFF	; 255
    d52e:	38 36       	cpi	r19, 0x68	; 104
    d530:	19 f0       	breq	.+6      	; 0xd538 <vfscanf+0xe4>
    d532:	3c 36       	cpi	r19, 0x6C	; 108
    d534:	59 f0       	breq	.+22     	; 0xd54c <vfscanf+0xf8>
    d536:	11 c0       	rjmp	.+34     	; 0xd55a <vfscanf+0x106>
    d538:	f4 01       	movw	r30, r8
    d53a:	f3 fc       	sbrc	r15, 3
    d53c:	25 91       	lpm	r18, Z+
    d53e:	f3 fe       	sbrs	r15, 3
    d540:	21 91       	ld	r18, Z+
    d542:	2f 01       	movw	r4, r30
    d544:	28 36       	cpi	r18, 0x68	; 104
    d546:	49 f4       	brne	.+18     	; 0xd55a <vfscanf+0x106>
    d548:	05 2f       	mov	r16, r21
    d54a:	08 60       	ori	r16, 0x08	; 8
    d54c:	04 60       	ori	r16, 0x04	; 4
    d54e:	f2 01       	movw	r30, r4
    d550:	f3 fc       	sbrc	r15, 3
    d552:	25 91       	lpm	r18, Z+
    d554:	f3 fe       	sbrs	r15, 3
    d556:	21 91       	ld	r18, Z+
    d558:	2f 01       	movw	r4, r30
    d55a:	22 23       	and	r18, r18
    d55c:	09 f4       	brne	.+2      	; 0xd560 <vfscanf+0x10c>
    d55e:	84 c0       	rjmp	.+264    	; 0xd668 <vfscanf+0x214>
    d560:	62 2f       	mov	r22, r18
    d562:	70 e0       	ldi	r23, 0x00	; 0
    d564:	85 ef       	ldi	r24, 0xF5	; 245
    d566:	97 e1       	ldi	r25, 0x17	; 23
    d568:	29 83       	std	Y+1, r18	; 0x01
    d56a:	9c d0       	rcall	.+312    	; 0xd6a4 <strchr_P>
    d56c:	29 81       	ldd	r18, Y+1	; 0x01
    d56e:	89 2b       	or	r24, r25
    d570:	09 f4       	brne	.+2      	; 0xd574 <vfscanf+0x120>
    d572:	7a c0       	rjmp	.+244    	; 0xd668 <vfscanf+0x214>
    d574:	00 fd       	sbrc	r16, 0
    d576:	07 c0       	rjmp	.+14     	; 0xd586 <vfscanf+0x132>
    d578:	f5 01       	movw	r30, r10
    d57a:	e0 80       	ld	r14, Z
    d57c:	f1 80       	ldd	r15, Z+1	; 0x01
    d57e:	c5 01       	movw	r24, r10
    d580:	02 96       	adiw	r24, 0x02	; 2
    d582:	5c 01       	movw	r10, r24
    d584:	02 c0       	rjmp	.+4      	; 0xd58a <vfscanf+0x136>
    d586:	e1 2c       	mov	r14, r1
    d588:	f1 2c       	mov	r15, r1
    d58a:	2e 36       	cpi	r18, 0x6E	; 110
    d58c:	49 f4       	brne	.+18     	; 0xd5a0 <vfscanf+0x14c>
    d58e:	f6 01       	movw	r30, r12
    d590:	46 81       	ldd	r20, Z+6	; 0x06
    d592:	57 81       	ldd	r21, Z+7	; 0x07
    d594:	60 e0       	ldi	r22, 0x00	; 0
    d596:	70 e0       	ldi	r23, 0x00	; 0
    d598:	20 2f       	mov	r18, r16
    d59a:	c7 01       	movw	r24, r14
    d59c:	ba dd       	rcall	.-1164   	; 0xd112 <putval>
    d59e:	73 cf       	rjmp	.-282    	; 0xd486 <vfscanf+0x32>
    d5a0:	23 36       	cpi	r18, 0x63	; 99
    d5a2:	89 f4       	brne	.+34     	; 0xd5c6 <vfscanf+0x172>
    d5a4:	01 ff       	sbrs	r16, 1
    d5a6:	11 e0       	ldi	r17, 0x01	; 1
    d5a8:	c6 01       	movw	r24, r12
    d5aa:	9d d0       	rcall	.+314    	; 0xd6e6 <fgetc>
    d5ac:	97 fd       	sbrc	r25, 7
    d5ae:	5a c0       	rjmp	.+180    	; 0xd664 <vfscanf+0x210>
    d5b0:	e1 14       	cp	r14, r1
    d5b2:	f1 04       	cpc	r15, r1
    d5b4:	29 f0       	breq	.+10     	; 0xd5c0 <vfscanf+0x16c>
    d5b6:	f7 01       	movw	r30, r14
    d5b8:	80 83       	st	Z, r24
    d5ba:	c7 01       	movw	r24, r14
    d5bc:	01 96       	adiw	r24, 0x01	; 1
    d5be:	7c 01       	movw	r14, r24
    d5c0:	11 50       	subi	r17, 0x01	; 1
    d5c2:	91 f7       	brne	.-28     	; 0xd5a8 <vfscanf+0x154>
    d5c4:	4b c0       	rjmp	.+150    	; 0xd65c <vfscanf+0x208>
    d5c6:	2b 35       	cpi	r18, 0x5B	; 91
    d5c8:	51 f4       	brne	.+20     	; 0xd5de <vfscanf+0x18a>
    d5ca:	92 01       	movw	r18, r4
    d5cc:	a7 01       	movw	r20, r14
    d5ce:	61 2f       	mov	r22, r17
    d5d0:	c6 01       	movw	r24, r12
    d5d2:	81 de       	rcall	.-766    	; 0xd2d6 <conv_brk>
    d5d4:	2c 01       	movw	r4, r24
    d5d6:	89 2b       	or	r24, r25
    d5d8:	09 f0       	breq	.+2      	; 0xd5dc <vfscanf+0x188>
    d5da:	40 c0       	rjmp	.+128    	; 0xd65c <vfscanf+0x208>
    d5dc:	3a c0       	rjmp	.+116    	; 0xd652 <vfscanf+0x1fe>
    d5de:	c6 01       	movw	r24, r12
    d5e0:	29 83       	std	Y+1, r18	; 0x01
    d5e2:	c3 dd       	rcall	.-1146   	; 0xd16a <skip_spaces>
    d5e4:	29 81       	ldd	r18, Y+1	; 0x01
    d5e6:	97 fd       	sbrc	r25, 7
    d5e8:	3d c0       	rjmp	.+122    	; 0xd664 <vfscanf+0x210>
    d5ea:	2f 36       	cpi	r18, 0x6F	; 111
    d5ec:	41 f1       	breq	.+80     	; 0xd63e <vfscanf+0x1ea>
    d5ee:	28 f4       	brcc	.+10     	; 0xd5fa <vfscanf+0x1a6>
    d5f0:	24 36       	cpi	r18, 0x64	; 100
    d5f2:	19 f1       	breq	.+70     	; 0xd63a <vfscanf+0x1e6>
    d5f4:	29 36       	cpi	r18, 0x69	; 105
    d5f6:	31 f1       	breq	.+76     	; 0xd644 <vfscanf+0x1f0>
    d5f8:	24 c0       	rjmp	.+72     	; 0xd642 <vfscanf+0x1ee>
    d5fa:	23 37       	cpi	r18, 0x73	; 115
    d5fc:	69 f0       	breq	.+26     	; 0xd618 <vfscanf+0x1c4>
    d5fe:	25 37       	cpi	r18, 0x75	; 117
    d600:	e1 f0       	breq	.+56     	; 0xd63a <vfscanf+0x1e6>
    d602:	1f c0       	rjmp	.+62     	; 0xd642 <vfscanf+0x1ee>
    d604:	e1 14       	cp	r14, r1
    d606:	f1 04       	cpc	r15, r1
    d608:	29 f0       	breq	.+10     	; 0xd614 <vfscanf+0x1c0>
    d60a:	f7 01       	movw	r30, r14
    d60c:	80 82       	st	Z, r8
    d60e:	c7 01       	movw	r24, r14
    d610:	01 96       	adiw	r24, 0x01	; 1
    d612:	7c 01       	movw	r14, r24
    d614:	11 50       	subi	r17, 0x01	; 1
    d616:	59 f0       	breq	.+22     	; 0xd62e <vfscanf+0x1da>
    d618:	c6 01       	movw	r24, r12
    d61a:	65 d0       	rcall	.+202    	; 0xd6e6 <fgetc>
    d61c:	4c 01       	movw	r8, r24
    d61e:	97 fd       	sbrc	r25, 7
    d620:	06 c0       	rjmp	.+12     	; 0xd62e <vfscanf+0x1da>
    d622:	38 d0       	rcall	.+112    	; 0xd694 <isspace>
    d624:	89 2b       	or	r24, r25
    d626:	71 f3       	breq	.-36     	; 0xd604 <vfscanf+0x1b0>
    d628:	b6 01       	movw	r22, r12
    d62a:	c4 01       	movw	r24, r8
    d62c:	d2 d0       	rcall	.+420    	; 0xd7d2 <ungetc>
    d62e:	e1 14       	cp	r14, r1
    d630:	f1 04       	cpc	r15, r1
    d632:	a1 f0       	breq	.+40     	; 0xd65c <vfscanf+0x208>
    d634:	f7 01       	movw	r30, r14
    d636:	10 82       	st	Z, r1
    d638:	11 c0       	rjmp	.+34     	; 0xd65c <vfscanf+0x208>
    d63a:	00 62       	ori	r16, 0x20	; 32
    d63c:	03 c0       	rjmp	.+6      	; 0xd644 <vfscanf+0x1f0>
    d63e:	00 61       	ori	r16, 0x10	; 16
    d640:	01 c0       	rjmp	.+2      	; 0xd644 <vfscanf+0x1f0>
    d642:	00 64       	ori	r16, 0x40	; 64
    d644:	20 2f       	mov	r18, r16
    d646:	a7 01       	movw	r20, r14
    d648:	61 2f       	mov	r22, r17
    d64a:	c6 01       	movw	r24, r12
    d64c:	a4 dd       	rcall	.-1208   	; 0xd196 <conv_int>
    d64e:	81 11       	cpse	r24, r1
    d650:	05 c0       	rjmp	.+10     	; 0xd65c <vfscanf+0x208>
    d652:	f6 01       	movw	r30, r12
    d654:	83 81       	ldd	r24, Z+3	; 0x03
    d656:	80 73       	andi	r24, 0x30	; 48
    d658:	29 f4       	brne	.+10     	; 0xd664 <vfscanf+0x210>
    d65a:	06 c0       	rjmp	.+12     	; 0xd668 <vfscanf+0x214>
    d65c:	00 fd       	sbrc	r16, 0
    d65e:	13 cf       	rjmp	.-474    	; 0xd486 <vfscanf+0x32>
    d660:	73 94       	inc	r7
    d662:	11 cf       	rjmp	.-478    	; 0xd486 <vfscanf+0x32>
    d664:	77 20       	and	r7, r7
    d666:	19 f0       	breq	.+6      	; 0xd66e <vfscanf+0x21a>
    d668:	87 2d       	mov	r24, r7
    d66a:	90 e0       	ldi	r25, 0x00	; 0
    d66c:	02 c0       	rjmp	.+4      	; 0xd672 <vfscanf+0x21e>
    d66e:	8f ef       	ldi	r24, 0xFF	; 255
    d670:	9f ef       	ldi	r25, 0xFF	; 255
    d672:	0f 90       	pop	r0
    d674:	df 91       	pop	r29
    d676:	cf 91       	pop	r28
    d678:	1f 91       	pop	r17
    d67a:	0f 91       	pop	r16
    d67c:	ff 90       	pop	r15
    d67e:	ef 90       	pop	r14
    d680:	df 90       	pop	r13
    d682:	cf 90       	pop	r12
    d684:	bf 90       	pop	r11
    d686:	af 90       	pop	r10
    d688:	9f 90       	pop	r9
    d68a:	8f 90       	pop	r8
    d68c:	7f 90       	pop	r7
    d68e:	5f 90       	pop	r5
    d690:	4f 90       	pop	r4
    d692:	08 95       	ret

0000d694 <isspace>:
    d694:	91 11       	cpse	r25, r1
    d696:	14 c1       	rjmp	.+552    	; 0xd8c0 <__ctype_isfalse>
    d698:	80 32       	cpi	r24, 0x20	; 32
    d69a:	19 f0       	breq	.+6      	; 0xd6a2 <isspace+0xe>
    d69c:	89 50       	subi	r24, 0x09	; 9
    d69e:	85 50       	subi	r24, 0x05	; 5
    d6a0:	d0 f7       	brcc	.-12     	; 0xd696 <isspace+0x2>
    d6a2:	08 95       	ret

0000d6a4 <strchr_P>:
    d6a4:	fc 01       	movw	r30, r24
    d6a6:	05 90       	lpm	r0, Z+
    d6a8:	06 16       	cp	r0, r22
    d6aa:	21 f0       	breq	.+8      	; 0xd6b4 <strchr_P+0x10>
    d6ac:	00 20       	and	r0, r0
    d6ae:	d9 f7       	brne	.-10     	; 0xd6a6 <strchr_P+0x2>
    d6b0:	c0 01       	movw	r24, r0
    d6b2:	08 95       	ret
    d6b4:	31 97       	sbiw	r30, 0x01	; 1
    d6b6:	cf 01       	movw	r24, r30
    d6b8:	08 95       	ret

0000d6ba <strnlen_P>:
    d6ba:	fc 01       	movw	r30, r24
    d6bc:	05 90       	lpm	r0, Z+
    d6be:	61 50       	subi	r22, 0x01	; 1
    d6c0:	70 40       	sbci	r23, 0x00	; 0
    d6c2:	01 10       	cpse	r0, r1
    d6c4:	d8 f7       	brcc	.-10     	; 0xd6bc <strnlen_P+0x2>
    d6c6:	80 95       	com	r24
    d6c8:	90 95       	com	r25
    d6ca:	8e 0f       	add	r24, r30
    d6cc:	9f 1f       	adc	r25, r31
    d6ce:	08 95       	ret

0000d6d0 <strnlen>:
    d6d0:	fc 01       	movw	r30, r24
    d6d2:	61 50       	subi	r22, 0x01	; 1
    d6d4:	70 40       	sbci	r23, 0x00	; 0
    d6d6:	01 90       	ld	r0, Z+
    d6d8:	01 10       	cpse	r0, r1
    d6da:	d8 f7       	brcc	.-10     	; 0xd6d2 <strnlen+0x2>
    d6dc:	80 95       	com	r24
    d6de:	90 95       	com	r25
    d6e0:	8e 0f       	add	r24, r30
    d6e2:	9f 1f       	adc	r25, r31
    d6e4:	08 95       	ret

0000d6e6 <fgetc>:
    d6e6:	cf 93       	push	r28
    d6e8:	df 93       	push	r29
    d6ea:	ec 01       	movw	r28, r24
    d6ec:	2b 81       	ldd	r18, Y+3	; 0x03
    d6ee:	20 ff       	sbrs	r18, 0
    d6f0:	33 c0       	rjmp	.+102    	; 0xd758 <fgetc+0x72>
    d6f2:	26 ff       	sbrs	r18, 6
    d6f4:	0a c0       	rjmp	.+20     	; 0xd70a <fgetc+0x24>
    d6f6:	2f 7b       	andi	r18, 0xBF	; 191
    d6f8:	2b 83       	std	Y+3, r18	; 0x03
    d6fa:	8e 81       	ldd	r24, Y+6	; 0x06
    d6fc:	9f 81       	ldd	r25, Y+7	; 0x07
    d6fe:	01 96       	adiw	r24, 0x01	; 1
    d700:	8e 83       	std	Y+6, r24	; 0x06
    d702:	9f 83       	std	Y+7, r25	; 0x07
    d704:	8a 81       	ldd	r24, Y+2	; 0x02
    d706:	90 e0       	ldi	r25, 0x00	; 0
    d708:	29 c0       	rjmp	.+82     	; 0xd75c <fgetc+0x76>
    d70a:	22 ff       	sbrs	r18, 2
    d70c:	0f c0       	rjmp	.+30     	; 0xd72c <fgetc+0x46>
    d70e:	e8 81       	ld	r30, Y
    d710:	f9 81       	ldd	r31, Y+1	; 0x01
    d712:	80 81       	ld	r24, Z
    d714:	08 2e       	mov	r0, r24
    d716:	00 0c       	add	r0, r0
    d718:	99 0b       	sbc	r25, r25
    d71a:	00 97       	sbiw	r24, 0x00	; 0
    d71c:	19 f4       	brne	.+6      	; 0xd724 <fgetc+0x3e>
    d71e:	20 62       	ori	r18, 0x20	; 32
    d720:	2b 83       	std	Y+3, r18	; 0x03
    d722:	1a c0       	rjmp	.+52     	; 0xd758 <fgetc+0x72>
    d724:	31 96       	adiw	r30, 0x01	; 1
    d726:	e8 83       	st	Y, r30
    d728:	f9 83       	std	Y+1, r31	; 0x01
    d72a:	0e c0       	rjmp	.+28     	; 0xd748 <fgetc+0x62>
    d72c:	ea 85       	ldd	r30, Y+10	; 0x0a
    d72e:	fb 85       	ldd	r31, Y+11	; 0x0b
    d730:	19 95       	eicall
    d732:	97 ff       	sbrs	r25, 7
    d734:	09 c0       	rjmp	.+18     	; 0xd748 <fgetc+0x62>
    d736:	2b 81       	ldd	r18, Y+3	; 0x03
    d738:	01 96       	adiw	r24, 0x01	; 1
    d73a:	11 f0       	breq	.+4      	; 0xd740 <fgetc+0x5a>
    d73c:	80 e2       	ldi	r24, 0x20	; 32
    d73e:	01 c0       	rjmp	.+2      	; 0xd742 <fgetc+0x5c>
    d740:	80 e1       	ldi	r24, 0x10	; 16
    d742:	82 2b       	or	r24, r18
    d744:	8b 83       	std	Y+3, r24	; 0x03
    d746:	08 c0       	rjmp	.+16     	; 0xd758 <fgetc+0x72>
    d748:	2e 81       	ldd	r18, Y+6	; 0x06
    d74a:	3f 81       	ldd	r19, Y+7	; 0x07
    d74c:	2f 5f       	subi	r18, 0xFF	; 255
    d74e:	3f 4f       	sbci	r19, 0xFF	; 255
    d750:	2e 83       	std	Y+6, r18	; 0x06
    d752:	3f 83       	std	Y+7, r19	; 0x07
    d754:	99 27       	eor	r25, r25
    d756:	02 c0       	rjmp	.+4      	; 0xd75c <fgetc+0x76>
    d758:	8f ef       	ldi	r24, 0xFF	; 255
    d75a:	9f ef       	ldi	r25, 0xFF	; 255
    d75c:	df 91       	pop	r29
    d75e:	cf 91       	pop	r28
    d760:	08 95       	ret

0000d762 <fputc>:
    d762:	0f 93       	push	r16
    d764:	1f 93       	push	r17
    d766:	cf 93       	push	r28
    d768:	df 93       	push	r29
    d76a:	fb 01       	movw	r30, r22
    d76c:	23 81       	ldd	r18, Z+3	; 0x03
    d76e:	21 fd       	sbrc	r18, 1
    d770:	03 c0       	rjmp	.+6      	; 0xd778 <fputc+0x16>
    d772:	8f ef       	ldi	r24, 0xFF	; 255
    d774:	9f ef       	ldi	r25, 0xFF	; 255
    d776:	28 c0       	rjmp	.+80     	; 0xd7c8 <fputc+0x66>
    d778:	22 ff       	sbrs	r18, 2
    d77a:	16 c0       	rjmp	.+44     	; 0xd7a8 <fputc+0x46>
    d77c:	46 81       	ldd	r20, Z+6	; 0x06
    d77e:	57 81       	ldd	r21, Z+7	; 0x07
    d780:	24 81       	ldd	r18, Z+4	; 0x04
    d782:	35 81       	ldd	r19, Z+5	; 0x05
    d784:	42 17       	cp	r20, r18
    d786:	53 07       	cpc	r21, r19
    d788:	44 f4       	brge	.+16     	; 0xd79a <fputc+0x38>
    d78a:	a0 81       	ld	r26, Z
    d78c:	b1 81       	ldd	r27, Z+1	; 0x01
    d78e:	9d 01       	movw	r18, r26
    d790:	2f 5f       	subi	r18, 0xFF	; 255
    d792:	3f 4f       	sbci	r19, 0xFF	; 255
    d794:	20 83       	st	Z, r18
    d796:	31 83       	std	Z+1, r19	; 0x01
    d798:	8c 93       	st	X, r24
    d79a:	26 81       	ldd	r18, Z+6	; 0x06
    d79c:	37 81       	ldd	r19, Z+7	; 0x07
    d79e:	2f 5f       	subi	r18, 0xFF	; 255
    d7a0:	3f 4f       	sbci	r19, 0xFF	; 255
    d7a2:	26 83       	std	Z+6, r18	; 0x06
    d7a4:	37 83       	std	Z+7, r19	; 0x07
    d7a6:	10 c0       	rjmp	.+32     	; 0xd7c8 <fputc+0x66>
    d7a8:	eb 01       	movw	r28, r22
    d7aa:	09 2f       	mov	r16, r25
    d7ac:	18 2f       	mov	r17, r24
    d7ae:	00 84       	ldd	r0, Z+8	; 0x08
    d7b0:	f1 85       	ldd	r31, Z+9	; 0x09
    d7b2:	e0 2d       	mov	r30, r0
    d7b4:	19 95       	eicall
    d7b6:	89 2b       	or	r24, r25
    d7b8:	e1 f6       	brne	.-72     	; 0xd772 <fputc+0x10>
    d7ba:	8e 81       	ldd	r24, Y+6	; 0x06
    d7bc:	9f 81       	ldd	r25, Y+7	; 0x07
    d7be:	01 96       	adiw	r24, 0x01	; 1
    d7c0:	8e 83       	std	Y+6, r24	; 0x06
    d7c2:	9f 83       	std	Y+7, r25	; 0x07
    d7c4:	81 2f       	mov	r24, r17
    d7c6:	90 2f       	mov	r25, r16
    d7c8:	df 91       	pop	r29
    d7ca:	cf 91       	pop	r28
    d7cc:	1f 91       	pop	r17
    d7ce:	0f 91       	pop	r16
    d7d0:	08 95       	ret

0000d7d2 <ungetc>:
    d7d2:	fb 01       	movw	r30, r22
    d7d4:	23 81       	ldd	r18, Z+3	; 0x03
    d7d6:	20 ff       	sbrs	r18, 0
    d7d8:	12 c0       	rjmp	.+36     	; 0xd7fe <ungetc+0x2c>
    d7da:	26 fd       	sbrc	r18, 6
    d7dc:	10 c0       	rjmp	.+32     	; 0xd7fe <ungetc+0x2c>
    d7de:	8f 3f       	cpi	r24, 0xFF	; 255
    d7e0:	3f ef       	ldi	r19, 0xFF	; 255
    d7e2:	93 07       	cpc	r25, r19
    d7e4:	61 f0       	breq	.+24     	; 0xd7fe <ungetc+0x2c>
    d7e6:	82 83       	std	Z+2, r24	; 0x02
    d7e8:	2f 7d       	andi	r18, 0xDF	; 223
    d7ea:	20 64       	ori	r18, 0x40	; 64
    d7ec:	23 83       	std	Z+3, r18	; 0x03
    d7ee:	26 81       	ldd	r18, Z+6	; 0x06
    d7f0:	37 81       	ldd	r19, Z+7	; 0x07
    d7f2:	21 50       	subi	r18, 0x01	; 1
    d7f4:	31 09       	sbc	r19, r1
    d7f6:	26 83       	std	Z+6, r18	; 0x06
    d7f8:	37 83       	std	Z+7, r19	; 0x07
    d7fa:	99 27       	eor	r25, r25
    d7fc:	08 95       	ret
    d7fe:	8f ef       	ldi	r24, 0xFF	; 255
    d800:	9f ef       	ldi	r25, 0xFF	; 255
    d802:	08 95       	ret

0000d804 <__ultoa_invert>:
    d804:	fa 01       	movw	r30, r20
    d806:	aa 27       	eor	r26, r26
    d808:	28 30       	cpi	r18, 0x08	; 8
    d80a:	51 f1       	breq	.+84     	; 0xd860 <__ultoa_invert+0x5c>
    d80c:	20 31       	cpi	r18, 0x10	; 16
    d80e:	81 f1       	breq	.+96     	; 0xd870 <__ultoa_invert+0x6c>
    d810:	e8 94       	clt
    d812:	6f 93       	push	r22
    d814:	6e 7f       	andi	r22, 0xFE	; 254
    d816:	6e 5f       	subi	r22, 0xFE	; 254
    d818:	7f 4f       	sbci	r23, 0xFF	; 255
    d81a:	8f 4f       	sbci	r24, 0xFF	; 255
    d81c:	9f 4f       	sbci	r25, 0xFF	; 255
    d81e:	af 4f       	sbci	r26, 0xFF	; 255
    d820:	b1 e0       	ldi	r27, 0x01	; 1
    d822:	3e d0       	rcall	.+124    	; 0xd8a0 <__ultoa_invert+0x9c>
    d824:	b4 e0       	ldi	r27, 0x04	; 4
    d826:	3c d0       	rcall	.+120    	; 0xd8a0 <__ultoa_invert+0x9c>
    d828:	67 0f       	add	r22, r23
    d82a:	78 1f       	adc	r23, r24
    d82c:	89 1f       	adc	r24, r25
    d82e:	9a 1f       	adc	r25, r26
    d830:	a1 1d       	adc	r26, r1
    d832:	68 0f       	add	r22, r24
    d834:	79 1f       	adc	r23, r25
    d836:	8a 1f       	adc	r24, r26
    d838:	91 1d       	adc	r25, r1
    d83a:	a1 1d       	adc	r26, r1
    d83c:	6a 0f       	add	r22, r26
    d83e:	71 1d       	adc	r23, r1
    d840:	81 1d       	adc	r24, r1
    d842:	91 1d       	adc	r25, r1
    d844:	a1 1d       	adc	r26, r1
    d846:	20 d0       	rcall	.+64     	; 0xd888 <__ultoa_invert+0x84>
    d848:	09 f4       	brne	.+2      	; 0xd84c <__ultoa_invert+0x48>
    d84a:	68 94       	set
    d84c:	3f 91       	pop	r19
    d84e:	2a e0       	ldi	r18, 0x0A	; 10
    d850:	26 9f       	mul	r18, r22
    d852:	11 24       	eor	r1, r1
    d854:	30 19       	sub	r19, r0
    d856:	30 5d       	subi	r19, 0xD0	; 208
    d858:	31 93       	st	Z+, r19
    d85a:	de f6       	brtc	.-74     	; 0xd812 <__ultoa_invert+0xe>
    d85c:	cf 01       	movw	r24, r30
    d85e:	08 95       	ret
    d860:	46 2f       	mov	r20, r22
    d862:	47 70       	andi	r20, 0x07	; 7
    d864:	40 5d       	subi	r20, 0xD0	; 208
    d866:	41 93       	st	Z+, r20
    d868:	b3 e0       	ldi	r27, 0x03	; 3
    d86a:	0f d0       	rcall	.+30     	; 0xd88a <__ultoa_invert+0x86>
    d86c:	c9 f7       	brne	.-14     	; 0xd860 <__ultoa_invert+0x5c>
    d86e:	f6 cf       	rjmp	.-20     	; 0xd85c <__ultoa_invert+0x58>
    d870:	46 2f       	mov	r20, r22
    d872:	4f 70       	andi	r20, 0x0F	; 15
    d874:	40 5d       	subi	r20, 0xD0	; 208
    d876:	4a 33       	cpi	r20, 0x3A	; 58
    d878:	18 f0       	brcs	.+6      	; 0xd880 <__ultoa_invert+0x7c>
    d87a:	49 5d       	subi	r20, 0xD9	; 217
    d87c:	31 fd       	sbrc	r19, 1
    d87e:	40 52       	subi	r20, 0x20	; 32
    d880:	41 93       	st	Z+, r20
    d882:	02 d0       	rcall	.+4      	; 0xd888 <__ultoa_invert+0x84>
    d884:	a9 f7       	brne	.-22     	; 0xd870 <__ultoa_invert+0x6c>
    d886:	ea cf       	rjmp	.-44     	; 0xd85c <__ultoa_invert+0x58>
    d888:	b4 e0       	ldi	r27, 0x04	; 4
    d88a:	a6 95       	lsr	r26
    d88c:	97 95       	ror	r25
    d88e:	87 95       	ror	r24
    d890:	77 95       	ror	r23
    d892:	67 95       	ror	r22
    d894:	ba 95       	dec	r27
    d896:	c9 f7       	brne	.-14     	; 0xd88a <__ultoa_invert+0x86>
    d898:	00 97       	sbiw	r24, 0x00	; 0
    d89a:	61 05       	cpc	r22, r1
    d89c:	71 05       	cpc	r23, r1
    d89e:	08 95       	ret
    d8a0:	9b 01       	movw	r18, r22
    d8a2:	ac 01       	movw	r20, r24
    d8a4:	0a 2e       	mov	r0, r26
    d8a6:	06 94       	lsr	r0
    d8a8:	57 95       	ror	r21
    d8aa:	47 95       	ror	r20
    d8ac:	37 95       	ror	r19
    d8ae:	27 95       	ror	r18
    d8b0:	ba 95       	dec	r27
    d8b2:	c9 f7       	brne	.-14     	; 0xd8a6 <__ultoa_invert+0xa2>
    d8b4:	62 0f       	add	r22, r18
    d8b6:	73 1f       	adc	r23, r19
    d8b8:	84 1f       	adc	r24, r20
    d8ba:	95 1f       	adc	r25, r21
    d8bc:	a0 1d       	adc	r26, r0
    d8be:	08 95       	ret

0000d8c0 <__ctype_isfalse>:
    d8c0:	99 27       	eor	r25, r25
    d8c2:	88 27       	eor	r24, r24

0000d8c4 <__ctype_istrue>:
    d8c4:	08 95       	ret

0000d8c6 <eeprom_read_byte>:
    d8c6:	03 d0       	rcall	.+6      	; 0xd8ce <eeprom_mapen>
    d8c8:	80 81       	ld	r24, Z
    d8ca:	99 27       	eor	r25, r25
    d8cc:	08 95       	ret

0000d8ce <eeprom_mapen>:
    d8ce:	e0 ec       	ldi	r30, 0xC0	; 192
    d8d0:	f1 e0       	ldi	r31, 0x01	; 1
    d8d2:	37 85       	ldd	r19, Z+15	; 0x0f
    d8d4:	37 fd       	sbrc	r19, 7
    d8d6:	fd cf       	rjmp	.-6      	; 0xd8d2 <eeprom_mapen+0x4>
    d8d8:	34 85       	ldd	r19, Z+12	; 0x0c
    d8da:	38 60       	ori	r19, 0x08	; 8
    d8dc:	34 87       	std	Z+12, r19	; 0x0c
    d8de:	fc 01       	movw	r30, r24
    d8e0:	e0 50       	subi	r30, 0x00	; 0
    d8e2:	f0 4f       	sbci	r31, 0xF0	; 240
    d8e4:	08 95       	ret

0000d8e6 <eeprom_update_byte>:
    d8e6:	26 2f       	mov	r18, r22

0000d8e8 <eeprom_update_r18>:
    d8e8:	f2 df       	rcall	.-28     	; 0xd8ce <eeprom_mapen>
    d8ea:	00 80       	ld	r0, Z
    d8ec:	02 16       	cp	r0, r18
    d8ee:	11 f0       	breq	.+4      	; 0xd8f4 <eeprom_update_r18+0xc>
    d8f0:	08 d0       	rcall	.+16     	; 0xd902 <eeprom_write_r18>
    d8f2:	01 97       	sbiw	r24, 0x01	; 1
    d8f4:	01 97       	sbiw	r24, 0x01	; 1
    d8f6:	08 95       	ret

0000d8f8 <eeprom_update_word>:
    d8f8:	01 96       	adiw	r24, 0x01	; 1
    d8fa:	27 2f       	mov	r18, r23
    d8fc:	f5 df       	rcall	.-22     	; 0xd8e8 <eeprom_update_r18>
    d8fe:	f3 cf       	rjmp	.-26     	; 0xd8e6 <eeprom_update_byte>

0000d900 <eeprom_write_byte>:
    d900:	26 2f       	mov	r18, r22

0000d902 <eeprom_write_r18>:
    d902:	e0 ec       	ldi	r30, 0xC0	; 192
    d904:	f1 e0       	ldi	r31, 0x01	; 1
    d906:	37 85       	ldd	r19, Z+15	; 0x0f
    d908:	37 fd       	sbrc	r19, 7
    d90a:	fd cf       	rjmp	.-6      	; 0xd906 <eeprom_write_r18+0x4>
    d90c:	34 85       	ldd	r19, Z+12	; 0x0c
    d90e:	37 7f       	andi	r19, 0xF7	; 247
    d910:	34 87       	std	Z+12, r19	; 0x0c
    d912:	37 85       	ldd	r19, Z+15	; 0x0f
    d914:	31 ff       	sbrs	r19, 1
    d916:	09 c0       	rjmp	.+18     	; 0xd92a <eeprom_write_r18+0x28>
    d918:	36 e3       	ldi	r19, 0x36	; 54
    d91a:	32 87       	std	Z+10, r19	; 0x0a
    d91c:	38 ed       	ldi	r19, 0xD8	; 216
    d91e:	34 bf       	out	0x34, r19	; 52
    d920:	31 e0       	ldi	r19, 0x01	; 1
    d922:	33 87       	std	Z+11, r19	; 0x0b
    d924:	37 85       	ldd	r19, Z+15	; 0x0f
    d926:	37 fd       	sbrc	r19, 7
    d928:	fd cf       	rjmp	.-6      	; 0xd924 <eeprom_write_r18+0x22>
    d92a:	33 e3       	ldi	r19, 0x33	; 51
    d92c:	32 87       	std	Z+10, r19	; 0x0a
    d92e:	80 83       	st	Z, r24
    d930:	91 83       	std	Z+1, r25	; 0x01
    d932:	12 82       	std	Z+2, r1	; 0x02
    d934:	24 83       	std	Z+4, r18	; 0x04
    d936:	25 e3       	ldi	r18, 0x35	; 53
    d938:	22 87       	std	Z+10, r18	; 0x0a
    d93a:	28 ed       	ldi	r18, 0xD8	; 216
    d93c:	31 e0       	ldi	r19, 0x01	; 1
    d93e:	24 bf       	out	0x34, r18	; 52
    d940:	33 87       	std	Z+11, r19	; 0x0b
    d942:	01 96       	adiw	r24, 0x01	; 1
    d944:	08 95       	ret

0000d946 <__divmodsi4>:
    d946:	05 2e       	mov	r0, r21
    d948:	97 fb       	bst	r25, 7
    d94a:	16 f4       	brtc	.+4      	; 0xd950 <__divmodsi4+0xa>
    d94c:	00 94       	com	r0
    d94e:	0f d0       	rcall	.+30     	; 0xd96e <__negsi2>
    d950:	57 fd       	sbrc	r21, 7
    d952:	05 d0       	rcall	.+10     	; 0xd95e <__divmodsi4_neg2>
    d954:	14 d0       	rcall	.+40     	; 0xd97e <__udivmodsi4>
    d956:	07 fc       	sbrc	r0, 7
    d958:	02 d0       	rcall	.+4      	; 0xd95e <__divmodsi4_neg2>
    d95a:	46 f4       	brtc	.+16     	; 0xd96c <__divmodsi4_exit>
    d95c:	08 c0       	rjmp	.+16     	; 0xd96e <__negsi2>

0000d95e <__divmodsi4_neg2>:
    d95e:	50 95       	com	r21
    d960:	40 95       	com	r20
    d962:	30 95       	com	r19
    d964:	21 95       	neg	r18
    d966:	3f 4f       	sbci	r19, 0xFF	; 255
    d968:	4f 4f       	sbci	r20, 0xFF	; 255
    d96a:	5f 4f       	sbci	r21, 0xFF	; 255

0000d96c <__divmodsi4_exit>:
    d96c:	08 95       	ret

0000d96e <__negsi2>:
    d96e:	90 95       	com	r25
    d970:	80 95       	com	r24
    d972:	70 95       	com	r23
    d974:	61 95       	neg	r22
    d976:	7f 4f       	sbci	r23, 0xFF	; 255
    d978:	8f 4f       	sbci	r24, 0xFF	; 255
    d97a:	9f 4f       	sbci	r25, 0xFF	; 255
    d97c:	08 95       	ret

0000d97e <__udivmodsi4>:
    d97e:	a1 e2       	ldi	r26, 0x21	; 33
    d980:	1a 2e       	mov	r1, r26
    d982:	aa 1b       	sub	r26, r26
    d984:	bb 1b       	sub	r27, r27
    d986:	fd 01       	movw	r30, r26
    d988:	0d c0       	rjmp	.+26     	; 0xd9a4 <__udivmodsi4_ep>

0000d98a <__udivmodsi4_loop>:
    d98a:	aa 1f       	adc	r26, r26
    d98c:	bb 1f       	adc	r27, r27
    d98e:	ee 1f       	adc	r30, r30
    d990:	ff 1f       	adc	r31, r31
    d992:	a2 17       	cp	r26, r18
    d994:	b3 07       	cpc	r27, r19
    d996:	e4 07       	cpc	r30, r20
    d998:	f5 07       	cpc	r31, r21
    d99a:	20 f0       	brcs	.+8      	; 0xd9a4 <__udivmodsi4_ep>
    d99c:	a2 1b       	sub	r26, r18
    d99e:	b3 0b       	sbc	r27, r19
    d9a0:	e4 0b       	sbc	r30, r20
    d9a2:	f5 0b       	sbc	r31, r21

0000d9a4 <__udivmodsi4_ep>:
    d9a4:	66 1f       	adc	r22, r22
    d9a6:	77 1f       	adc	r23, r23
    d9a8:	88 1f       	adc	r24, r24
    d9aa:	99 1f       	adc	r25, r25
    d9ac:	1a 94       	dec	r1
    d9ae:	69 f7       	brne	.-38     	; 0xd98a <__udivmodsi4_loop>
    d9b0:	60 95       	com	r22
    d9b2:	70 95       	com	r23
    d9b4:	80 95       	com	r24
    d9b6:	90 95       	com	r25
    d9b8:	9b 01       	movw	r18, r22
    d9ba:	ac 01       	movw	r20, r24
    d9bc:	bd 01       	movw	r22, r26
    d9be:	cf 01       	movw	r24, r30
    d9c0:	08 95       	ret

0000d9c2 <_exit>:
    d9c2:	f8 94       	cli

0000d9c4 <__stop_program>:
    d9c4:	ff cf       	rjmp	.-2      	; 0xd9c4 <__stop_program>
